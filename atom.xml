<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Junedayday Blog</title>
  
  <subtitle>六月天天的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-10T13:55:03.348Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Junedayday</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>五分钟技术小分享 - 2022Week10</title>
    <link href="http://example.com/2022/03/07/sharing-5min/2022-03/2022Week10/"/>
    <id>http://example.com/2022/03/07/sharing-5min/2022-03/2022Week10/</id>
    <published>2022-03-07T04:00:00.000Z</published>
    <updated>2022-03-10T13:55:03.348Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57591641299799_.pic_hd.jpg" alt="2020-03"></p><h2 id="2022-03-07-CNCF-Provisioning层"><a href="#2022-03-07-CNCF-Provisioning层" class="headerlink" title="2022-03-07 CNCF-Provisioning层"></a>2022-03-07 CNCF-Provisioning层</h2><p>今天，我们将加快进度，来对Provisioning这一层的项目做一下概览。Provisioning层是一种工具性质的项目，能一定程度上提升Kubernetes的综合能力，尤其是镜像管理和安全性。</p><h3 id="KubeEdge"><a href="#KubeEdge" class="headerlink" title="KubeEdge"></a>KubeEdge</h3><p>KubeEdge在近几年非常火，贴合边缘计算这个概念。</p><p>众所周知，由于Kubernetes是一个以master为核心的调度系统，许多核心能力都依赖master节点，会导致边端能力的受限。KubeEdge就是以这个为切入点。</p><p>目前落地KubeEdge的公司主要就是以华为为代表，其余大厂并没有加入到这个阵营。我之前的公司也引入过KubeEdge，但整体效果不佳。</p><blockquote><p>在引入KubeEdge前，我们需要思考一个问题：边缘计算的系统一定要结合Kubernetes吗？</p></blockquote><h3 id="Harbor"><a href="#Harbor" class="headerlink" title="Harbor"></a>Harbor</h3><p>Harbor是云原生的制品仓库，用来存储镜像等内容。它非常强调自身的安全性。</p><p>Harbor整体的学习与使用成本较低，也提供大量的界面化工具，主要存在新老版本的兼容问题。对于新团队，强烈建议直接使用Harbor。</p><h3 id="Dragonfly"><a href="#Dragonfly" class="headerlink" title="Dragonfly"></a>Dragonfly</h3><p>Dragonfly这个项目利用了P2P的思想，进行镜像、文件的分发，对多机房、多数据中心且传输的文件量大的场景才能突出其价值。</p><p>一般情况下我们无需考虑。</p><h3 id="Open-Policy-Agent"><a href="#Open-Policy-Agent" class="headerlink" title="Open Policy Agent"></a>Open Policy Agent</h3><p>OPA是一个很有意思的项目，我们可以看看它的实际构成。一个具体的OPA主要包括2块：</p><ol><li>Policy - Rego语法、特有</li><li>Data - JSON语法</li></ol><p>Policy即策略，例如大于某个值时执行策略；而Data则是配置Policy的具体数据，例如将Policy的某个值设置为10。组合了Policy+Data，这个策略才能真正地执行，可以使用OPA的库或者服务。</p><p>OPA的思想对项目的可读性和扩展性很有意义，尤其是对于一些需要大量策略配置的服务，如Envoy。</p><h3 id="TUF-Notary"><a href="#TUF-Notary" class="headerlink" title="TUF/Notary"></a>TUF/Notary</h3><p>TUF是软件更新系统的行业事实上的标准，对于实际开发的意义不大。</p><p>Notary是一个允许任何人信任任意数据集合的项目，是TUF的一个具体实现。目前主要应用在镜像上。</p><h3 id="Falco"><a href="#Falco" class="headerlink" title="Falco"></a>Falco</h3><p>Falco是一个保证运行时安全的项目，用来检测云原生运行时的各种异常与安全问题。</p><p>运行时的安全问题是系统安全的最后一道防线，往往需要研发团队紧急处理。</p><h3 id="SPIFFE-SPIRE"><a href="#SPIFFE-SPIRE" class="headerlink" title="SPIFFE/SPIRE"></a>SPIFFE/SPIRE</h3><p>SPIFFE 定义了服务的认证标准和认证信息的标准，SPIRE 是它的一个具体实现。</p><p>这块内容仍处于初期，我们了解即可。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>今天，我们走马观花地查看了Provisioning层的项目，大家重点关注Harbor和KubeEdge即可。其中Harbor操作难度低，可以快速上手使用；而KubeEdge面向的边缘计算领域比较窄，适用于特定人群。</p><p>到这里，我们的CNCF之旅已经基本完成了。后续有机会，我会挑选几个受欢迎的项目做细致的分析。</p><h2 id="2022-03-10-Go垃圾回收之旅（一）"><a href="#2022-03-10-Go垃圾回收之旅（一）" class="headerlink" title="2022-03-10 Go垃圾回收之旅（一）"></a>2022-03-10 Go垃圾回收之旅（一）</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>关于Go语言的垃圾回收<code>Garbage Collector</code>，相信大家都在网上看过很多相关的文章：有的是科普性质的讲解，有的是直接对着源码的分析，也有的是与其余语言的对比。但文章往往具有时效性，或多或少与最新的Go语言实现有一些偏差。</p><p>从这篇开始，我将分析更具权威和参考价值的官方资料，让大家对Go的GC有深刻而长远的认识。</p><p>我们今天看的这一篇文章，来自内存管理大师理查德·哈德森的一次分享。我将挑选其中的一些关键点来描述。</p><blockquote><p>参考链接 - <a href="https://go.dev/blog/ismmkeynote">https://go.dev/blog/ismmkeynote</a></p></blockquote><h3 id="调度概览"><a href="#调度概览" class="headerlink" title="调度概览"></a>调度概览</h3><blockquote><p>The Go scheduler multiplexes Goroutines onto OS threads which hopefully run with one OS thread per HW thread.</p></blockquote><p>学习GC前，我们先得对Go的GMP模型有一定额了解。这句话包括了三个关键对象：</p><ul><li><strong>Goroutines</strong> - 即Go语言中通过关键词<code>go</code>产生的协程</li><li><strong>OS thread</strong> - 系统线程，一般由操作系统创建</li><li><strong>HW thread</strong> - 硬件线程，一般1核（物理核）CPU对应2个硬件线程</li></ul><p>这三者，分别对应GMP模型中的G、M、P。这里我们先聚焦于两个关键点：</p><ul><li><strong>Go scheduler multiplexes Goroutines</strong> - Go的调度器参考多路复用的机制，调度Goroutines的运行；</li><li><strong>hopefully run with one OS thread per HW thread</strong> - 尽可能地将系统线程与硬件线程绑定，这样可以减少切换上下文时带来的开销。</li></ul><p>关于GMP，我们到这里浅尝辄止。更多的实现细节，会在后面单独开启一个系列。</p><h3 id="value-oriented"><a href="#value-oriented" class="headerlink" title="value-oriented"></a>value-oriented</h3><blockquote><p>Go is a value-oriented language.</p></blockquote><p>理解value-oriented与reference-oriented的差别，对我们学习与理解GC意义很大。以官方<code>tar</code>包中的<code>Reader</code>为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">r    io.Reader</span><br><span class="line">pad  <span class="keyword">int64</span>      <span class="comment">// Amount of padding (ignored) after current file entry</span></span><br><span class="line">curr fileReader <span class="comment">// Reader for current file entry</span></span><br><span class="line">blk  block      <span class="comment">// Buffer to use as temporary local storage</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// err is a persistent error.</span></span><br><span class="line"><span class="comment">// It is only the responsibility of every exported method of Reader to</span></span><br><span class="line"><span class="comment">// ensure that this error is sticky.</span></span><br><span class="line">err error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我各举一个最简单的实现：</p><ul><li><p><strong>value-oriented</strong>语言，<code>Reader</code>结构体里的所有数据（各个field）都是放在 <strong>栈上连续的内存</strong> </p></li><li><p><strong>reference-oriented</strong>语言，会将具体数据保存在堆空间里（暂称为堆上对象），而在栈上分配一个指针，记录这个堆上对象的起始地址，方便找到。</p></li></ul><p>所以，这两者内存分配的区别主要在于：</p><ul><li><strong>value-oriented</strong><ul><li>栈：sizeof(Reader) </li><li>堆：无</li></ul></li><li><strong>reference-oriented</strong><ul><li>栈：1个指针(如64bit) </li><li>堆：sizeof(Reader) </li></ul></li></ul><p>两种实现各有优劣，我这边以 <strong>运行时的复杂度</strong> 举个例子：</p><blockquote><p>运行时的复杂度，可以简单理解为：当数据的量越多、变化越频繁、运行时间越长，这个程序的运行时就越复杂，需要在内存中维护大量的信息。</p></blockquote><ul><li><strong>value-oriented</strong> - 更适合轻量级的运行时，在栈上维护会更省空间、访问起来也迅速</li><li><strong>reference-oriented</strong> - 适合重量级的运行时，当对象数量达到一定级别后，统一在堆上管理更为方便</li></ul><p>注意：以上内容适用于大部分的场景，但并不是绝对的，比如涉及到变量的逃逸分析时，分配方式会有所变化。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>本篇文章需要大家对 <strong>程序的堆与栈</strong> 有一定的基础了解，如果有同学不太清楚，建议花几分钟的时间去补一补。</p><p>文中提到了两个value-oriented的价值，建议了解大致原理即可，对理解GC意义不大。</p><ul><li><strong>提高缓存命中</strong> - 将相关的字段临近分配</li><li><strong>支持跨语言接口的访问</strong> - 如Go访问C/C++</li></ul><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57591641299799_.pic_hd.jpg&quot; alt=&quot;2020-03&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2022-03-07-C
      
    
    </summary>
    
      <category term="每日技术分享" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Daily-Sharing" scheme="http://example.com/tags/Daily-Sharing/"/>
    
  </entry>
  
  <entry>
    <title>五分钟技术小分享 - 2022Week09</title>
    <link href="http://example.com/2022/02/28/sharing-5min/2022-02/2022Week09/"/>
    <id>http://example.com/2022/02/28/sharing-5min/2022-02/2022Week09/</id>
    <published>2022-02-28T04:00:00.000Z</published>
    <updated>2022-03-07T12:46:41.430Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57581641299795_.pic_hd.jpg" alt="2022-02"></p><h2 id="2022-02-28-CNCF-OpenTelemetry等"><a href="#2022-02-28-CNCF-OpenTelemetry等" class="headerlink" title="2022-02-28 CNCF-OpenTelemetry等"></a>2022-02-28 CNCF-OpenTelemetry等</h2><p>今天，我们会以OpenTelemetry的三个核心Metrics、Logs、Traces为切入点，来看看OpenMetrics、Fluentd、Jaeger这三个具有代表性的项目。</p><h3 id="OpenTelemetry"><a href="#OpenTelemetry" class="headerlink" title="OpenTelemetry"></a>OpenTelemetry</h3><p>OpenTelemetry主要分为三大块：Metrics、Logs、Traces。</p><ul><li>Metrics指标：程序将运行中关键的一些指标数据保存下来，常通过RPC的方式Pull/Push到统一的平台</li><li>Logs日志：依赖程序自身的打印。可通过ELK/EFK等工具采集到统一的平台并展示</li><li>Traces分布式追踪：遵循Dapper等协议，获取一个请求在整个系统中的调用链路</li></ul><p>OpenTelemetry有多语言的、具体落地的现成库，供业务方快速落地实践。</p><blockquote><p>更多可以参考 <a href="https://junedayday.github.io/2021/10/14/readings/go-digest-2/">https://junedayday.github.io/2021/10/14/readings/go-digest-2/</a></p></blockquote><h3 id="Metrics-OpenMetrics"><a href="#Metrics-OpenMetrics" class="headerlink" title="Metrics - OpenMetrics"></a>Metrics - OpenMetrics</h3><blockquote><p>Evolving the Prometheus exposition format into a standard.</p></blockquote><p>这个项目更多的是一种规范性质，基本就是以Prometheus的指标为标准。</p><p>更多的信息可以参考 <a href="https://prometheus.io/docs/instrumenting/exposition_formats/%E3%80%82">https://prometheus.io/docs/instrumenting/exposition_formats/。</a></p><h3 id="Logs-Fluentd"><a href="#Logs-Fluentd" class="headerlink" title="Logs - Fluentd"></a>Logs - Fluentd</h3><blockquote><p>unified logging layer 统一的日志层</p></blockquote><p>我们这里谈的Logs并不是指各编程语言的日志库，更多是指对日志产生后，<strong>如何进行解析与采集</strong>，而Fluentd就是一个代表性的项目。</p><p>当前主流的日志采集与分析方案，也由ELK转变成了EFK，也就是Logstash被Fluentd所替代。</p><p>Fluentd最核心的优势，在于它提供了大量的可供快速接入的插件 - <a href="https://www.fluentd.org/plugins%E3%80%82">https://www.fluentd.org/plugins。</a></p><h3 id="Traces-Jaeger"><a href="#Traces-Jaeger" class="headerlink" title="Traces - Jaeger"></a>Traces - Jaeger</h3><blockquote><p>open source, end-to-end distributed tracing</p></blockquote><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/jaeger-architecture-v1.png" alt="jaeger"></p><p>Jaeger为OpenTracing提供了一套具体落地的方案，在Jaeger-Client侧也提供了多语言的SDK，我们就可以在分布式系统中查到请求的整个生命周期的具体数据。但落地到平台时，我们要重点思考以下两点：</p><ol><li>Traces与Logs的关联：两者的收集、推送、分析、展示的整个链路非常相似，而且我们也往往希望在Trace里查询信息时，能查到应用程序中自行打印的日志；</li><li>Traces与Service Mesh的关联：Jaeger-Agent与Service Mesh的Sidecar模式非常类似，两者该怎么配合实践</li></ol><p>我们可以独立建设Traces、Logs、Service Mesh这三块技术，但如果能将它们有机结合起来，有助于整个基础平台的统一化。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>OpenTelemetry提倡的可观测性在复杂工程中非常重要，能大幅提高程序的可维护性。如果有机会实践，建议大家应优先理解它的理念，再结合当前开源生态进行落地。</p><h2 id="2022-03-01-CNCF-Litmus-ChaosMesh"><a href="#2022-03-01-CNCF-Litmus-ChaosMesh" class="headerlink" title="2022-03-01 CNCF-Litmus/ChaosMesh"></a>2022-03-01 CNCF-Litmus/ChaosMesh</h2><p>随着Kubernetes的落地，混沌工程在近几年越来越流行，CNCF也将它作为重点项目。如果用一个词概括混沌工程，最常用的就是 <strong>故障注入</strong>。</p><p>今天我将针对其中两个重要项目 - Litmus 和 ChaosMesh 做简单介绍，让大家对混沌工程有基本理解。</p><h3 id="Litmus"><a href="#Litmus" class="headerlink" title="Litmus"></a>Litmus</h3><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/litmus-arch.png" alt="litmus"></p><p>Litmus的架构分为控制平面和执行平面。前者更多是提供可交互的web界面与整体的功能管理；而后者更专注于具体故障功能的实现。</p><p>整体来说，Litmus的架构是比较重量级的：</p><ol><li>平台组件复杂</li><li>和Argo/Prometheus等软件有一定的交叉</li></ol><h3 id="ChaosMesh"><a href="#ChaosMesh" class="headerlink" title="ChaosMesh"></a>ChaosMesh</h3><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/chaos-mesh-arch.png" alt="chaos-mesh"></p><p>相对而言，Chaos Mesh是一个比较轻量级的实现，整体的架构分为三块：</p><ol><li>Dashboard - 提供界面化交互能力</li><li>Controller Manager - 统一管理多种CRD</li><li>Daemon - 负责Pod端具体的故障注入</li></ol><p>我们可以仔细分析这里的三大块，都有不少的扩展点：</p><ol><li>可通过kubectl或自定义客户端下发指令</li><li>Controller Manager 可实现工作流等复杂CRD</li><li>Daemon可通过直接请求、容器运行时和Sidecar三种方式注入错误</li></ol><h3 id="故障注入能力"><a href="#故障注入能力" class="headerlink" title="故障注入能力"></a>故障注入能力</h3><p>我个人更看好ChaosMesh这个项目，它的架构图中所呈现的扩展性非常棒。那么，接下来我就以Chaos Mesh为例，看看它所提供的的故障注入能力：</p><ul><li>基本故障:<ul><li><a href="https://chaos-mesh.org/docs/simulate-pod-chaos-on-kubernetes/">PodChaos</a>: Pod</li><li><a href="https://chaos-mesh.org/docs/simulate-network-chaos-on-kubernetes/">NetworkChaos</a>: 网络</li><li><a href="https://chaos-mesh.org/docs/simulate-dns-chaos-on-kubernetes/">DNSChaos</a>: DNS</li><li><a href="https://chaos-mesh.org/docs/simulate-http-chaos-on-kubernetes/">HTTPChaos</a>: HTTP</li><li><a href="https://chaos-mesh.org/docs/simulate-heavy-stress-on-kubernetes/">StressChaos</a>: CPU或内存</li><li><a href="https://chaos-mesh.org/docs/simulate-io-chaos-on-kubernetes/">IOChaos</a>: IO</li><li><a href="https://chaos-mesh.org/docs/simulate-time-chaos-on-kubernetes/">TimeChaos</a>: 时间</li><li><a href="https://chaos-mesh.org/docs/simulate-kernel-chaos-on-kubernetes/">KernelChaos</a>: 内核</li></ul></li><li>平台故障:<ul><li><a href="https://chaos-mesh.org/docs/simulate-aws-chaos/">AWSChaos</a>: AWS</li><li><a href="https://chaos-mesh.org/docs/simulate-gcp-chaos/">GCPChaos</a>: GCP</li></ul></li><li>应用故障:<ul><li><a href="https://chaos-mesh.org/docs/simulate-jvm-application-chaos/">JVMChaos</a>: JVM</li></ul></li></ul><p>要覆盖基本故障这些case，已经需要投入非常多的人力物力了。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>我个人认为，混沌工程更多地是面向Iaas/Paas/Saas这类通用服务而提供的能力：</p><ol><li>Iaas/Paas/Saas这类服务是大规模共用的，对稳定性要求极高，才能体现出混沌工程的价值；</li><li>在业务系统中引入混沌工程有两大问题：<ol><li>一方面，ROI是非常低的，业务变化多、迭代快，从业务开发的角度来看，更希望基础平台侧能覆盖这些异常情况</li><li>另一方面，混沌工程会带来很多不确定性，可能导致业务受损</li></ol></li></ol><p>对大部分的开发者来说，可以学习混沌工程的理念，提高自己设计系统时的健壮性，但不要过于追求完美。</p><h2 id="2022-03-02-CNCF-Rook-Longhorn"><a href="#2022-03-02-CNCF-Rook-Longhorn" class="headerlink" title="2022-03-02 CNCF-Rook/Longhorn"></a>2022-03-02 CNCF-Rook/Longhorn</h2><p>今天，我们一起看看CNCF中存储这块。在云原生的环境下，分布式存储绝对是排名前三的技术难点，我也不可能通过短短五分钟描述清楚。</p><p>所以，我将针对性地介绍核心概念，帮助大家有个初步印象。</p><h3 id="CSI-Container-Storage-Interface"><a href="#CSI-Container-Storage-Interface" class="headerlink" title="CSI - Container Storage Interface"></a>CSI - Container Storage Interface</h3><p>容器存储之所以能在市场中蓬勃发展，离不开一个优秀的接口定义 - CSI。有了标准可依，各家百花齐放、优胜劣汰。</p><blockquote><p>CSI规范链接 - <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">https://github.com/container-storage-interface/spec/blob/master/spec.md</a></p></blockquote><p>CSI整套规范内容很多，非存储这块的专业人士无需深入研究。不过，我们可以将它作为一个学习资料，花10分钟看看如下内容：</p><ol><li>记住核心术语概念 - <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#terminology">https://github.com/container-storage-interface/spec/blob/master/spec.md#terminology</a></li><li>了解架构 - <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#architecture">https://github.com/container-storage-interface/spec/blob/master/spec.md#architecture</a></li><li>学习核心RPC的命名 - <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#rpc-interface">https://github.com/container-storage-interface/spec/blob/master/spec.md#rpc-interface</a></li></ol><h3 id="Ceph"><a href="#Ceph" class="headerlink" title="Ceph"></a>Ceph</h3><p>开源中最有名的分布式存储系统当属Ceph了。它并没有被捐献给CNCF组织，所以我们无法在全景图里找到它。</p><blockquote><p><a href="https://docs.ceph.com/en/latest/start/intro/">https://docs.ceph.com/en/latest/start/intro/</a></p></blockquote><p>这里不会讨论Ceph的细节，但还是希望大家能够了解：Ceph的维护成本不低，不要把它当作分布式存储的“银弹”。</p><p>所以，对于中小型公司来说，核心业务优先考虑使用公有云的存储产品。</p><h3 id="Rook"><a href="#Rook" class="headerlink" title="Rook"></a>Rook</h3><p>Rook这个项目其实分为两类概念：</p><ol><li>云原生存储编排引擎 - Rook</li><li>对接具体文件系统的实现 - rook-ceph/rook-nfs</li></ol><p>Rook将Ceph的存储抽象为了Kubernetes系统中的Pod，进行统一调度，更加贴合云原生的设计理念。</p><p>Rook在市场上的应用基本集中在rook-ceph上，不太建议使用rook-nfs。</p><h3 id="Longhorn"><a href="#Longhorn" class="headerlink" title="Longhorn"></a>Longhorn</h3><p>CNCF中另一个项目 - Longhorn则选择脱离Ceph的生态，实现了一整个从编排到具体存储的链路。</p><p>从其官方介绍来说，它更聚焦于微服务的场景，也就是能调度更大量级的Volume。</p><p>关于Longhorn的实践资料并不多，很难对其下结论，不过官方提供了完善的文档资料，给对应的开发者不小信心。</p><blockquote><p>官网 - <a href="https://longhorn.io/">https://longhorn.io/</a></p></blockquote><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>分布式存储是一块仍在快速发展的领域，对大部分公司或团队来说选择比较有限：</p><ol><li>优先考虑云服务</li><li>有Ceph维护经验+一定二次开发能力的，考虑rook+ceph</li><li>有强烈的技术信心的，可以考虑小规模落地Longhorn体验</li></ol><p>到这里，我再补充一点：我们千万不要过度迷恋分布式存储中的“分布式”这个词，很多时候单点存储（本地存储和远程存储）就能满足我们的开发要求了。</p><h2 id="2022-03-03-CNCF-containerd-cri-o"><a href="#2022-03-03-CNCF-containerd-cri-o" class="headerlink" title="2022-03-03 CNCF-containerd/cri-o"></a>2022-03-03 CNCF-containerd/cri-o</h2><p>容器的运行时是Kubernetes运行容器的基础。与CSI类似，Kubernetes提出了CRI - Container Runtime Interface的概念。</p><p>今天，我们会更多地关注到CRI这个规范，而不会对这两个项目底层进行分析 - 毕竟，虽然提供了开放的接口，但目前绝大部分的k8s依然是以Docker容器作为具体实现的，并且这现象会持续相当一段时间。</p><p>我会侧重讲讲它们之间的联系。</p><h3 id="CRI"><a href="#CRI" class="headerlink" title="CRI"></a>CRI</h3><p>CRI主要是针对的是Kubernetes中<code>kubelet</code>这个组件的，它用于在各个Node节点管理满足标准的OCI容器。</p><blockquote><p>OCI是一个容器界的事实标准，主流的容器都满足该规范，我们在这里了解即可。</p></blockquote><p>CRI最新的版本可以参考这个链接 - <a href="https://github.com/kubernetes/cri-api/blob/release-1.23/pkg/apis/runtime/v1alpha2/api.proto">https://github.com/kubernetes/cri-api/blob/release-1.23/pkg/apis/runtime/v1alpha2/api.proto</a></p><p>CRI主要分为如下：</p><ol><li>RuntimeService 运行时服务<ol><li>PodSandbox 相关，即Pod中的根容器，一般也叫做pause容器；</li><li>Container 相关，即普通的容器；</li></ol></li><li>ImageService 镜像服务</li></ol><p>CRI里的内容很多，我这边分享个人阅读大型<code>protobuffer</code>文件的两个技巧：</p><ol><li>弄懂高频词汇，如上面的Sandbox</li><li>聚焦核心的枚举enum</li></ol><p>这里有两个枚举值得关注：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PodSandboxState</span> </span>&#123;</span><br><span class="line">    SANDBOX_READY    = <span class="number">0</span>;</span><br><span class="line">    SANDBOX_NOTREADY = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ContainerState</span> </span>&#123;</span><br><span class="line">    CONTAINER_CREATED = <span class="number">0</span>;</span><br><span class="line">    CONTAINER_RUNNING = <span class="number">1</span>;</span><br><span class="line">    CONTAINER_EXITED  = <span class="number">2</span>;</span><br><span class="line">    CONTAINER_UNKNOWN = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这两个定义，如果你对容器/Pod有一定的了解，能很快地联系到它们的生命周期管理了。</p><h3 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h3><p>我们看看Docker与Kubernetes的分层：</p><ul><li><p>Docker Engine -&gt; containerd -&gt; runc</p></li><li><p>Kubernetes（Kubelet组件） -&gt; containerd -&gt; runc</p></li></ul><p>所以，containerd的作用很直观：对上层（Docker Engine/Kubernetes）屏蔽下层（runc等）的实现细节。</p><h3 id="cri-o"><a href="#cri-o" class="headerlink" title="cri-o"></a>cri-o</h3><blockquote><p>LIGHTWEIGHT CONTAINER RUNTIME FOR KUBERNETES</p></blockquote><p>从定义不难看出，它是面向Kubernetes的、更为轻量级的CRI。cri-o属于我们前面聊过的OCI项目之一。</p><p>对应上面的分层，cri-o封装的是runc这种具体的实现，让上层（Kubernetes）不需要关心下层具体运行容器的引擎。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>今天涉及的概念有很多，其实问题起源是 Docker没有捐献给CNCF基金会，为了摆脱不确定性，Kubernetes想解耦Docker这个强依赖。</p><p>无论是抽象出标准接口，还是通过分层设计，从理论上的确可以脱离了对Docker的依赖，但现实情况依旧有相当一段路要走，毕竟Docker的存量市场实在太过庞大。</p><h2 id="2022-03-04-CNCF-CNI-Cilium"><a href="#2022-03-04-CNCF-CNI-Cilium" class="headerlink" title="2022-03-04 CNCF-CNI/Cilium"></a>2022-03-04 CNCF-CNI/Cilium</h2><p>之前我们了解了CSI和CRI这两大块，今天我们将接触到Kubernetes另一个重要规范 - CNI，也就是Container Network Interface。</p><p>了解分布式系统的同学都深有体会，网络绝对是最复杂的因素，无论是拥塞、延迟、丢包等常规情况，还是像网络分区等复杂难题，都需要大量的学习成本。无疑，CNI的学习难度也是非常高的。而Cilium作为CNI的一种实现，我今天依然会简单带过。</p><h3 id="CNI规范"><a href="#CNI规范" class="headerlink" title="CNI规范"></a>CNI规范</h3><blockquote><p>官方链接 - <a href="https://github.com/containernetworking/cni">https://github.com/containernetworking/cni</a></p></blockquote><h4 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h4><p>CNI没有像CSI/CRI那样有一个明确的接口定义。要想了解它，我们先要理解它要解决的问题。</p><p>简单来说，就是在Kubernetes的容器环境里， <strong>分配容器网络并保证互相联通</strong>。</p><h4 id="核心五个规范"><a href="#核心五个规范" class="headerlink" title="核心五个规范"></a>核心五个规范</h4><ol><li>A format for administrators to define network configuration. 网络配置的格式</li><li>A protocol for container runtimes to make requests to network plugins.  执行协议</li><li>A procedure for executing plugins based on a supplied configuration. 基于网络配置的执行过程</li><li>A procedure for plugins to delegate functionality to other plugins. 插件授权</li><li>Data types for plugins to return their results to the runtime. 返回的格式</li></ol><h4 id="CNI插件"><a href="#CNI插件" class="headerlink" title="CNI插件"></a>CNI插件</h4><p>我们通常谈到CNI的插件，会存在歧义，主要有两种理解：</p><ol><li>一种是涉及到CNI底层开发的插件，可参考 <a href="https://www.cni.dev/plugins/current/">https://www.cni.dev/plugins/current/</a> ， 主要为自研提供基础能力；</li><li>另一种是已经实现CNI的现有项目，如 Flannel、Calico、Canal 和 Weave 等</li></ol><h3 id="CNI项目对比"><a href="#CNI项目对比" class="headerlink" title="CNI项目对比"></a>CNI项目对比</h3><p>CNI的可选项目有很多，如市场上主流的Flannel和Calico，CNCF中的Cilium等。</p><p>对于绝大多数的用户，我们不会关心具体实现，更多地是希望找到一个最适合自己的。横向对比的网络资料有很多，我这里提供一张图作为参考。</p><blockquote><p>链接 - <a href="https://itnext.io/benchmark-results-of-kubernetes-network-plugins-cni-over-10gbit-s-network-updated-august-2020-6e1b757b9e49">https://itnext.io/benchmark-results-of-kubernetes-network-plugins-cni-over-10gbit-s-network-updated-august-2020-6e1b757b9e49</a></p></blockquote><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/benchmark-cni.png" alt="benchmark-cni"></p><p>这里面的对比维度会让我们在选型时有所启发：</p><ul><li>配置</li><li>性能（带宽）</li><li>资源消耗</li><li>安全特性</li></ul><p>注意，表格里的快与慢、高与低都是相对值，在Kubernetes集群规模较大时才有明显差异。</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>在落地Kubernetes时，我们不要盲目地追求速度快、性能高的方案，尤其是对规模小、没有资深运维经验的团队，应该优先实现最简单、最容易维护的方案。</p><p>基于CNI的容器网络解决方案，替换性会比较强，可以在后续有了足够的经验、遇到了相关的瓶颈后，再考虑针对性地迁移。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57581641299795_.pic_hd.jpg&quot; alt=&quot;2022-02&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2022-02-28-C
      
    
    </summary>
    
      <category term="每日技术分享" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Daily-Sharing" scheme="http://example.com/tags/Daily-Sharing/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 15.【Go并发编程】自顶向下地写出优雅的Goroutine</title>
    <link href="http://example.com/2022/02/22/go-tip/go-tip-15/"/>
    <id>http://example.com/2022/02/22/go-tip/go-tip-15/</id>
    <published>2022-02-22T04:00:00.000Z</published>
    <updated>2022-02-22T07:45:25.903Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p><code>Go</code>语言的Goroutine特性广受好评，初学者也能快速地实现并发。但随着不断地学习与深入，有很多开发者都陷入了对<code>goroutine</code>、<code>channel</code>、<code>context</code>、<code>select</code>等并发机制的迷惑中。</p><p>这里，我将结合一个具体示例，自顶向下地介绍这部分的知识，帮助大家形成体系。具体代码以下面这段为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> SubFoo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>Foo()</code>为<strong>父Goroutine</strong>，内部开启了一个<strong>子Goroutine</strong> - <code>SubFoo()</code>。</p><h2 id="Part1-父子Goroutine的生命周期管理"><a href="#Part1-父子Goroutine的生命周期管理" class="headerlink" title="Part1 - 父子Goroutine的生命周期管理"></a>Part1 - 父子Goroutine的生命周期管理</h2><h3 id="聚焦核心"><a href="#聚焦核心" class="headerlink" title="聚焦核心"></a>聚焦核心</h3><p><strong>父Goroutine</strong> 与 <strong>子Goroutine</strong> 最重要的交集 - 是两者的生命周期管理。包括三种：</p><ol><li><strong>互不影响</strong> - 两者完全独立、各自运行</li><li><strong>parent控制children</strong> - 父Goroutine结束时，子Goroutine也能随即结束</li><li><strong>children控制parent</strong> - 子Goroutine结束时，父Goroutine也能随即结束</li></ol><p>这个生命周期的关系，重点体现的是两个协程之间的控制关系。</p><blockquote><p>注意，这时不要过于关注具体的代码实现，如数据传递，容易绕晕。</p></blockquote><h3 id="1-互不影响"><a href="#1-互不影响" class="headerlink" title="1-互不影响"></a>1-互不影响</h3><p>两个Goroutine互不影响的代码很简单，如同示例。</p><p>不过我们要注意一点，如果子goroutine需要context这个入参，尽量新建。更具体的内容我们看下一节。</p><h3 id="2-parent控制children"><a href="#2-parent控制children" class="headerlink" title="2-parent控制children"></a>2-parent控制children</h3><p>下面是一个最常见的用法，也就是利用了context：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="comment">// 退出前执行，表示parent执行完了</span></span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> SubFoo(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">// parent完成后，就退出</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，context并不是唯一的解法，我们也可以自建一个channel用来通知关闭。但综合考虑整个Go语言的生态，更建议大家尽可能地使用context，这里不扩散了。</p><blockquote><p>延伸 - 如果1个parent要终止多个children时，context的这种方式依然适用，而channel就很麻烦了。</p></blockquote><h3 id="3-children控制parent"><a href="#3-children控制parent" class="headerlink" title="3-children控制parent"></a>3-children控制parent</h3><p>逻辑也比较直观，我们直接看代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> SubFoo(ch)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 获取通知并退出</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 通知parent的channel</span></span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="情况3的延伸"><a href="#情况3的延伸" class="headerlink" title="情况3的延伸"></a>情况3的延伸</h4><p>如果1个parent产生了n个children时，又会有以下两种情况：</p><ol><li>n个children都结束了，才停止parent</li><li>n个children中有m个结束，就停止parent</li></ol><p>其中，前者的最常用的解决方案如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg = <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line">wg.Add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> SubFoo(wg)</span><br><span class="line"><span class="keyword">go</span> SubFoo(wg)</span><br><span class="line"><span class="keyword">go</span> SubFoo(wg)</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种延伸情况有很多种解法，有兴趣的可以自行研究，网上也有不少实现。</p><h3 id="Par1小结"><a href="#Par1小结" class="headerlink" title="Par1小结"></a>Par1小结</h3><p>从生命周期入手，我们能在脑海中快速形成代码的基本结构：</p><ol><li>互不影响 - 注意context独立</li><li>parent控制children - 优先用context控制</li><li>children控制parent - 一对一时用channel，一对多时用sync.WaitGroup等</li></ol><p>但在实际的开发场景中，parent和children的处理逻辑会有很多复杂的情况，导致我们很难像示例那样写出优雅的<code>select</code>等方法，我们会在下节继续分析，但不会影响这里梳理出的框架。</p><h2 id="Part2-for-select的核心机制"><a href="#Part2-for-select的核心机制" class="headerlink" title="Part2 - for+select的核心机制"></a>Part2 - for+select的核心机制</h2><p>一次性的select机制的代码比较简单，单次执行后即退出，讨论的意义不大。接下来，我将重点讨论for+select相关的代码实现。</p><h3 id="for-select的核心机制"><a href="#for-select的核心机制" class="headerlink" title="for+select的核心机制"></a>for+select的核心机制</h3><p>我们看一个来自官方的斐波那契数列的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- x:</span><br><span class="line">x, y = y, x+y</span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">quit &lt;- <span class="number">0</span></span><br><span class="line">&#125;()</span><br><span class="line">fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很长，我们聚焦于for+select这块，它实现了两个功能：</p><ol><li><code>c</code>传递数据</li><li><code>quit</code>传递停止的信号</li></ol><p>这时，如果你花时间去理解这两个channel的传递机制，容易陷入对select理解的误区；而我们应该从更高的维度，去看这两个case中获取到数据后的操作、即case中的执行逻辑，才能更好地理解整块代码。</p><h3 id="分析select中的case"><a href="#分析select中的case" class="headerlink" title="分析select中的case"></a>分析select中的case</h3><p>我们要注意到，在case里代码运行的过程中，整块代码是无法再回到select、去判断各case的（这里不讨论panic，return，os.Exit()等情况）。</p><p>以上面的代码为例，如果<code>x, y = y, x+y</code>函数的处理耗时，远大于<code>x</code>这个通道中塞入数据的速度，那么这个<code>x</code>的写入处将长期处于排队的阻塞状态。这时，不适合采用select这种模式。</p><p>所以，<strong>select适合IO密集型逻辑，而不适合计算密集型</strong>。也就是说，select中的每个case（包括default），应消耗尽量少的时间，快速回到for循环、继续等待。IO密集型常指文件、网络等操作，它消耗的CPU很少、更多的时间是在等待返回，它能更好地体现出<strong>runtime调度Goroutine的价值</strong>。</p><blockquote><p>Go 的 select这个关键词，可以结合网络模型中的select进行理解。</p></blockquote><h3 id="父子进程中的长逻辑处理"><a href="#父子进程中的长逻辑处理" class="headerlink" title="父子进程中的长逻辑处理"></a>父子进程中的长逻辑处理</h3><p>这时，如果我们的父子进程里，就是有那么一长段的业务逻辑，那代码该怎么写呢？我们来看看下面这一段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">LongLogic()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LongLogic</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 如1累加到10000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>LongLogic()</code>会花费很长的运行时间，所以当外部的context取消了，也就是父Goroutine发出通知可以结束了，这个子Goroutine是无法快速触发到<code>&lt;-ctx.Done()</code>的，因为它还在跑<code>LongLogic()</code>里的代码。也就是说，子进程生命周期结束的时间点延长到<code>LongLogic()</code>之后了。</p><p>这个问题的原因在于违背了我们上面讨论的点，即在select的case里包含了计算密集型任务。</p><blockquote><p>补充一下，case里包含长逻辑不代表程序一定有问题，但或多或少地不符合for+select+channel的设计理念。</p></blockquote><h3 id="两个长逻辑处理"><a href="#两个长逻辑处理" class="headerlink" title="两个长逻辑处理"></a>两个长逻辑处理</h3><p>这时，我们再来写个长进程处理，整个代码结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">LongLogic()</span><br><span class="line"><span class="keyword">case</span> &lt;-dataCh2:</span><br><span class="line">LongLogic()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>dataCh</code>和<code>dataCh2</code>会产生竞争，也就是两个通道的 <strong>写长期阻塞、读都在等待LongLogic执行完成</strong>。给channel加个buffer可以减轻这个问题，但无法根治，运行一段时间依旧会阻塞。</p><h3 id="改造思路"><a href="#改造思路" class="headerlink" title="改造思路"></a>改造思路</h3><p>有了上面代码的基础，改造思路比较直观了，将<code>LongLogic</code>异步化，我们先通过新建协程来简单实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line"><span class="keyword">go</span> LongLogic()</span><br><span class="line"><span class="keyword">case</span> &lt;-finishedCh:</span><br><span class="line">fmt.Println(<span class="string">&quot;LongLogic finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LongLogic</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Minute)</span><br><span class="line">finishedCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里要注意一个点，如果<code>LongLogic()</code>是一段需要CPU密集计算的代码，比如计算1累加到10000，它是没有办法通过channel等其余方式突然中止的。它具备一定的原子性 - <strong>要么不跑，要么跑完，跑的过程中没有外部插手的地方</strong>。</p><p>而如果硬要中断<code>LongLogic()</code>，那就往往只能杀掉整个进程。</p><h3 id="Part2小结"><a href="#Part2小结" class="headerlink" title="Part2小结"></a>Part2小结</h3><p>我们记住for+select代码块设计的核心要领 - IO密集型。Go语言的goroutine特性，更多地是为了解决IO密集型程序的问题所设计的，对计算密集型的任务较其它语言没有太大优势。落到具体实践上，就是<strong>让每个case中代码的运行时间尽可能地短，快速回到for循环里的select去继续监听各个case中的channel</strong>。</p><p>上面这段代码比较粗糙，在具体工程中会遇到很多问题，比如无限制地开启了大量的<code>LongLogic()</code>协程。我们会在下一节继续来看。</p><h2 id="Part3-长耗时功能的优化"><a href="#Part3-长耗时功能的优化" class="headerlink" title="Part3 - 长耗时功能的优化"></a>Part3 - 长耗时功能的优化</h2><p>通过前面两篇的铺垫，我们对 <strong>父子Goroutine的生命周期管理</strong> 与 <strong>for+select的核心机制</strong> 有了基本的了解，把问题聚焦到了耗时较长的处理函数中。</p><p>今天，我们再接着看看在具体工程中的优化点。</p><h3 id="实时处理"><a href="#实时处理" class="headerlink" title="实时处理"></a>实时处理</h3><p>我们先回顾上一讲的这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line"><span class="keyword">go</span> LongLogic()</span><br></pre></td></tr></table></figure><p>直觉会认为<code>go LongLogic()</code>这里会很容易出现性能问题：当<code>dataCh</code>的数据写入速度很快时，有大量的<code>LongLogic()</code>还未结束、仍在程序内运行，导致CPU超负荷。</p><p>但是，如果这些代码编写的逻辑问题确实就是业务逻辑，即：<strong>程序确确实实需要实时处理这么多的数据</strong>，那我们该怎么做呢？</p><p>常规思路中引入 <strong>排队机制</strong> 确实是一个方案，但很容易破坏原始需求 - <strong>实时计算处理</strong>，排队机制会导致延迟，这是业务无法接收的。在现实中，扩增资源是最直观的解决方案，最常见是利用Kubernetes平台的Pod水平扩容机制HPA，保证CPU使用率到达一定程度后自动扩容，而不用在程序中加上限制。</p><p>从本质上来说，这个问题是对<strong>实时计算资源</strong>的需求。</p><h3 id="非实时处理-程序外优化"><a href="#非实时处理-程序外优化" class="headerlink" title="非实时处理 - 程序外优化"></a>非实时处理 - 程序外优化</h3><p>在实际工程中，我们其实往往对实时性要求没有那么高，所以排队等限流机制带来的延时可以接受的，也就是准实时。而综合考虑到研发代码质量的不确定性，迭代过程可能中会引入bug导致调用量暴增，这时限流机制能大幅提升程序的健壮性。</p><p>在程序外部，我们可以依赖消息队列进行削峰填谷，如：</p><ul><li>配置消息积压的告警来保证生产能力与消费能力的匹配</li><li>配置限流参数来保证不要超过消费者程序的处理极限，避免雪崩</li></ul><p>这里的消息队列在软件架构中是一个 <strong>分离生产与消费程序</strong> 的设计，有利于两侧程序的健壮性。在计算密集型的场景中，意义尤为重大，只需要针对计算密集型的消费者进行快速地扩缩容。</p><h3 id="非实时处理-程序内优化"><a href="#非实时处理-程序内优化" class="headerlink" title="非实时处理 - 程序内优化"></a>非实时处理 - 程序内优化</h3><p>上面消息队列方案虽然很棒，但从系统来说引入了一个新的组件，在业务体量小的场景里，有一种杀鸡用牛刀的感觉，对部分没有消息队列的团队来说成本也较高。</p><p>那么，我们尝试在程序中做一下优化。首先，我们在上层要做一次抽象，将逻辑收敛到一个独立的package中(示例中为logic)，方便后续优化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line"><span class="comment">// logic包内部保证</span></span><br><span class="line">logic.Run()</span><br><span class="line"><span class="keyword">case</span> result := &lt;-logic.Finish():</span><br><span class="line">fmt.Println(<span class="string">&quot;result&quot;</span>, result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而logic包中的大致框架如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> logic</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> finishedCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 在这里引入排队机制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// long time process</span></span><br><span class="line"></span><br><span class="line">&lt;-finishedCh</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Finish</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> finishedCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以在这里加一个<code>error</code>返回，在排队满时返回给调用方，由调用方决定怎么处理，如丢弃或重新排队等。排队机制的代码是业务场景决定的，我就不具体写了。</p><p>这种解法，可以类比到一个线程池管理。而更上层的for+select维度来看，类似于一个负责调度任务的master+多个负责执行任务的worker。</p><h3 id="Part3小结"><a href="#Part3小结" class="headerlink" title="Part3小结"></a>Part3小结</h3><p>我们分别从三个场景分析了耗时较长的处理函数：</p><ul><li><strong>实时处理</strong> - 结合Paas平台进行资源扩容</li><li><strong>非实时处理 - 程序外优化</strong> - 引入消息队列</li><li><strong>非实时处理 - 程序内优化</strong> - 实现一个线程池控制资源</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分享的内容只是Go并发编程的冰山一角，希望能对大家有所启发，也欢迎与我讨论~</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;h
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 11.【全排列LeetCode-46】</title>
    <link href="http://example.com/2022/02/21/go-leetcode/go-leetcode-11/"/>
    <id>http://example.com/2022/02/21/go-leetcode/go-leetcode-11/</id>
    <published>2022-02-21T04:00:00.000Z</published>
    <updated>2022-02-20T13:33:17.638Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-46-全排列"><a href="#Leetcode-46-全排列" class="headerlink" title="Leetcode-46 全排列"></a>Leetcode-46 全排列</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="基础解法"><a href="#基础解法" class="headerlink" title="基础解法"></a>基础解法</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-46-全排列&quot;&gt;&lt;a href=&quot;#Leetcode-46-全排列&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-46 全排列&quot;&gt;&lt;/a&gt;Leetcode-46 全排列&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/permutations/&quot;&gt;https://leetcode-cn.com/problems/permutations/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;permute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nums []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; [][]&lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法实战" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>五分钟技术小分享 - 2022Week08</title>
    <link href="http://example.com/2022/02/21/sharing-5min/2022-02/2022Week08/"/>
    <id>http://example.com/2022/02/21/sharing-5min/2022-02/2022Week08/</id>
    <published>2022-02-21T04:00:00.000Z</published>
    <updated>2022-03-03T02:25:09.889Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57581641299795_.pic_hd.jpg" alt="2022-02"></p><h2 id="2022-02-21-自顶向下地写出优雅的Goroutine（下）"><a href="#2022-02-21-自顶向下地写出优雅的Goroutine（下）" class="headerlink" title="2022-02-21 自顶向下地写出优雅的Goroutine（下）"></a>2022-02-21 自顶向下地写出优雅的Goroutine（下）</h2><p>通过前面两篇的铺垫，我们对 <strong>父子进程的生命周期管理</strong> 与 <strong>select代码的核心机制</strong> 有了基本的了解。</p><p>今天我们再接着看看在具体工程中的优化点。注意，在上一篇，我们已经把问题聚焦到了耗时较长的处理函数中。</p><h3 id="实时处理"><a href="#实时处理" class="headerlink" title="实时处理"></a>实时处理</h3><p>我们先看回顾上一讲的这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line"><span class="keyword">go</span> LongLogic()</span><br></pre></td></tr></table></figure><p>简单想一下，我们会觉得<code>LongLogic()</code>这里会很容易出现性能问题：当<code>dataCh</code>的数据写入速度很快时，有大量的<code>LongLogic()</code>还未结束、仍在程序内运行，导致CPU超负荷。</p><p>但是，如果这些代码编写的逻辑问题确实就是业务逻辑，即：<strong>程序确确实实需要实时处理这么多的数据</strong>，那我们该怎么做呢？</p><p>常规思路中引入 <strong>排队机制</strong> 确实是一个方案，但很容易破坏原始需求 - <strong>实时计算处理</strong>，排队机制会导致延迟，那这就是业务无法接受的。在现实中，扩增资源是最直观的解决方案，最常见是利用Kubernetes平台的Pod水平扩容机制，保证CPU使用率到达一定程度后自动扩容，而不用在程序中加上限制。</p><p>这个问题的本质上是实时计算资源的需求。</p><h3 id="非实时处理-程序外优化"><a href="#非实时处理-程序外优化" class="headerlink" title="非实时处理 - 程序外优化"></a>非实时处理 - 程序外优化</h3><p>在实际工程中，我们其实往往对实时性要求没有那么高，所以排队等限流机制带来的延时可以接受的。而综合考虑到研发代码质量的不确定性，迭代过程可能中会引入bug导致调用量暴增，这时限流机制能提升程序的健壮性。</p><p>在程序外部，我们可以依赖消息队列进行削峰填谷：</p><ul><li>配置消息积压的告警来保证生产者程序的监控</li><li>配置限流参数来保证不要超过消费者程序的处理极限</li></ul><p>在这里，消费队列在软件架构中是一个 <strong>分离生产与消费程序</strong> 的设计，有利于两侧程序的健壮性。在计算密集型的场景中，意义尤为重大。</p><h3 id="非实时处理-程序内优化"><a href="#非实时处理-程序内优化" class="headerlink" title="非实时处理 - 程序内优化"></a>非实时处理 - 程序内优化</h3><p>上面消息队列方案虽然很棒，但从系统来说引入了一个新的组件，有时一种杀鸡用牛刀的感觉，对部分没有消息队列的团队来说也比较难以接受。</p><p>那么，我们尝试在程序中做一下优化。首先，我们在上层要做一次抽象，将逻辑收敛到一个独立的package中(示例中为logic)，方便后续优化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line"><span class="comment">// logic包内部保证</span></span><br><span class="line">logic.Run()</span><br><span class="line"><span class="keyword">case</span> result := &lt;-logic.Finish():</span><br><span class="line">fmt.Println(<span class="string">&quot;result&quot;</span>, result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而logic包中的大致框架如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> logic</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> finishedCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 在这里引入排队机制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// long time process</span></span><br><span class="line"></span><br><span class="line">&lt;-finishedCh</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Finish</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> finishedCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以在这里加一个<code>error</code>返回，在排队满时返回给调用方，由调用方决定怎么处理，如丢弃或重新排队等。排队机制的代码是业务场景决定的，我就不具体写了，本质上类似于一个线程池管理。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从今天，我们分别从三个场景分析了耗时较长的处理函数：</p><ul><li><strong>实时处理</strong> - 结合Paas平台进行资源扩容</li><li><strong>非实时处理 - 程序外优化</strong> - 引入消息队列</li><li><strong>非实时处理 - 程序内优化</strong> - 程序内的线程池</li></ul><p>到这里，我们自顶向下地写出优雅的Goroutine的三讲已经完成了，希望对大家有所启发，也欢迎向我提问。</p><h2 id="2022-02-22-CNCF-Prometheus"><a href="#2022-02-22-CNCF-Prometheus" class="headerlink" title="2022-02-22 CNCF-Prometheus"></a>2022-02-22 CNCF-Prometheus</h2><p>看完了调度管理层与应用层的项目后，我们接下来了解可观察性和分析这块。提升可观察性和分析能力，非常有助于对整套系统的掌控。</p><p>今天的主角是CNCF中第二个毕业的项目 - Prometheus，它提供了软件系统核心的监控功能。我们今天就从核心架构入手，了解其特性。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/prom-architecture.png" alt="prom-architecture"></p><p>这张图中的内容核心分为五块：</p><ul><li>指标收集端 - Exporters + Pushgateway<ul><li>Exporters 长生命周期的进程，将指标保存在内存，重启后清零</li><li>Pushgateway 作为短生命周期指标的“中转站”</li></ul></li><li>服务端 - Prometheus Server</li><li>服务发现 - Kubernetes等<ul><li>对接Kubernetes平台原生兼容</li><li>对接非k8s平台，可以选择consul或者直接采用静态文件配置</li></ul></li><li>告警 - Alertmanager</li><li>展示 - Prometheus web UI + Grafana等<ul><li>web ui可以用来查看简单的指标</li><li>Grafana是最主流的指标展示工具，没有之一</li></ul></li></ul><blockquote><p>文档写得比较粗糙，欢迎大家通过这个视频链接看看更详细的说明 <a href="https://www.bilibili.com/video/BV1PP4y1c7ps/">https://www.bilibili.com/video/BV1PP4y1c7ps/</a></p></blockquote><h3 id="八大特性"><a href="#八大特性" class="headerlink" title="八大特性"></a>八大特性</h3><ul><li>多维度数据Dimensional data - Prometheus implements a highly dimensional data model. Time series are identified by a metric name and a set of key-value pairs.</li><li>强力的查询Powerful queries - PromQL allows slicing and dicing of collected time series data in order to generate ad-hoc graphs, tables, and alerts.</li><li>很棒的可视化Great visualization - Prometheus has multiple modes for visualizing data: a built-in expression browser, Grafana integration, and a console template language.</li><li>高效存储Efficient storage - Prometheus stores time series in memory and on local disk in an efficient custom format. Scaling is achieved by functional sharding and federation.</li><li>简单操作Simple operation - Each server is independent for reliability, relying only on local storage. Written in Go, all binaries are statically linked and easy to deploy.</li><li>精确告警Precise alerting - Alerts are defined based on Prometheus’s flexible PromQL and maintain dimensional information. An alertmanager handles notifications and silencing.</li><li>很多客户端库Many client libraries - Client libraries allow easy instrumentation of services. Over ten languages are supported already and custom libraries are easy to implement.</li><li>大量现有集成Many integrations - Existing exporters allow bridging of third-party data into Prometheus. Examples: system statistics, as well as Docker, HAProxy, StatsD, and JMX metrics.</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><code>Prometheus</code>的官方文档 - <a href="https://prometheus.io/docs/introduction/overview/">https://prometheus.io/docs/introduction/overview/</a> 提供了很多有价值的信息，尤其是原理和最佳实践。我也曾经实践过一套企业级的<code>Prometheus</code>平台，有机会的话会和大家分享分享。</p><h2 id="2022-02-23-CNCF-Cortex-Thanos"><a href="#2022-02-23-CNCF-Cortex-Thanos" class="headerlink" title="2022-02-23 CNCF-Cortex/Thanos"></a>2022-02-23 CNCF-Cortex/Thanos</h2><p>今天，我将串讲两个基于Prometheus的扩展的项目：Cortex和Thanos。</p><p>为了让大家更好地了解到大型监控系统的方案，我将结合Prometheus自带的联邦方案和大家聊聊。</p><h3 id="Prometheus的联邦模式"><a href="#Prometheus的联邦模式" class="headerlink" title="Prometheus的联邦模式"></a>Prometheus的联邦模式</h3><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/prometheus-federation.png" alt="prometheus-federation"></p><p>联邦模式是一种树状的级联模式，核心体现出了一个点：<code>Prometheus</code>本身就是一种Exporter，可以用来采集指标。</p><p>关于这个架构，我们还能发现以下特点：</p><ol><li>Prometheus高可用方案，是多个上层节点重复Pull下层数据，本质上仍然是单点保存全量数据</li><li>Prometheus提供远程存储方案，但远程存储的能力很有限，往往只能支持异常后数据恢复</li><li>Prometheus提供了record rule等指标加工能力，可以减少上层的数据存储</li><li>可以更好地保证网络的安全性，减少防火墙的配置</li></ol><p>联邦模式基本能支持大多数Prometheus的场景，一般建议优先考虑。</p><h3 id="Cortex"><a href="#Cortex" class="headerlink" title="Cortex"></a>Cortex</h3><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/cortex-architecture.png" alt="cortex-architecture"></p><p>对标到上面的Prometheus联邦模式，Cortex核心是依赖远程写的接口。写完数据后，Cortex就与Prometheus完全没有依赖了。也就是说，Cortex是构建在Prometheus之上的一套解决方案。</p><p>上面的架构有很多细节上的实现，但我不想在这里聊得太细，主要考虑到：作为使用方，我们不需要过于关注Cortex的实现，毕竟它只依赖Prometheus远程写的接口，完全可以独立于Prometheus、快速迭代自身的架构。</p><p>所以，如果你想使用Cortex，可以看看官方的介绍文档 - <a href="https://cortexmetrics.io/%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%E6%98%AF%E4%BD%A0%E7%89%B9%E5%88%AB%E5%85%B3%E6%B3%A8%E7%9A%84%E3%80%82">https://cortexmetrics.io/，有什么特性是你特别关注的。</a></p><h3 id="Thanos"><a href="#Thanos" class="headerlink" title="Thanos"></a>Thanos</h3><p>Thanos提供了两种模式<code>Sidecar</code>和<code>Receive</code>，其中后者提出的时间不长，与Cortex的实现基本一致，我们就不细看了。我们重点看看边车的实现。</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/thanos-architecture.png" alt="thanos-architecture"></p><p>我们重点聚焦到Thanos和Prometheus的交互：</p><ol><li>读 - 从Thanos传到Prometheus远程读的接口，再进行数据查询</li><li>写 - 由于是sidecar模式，两者共享Pod里的数据，所以Prometheus写入的数据可以由Thanos直接访问</li></ol><p>从这两点来看，Thanos好像什么都没做，那它的意义在哪呢？其实，Thanos的核心是：<strong>依赖图中的对象存储，实现出的一套分布式的解决方案</strong>。</p><p>我们上文提到，Prometheus本质上还是一个单体的架构，而Thanos提供的分布式方案，从理论上可以解决单点计算力的问题。所以，Thanos对标Prometheus和Cortex的差异性价值，非常依赖它在分布式上的表现。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>整体来说，关于Prometheus的扩展方案，我个人的倾向如下：</p><ol><li>联邦模式：使用Prometheus的必要基础，有很多优化技巧，建议优先考虑；</li><li>Cortex：对现有的Prometheus侵入小，适合快速解决问题，但长期来看很受限；</li><li>Thanos：是对Prometheus从单体到分布式的一种改造，发展前景很棒，但遇到的问题也自然更多；</li></ol><p>今天聊的这三种方案理解起来不难，我更希望对大家在软件架构上有所启发。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57581641299795_.pic_hd.jpg&quot; alt=&quot;2022-02&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2022-02-21-自
      
    
    </summary>
    
      <category term="每日技术分享" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Daily-Sharing" scheme="http://example.com/tags/Daily-Sharing/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 10.【圆环回原点问题】</title>
    <link href="http://example.com/2022/02/19/go-leetcode/go-leetcode-10/"/>
    <id>http://example.com/2022/02/19/go-leetcode/go-leetcode-10/</id>
    <published>2022-02-19T04:00:00.000Z</published>
    <updated>2022-02-19T13:32:23.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="经典面试题-圆环回原点问题"><a href="#经典面试题-圆环回原点问题" class="headerlink" title="经典面试题 圆环回原点问题"></a>经典面试题 圆环回原点问题</h2><p>0-12共13个数构成一个环，从0出发，每次走1步，走n步回到0共有多少种走法？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CircleToOrigin</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="基础思路"><a href="#基础思路" class="headerlink" title="基础思路"></a>基础思路</h2><p>这道题需要一定的<strong>动态规划</strong>的基础，我们要对这道题做一定的简化，也就是将n变量变成n-1，看看前一步走到了哪。</p><p><code>第n步走到0 = 第n-1步走到12 + 第n-1步走到1</code></p><p>所以，我们要引入一个变量，就是当前走到了哪个位置。用代码表示，就是</p><p><code>result[n][pos] = result[n-1][pos+1] + result[n-1][pos-1] </code></p><p>我们再考虑到pos-1&lt;0的情况，保证处于0到12的范围，代码就更新为:</p><p><code>result[n][pos] = result[n-1][(pos+1+13)%13] + result[n-1][(pos-1+13)%13]</code></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CircleToOrigin</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">make</span>([][]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">result[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">13</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始处于原点</span></span><br><span class="line">result[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">13</span>; j++ &#123;</span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line">result[i][j] = result[i<span class="number">-1</span>][(j+<span class="number">1</span>+<span class="number">13</span>)%<span class="number">13</span>] + result[i<span class="number">-1</span>][(j<span class="number">-1</span>+<span class="number">13</span>)%<span class="number">13</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result[n][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个代码实现很清晰。我们可以将这个<code>13</code>提取出来作为一个变量，也就是环的大小可以自行变化。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态规划最重要的是写出递推的公式，是我们重点需要记忆的部分，剩余的就是考虑边界条件即可。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;经典面试题-圆环回原点问题&quot;&gt;&lt;a href=&quot;#经典面试题-圆环回原点问题&quot; class=&quot;headerlink&quot; title=&quot;经典面试题 圆环回原点问题&quot;&gt;&lt;/a&gt;经典面试题 圆环回原点问题&lt;/h2&gt;&lt;p&gt;0-12共13个数构成一个环，从0出发，每次走1步，走n步回到0共有多少种走法？&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CircleToOrigin&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(n &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法实战" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>五分钟技术小分享 - 2022Week07</title>
    <link href="http://example.com/2022/02/14/sharing-5min/2022-02/2022Week07/"/>
    <id>http://example.com/2022/02/14/sharing-5min/2022-02/2022Week07/</id>
    <published>2022-02-14T04:00:00.000Z</published>
    <updated>2022-02-18T13:50:32.838Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57581641299795_.pic_hd.jpg" alt="2022-02"></p><h2 id="2022-02-14-CNCF-Argo"><a href="#2022-02-14-CNCF-Argo" class="headerlink" title="2022-02-14 CNCF-Argo"></a>2022-02-14 CNCF-Argo</h2><p><code>Argo</code>是Kubernetes上最受欢迎的工作流引擎，已经有大量的用户群体与软件生态。围绕着Workflow这个关键词，我们来一起初步了解<code>Argo</code>。</p><blockquote><p>Workflow engine for Kubernetes</p></blockquote><ul><li>官网 - <a href="https://argoproj.github.io/">https://argoproj.github.io/</a></li><li>Github - <a href="https://github.com/argoproj/argo-workflows">https://github.com/argoproj/argo-workflows</a></li></ul><h3 id="Argo-Workflow"><a href="#Argo-Workflow" class="headerlink" title="Argo Workflow"></a>Argo Workflow</h3><p>官方的介绍分为四点（前两点描述的是基本原理，后两者描述的是特定应用的价值）：</p><ol><li>工作流的每一个步骤都是一个容器；</li><li>以DAG（有向无环图）来分析工作流的依赖；</li><li>对计算密集型任务（如机器学习、大数据处理），能充分利用k8s集群的相对空闲的碎片时间；</li><li>结合CICD流水线，让应用能运行在云原生环境里快速迭代；</li></ol><h3 id="为什么使用Argo-Workflow"><a href="#为什么使用Argo-Workflow" class="headerlink" title="为什么使用Argo Workflow"></a>为什么使用Argo Workflow</h3><p><code>Argo</code>的工作流对标传统的CICD有很多亮点，但如果谈论其核心价值，主要集中在两点：</p><ol><li>保证应用的整个生命周期都基于云原生生态，彻底抛弃原来的虚拟机等模式；</li><li>完全对接云原生，有利于充分利用Kubernetes实现更便捷的并行、扩缩容等操作；</li></ol><p>我们就以一个经典的CICD Workflow的发展历程来看：</p><ol><li>传统Jenkins为核心的CICD<ol><li>提交代码到Gitlab</li><li>触发Jenkins编译任务，某VM服务器编译出二进制文件并发布</li><li>触发Jenkins部署任务，将二进制文件发布到对应机器并重新运行程序</li></ol></li><li>改进版 - 容器化，将Gitlab/Jenkins/编译服务器等都改造到容器化平台中</li><li>云原生化 - 利用Argo Workflow</li></ol><blockquote><p>第二与第三阶段的区分并不清晰，我个人会从 <strong>配置是否集中化</strong> 这个特点进行分析。</p></blockquote><p>目前很多大公司的CICD仍处于第二阶段，但它们沉淀出了不少类似于<code>Argo</code>工作流的能力。我们可以从以下三点进行思考：</p><ol><li><strong>工作流是和公司强相关的</strong>：往往依赖公司内的各种平台，如OA；</li><li><strong>工作流的开发难度不高</strong>：只要规则清晰、要求严格，整体的开发量并不大，所以有能力、有资源的大公司，并不愿意太依赖开源生态；</li><li><strong>云原生的工作流价值仍比较有限</strong>：<code>Argo</code>体现出的价值，有不少类似的方案可以替代；</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>Argo</code>项目的用户在社区中日趋增长，这其实体现出了一个趋势 - <strong>互联网进入精耕细作的阶段</strong>。</p><p>在野蛮生长阶段遇到瓶颈时，公司会趋向于用扩增大量的人力或机器资源来解决问题；而在精耕细作阶段，随着Kubenetes为代表的基础平台能力的标准化，整个生态提供了丰富的能力集，技术人员更应重视遵循规范，把时间投入到合理的方向，来快速地迭代业务。</p><p>这时，以<code>Argo</code>为代表的工作流引擎，能帮助整个开发体系落地自动化的规范，自然越来越受到欢迎。</p><h2 id="2022-02-15-谈谈对Go接口断言的误区"><a href="#2022-02-15-谈谈对Go接口断言的误区" class="headerlink" title="2022-02-15 谈谈对Go接口断言的误区"></a>2022-02-15 谈谈对Go接口断言的误区</h2><p>最近有好几个朋友和我聊到Go语言里的接口interface相关的使用方法，发现了一个常见的误区。今天，我分享一下我的思考，希望能给大家带来启发。</p><h3 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">interface</span> &#123;</span><br><span class="line">  Pay() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">orderImpl1</span> <span class="title">struct</span></span>&#123;</span><br><span class="line">  Id <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(order *orderImpl1)</span><span class="title">Pay</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">orderImpl2</span> <span class="title">struct</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(order *orderImpl2)</span><span class="title">Pay</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个很常见的接口与实现的示例。</p><h3 id="接口断言背后的真正问题"><a href="#接口断言背后的真正问题" class="headerlink" title="接口断言背后的真正问题"></a>接口断言背后的真正问题</h3><p>在代码中，我们经常会对抽象进行断言，来获取更详细的信息，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 在这里是一个接口</span></span><br><span class="line">  <span class="keyword">var</span> order Order</span><br><span class="line">  <span class="comment">// 断言是orderImpl1，并打印其中内容</span></span><br><span class="line">  <span class="keyword">if</span> o,ok := order.(orderImpl1); ok &#123;</span><br><span class="line">    fmt.Println(o.Id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很清晰，让我们层层递进，思考一下这段代码背后的真正逻辑：程序要使用 <strong>接口背后的具体实现</strong>（orderImpl1中的Id字段）。</p><p>这种做法，就和接口所要解决的问题背道而驰了：接口是为了屏蔽具体的实现细节，而这里的代码又回退成了具体实现。所以，这个现象的真正问题是：<strong>接口抽象得不够完全</strong>。</p><h3 id="解法1：新增获取方法"><a href="#解法1：新增获取方法" class="headerlink" title="解法1：新增获取方法"></a>解法1：新增获取方法</h3><p>这个解法很直接，我们增加一个接口方法即可，如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Order <span class="keyword">interface</span> &#123;</span><br><span class="line">  Pay() error</span><br><span class="line">  GetId() <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果要区分具体实现，即orderImpl2没有Id字段，我们最好采用一个error字段进行区分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Order <span class="keyword">interface</span> &#123;</span><br><span class="line">  Pay() error</span><br><span class="line">  GetId() (<span class="keyword">int64</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法2：封装背后的真正逻辑"><a href="#解法2：封装背后的真正逻辑" class="headerlink" title="解法2：封装背后的真正逻辑"></a>解法2：封装背后的真正逻辑</h3><p>上面<code>GetId</code>这个方法，只是一个具体动作，按DDD的说法，这是一个贫血的模型。我们真正要关注的是 - <strong>获取Id后真正的业务逻辑，将其封装成一个方法</strong>。</p><p>比如说，我们要获取这个Id后，想要根据这个Id取消这个订单，那么完全可以封装到一个<code>Cancel()</code>函数中；</p><p>又比如说，我们仅仅想要打印具体实现的内部信息，那么完全可以实现一个<code>Debug() string</code>方法，将想要的内容都拼成字符串返回出来。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>今天讲的这个case在业务开发中非常常见，它是一种惯性思维解决问题的产物。我们无需苛求所有抽象都要到位，但心里一定要有明确的解决方案。</p><h2 id="2022-02-16-CNCF-Flux"><a href="#2022-02-16-CNCF-Flux" class="headerlink" title="2022-02-16 CNCF-Flux"></a>2022-02-16 CNCF-Flux</h2><p>今天我们来看CNCF中另一款持续交付的项目 - <code>Flux</code>。相对于<code>Argo</code>，<code>Flux</code>的应用范围不广，但它的功能更加简洁、使用起来也更为便捷。</p><ul><li>官网 - <a href="https://fluxcd.io/">https://fluxcd.io/</a></li><li>Github - <a href="https://github.com/fluxcd/flux2">https://github.com/fluxcd/flux2</a></li></ul><h3 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h3><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/gitops-toolkit.png" alt="gitops-toolkit"></p><p><code>Flux</code>的核心实现非常清晰，主要分为两块：</p><ol><li>Source controller用于监听Source的变化，如常见的github、gitlab、helm；</li><li>将部署任务，交由Kustomize controller 或 Helm controller进行实现；</li></ol><blockquote><p>这里有一个秀英语单词的技巧，在软件系统里经常会将定制化这个词，Customize用Kustomize代替。</p></blockquote><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>官方的核心概念如下：<a href="https://fluxcd.io/docs/concepts/">https://fluxcd.io/docs/concepts/</a></p><ol><li>GitOps的理念有很多说法，可以简单认为就是：<strong>围绕着Git而展开的一套CICD机制</strong>。</li></ol><blockquote><p>GitOps is a way of managing your infrastructure and applications so that whole system is described declaratively and version controlled (most likely in a Git repository), and having an automated process that ensures that the deployed environment matches the state specified in a repository.</p></blockquote><ol start="2"><li>Source源，包括期望状态与获取的途径。</li></ol><blockquote><p>A <em>Source</em> defines the origin of a repository containing the desired state of the system and the requirements to obtain it (e.g. credentials, version selectors). </p></blockquote><ol start="3"><li>Reconciliation协调，重点是怎么协调、也就是Controller执行的逻辑，最常见的就是自己编写一个Operator。</li></ol><blockquote><p>Reconciliation refers to ensuring that a given state (e.g. application running in the cluster, infrastructure) matches a desired state declaratively defined somewhere (e.g. a Git repository).</p></blockquote><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>CICD相关软件目前的格局还不是很清晰，建议大家多花时间在选型上，尽可能地符合自己的业务场景，而不建议做过多的二次开发。<code>Flux</code>是一个非常轻量级的CD项目，对接起来很方便，很适合无历史包袱的研发团队快速落地。</p><h2 id="2022-02-17-自顶向下地写出优雅的Goroutine（上）"><a href="#2022-02-17-自顶向下地写出优雅的Goroutine（上）" class="headerlink" title="2022-02-17 自顶向下地写出优雅的Goroutine（上）"></a>2022-02-17 自顶向下地写出优雅的Goroutine（上）</h2><p><code>Go</code>语言的Goroutine特性广受好评，让初学者也能快速地实现并发。但随着不断地学习与深入，有很多开发者都陷入了对<code>goroutine</code>、<code>channel</code>、<code>context</code>、<code>select</code>等并发机制的迷惑中。</p><p>那么，我将自顶向下地介绍这部分的知识，帮助大家形成体系。具体的代码以下面这段为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> SubFoo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>Foo()</code>为<strong>父Goroutine</strong>，内部开启了一个<strong>子Goroutine</strong> - <code>SubFoo()</code>。</p><h3 id="聚焦核心"><a href="#聚焦核心" class="headerlink" title="聚焦核心"></a>聚焦核心</h3><p><strong>父Goroutine</strong> 与 <strong>子Goroutine</strong> 最重要的交集 - 是两者的生命周期管理。包括三种：</p><ol><li>互不影响 - 两者完全独立</li><li>parent控制children - 父Goroutine结束时，子Goroutine也能随即结束</li><li>children控制parent - 子Goroutine结束时，父Goroutine也能随即结束</li></ol><p>这个生命周期的关系，体现了一种控制流的思想。</p><blockquote><p>注意，这个时候不要去关注具体的数据或代码实现，初学者容易绕晕。</p></blockquote><h3 id="1-互不影响"><a href="#1-互不影响" class="headerlink" title="1-互不影响"></a>1-互不影响</h3><p>两个Goroutine互不影响的代码很简单，如同示例。</p><p>不过我们要注意一点，如果子goroutine需要context这个入参，尽量新建。这点我们看第二个例子就清楚了。</p><h3 id="2-parent控制children"><a href="#2-parent控制children" class="headerlink" title="2-parent控制children"></a>2-parent控制children</h3><p>下面是一个最常见的用法，也就是利用了context：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="comment">// 退出前执行，表示parent执行完了</span></span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> SubFoo(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">// parent完成后，就退出</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，context并不是唯一的解法，我们也可以自建一个channel用来通知关闭。但综合考虑整个Go语言的生态，更建议大家尽可能地使用context，这里不扩散了。</p><blockquote><p>延伸 - 如果1个parent要终止多个children时，context的这种方式依然适用。</p></blockquote><h3 id="3-children控制parent"><a href="#3-children控制parent" class="headerlink" title="3-children控制parent"></a>3-children控制parent</h3><p>这部分的逻辑也比较直观：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> SubFoo(ch)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 获取通知并退出</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 通知parent的channel</span></span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="情况3的延伸"><a href="#情况3的延伸" class="headerlink" title="情况3的延伸"></a>情况3的延伸</h3><p>如果1个parent产生了n个children时，又会有以下两种情况：</p><ol><li>n个children都结束了，才停止parent</li><li>n个children中有m个结束，就停止parent</li></ol><p>其中，前者的最常用的解决方案如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg = <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line">wg.Add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> SubFoo(wg)</span><br><span class="line"><span class="keyword">go</span> SubFoo(wg)</span><br><span class="line"><span class="keyword">go</span> SubFoo(wg)</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这两个延伸情况更多的解法，就留给大家自己去思考了，它们有不止一种解法。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>从生命周期入手，我们能快速地形成代码的基本结构：</p><ol><li>互不影响 - 注意context独立</li><li>parent控制children - 优先用context控制</li><li>children控制parent - 一对一时用channel，一对多时用sync.WaitGroup等</li></ol><p>但在实际的开发场景中，parent和children的处理逻辑会有很多复杂的情况，导致我们很难像示例那样写出优雅的<code>select</code>等方法，我们会在下期继续分析，但不会影响我们今天梳理出的框架。</p><h2 id="2022-02-18-自顶向下地写出优雅的Goroutine（中）"><a href="#2022-02-18-自顶向下地写出优雅的Goroutine（中）" class="headerlink" title="2022-02-18 自顶向下地写出优雅的Goroutine（中）"></a>2022-02-18 自顶向下地写出优雅的Goroutine（中）</h2><p>通过上一篇，我们通过生命周期管理了解了父子进程的大致模型。</p><p>今天，我们将更进一步，分析优雅的Goroutine的核心语法 - select。</p><h3 id="了解select的核心意义"><a href="#了解select的核心意义" class="headerlink" title="了解select的核心意义"></a>了解select的核心意义</h3><p>我们看一个官方的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- x:</span><br><span class="line">x, y = y, x+y</span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">quit &lt;- <span class="number">0</span></span><br><span class="line">&#125;()</span><br><span class="line">fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很长，我们聚焦于select这块，它实现了两个功能：</p><ol><li>传递数据</li><li>传递停止的信号</li></ol><p>这时，如果你深入去理解这两个channel的用法，容易陷入对select理解的误区；而我们应该从更高的维度，去看这两个case中获取到数据后的操作，才能真正掌握。</p><h3 id="分析select中的case"><a href="#分析select中的case" class="headerlink" title="分析select中的case"></a>分析select中的case</h3><p>我们要注意到，在case里代码运行的过程中，整个goroutine都是忙碌的（除非调用panic，return，os.Exit()等函数退出）。</p><p>以上面的代码为例，如果<code>x, y = y, x+y</code>函数的处理耗时，远大于<code>x</code>这个通道中塞入数据的速度，那么这个<code>x</code>的写入处，将长期处于排队的阻塞状态。这时，不适合采用select这种模式。</p><p>所以说，<strong>select适合IO密集型逻辑，而不适合计算密集型</strong>。也就是说，select中的每个case，应尽量花费少的时间。IO密集型常指文件、网络等操作，它消耗的CPU很少、更多的时间在等待返回。</p><blockquote><p>Go 的 select这个关键词，可以结合网络模型中的select进行理解。</p></blockquote><h3 id="父子进程中的长逻辑处理"><a href="#父子进程中的长逻辑处理" class="headerlink" title="父子进程中的长逻辑处理"></a>父子进程中的长逻辑处理</h3><p>这时，如果我们的父子进程里，就是有那么一长段的业务逻辑，那代码该怎么写呢？我们来看看下面这一段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">LongLogic()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LongLogic</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 如1累加到10000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>LongLogic()</code>会花费很长的运行时间，所以当外部的context取消了，也就是父Goroutine发出通知可以结束了，这个子Goroutine是无法快速触发到<code>&lt;-ctx.Done()</code>的，因为它还在跑<code>LongLogic()</code>里的代码。也就是说，子进程生命周期结束的时间点延长到<code>LongLogic()</code>之后了。</p><p>所以，根本原因在于违背了我们上面说的原则，即在select的case/default里包含了计算密集型任务。</p><blockquote><p>case里包含长逻辑不代表程序一定有问题，但或多或少地不符合select+channel的设计理念。</p></blockquote><h3 id="两个长逻辑处理"><a href="#两个长逻辑处理" class="headerlink" title="两个长逻辑处理"></a>两个长逻辑处理</h3><p>这时，我们再来写个长进程处理，整个代码结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">LongLogic()</span><br><span class="line"><span class="keyword">case</span> &lt;-dataCh2:</span><br><span class="line">LongLogic()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，dataCh和dataCh2会产生竞争，也就是两个通道的 <strong>写长期阻塞、读都在等待LongLogic执行完成</strong>。给channel加个buffer可以减轻这个问题，但无法根治，运行一段时间依旧阻塞。</p><h3 id="改造思路"><a href="#改造思路" class="headerlink" title="改造思路"></a>改造思路</h3><p>有了上面代码的基础，改造思路比较直观了，将<code>LongLogic</code>异步化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line"><span class="keyword">go</span> LongLogic()</span><br><span class="line"><span class="keyword">case</span> &lt;-finishedCh:</span><br><span class="line">fmt.Println(<span class="string">&quot;LongLogic finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LongLogic</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Minute)</span><br><span class="line">finishedCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要注意一个点，如果<code>LongLogic()</code>是一段需要CPU密集计算的代码，比如计算1累加到10000，它是没有办法通过channel等其余方式突然中止的。它具备一定的原子性 - <strong>要么不跑，要么跑完，没有Channel的插手的地方</strong>。</p><p>而如果硬要中断<code>LongLogic()</code>，那就是杀掉整个进程。</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>今天的内容是围绕着select这个关键词展开的，我们记住select代码块设计的核心要领 - IO密集型。Go语言的goroutine特性，更多地是为了解决IO密集型程序的问题所设计的编程语言，对计算密集型的任务较其它语言很难体现出其价值。</p><p>落到具体实践上，就是让每个case中代码的运行时间尽可能地短，快速回到for循环里的select去继续监听各个case中的channel。</p><p>上面这段代码比较粗糙，在具体工程中会遇到很多问题，比如无脑地开启了大量的<code>LongLogic()</code>协程。我们会放在最后一讲再来细谈。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57581641299795_.pic_hd.jpg&quot; alt=&quot;2022-02&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2022-02-14-C
      
    
    </summary>
    
      <category term="每日技术分享" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Daily-Sharing" scheme="http://example.com/tags/Daily-Sharing/"/>
    
  </entry>
  
  <entry>
    <title>五分钟技术小分享 - 2022Week06</title>
    <link href="http://example.com/2022/02/07/sharing-5min/2022-02/2022Week06/"/>
    <id>http://example.com/2022/02/07/sharing-5min/2022-02/2022Week06/</id>
    <published>2022-02-07T04:00:00.000Z</published>
    <updated>2022-02-13T05:34:40.860Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57581641299795_.pic_hd.jpg" alt="2022-02"></p><h2 id="2022-02-07-CNCF-CloudEvents"><a href="#2022-02-07-CNCF-CloudEvents" class="headerlink" title="2022-02-07 CNCF-CloudEvents"></a>2022-02-07 CNCF-CloudEvents</h2><p>今天，我们一起来看<code>CloudEvents</code>，并不是一款成熟的软件系统，而更像是一种协议与标准。不过，它提出的相关概念，对我们开发与设计软件系统时，很有参考意义。</p><ul><li>官网 - <a href="https://cloudevents.io/">https://cloudevents.io/</a> </li><li>Github - <a href="https://github.com/cloudevents/spec">https://github.com/cloudevents/spec</a></li></ul><h3 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h3><blockquote><p>CloudEvents is a vendor-neutral specification for defining the format of event data.</p></blockquote><p>顾名思义，<code>CloudEvents</code>项目旨在定义 <strong>云时代的事件</strong>。事件是一个很广的定义，在不同的软件系统里有不同的表现形式。</p><p>想要将所有软件系统里的事件进行标准化，这里面的工作量与难度可想而知，在很长一段时间内很难落地。在我看来，这个项目的意义是长期的 - <strong>先提供一套切实可行的标准与SDK，再尝试结合云原生生态的在核心项目中落地，最后再大规模推广</strong>。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>事件里涉及到了很多概念，我选择其中的核心概念，并将其分成了两类。</p><blockquote><p> 完整的内容可以参考： <a href="https://github.com/cloudevents/spec/blob/v1.0.1/spec.md#notations-and-terminology">https://github.com/cloudevents/spec/blob/v1.0.1/spec.md#notations-and-terminology</a> </p></blockquote><p>数据类：</p><ol><li>Occurrence - 发生（客观事实）</li><li>Data - 数据</li><li>Context - 上下文</li><li>Event - 事件</li></ol><p>传输类：</p><ol><li>Producer - 生产者</li><li>Intermediary - 中介</li><li>Consumer - 消费者</li><li>Event Format - 事件格式</li><li>Message - 消息</li><li>Protocol - 协议</li></ol><h3 id="关键字段"><a href="#关键字段" class="headerlink" title="关键字段"></a>关键字段</h3><p><code>CloudEvents</code>给出了规范的同时，也给出了多语言的SDK。我们可以参考它的命名方式，引入到自己的开发系统中。</p><p>必填字段：</p><ol><li>id - string</li><li>source - URI-reference</li><li>specversion - string</li><li>type - string</li></ol><blockquote><p>保证 id+source 全局唯一</p></blockquote><p>可选字段：</p><ol><li>datacontenttype - string</li><li>dataschema - string</li><li>subject -string</li><li>time - timestamp，推荐RFC-3339</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>CloudEvents</code> 目前仍处于非常早期的阶段，有兴趣的朋友，可以尝试引入其SDK，将内部的RPC、MQ等通信数据统一起来。</p><p>从长期来看，将一个系统中的事件格式统一起来，对整个系统的帮助是很大的。比如说，我们完全可以将服务注册、服务发现等功能认为是一种事件，要求<code>Etcd</code>、<code>Zookeeper</code>、<code>Consul</code>等均支持该方式，就能有利于相关功能的标准化。</p><h2 id="2022-02-08-CNCF-NATS"><a href="#2022-02-08-CNCF-NATS" class="headerlink" title="2022-02-08 CNCF-NATS"></a>2022-02-08 CNCF-NATS</h2><p>作为CNCF中消息系统的核心项目，<code>NATS</code>受到了各大公司的青睐，近年来使用量也在逐步提升。有不少同学对消息系统的认识还比较模糊，今天我们就借<code>NATS</code>的核心模型，对消息系统有进一步的认识。</p><p>官网 - <a href="https://nats.io/">https://nats.io/</a></p><p>Github - <a href="https://github.com/nats-io/nats-server">https://github.com/nats-io/nats-server</a></p><h3 id="三种消息传递模型"><a href="#三种消息传递模型" class="headerlink" title="三种消息传递模型"></a>三种消息传递模型</h3><p><strong>发布-订阅模式</strong>：类似于广播模式</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/publish-subscribe.png" alt="publish-subscribe"></p><p><strong>请求-响应模式</strong>：对应关系可自行调整，请求者必须等待到响应才认为是成功</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/request-reply.png" alt="request-reply"></p><p><strong>队列-订阅模式</strong>：分布式系统中非常重要的消息队列功能，实现消息分发</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/queue-groups.png" alt="queue-groups"></p><h3 id="分布式系统中的消息系统"><a href="#分布式系统中的消息系统" class="headerlink" title="分布式系统中的消息系统"></a>分布式系统中的消息系统</h3><p>了解上面三种消息传递模型后，你可能仍不清楚它们的适用场景。我建议大家深入地了解这三种模型的本质，这样更方便记忆与理解。其实，在分布式系统中，最核心的是 <strong>队列-订阅</strong> 模式，其余两种模式意义并不大。</p><ol><li><strong>发布订阅</strong> 只是 <strong>队列订阅</strong> 的一种特殊的广播模式；</li><li><strong>请求响应</strong> 更多地应结合服务发现能力，在RPC框架中进行实现；</li></ol><blockquote><p>第一点的使用场景不多见，举个例子：</p><p>服务2有多个实例，本地内存里保存了一些信息；现在服务1要更新所有服务2中内存的信息，就需要采用发布-订阅模式，否则会导致服务间数据不一致。</p><p>如果服务2引入了分布式缓存，那就是队列-订阅模式。</p></blockquote><p>那么，<strong>队列-订阅模式</strong> 对分布式系统来说有什么意义呢？这其实就是消息队列的价值，我这里列举最关键的两点：</p><ol><li>削峰填谷：针对分布式系统中的性能问题，通过队列的形式，将高峰期的msg积压到Queue中，在低峰期时交给消费者处理。</li><li>解耦强依赖：从调用关系可以看到，其实Publisher是要将信息传递给Subscriber；但增加了Queue后，Publisher只与Queue交互，Subscriber也只与Queue交互。可以想象，即便Subscriber短暂地挂了，重启后依旧可以正常使用。</li></ol><p>分布式的消息队列还有很多注意点，这里我就不一一列举了，更多的资料大家可以自行搜索。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>虽然从生产环境的应用范围来看，<code>NATS</code>仍与老牌的重量级消息队列Kafka有相当大的差距，尤其是在大数据的系统中。但对比RocketMQ、RabbitMQ等轻量级产品，<code>NATS</code>的优势已经越来越明显，尤其是在性能与多语言的SDK上，建议有条件的朋友可以尝试使用。</p><h2 id="2022-02-09-CNCF-Helm"><a href="#2022-02-09-CNCF-Helm" class="headerlink" title="2022-02-09 CNCF-Helm"></a>2022-02-09 CNCF-Helm</h2><p><code>Helm</code>在整个云原生平台中扮演了重要角色。值得注意的是，<code>Helm</code>自身的复杂度并不高，它更多依赖的是优秀的设计理念与当前包含大量软件的生态。</p><p>官方的定义很简洁，即Kubernetes中的包管理者，即一个公共的软件仓。</p><blockquote><p>The Kubernetes Package Manager</p></blockquote><ul><li>官网 - <a href="https://helm.sh/">https://helm.sh/</a></li><li>Github - <a href="https://github.com/helm/helm">https://github.com/helm/helm</a></li><li>仓库 - <a href="https://artifacthub.io/packages">https://artifacthub.io/packages</a></li></ul><h3 id="使用Helm"><a href="#使用Helm" class="headerlink" title="使用Helm"></a>使用Helm</h3><p>类似于Dockerhub，<code>Helm</code>的一大特色就是使用起来非常简单，可快速地在Kubernetes环境中安装软件。</p><p>以Kubernetes中的证书管理为例，我们可以参考链接 - <a href="https://artifacthub.io/packages/helm/cert-manager/cert-manager">https://artifacthub.io/packages/helm/cert-manager/cert-manager</a> ，可以快速地通过几个命令就能完成下载与部署。</p><p>我希望大家能注意到：<strong>低门槛是吸引用户的重要因素，但真正决定软件长期走向的，是它自身的核心功能</strong>。所以，<code>Helm</code>中的软件有三点需要特别关注：</p><ol><li>契合Kubernetes平台：许多软件原生并不支持Kubernetes，需要做一定的改造；</li><li>保证常规功能：如安装时要判断依赖项、卸载时清理哪些数据、升降版本兼容性等等，都是很琐碎、又是很重要的事情；</li><li>人工维护问题：软件是高频迭代的，尤其是在云原生环境下，核心项目往往要大量的人力投入到 FAQ、配置参数说明、兼容性问题的处理；</li></ol><p>这三点给<code>Helm</code>带来的是一种滚雪球效应，即越滚越大、越难以被替代；而这种雪球最终能支撑多大的市场，非常依赖<code>Helm</code>内部的核心设计，尤其是扩展性部分。</p><h3 id="Charts"><a href="#Charts" class="headerlink" title="Charts"></a>Charts</h3><p><code>Helm</code>称自己是Kubernetes平台中的包管理器，而这个包的格式被称为Charts，我们一起来看看一个官方示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wordpress/</span><br><span class="line">  Chart.yaml          # A YAML file containing information about the chart</span><br><span class="line">  LICENSE             # OPTIONAL: A plain text file containing the license for the chart</span><br><span class="line">  README.md           # OPTIONAL: A human-readable README file</span><br><span class="line">  values.yaml         # The default configuration values for this chart</span><br><span class="line">  values.schema.json  # OPTIONAL: A JSON Schema for imposing a structure on the values.yaml file</span><br><span class="line">  charts/             # A directory containing any charts upon which this chart depends.</span><br><span class="line">  crds/               # Custom Resource Definitions</span><br><span class="line">  templates/          # A directory of templates that, when combined with values,</span><br><span class="line">                      # will generate valid Kubernetes manifest files.</span><br><span class="line">  templates/NOTES.txt # OPTIONAL: A plain text file containing short usage notes</span><br></pre></td></tr></table></figure><p>关键在于三个目录：</p><ol><li>charts - 保存当前chart的依赖子chart</li><li>crds - 这是chart依赖Kubernetes实现软件运行的关键（CRD是k8s可扩展性的一大特色）</li><li>templates - 用来绑定chart自定义参数</li></ol><p>换一个视角，这三个文件夹体现了三种能力：</p><ol><li>charts - package能力复用</li><li>crds - 自定义对接Paas平台（k8s）</li><li>templates - 定制化参数</li></ol><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><code>Helm</code>是Kubernetes使用人员需要非常重视的一个产品，它能快速地帮助我们安装与部署软件。</p><p>不过，我不建议大家去阅读它的相关源码，它的代码并不优秀；相反地，我更建议大家可以去尝试自己做一个chart（最好能结合自己开发的程序+依赖的中间件，如go程序+redis），这样既能结合<code>Helm</code>实现应用程序的快速部署，又能去实践Kubernetes的CRD。</p><h2 id="2022-02-10-CNCF-Buildpacks"><a href="#2022-02-10-CNCF-Buildpacks" class="headerlink" title="2022-02-10 CNCF-Buildpacks"></a>2022-02-10 CNCF-Buildpacks</h2><p><code>Buildpacks</code>是一款对标<code>Docker</code>的镜像打包工具，虽然在CNCF中作为核心项目，但在目前的主流开发场景中用到的并不多。</p><ul><li>官网 - <a href="https://buildpacks.io/">https://buildpacks.io/</a></li><li>Github - <a href="https://github.com/buildpacks/pack">https://github.com/buildpacks/pack</a></li></ul><p>我们不妨来思考一下<code>Buildpacks</code>与竞品的核心优势：</p><p><code>Buildpacks</code>官网介绍自身的核心特性为3个：<code>Control</code>、<code>Compliance</code>和<code>Maintainability</code>。我们今天挑选两个关键性的特征来聊一聊。</p><h3 id="Control-Balanced-control-between-App-Devs-and-Operators"><a href="#Control-Balanced-control-between-App-Devs-and-Operators" class="headerlink" title="Control - Balanced control between App Devs and Operators."></a>Control - Balanced control between App Devs and Operators.</h3><p>平衡开发者与运维人员。这个也是<code>Buildpacks</code>对标<code>Docker</code>的最大优势。</p><p>刚熟悉Dockerfile的同学，会觉得体验很棒，只需要少数几行就能快速制作出一个镜像；但是，如果你是重度使用的用户，就会有不一样的体验：</p><ol><li>多应用的Dockerfile中有大量重复、但又有少量定制化的内容（如依赖的软件）</li><li>由于定制化的内容存在，往往需要开发工程师编写Dockerfile</li></ol><p>所以，维护Dockerfile成为了开发工程师很琐碎的工作，而<code>Buildpacks</code>则是希望将部分工作转移给运维人员。但在我看来，这个收益并不明显：</p><ol><li>现状：大部分的公司会封装一些基础镜像，在基础镜像上的Dockerfile所需要的命令已经很少了，整体的复杂度不会很高；</li><li>工作平衡：平衡的意义并没有减少整体的工作量，两种角色的人数总量仍不会有大的变化；</li><li>责任明确：目前大型公司的运维人员越来越少，更强调的是开发人员自己管理应用的整个生命周期；</li></ol><p>但换一个角度，<code>Buildpacks</code>理念是可以降低开发人员对Dockerfile这块的门槛，更专注于业务代码的开发。但是，编写Dockerfile这项技能本身难度不高，而且有利于研发自行排查问题，我个人是非常建议开发人员去学习的。</p><h3 id="Maintainability-Perform-upgrades-with-minimal-effort-and-intervention"><a href="#Maintainability-Perform-upgrades-with-minimal-effort-and-intervention" class="headerlink" title="Maintainability - Perform upgrades with minimal effort and intervention."></a>Maintainability - Perform upgrades with minimal effort and intervention.</h3><p>这一点是<code>Buildpacks</code>的一大特色。</p><p>如果你对Docker的镜像底层有一定的了解，会清楚一个镜像就是一层层layer的堆叠；从最上层来看，就是一个完整的操作系统。但如果只对某个layer进行更改，就得销毁老容器、再起一个新的。而<code>Buildpacks</code>则提供了rebase的能力，也就是在运行中的容器中做到快速替换某个layer，而不需要整个重建。</p><p>举一个例子，当前运行的容器有层layer是设置环境变量（参考Dockerfile中的ENV指令），我们要进行增加或者更改参数，就能快速实现rebase。当然，rebase肯定是有不少限制条件的，尤其是rebase中的内容不能影响到程序的运行。</p><p>我们不妨发散地思考这个特性的价值：由于它核心解决了无需重启整个容器的作用，所以对启动成本比较大的程序，它的意义是很大的，尤其是Java程序。</p><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p><code>Buildpacks</code>在社区中活跃度并不高，这也间接证明了<code>Docker</code>的统治地位，而它则需要一个合适的契机才可能得到大幅度的应用。这也提醒了我们，不要一味地追求新的技术，更应该结合现状理性分析。</p><h2 id="2022-02-11-CNCF-Operator-Framework"><a href="#2022-02-11-CNCF-Operator-Framework" class="headerlink" title="2022-02-11 CNCF-Operator Framework"></a>2022-02-11 CNCF-Operator Framework</h2><p><code>Operator Framework</code>是为了降低Kubernetes中Operator开发门槛，而由CNCF社区提供的一套框架。由于这一整套的解决方案门槛很高，需要使用者对Kubernetes的原理有相当的基础，所以今天我们不会深入其细节，而是通过借由这个项目更好地理解Kubernetes。</p><ul><li>官网 - <a href="https://cloud.redhat.com/learn/topics/operators">https://cloud.redhat.com/learn/topics/operators</a></li><li>Github - <a href="https://github.com/operator-framework/operator-sdk">https://github.com/operator-framework/operator-sdk</a></li><li>公开库 - <a href="https://operatorhub.io/">https://operatorhub.io/</a></li></ul><h3 id="Controller的工作原理"><a href="#Controller的工作原理" class="headerlink" title="Controller的工作原理"></a>Controller的工作原理</h3><p><strong>Operator本质上，是一种定制化的Controller；而控制器的核心思想，是根据期望状态与当前状态，管理k8s中的资源。</strong>我们这边可以结合下面这张图，来了解Controller的工作原理。</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/k8s-controller.png" alt="k8s-controller"></p><ol><li>client-go是k8s提供的代码生成工具，相关的代码会自动生成；而controller-specific是自行开发的内容；</li><li>期望状态与当前状态的对比逻辑，决策的结果是 新增、更新、删除对应的资源，触发对应的callbacks；</li><li>具体的执行工作，交给Worker执行，而结果如果未达到预期，依然会再次触发整个流程；</li></ol><blockquote><p>关于k8s中的controller，源码分析可以参考我之前的一篇博客 <a href="https://junedayday.github.io/2021/02/18/k8s/k8s-012/">https://junedayday.github.io/2021/02/18/k8s/k8s-012/</a> </p></blockquote><h3 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h3><ol><li>Operator SDK - 快速生成Operator相关代码</li><li>Operator Lifecycle Manager - k8s中的生命周期管理</li><li>Operator Metering - 监控</li></ol><p>其中监控部分很重要，能帮助使用人员在复杂的K8s系统中排查问题。</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>目前<code>Operator Framework</code>虽然在社区比较受欢迎，但使用者往往仅限于k8s的深度用户；而许多大型公司又往往会自行封装k8s，不能完美兼容<code>Operator Framework</code>，导致它的推广很受限。</p><p>我个人有三点建议：</p><ol><li>优先去Helm里搜索成熟应用，不要自行开发Operator；</li><li>如果有切实的使用需求，优先去公开库 - <a href="https://operatorhub.io/">https://operatorhub.io/</a> 搜索；</li><li>k8s深度玩家可忽略以上两点~</li></ol><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57581641299795_.pic_hd.jpg&quot; alt=&quot;2022-02&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2022-02-07-C
      
    
    </summary>
    
      <category term="每日技术分享" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Daily-Sharing" scheme="http://example.com/tags/Daily-Sharing/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 14.【浅析微服务框架】go-zero概览</title>
    <link href="http://example.com/2022/02/02/go-tip/go-tip-14/"/>
    <id>http://example.com/2022/02/02/go-tip/go-tip-14/</id>
    <published>2022-02-02T04:00:00.000Z</published>
    <updated>2022-02-02T13:59:21.507Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="go-zero概况"><a href="#go-zero概况" class="headerlink" title="go-zero概况"></a>go-zero概况</h2><p><code>go-zero</code>是当前处于CNCF孵化中的一个<code>Go</code>z语言框架项目，在Github上的star数目前达到14.3K。</p><p>作为一款起源于国内的项目，<code>go-zero</code>的中文资料比较齐全，对国内开发者相对友好。但前景如何，还需要进一步的观察。今天我们一起来了解这个项目。</p><span id="more"></span><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>官方文档 - <a href="https://go-zero.dev/cn/">https://go-zero.dev/cn/</a></p><p>Github - <a href="https://github.com/zeromicro/zero-doc">https://github.com/zeromicro/zero-doc</a></p><blockquote><p>go-zero is a web and rpc framework written in Go. It’s born to ensure the stability of the busy sites with resilient design. Builtin goctl greatly improves the development productivity.</p></blockquote><p>官方核心将自己定位为一个 <strong>Go语言的web和rpc框架</strong>。其余描述内容的意义不大，如稳定的、可伸缩的，更多依赖的是Paas平台与程序自身的设计。</p><h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><p>有了前面三个框架的基础，了解<code>go-zero</code>会相对容易。这次，我将换一个思路讲解，先从官方的示例出发，再回过头来看看这个框架的核心思想。</p><p>以下内容，来自<code>go-zero</code>提供的中文示例 - <a href="https://go-zero.dev/cn/shorturl.html">https://go-zero.dev/cn/shorturl.html</a></p><h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><p>主要安装的二进制工具包括以下三个：</p><ul><li>protoc-gen-go</li><li>protoc</li><li>goctl</li></ul><p>其中第三个是<code>go-zero</code>自研的。不难看出，<code>go-zero</code>是强依赖protobuffer生态的。</p><h3 id="API-Gateway代码"><a href="#API-Gateway代码" class="headerlink" title="API Gateway代码"></a>API Gateway代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">  shortenReq &#123;</span><br><span class="line">    url <span class="keyword">string</span> <span class="string">`form:&quot;url&quot;`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shortenResp &#123;</span><br><span class="line">    shorten <span class="keyword">string</span> <span class="string">`json:&quot;shorten&quot;`</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">service shorturl-api &#123;</span><br><span class="line">  @server(</span><br><span class="line">    handler: ShortenHandler</span><br><span class="line">  )</span><br><span class="line">  get /shorten(shortenReq) returns(shortenResp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一套 <code>go-zero</code> 特定的语法。虽说这个语法阅读起来很容易理解，里面有Go语言和protobuffer的影子，但就是一个完全独立的一套方案。</p><p>值得注意的是，我们如果要在这个语法中引入各类网关层的特性，如限流参数等，会导致这个语法的学习成本越来越高。</p><h3 id="rpc服务代码"><a href="#rpc服务代码" class="headerlink" title="rpc服务代码"></a>rpc服务代码</h3><p>核心为一个protobuffer的定义，如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> transform;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">shortenReq</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> url = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">shortenResp</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> shorten = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">transformer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> shorten(shortenReq) <span class="keyword">returns</span>(shortenResp)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来工具会生成相应的代码，以及会有相关的配置文件可供修改。</p><h3 id="关联API-Gateway和rpc服务"><a href="#关联API-Gateway和rpc服务" class="headerlink" title="关联API Gateway和rpc服务"></a>关联API Gateway和rpc服务</h3><p>由于API Gateway与rpc服务是两个独立的进程，所以需要修改对应的配置（端口等信息），进行打通。</p><p>核心代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ShortenLogic)</span> <span class="title">Shorten</span><span class="params">(req types.ShortenReq)</span> <span class="params">(types.ShortenResp, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 手动代码开始</span></span><br><span class="line">    resp, err := l.svcCtx.Transformer.Shorten(l.ctx, &amp;transformer.ShortenReq&#123;</span><br><span class="line">        Url: req.Url,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> types.ShortenResp&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> types.ShortenResp&#123;</span><br><span class="line">      Shorten: resp.Shorten,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 手动代码结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即新建出一个rpc服务的对象<code>Transformer</code>，调用对应的方法<code>Shorten</code>。</p><h3 id="rpc服务最终调用到model层"><a href="#rpc服务最终调用到model层" class="headerlink" title="rpc服务最终调用到model层"></a>rpc服务最终调用到model层</h3><p>关于model层的生成，也就是对<code>MySQL</code>的CRUD方案，我这里就不专门写了。</p><p>我们关注一下最终调用到<code>MySQL</code>层的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ShortenLogic)</span> <span class="title">Shorten</span><span class="params">(in *transform.ShortenReq)</span> <span class="params">(*transform.ShortenResp, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 手动代码开始，生成短链接</span></span><br><span class="line">  key := hash.Md5Hex([]<span class="keyword">byte</span>(in.Url))[:<span class="number">6</span>]</span><br><span class="line">  _, err := l.svcCtx.Model.Insert(model.Shorturl&#123;</span><br><span class="line">    Shorten: key,</span><br><span class="line">    Url:     in.Url,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;transform.ShortenResp&#123;</span><br><span class="line">    Shorten: key,</span><br><span class="line">  &#125;, <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 手动代码结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="架构概览"><a href="#架构概览" class="headerlink" title="架构概览"></a>架构概览</h2><p>有了这么一个实例，我们再回过头来看看整体的架构：</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/architecture-en.png" alt="go-zero"></p><p><code>go-zero</code>的架构图包含了五层，但它的核心聚焦于API Gateway与Services这两层。</p><ul><li>Clients层：对接的是API Gateway上的HTTP服务，要考虑能否自动生成跨语言的SDK</li><li>Cache+DB：关注高频+重复性高CRUD代码的自动生成功能，抽象成model</li><li>API Gateway：这部分功能更像是Go语言+Service Mesh的一个结合方案</li><li>Services：业务代码的具体实现，提供了很多常用的工具集</li></ul><p>从框架分层来看，我个人是不太认同这种划分方式。这张图中的架构，更多地是为了体现出<code>go-zero</code>的两层结构而产出的架构图。尤其是API Gateway这个设计，表现出了团队在Service Mesh上能力的不足、而引入的功能。</p><h2 id="Go语言微服务框架的聚焦点"><a href="#Go语言微服务框架的聚焦点" class="headerlink" title="Go语言微服务框架的聚焦点"></a>Go语言微服务框架的聚焦点</h2><p>目前为止，我们已经一起看了四个不同的微服务框架，也许有同学会觉得我总是在到处挑刺，那么我理想中的微服务框架是怎么样的呢？我来谈谈：</p><h3 id="三个分层"><a href="#三个分层" class="headerlink" title="三个分层"></a>三个分层</h3><ul><li>控制层controller - 处理数据格式的转换，做一些panic处理等通用性较强的工作</li><li>业务层service - 聚焦于service层的业务逻辑代码编写</li><li>数据存储层model - 通用性强的数据存储，对接MySQL、Redis等存储</li></ul><h3 id="五个聚焦点"><a href="#五个聚焦点" class="headerlink" title="五个聚焦点"></a>五个聚焦点</h3><ol><li><strong>控制层以上</strong> - 即请求是怎么进入微服务的，不应该由微服务框架关心，而应交由Paas平台层的产品，尤其是Kubernetes和Service Mesh；</li><li><strong>控制层</strong> - 以protobuffer定义+gRPC生态为核心，自动生成代码框架，在对应的server层提供大量通用的middleware处理panic、context、logging等能力；</li><li><strong>业务层</strong> - 业务层应高度关注代码的可测试性，也就是单元测试尽可能在这里闭环，这就需要下层的Mock能力+DI的代码风格；</li><li><strong>数据存储层</strong> - 数据存储层必须结合code generation实现高度的自动化，尽可能地引用主流库、而非自研，而且有可能的话，后续可以提供多种库的切换方案，如MySQL用原生库/gorm/ent/sqlx等方案；</li><li><strong>数据存储层以下</strong> - 如怎么对接分布式的数据库、或者怎么对接其余的微服务，这一类的问题，不应由微服务框架自行解决，而应由底层服务提供SDK或库（如服务发现能力），结合到微服务框架里</li></ol><p>这么聊下来，可能还是有点抽象，我再结合两个例子谈谈这块：</p><ol><li>服务熔断功能<ol><li>在Service Mesh层配置熔断条件(如错误码和错误次数)，在达到具体条件后实现熔断，阻断后续的请求到微服务</li><li>Go微服务框架应保证按照Service Mesh层地定义的协议格式返回错误码；</li></ol></li><li>对接分布式服务（Client-Client模式）<ol><li>在Paas层提供服务发现的SDK，包括两块功能：获取目标服务的地址列表与多种负载均衡策略</li><li>Go微服务框架引入这个SDK，填写目标服务名称+负载均衡策略，SDK选择一个最合适的节点并进行请请求，而如何请求由微服务框架之间的通信协议决定，如HTTP或gRPC；</li></ol></li></ol><h3 id="我心中Go框架的核心价值"><a href="#我心中Go框架的核心价值" class="headerlink" title="我心中Go框架的核心价值"></a>我心中Go框架的核心价值</h3><ol><li>Controller层 - 利用<code>gRPC</code>的生态生成具体的代码，充分利用middleware(拦截器)的特性实现panic recovery+logging+metrcis等通用的能力；</li><li>Model层是体现自动化的最核心模块，必须要充分利用代码生成的技术，体现出两个价值：<ol><li>能自动化地实现Mocking，为上层Service的单元测试提供基础保障</li><li>降低用户使用成本，尽可能避免学习一套新的语法</li></ol></li></ol><blockquote><p>最后一点有部分人会不好理解，以MySQL ORM框架为例，它们在函数中提供的查询方法名是Find/Query/Search等，但对应到SQL的关键词是SELECT，这就对熟悉MySQL的同学来说需要一种思维转变，有一定的成本。更好的方式，那就是ORM里的函数直接使用SELECT这种关键词。</p></blockquote><p>Controller这层的开发量很有限，基本已经由社区提供能力，更应该关注如何能形成一套标准规范；而框架更多的精力应关注在Model这层，它需要大量的、易用的SDK积累，能便捷地对接各类中间件，才能体现出框架的价值。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总体来说，我觉得<code>go-zero</code>是一个早期云原生环境下的框架，在目前Service Mesh大规模落地后，有大量的特性造成了冲突。从研发体验、维护成本和稳定性角度来看，这部分功能更应该交给跨语言的Service Mesh来解决，而不是编程语言强相关的框架。目前，国内互联网大公司基本不会采用<code>go-zero</code>，这点占据很大因素。</p><p>不过，<code>go-zero</code>在Model层做了一定的自动化，是一个很值得学习的能力。作为CNCF的项目之一，<code>go-zero</code>后续是否会有大的转变、更加贴合整个CNCF的氛围，我个人还是非常期待的。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;go-zero概况&quot;&gt;&lt;a href=&quot;#go-zero概况&quot; class=&quot;headerlink&quot; title=&quot;go-zero概况&quot;&gt;&lt;/a&gt;go-zero概况&lt;/h2&gt;&lt;p&gt;&lt;code&gt;go-zero&lt;/code&gt;是当前处于CNCF孵化中的一个&lt;code&gt;Go&lt;/code&gt;z语言框架项目，在Github上的star数目前达到14.3K。&lt;/p&gt;
&lt;p&gt;作为一款起源于国内的项目，&lt;code&gt;go-zero&lt;/code&gt;的中文资料比较齐全，对国内开发者相对友好。但前景如何，还需要进一步的观察。今天我们一起来了解这个项目。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>五分钟技术小分享 - 2022Week04</title>
    <link href="http://example.com/2022/01/24/sharing-5min/2022-01/2022Week04/"/>
    <id>http://example.com/2022/01/24/sharing-5min/2022-01/2022Week04/</id>
    <published>2022-01-24T04:00:00.000Z</published>
    <updated>2022-01-29T04:40:40.574Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg" alt="2022-01"></p><h2 id="2022-01-24-CNCF-Linkerd"><a href="#2022-01-24-CNCF-Linkerd" class="headerlink" title="2022-01-24 CNCF-Linkerd"></a>2022-01-24 CNCF-Linkerd</h2><p>今天我们来看 <strong>Orchestration &amp; Management 编排和管理</strong> 层最后一个核心项目 - Linkerd。从严格意义上来说，我们应称它为Linkerd2，区别于原来的1.0版本。</p><blockquote><p>Linkerd是Service Mesh的第一个产品，但在Google的Istio入场后在功能与性能上完全超越。这一段的历史很有意思，大家可以自行搜索了解。</p></blockquote><p>关于Service Mesh，我们已经聊过两款CNCF中的软件了 - Envoy/Contour，这个Linkerd是两者的结合。我们来看一下它的架构示意图，整体来说分为三块：</p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/control-plane.png" alt="Linkerd2" style="zoom:50%;" /><ol><li>CLI - 客户端，对Linkerd2进行管理</li><li>Control Plane 控制平面<ol><li>destination 获取各类信息，如服务发现、网络策略、性能和监控指标</li><li>indentity 主要是TLS安全相关</li><li>proxy-injector 是一种Kubernetes的Admission Controller，用于对初始化pod注入linkerd相关的信息</li></ol></li><li>Data Plane 数据平面<ol><li>linkerd-proxy 核心的功能实现，包括代理、路由、TLS、限流等等</li><li>linkerd-init 是一种Kubernetes的Init Containter，用iptables的特性将Pod的流量都导向linkerd-proxy</li></ol></li></ol><p>Linkerd的架构非常清晰明了，与Kubernetes的特性紧密结合。我们也不难看到，它的核心能力非常依赖linkerd-proxy这个组件。linkerd-proxy采用了Rust语言编写，而对应的Envoy使用的是C++，从性能来看两者相差无几，更多的是语言生态上的选择不同。</p><p>我们再一起读一段<a href="https://linkerd.io/what-is-a-service-mesh/">Linkerd官方对Service Mesh的定义</a>：</p><blockquote><p>A service mesh like Linkerd is a tools for adding observability, security, and reliability features to “cloud native” applications by transparently inserting this functionality at the platform layer rather than the application layer.</p></blockquote><ul><li><p>observability - 可观察性：logging、metrics、tracing</p></li><li><p>security - 安全性：TLS等特性</p></li><li><p>reliability - 可靠性：体现在对网络层的统一管理</p></li></ul><p>从目前来看，Linkerd仍处于一个比较早期的阶段，对标Istio还有大量的功能缺失，我在短期内不太看好。不过它引入了Rust语言有可能吸引一批优秀的人才，成为突破口。</p><h2 id="2022-01-25-Go1-18的两个教程"><a href="#2022-01-25-Go1-18的两个教程" class="headerlink" title="2022-01-25 Go1.18的两个教程"></a>2022-01-25 Go1.18的两个教程</h2><p>在1月初，我们已经一起看了Go官方对1.18的新特性讲解，想回顾的朋友可以点击这个链接：<a href="https://junedayday.github.io/2022/01/04/sharing-5min/2022-01/2022Week01/#2022-01-04-Go1-18%E6%A6%82%E8%A7%88">Go1.18概览</a>。前几天，官方又发布了对泛型和Fuzzing的两个教程，我们再一起浏览下，查漏补缺。</p><ul><li><a href="https://go.dev/doc/tutorial/generics">Tutorial: Getting started with generics</a></li><li><a href="https://go.dev/doc/tutorial/fuzz">Tutorial: Getting started with fuzzing</a></li></ul><h3 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumIntsOrFloats</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">int64</span> | <span class="title">float64</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span> <span class="title">V</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s V</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        s += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>comparable 是个关键词，指的是支持操作符<code>==</code> 和 <code>!=</code></li><li>int64 | float64 则用简洁的语法表示了两种支持的类型</li></ul><p>但第二点，如果支持的类型太多，就需要做一次抽象，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Number <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int64</span> | <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumNumbers</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">Number</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span> <span class="title">V</span></span> &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言的泛型表示方法非常简单，其支持的能力也很有限。相对于C++与JAVA中的泛型，无疑逊色了很多。我们可以简单地归纳Go泛型的使用场景：用于 <strong>基础类型</strong> 的通用操作，如int/int32/int64/float64等这种重复性很高的基本运算。</p><p>作为一种标准，Go的泛型落地非常坎坷，短期内官方也不太可能在这块扩增新的特性，所以Go的泛型适用性会比较窄。</p><p>随着1.18的完全落地，我们可以在很多基础库中看到泛型的实践，到时候我们再可以根据具体case进行了解。</p><h3 id="Fuzzing"><a href="#Fuzzing" class="headerlink" title="Fuzzing"></a>Fuzzing</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuzzReverse</span><span class="params">(f *testing.F)</span></span> &#123;</span><br><span class="line">    testcases := []<span class="keyword">string</span>&#123;<span class="string">&quot;Hello, world&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;!12345&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, tc := <span class="keyword">range</span> testcases &#123;</span><br><span class="line">        f.Add(tc)  <span class="comment">// Use f.Add to provide a seed corpus</span></span><br><span class="line">    &#125;</span><br><span class="line">    f.Fuzz(<span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, orig <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        rev := Reverse(orig)</span><br><span class="line">        doubleRev := Reverse(rev)</span><br><span class="line">        <span class="keyword">if</span> orig != doubleRev &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;Before: %q, after: %q&quot;</span>, orig, doubleRev)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> utf8.ValidString(orig) &amp;&amp; !utf8.ValidString(rev) &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;Reverse produced invalid UTF-8 string %q&quot;</span>, rev)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对于传统的单元测试，Fuzzing Test更强调一种 <strong>不确定性的输入</strong> 理念 - 由于输入的数据是随机的，输出往往是不确定的，那我们最好可以通过一定的操作，<strong>减少甚至消除输出的不确定性</strong>，才能保证测试的完备性：</p><p>比如说，示例中对字符串的反转，转变成了两个测试点：</p><ol><li>Reversing a string twice preserves the original value 即两次反转后成为原字符串，</li><li>The reversed string preserves its state as valid UTF-8 字符串依然为UTF-8编码格式</li></ol><p>从输入和输出来看，如果每个输入都对应枚举出一个输出，那就是单元测试；而Fuzzing Test的理念是尽可能地将输出做到可控，更方便地写各种测试。</p><p>在实际工程中，能用到Fuzzing特性的地方很少，更多的还是依赖简单地单元测试保障我们的代码质量。</p><h2 id="2022-01-26-如何避免分布式事务"><a href="#2022-01-26-如何避免分布式事务" class="headerlink" title="2022-01-26 如何避免分布式事务"></a>2022-01-26 如何避免分布式事务</h2><p>最近，有朋友和我交流分布式事务的实践心得，而我的建议是：<strong>尽量避免分布式事务</strong>。</p><p>这里的避免并非完全的不要使用，毕竟像金融场景中，这还是一个必要的特性。但对于绝大多数系统，分布式事务带来的复杂度是非常高的，也需要很高的维护成本与理解成本，远超其收益，我不太建议大家刻意地使用这个技术。</p><p>举一个简单的case - 用户下了一个订单，经过如下步骤：</p><ol><li>订单服务生成订单</li><li>库存服务扣去库存</li><li>付费服务完成扣款</li><li>用户积分服务增加积分</li></ol><p>这时，最直观的解法是要有一套成熟的分布式事务的方案。但事实上，我更推荐在工程上采用下面两种解决方案，而其中的关键词就是 - <strong>补偿</strong>。</p><h3 id="在MQ中重试"><a href="#在MQ中重试" class="headerlink" title="在MQ中重试"></a>在MQ中重试</h3><p>我们经常会利用MQ来解耦服务，那么自然会用它来驱动大量的消息。</p><p>例如，我们将扣款请求放到MQ里，扣款服务处理成功后通过另一个MQ通知成功。而当扣款服务出现问题时、也就是扣款失败，常见的有2种选择：</p><ol><li>如果要求是必须成功的，消费时就不要返回成功，在服务中反复重试，即便MQ积压产生告警、再人工恢复；</li><li>如果允许失败，那就设置一个最大重试次数，超过最大重试次数则通知给对应的补偿服务；</li></ol><h3 id="利用trace-id-ELK"><a href="#利用trace-id-ELK" class="headerlink" title="利用trace-id+ELK"></a>利用trace-id+ELK</h3><p>trace-id是分布式链路追踪的关键信息，用于串联信息；而ELK又通过日志收集系统，将这块收集到了一个系统。</p><p>我们可以在生成订单时，同时记录这个关键性的trace-id，然后调用各个服务。有任何一个服务失败，我们就将订单状态修改为失败或超时；而数据不一致的问题，就由对应的补偿服务，根据这些有问题的订单的trace-id去分析。</p><blockquote><p>其实可以从这个方案延伸出类似的，比如直接将错误通过trace-id+信息发送给补偿服务，统一收集。</p></blockquote><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>补偿不代表只能手动，我们可以在补偿服务内根据错误码，实现一定的自动化；</li><li>补偿更多体现的是一种<strong>最终一致性</strong>的思想，会有延时，我们要保证中间状态的数据不会污染系统；</li></ol><p>在微服务+云原生时代，我们非常提倡 <strong>面向错误编程</strong>，正是为了能更好地面对各种不确定的异常case。分布式事务带来了大量的复杂度，目前也没有一套跨语言、跨组件的通用解决方案，目前主流几个方案对应用的侵入性很强，所以我不太建议大部分朋友在生产环境使用，而花更多时间学习相关理论、应付面试就行了。</p><h2 id="2022-01-27-CNCF-TiKV"><a href="#2022-01-27-CNCF-TiKV" class="headerlink" title="2022-01-27 CNCF-TiKV"></a>2022-01-27 CNCF-TiKV</h2><p>了解完核心的 <strong>调度与管理</strong> 相关的软件后，我们接下来开始接触 <strong>应用定义与开发</strong> 的相关软件，这部分与我们实际开发接触最为紧密，也更容易理解。</p><ul><li>官网 - <a href="https://tikv.org/">https://tikv.org/</a></li><li>Github - <a href="https://github.com/tikv/tikv">https://github.com/tikv/tikv</a></li></ul><p>官方的定义为：</p><blockquote><p>TiKV provides both raw and ACID-compliant transactional key-value API, which is widely used in online serving services, such as the metadata storage system for object storage service, the storage system for recommendation systems, the online feature store, etc.</p></blockquote><p>也就是TiKV支持 <strong>简单的与满足ACID事务性的KV存储</strong>，被应用在各种存储系统上，如关系型数据库、非关系型数据库、分布式文件系统，最具有代表性的即同属一个公司的TiDB。按官方的定义，我们可以将它对标Redis。</p><p>我们结合TiKV的核心特性来看看。</p><h3 id="Low-and-stable-latency"><a href="#Low-and-stable-latency" class="headerlink" title="Low and stable latency"></a>Low and stable latency</h3><blockquote><p>RawKV’s average response time less than 1 ms (P99=10 ms).</p></blockquote><p>延迟是IO相关的软件很重要的特性。但对于这个特性，我们要注意两点：</p><ol><li>只针对简单KV，而不针对事务</li><li>真实延迟很依赖存储介质</li></ol><p>从这点来看，在TiKV层面引入事务的特性前，需要我们要斟酌一下它对延迟的影响。</p><h3 id="High-scalabilit"><a href="#High-scalabilit" class="headerlink" title="High scalabilit"></a>High scalabilit</h3><blockquote><p>With the Placement Driver and carefully designed Raft groups, TiKV excels in horizontal scalability and can easily scale to 100+ terabytes of data. Scale-out your TiKV cluster to fit the data size growth without any impact on the application.</p></blockquote><p>强调了高扩展性，可支持100TB+的数据。</p><p>TiKV采用了Raft作为分布式一致性的协议，这一点与Etcd一致。关于Raft这块是目前工程化的主流，相对于Paxos更容易落地。不过，各家在实现Raft时都或多或少有一些变种，这块我们暂时不细聊。</p><h3 id="Consistent-distributed-transactions"><a href="#Consistent-distributed-transactions" class="headerlink" title="Consistent distributed transactions"></a>Consistent distributed transactions</h3><blockquote><p>Similar to Google’s Spanner, TiKV (TxnKV mode) supports externally consistent distributed transactions.</p></blockquote><p>支持一致性的分布式事务。</p><p>分布式事务对强一致性的业务非常有价值，但它的实现必然会带来一定的性能问题，尤其体现在延迟上。以金融服务为例，分布式事务能保证资金的一致性，不产生资损；但延迟问题又会带来一些异常case，所以需要做好权衡。</p><h3 id="Adjustable-consistency"><a href="#Adjustable-consistency" class="headerlink" title="Adjustable consistency"></a>Adjustable consistency</h3><blockquote><p>In RawKV and TxnKV modes, you can customize the balance between consistency and performance.</p></blockquote><p>对简单KV模式与事务性的KV模式，提供了可调节的一致性功能。</p><p>这就是一致性与性能上的权衡。关于这点，大家可以了解一下ACID与BASE对业务的价值。从我的观察来看，目前越来越多的服务倾向于最终一致性，主要有以下优点：</p><ol><li><strong>对外部服务来说视角清晰，更容易理解</strong> - 从外部服务视角来看，本服务最终会趋于一致，而不需要关心各种异常的中间状态，这非常有助于微服务的边界划分；</li><li><strong>服务更具健壮性</strong> - 软件系统的不稳定因素很多，最终一致性可以更好地处理这些异常。</li></ol><p>当然，对应的代价是该服务需要引入重试、幂等、异步校验、状态机、恢复日志等特性，自身的复杂度是比较高的。这些技术我也会在后面和大家分享。</p><h2 id="2022-01-28-CNCF-Vitess"><a href="#2022-01-28-CNCF-Vitess" class="headerlink" title="2022-01-28 CNCF-Vitess"></a>2022-01-28 CNCF-Vitess</h2><p>今天我们来聊聊一款和关系型数据库相关的产品 - <code>Vitess</code>。<code>Vitess</code>的定位很简洁：</p><blockquote><p>A database clustering system for horizontal scaling of MySQL</p></blockquote><p>我们直接从架构图入手，来了解它是怎么实现 <strong>MySQL横向扩展</strong> 的。</p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/20220127221720.png" style="zoom:50%;" /><p>我们关注最核心的两个模块：</p><h3 id="VTTablet"><a href="#VTTablet" class="headerlink" title="VTTablet"></a>VTTablet</h3><blockquote><p>A <em>tablet</em> is a combination of a <code>mysqld</code> process and a corresponding <code>vttablet</code> process, usually running on the same machine. Each tablet is assigned a <em>tablet type</em>, which specifies what role it currently performs.</p></blockquote><p>一个<code>Tablet</code>对应到一个具体的<code>MySQL</code>实例，类似于sidecar模式。我之前基于VTTablet做过一定的二次开发，和大家分享一下我对这块的认识：</p><p><code>VTTablet</code>最核心实现，是 <strong>模拟一个MySQL，与真正的MySQL进行连接</strong>。所以，可以体现如下的特点：</p><ol><li>无侵入式 - 充分利用了MySQL集群间通信的协议，不会侵入原MySQL。这点能衍生出很多价值，例如兼容多版本的MySQL。</li><li>性能较优 - 通过MySQL内部通信的协议交互。</li><li>可扩展性强 - 从原先对大MySQL集群的维护，转变成了相对轻量级的<code>VTTablet</code>集群的维护</li></ol><h3 id="VTGate"><a href="#VTGate" class="headerlink" title="VTGate"></a>VTGate</h3><blockquote><p>VTGate is a lightweight proxy server that routes traffic to the correct VTTablet servers and returns consolidated results back to the client. It speaks both the MySQL Protocol and the Vitess gRPC protocol. Thus, your applications can connect to VTGate as if it is a MySQL Server.</p></blockquote><p><code>VTGate</code>是网关层的角色，主要分三块功能：</p><ol><li>对外暴露出原生的MySQL协议与gRPC协议；</li><li>对内维护与<code>VTTablet</code>集群的连接；</li><li>核心依赖Topology服务中的数据，主要是<code>VTTablet</code>的状态数据和Admin的配置数据</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>Vitess</code>是用Go语言编写的软件，我比较推荐对数据库原理感兴趣的朋友去阅读<code>VTTablet</code>相关的源码，从中你可以了解到很多MySQL的关键性功能，会比直接阅读MySQL的C++简单很多。比如我曾经做过的：</p><ol><li>SQL解析 - 用于自研的查询平台</li><li>Binlog同步 - 用于MySQL到异构数据库的同步平台</li></ol><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg&quot; alt=&quot;2022-01&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2022-01-24-C
      
    
    </summary>
    
      <category term="每日技术分享" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Daily-Sharing" scheme="http://example.com/tags/Daily-Sharing/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 13.【浅析微服务框架】Go-Kit概览</title>
    <link href="http://example.com/2022/01/23/go-tip/go-tip-13/"/>
    <id>http://example.com/2022/01/23/go-tip/go-tip-13/</id>
    <published>2022-01-23T04:00:00.000Z</published>
    <updated>2022-01-27T07:02:49.922Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="Go-Kit概况"><a href="#Go-Kit概况" class="headerlink" title="Go-Kit概况"></a>Go-Kit概况</h2><p>截止到本文发布时，<code>Go-Kit</code>在github上的star数为22.2k，超过了我们已经一起看过的<code>Go-Micro</code>与<code>Kratos</code>。</p><p><code>Go-Kit</code>不同于前两者，它更像是一种Go语言的工具集，而不是一种统一化的框架。</p><span id="more"></span><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>官网 - <a href="https://gokit.io/">https://gokit.io/</a></p><p>Github - <a href="https://github.com/go-kit/kit">https://github.com/go-kit/kit</a></p><p><strong>Go kit is a collection of Go (golang) packages (libraries) that help you build robust, reliable, maintainable microservices.</strong> 官方的定义是一种功能集合collection。</p><h2 id="三个分层"><a href="#三个分层" class="headerlink" title="三个分层"></a>三个分层</h2><p> 官方将<code>Go-Kit</code>核心分成了三层，分别为:</p><ol><li>Transport layer</li><li>Endpoint layer</li><li>Service layer</li></ol><h3 id="Transport"><a href="#Transport" class="headerlink" title="Transport"></a>Transport</h3><p><strong>The transport domain is bound to concrete transports like HTTP or gRPC.</strong></p><p>通信协议相关的传输层。</p><p>这一层具有很多通信协议相关的功能。比如在<code>HTTP</code>协议中，根据返回数据的具体格式，在<code>HTTP</code>头中设置<code>Content-Type</code>。这部分的功能具有很强的重复性，如果设计良好，往往不需要太多的coding。</p><h3 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h3><p><strong>An endpoint is like an action/handler on a controller; it’s where safety and antifragile logic lives.</strong></p><p>RPC函数的控制层入口。</p><p>从一个请求来说，通过<code>Transport</code>上一定的路由关系后，就会落到具体的<code>Endpoint</code>层。一个具体的<code>Endpoint</code>有两个关键的、类型确定的参数：请求与响应。</p><p>定义中还讲到了安全与反脆弱性，可以理解为在<code>Endpoint</code>层要处理panic等异常信息，不要让<code>Endpoint</code>与<code>Service</code>层的问题影响到整个服务的稳定性。</p><h3 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h3><p><strong>Services are where all of the business logic is implemented.</strong></p><p>业务逻辑的实现层。</p><p>整个框架的对<code>Service</code>的定义很宽松，给业务开发很大的空间。如何组织，可以参考其余框架的实践。</p><h2 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h2><p><code>Go-Kit</code>的详细信息并不多，我们就从一个官方的示例入手，来更好地了解<code>Go-Kit</code>，链接如下：</p><p><a href="https://github.com/go-kit/examples/blob/master/stringsvc1/main.go">https://github.com/go-kit/examples/blob/master/stringsvc1/main.go</a></p><h3 id="1-定义服务接口"><a href="#1-定义服务接口" class="headerlink" title="1. 定义服务接口"></a>1. 定义服务接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个功能接口</span></span><br><span class="line"><span class="keyword">type</span> StringService <span class="keyword">interface</span> &#123;</span><br><span class="line">Uppercase(<span class="keyword">string</span>) (<span class="keyword">string</span>, error)</span><br><span class="line">Count(<span class="keyword">string</span>) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-主函数-Transport层"><a href="#2-主函数-Transport层" class="headerlink" title="2.主函数+Transport层"></a>2.主函数+Transport层</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">svc := stringService&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Uppercase方法的定义，包括request和response的编解码</span></span><br><span class="line">uppercaseHandler := httptransport.NewServer(</span><br><span class="line">makeUppercaseEndpoint(svc),</span><br><span class="line">decodeUppercaseRequest,</span><br><span class="line">encodeResponse,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Count方法的定义，包括request和response的编解码</span></span><br><span class="line">countHandler := httptransport.NewServer(</span><br><span class="line">makeCountEndpoint(svc),</span><br><span class="line">decodeCountRequest,</span><br><span class="line">encodeResponse,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将上面两个endpoint注册上去</span></span><br><span class="line">http.Handle(<span class="string">&quot;/uppercase&quot;</span>, uppercaseHandler)</span><br><span class="line">http.Handle(<span class="string">&quot;/count&quot;</span>, countHandler)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Endpoint层"><a href="#3-Endpoint层" class="headerlink" title="3. Endpoint层"></a>3. Endpoint层</h3><p>我们以其中一个<code>Endpoint</code>为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeCountEndpoint</span><span class="params">(svc StringService)</span> <span class="title">endpoint</span>.<span class="title">Endpoint</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, request <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 类型判断</span></span><br><span class="line">req := request.(countRequest)</span><br><span class="line">v := svc.Count(req.S)</span><br><span class="line"><span class="keyword">return</span> countResponse&#123;v&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Service层"><a href="#4-Service层" class="headerlink" title="4.Service层"></a>4.Service层</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stringService)</span> <span class="title">Count</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>从整体的调用链路来说，<code>Go-Kit</code>的使用方式还是比较简单的。我依旧尝试着从中挑两个改进点和大家聊聊：</p><h3 id="1-Transport层的定义过于冗余"><a href="#1-Transport层的定义过于冗余" class="headerlink" title="1.Transport层的定义过于冗余"></a>1.Transport层的定义过于冗余</h3><p>编解码方式往往可以被包含在协议中。</p><p>以<code>HTTP</code>为例，可以根据Content-Type去解析数据，而不是在编码中自行定义。这点是<code>Go-Kit</code>微服务框架为了兼容各种编解码方式，而引入的额外工作量，我个人反倒是建议可以在这块做一些强限制，提高编写代码的便利性。</p><h3 id="2-Endpoint层的请求与响应数据类型为interface"><a href="#2-Endpoint层的请求与响应数据类型为interface" class="headerlink" title="2.Endpoint层的请求与响应数据类型为interface{}"></a>2.Endpoint层的请求与响应数据类型为interface{}</h3><p>定义如：<code>func(_ context.Context, request interface&#123;&#125;) (interface&#123;&#125;, error)</code>。</p><p>对框架来说可以做到统一，但对使用者来说很容易带来不好的体验，比如说：</p><ul><li>请求要做一次数据转换，这个预期的结构体是什么样的？如果转换不成功又该如何处理？</li><li>响应通过<code>interface&#123;&#125;</code>返回，但如果我们要提取内部某个字段做埋点或监控，又需要做一次转换。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们不妨以<code>Kratos</code>中的protobuf提供的<code>gRPC-Gateway</code>方案进行对比，其实<code>Transport</code>+<code>Endpoint</code>层完全可以通过protoc等代码生成工具实现。但是，<code>Go-Kit</code>为了兼容各类RPC框架，无法在这一块利用代码生成等技术继续提效，而只能通过人工组合。</p><p>这一方面体现了集合类框架的价值 - 兼容性强，但也带来了一个最大的弊端 - 不如体系化的框架那么方便。</p><p>官网有一段<a href="https://gokit.io/faq/#dependency-injection-mdash-why-is-func-main-always-so-big">关于依赖注入</a>的内容，这块的思想与<code>Kratos</code>框架提供的<code>wire</code>有异曲同工之妙。但在细节的实现上会有一些差异，我们会在后面聊到这块~</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Go-Kit概况&quot;&gt;&lt;a href=&quot;#Go-Kit概况&quot; class=&quot;headerlink&quot; title=&quot;Go-Kit概况&quot;&gt;&lt;/a&gt;Go-Kit概况&lt;/h2&gt;&lt;p&gt;截止到本文发布时，&lt;code&gt;Go-Kit&lt;/code&gt;在github上的star数为22.2k，超过了我们已经一起看过的&lt;code&gt;Go-Micro&lt;/code&gt;与&lt;code&gt;Kratos&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Go-Kit&lt;/code&gt;不同于前两者，它更像是一种Go语言的工具集，而不是一种统一化的框架。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>五分钟技术小分享 - 2022Week03</title>
    <link href="http://example.com/2022/01/17/sharing-5min/2022-01/2022Week03/"/>
    <id>http://example.com/2022/01/17/sharing-5min/2022-01/2022Week03/</id>
    <published>2022-01-17T04:00:00.000Z</published>
    <updated>2022-01-22T13:49:36.969Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg" alt="2022-01"></p><h2 id="2022-01-17-CNCF-gRPC"><a href="#2022-01-17-CNCF-gRPC" class="headerlink" title="2022-01-17 CNCF-gRPC"></a>2022-01-17 CNCF-gRPC</h2><p>今天，我们一起来看CNCF的 <strong>Remote Procedure Call - RPC</strong> 模块中最具代表性的项目 - gRPC。</p><p>gRPC官网的定义很简洁，重点强调了其<strong>高性能</strong>的特点：</p><blockquote><p>A high performance, open source universal RPC framework.</p></blockquote><p>我们再看一段官方更详细的描述：</p><blockquote><p>gRPC is a modern open source high performance Remote Procedure Call (RPC) framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking and authentication. It is also applicable in last mile of distributed computing to connect devices, mobile applications and browsers to backend services.</p></blockquote><p>除了高性能，这里还提到了两个重要特性：</p><ul><li><strong>插件化的支持</strong>：负载均衡、tracing、健康监测、认证等</li><li><strong>最后一公里</strong>：将手机app、浏览器与后端服务器的联通</li></ul><p>第一点体现出了gRPC的高度可扩展性。这里的插件化不仅体现在上面列举的这些具体功能，甚至像序列化的方案、底层通信的协议，都可以做到快速替换与迭代。</p><p>第二点在实际生产上应用的case并不多，仍需要大量的实践与经验沉淀后，才建议大家尝试。目前，绝大多数的gRPC通信都是发生在后端服务之间。</p><p>接下来，我们来谈谈官网列举的四个特性：</p><h3 id="Simple-service-definition"><a href="#Simple-service-definition" class="headerlink" title="Simple service definition"></a>Simple service definition</h3><p>gRPC采用<code>Protocol Buffers</code>进行定义，从整体来说阅读体验确实是比较简洁的，但在实际工程中仍存在两个问题：</p><ol><li><strong>迁移成本大</strong>：gRPC没有提供从很多历史RPC解决方案中迁移的途径，如Thrift等，完全是另起炉灶，这对有历史包袱的团队来说很难接受；</li><li><strong>配套开发工具缺失</strong>：高频使用<code>Protocol Buffers</code>的朋友都有了解，主流IDE对<code>pb</code>文件的错误提示和文件格式化都有缺失，很多问题都无法在coding的过程中实时提示，而是需要运行二进制命令<code>protoc</code>后才能了解。</li></ol><h3 id="Start-quickly-and-scale"><a href="#Start-quickly-and-scale" class="headerlink" title="Start quickly and scale"></a>Start quickly and scale</h3><p><strong>快速启动</strong> - 强调的是通过<code>Protocol Buffers</code>生成的代码，可以在各语言内用简洁的代码就可运行（这部分与各语言强相关）</p><p><strong>快速扩容</strong> - 这个特性需要与<code>Kubernetes</code>的能力结合。</p><h3 id="Works-across-languages-and-platforms"><a href="#Works-across-languages-and-platforms" class="headerlink" title="Works across languages and platforms"></a>Works across languages and platforms</h3><p>跨语言与平台的特性，非常依赖背后的生态 - 需要大量的工作去兼容多语言，也要兼顾性能、稳定性等问题。</p><p>所以，这不仅仅是技术上的问题，更需要社区、资金等复杂因素的支持。</p><h3 id="Bi-directional-streaming-and-integrated-auth"><a href="#Bi-directional-streaming-and-integrated-auth" class="headerlink" title="Bi-directional streaming and integrated auth"></a>Bi-directional streaming and integrated auth</h3><ul><li><strong>双向流式通信</strong> - 这点是gRPC的核心特性，体现出了与其它RPC方案的差异</li><li><strong>集成认证功能</strong> - Auth是gRPC插件化生态中的重要一环，这部分其实与服务网格的功能存在一定的重叠</li></ul><h2 id="2022-01-18-CNCF-Envoy"><a href="#2022-01-18-CNCF-Envoy" class="headerlink" title="2022-01-18 CNCF-Envoy"></a>2022-01-18 CNCF-Envoy</h2><p>作为云原生Service Mesh代表性的产品之一，Envoy占据了大壁江山。</p><blockquote><p>Envoy is an L7 proxy and communication bus designed for large modern service oriented architectures.</p></blockquote><ol><li>定位：L7 代理和通信总线</li><li>重点服务对象：SOA面向服务架构（也完全适用于微服务架构）</li></ol><p>核心理念：</p><blockquote><p>The network should be transparent to applications. When network and application problems do occur it should be easy to determine the source of the problem.</p><p>网络应对应用程序透明。当网络和应用程序出现问题时，应该很容易地确定问题根源。</p></blockquote><p>文档资料：</p><ul><li>官方：<a href="https://www.envoyproxy.io/docs/envoy/latest/intro/intro">https://www.envoyproxy.io/docs/envoy/latest/intro/intro</a></li><li>中文版：<a href="https://www.servicemesher.com/envoy/">https://www.servicemesher.com/envoy/</a></li></ul><p>我们依旧挑选三个核心特性展开：</p><h3 id="Out-of-process-architecture-进程外架构"><a href="#Out-of-process-architecture-进程外架构" class="headerlink" title="Out of process architecture 进程外架构"></a>Out of process architecture 进程外架构</h3><p>进程外架构，其实就是一种微服务理念的体现，它的利与弊也是和微服务强相关的。</p><p>优点很直观 - Envoy可以支持多语言，也可以独立于业务快速迭代与发展。</p><p>而弊端在官网上没有体现，最关键的一点是：<strong>性能损耗</strong>。作为一种side-car模式，Envoy是在本机内、进程间进行通信，远远地比进程内调用的压栈、出栈更花时间。</p><h3 id="Service-discovery-and-dynamic-configuration-服务发现和动态配置"><a href="#Service-discovery-and-dynamic-configuration-服务发现和动态配置" class="headerlink" title="Service discovery and dynamic configuration 服务发现和动态配置"></a>Service discovery and dynamic configuration 服务发现和动态配置</h3><p>很多运维同学都会拿Envoy去对比Nginx，确实在很多特性上，两者有很大的相似之处。但在这个特性上，Envoy有得天独厚的优势。</p><p>以一个常见的动态负载均衡为例，nginx需要结合consul template来实现，还需要对应用程序做一定的侵入。而Envoy可以与Kubernetes完美契合，大幅度减少维护成本。</p><h3 id="Best-in-class-observability-最佳的可观察性"><a href="#Best-in-class-observability-最佳的可观察性" class="headerlink" title="Best in class observability 最佳的可观察性"></a>Best in class observability 最佳的可观察性</h3><p>Envoy 的最主要目标是使网络透明，而最佳的可观测性往往会从OpenTelemetry推荐的三点入手：Metrics、Logging、Tracing。</p><p>Envoy提供了大量的插件，一方面保证了Envoy内部的问题清晰明了，同时也能快速地协助定位到应用侧的问题。</p><h2 id="2022-01-19-CNCF-Contour"><a href="#2022-01-19-CNCF-Contour" class="headerlink" title="2022-01-19 CNCF-Contour"></a>2022-01-19 CNCF-Contour</h2><p>作为CNCF中的控制平面的主打产品，Contour的知名度远不如Google的Istio。但由于种种原因，Istio并没有被捐献给云原生基金会，于是CNCF就孵化了Contour。</p><blockquote><p>定义</p><p>Contour is an open source Kubernetes ingress controller providing the control plane for the Envoy edge and service proxy. Contour supports dynamic configuration updates and multi-team ingress delegation out of the box while maintaining a lightweight profile.</p><p>三大特性</p><ul><li>Envoy Inside</li><li>Flexible Architecture</li><li>TLS Certificate Delegation</li></ul></blockquote><p>从定义与三个特性的描述里，我们很难真实地感受到Contour的特点。</p><p>今天我将换一个角度：从控制平面与数据平面进行分析。如果我们能清楚地认识到这两者的定义与边界，那么会对云原生的Service Mesh理念，以及Envoy、Contour、Istio等产品有更深的理解。</p><p><a href="http://dockone.io/article/9919">这篇博客</a>的定义很具有参考意义：</p><ul><li><strong>控制平面</strong> - 通过配置和控制消息来组织编排网络的逻辑，并下发给数据平面</li><li><strong>数据平面</strong> - 以 Sidecar 的形式与应用部署在一起，承载其流量的发送与接收</li></ul><p>控制平面的关键功能就是<strong>控制与管理</strong>，重点对象是<strong>配置信息</strong>。</p><p>我们可以将数据平面看作为基础的Nginx服务，它是和底层的应用强相关的，解析相关的数据包并实现路由、负载均衡等功能。但Nginx自身也需要有一定的配置信息，比如说：</p><ul><li>数据平面的服务发现中心往往是因服务而异的；</li><li>数据平面的超时参数会频繁调整；</li><li>在做蓝绿测试时，需要频繁调整流量；</li><li>认证相关的设置往往需要统一更新，如证书；</li></ul><p>在我看来，控制平面更像是数据平面的配置中心，解决的是高频变化或应用间差异性很大的配置信息，让数据平面更稳定地运行。</p><blockquote><p>从架构层面来说，如果一层解决不了问题，那就再抽象一层。</p></blockquote><p>从具体的工程实践来说，数据平面主要负责的是底层实现，在保证稳定性的情况下更要兼具性能，所以不宜有太多丰富的功能。这时，引入了控制平面，我们可以将很多的配置信息通过界面UI方式进行管理，下发到各个控制平面，然后控制平面再针对性地进行转发到数据平面，就能大幅度地提高整个Service Mesh方案的可维护性。</p><h2 id="2022-01-20-CNCF-Emissary-Ingress"><a href="#2022-01-20-CNCF-Emissary-Ingress" class="headerlink" title="2022-01-20 CNCF-Emissary-Ingress"></a>2022-01-20 CNCF-Emissary-Ingress</h2><p>Emissary-Ingress是CNCF中又一个与网络相关的项目。这款软件的前身叫作Ambassador。但Ambassador是一款商业软件，为了避免相关的问题，更名为Emissary-Ingress后被捐献给了CNCF。因为网上资料更多的都是Ambassador，下面统一用Ambassador对这款软件进行描述。</p><p>CNCF上的定义为：</p><blockquote><p>open source Kubernetes-native API gateway for microservices built on the Envoy Proxy</p></blockquote><p>我们很容易将这个产品与Istio、Envoy混淆起来，那它们之间的区别是什么呢？这里有篇<a href="https://itnext.io/ambassador-and-istio-edge-proxy-and-service-mesh-814aac9f23df">文章</a>，介绍了具体的实践，但我们直接可以从标题中得到关键信息：</p><ul><li>Ambassador - Edge proxy</li><li>Istio - service mesh</li></ul><p>而Envoy+Contour对标的是Istio，所以不难看出，云原生推荐将Ambassador作为一种边缘网关，更多地是作为整体流量的出入口。如果说service mesh是一种对网络的精细化管理，那么边缘网关更多地是对整体流量的管理。</p><p>但在实际使用中，两者有大量的重叠功能，如路由、认证、限速等，而我也没有在网上找到相关的Best Practice，这部分就很需要大家的经验与摸索了。从我的角度来看，更倾向于大家多使用Envoy的特性，毕竟它的生态最成熟。即便后续有了替代品，对方也往往会提供对应的兼容方案。</p><p>这里，我引用了一个<a href="https://www.getambassador.io/docs/emissary/latest/topics/concepts/microservices-api-gateways/#microservices-api-gateways-vs-enterprise-api-gateways">链接</a>，讲述了微服务网关(Emissary-Ingress定位)与传统企业级网关的差异。</p><h3 id="Primary-Purpose-主要目标"><a href="#Primary-Purpose-主要目标" class="headerlink" title="Primary Purpose 主要目标"></a>Primary Purpose 主要目标</h3><ul><li>传统企业级网关 - Expose, compose, and manage internal business APIs</li><li>微服务网关 - Expose and observe internal business services</li></ul><p>微服务网关相对而言会更轻量级，而且对外以服务的维度呈现。</p><h3 id="Publishing-Functionality-发布功能"><a href="#Publishing-Functionality-发布功能" class="headerlink" title="Publishing Functionality 发布功能"></a>Publishing Functionality 发布功能</h3><ul><li>传统企业级网关 - API management team or service team registers / updates gateway via admin API</li><li>微服务网关 - Service team registers / updates gateway via declarative code as part of the deployment process</li></ul><p>微服务网关更倡导自运维的方式。</p><h3 id="Handling-and-Debugging-Issues-处理和Debug问题"><a href="#Handling-and-Debugging-Issues-处理和Debug问题" class="headerlink" title="Handling and Debugging Issues 处理和Debug问题"></a>Handling and Debugging Issues 处理和Debug问题</h3><ul><li><p>传统企业级网关 - L7 error-handling (e.g. custom error page or payload). Run gateway/API with additional logging. Troubleshoot issue in staging environment</p></li><li><p>微服务网关 - Configure more detailed monitoring. Enable traffic shadowing and / or canarying</p></li></ul><p>微服务网关更强调的是网络侧的更细致化的管理，突出了灵活性。</p><h2 id="2022-01-21-谈谈Context在Go程序外的传递"><a href="#2022-01-21-谈谈Context在Go程序外的传递" class="headerlink" title="2022-01-21 谈谈Context在Go程序外的传递"></a>2022-01-21 谈谈Context在Go程序外的传递</h2><p>这两天，有个读者跟我讨论了一个关于链路追踪的问题 - 他发现通过context传递的trace-id丢失了。从根本上来说，这涉及到了<strong>Context在Go程序外的传递</strong>的理解，细想的话很有意思，所以我今天专门拿出来讲讲。</p><p>如果你对Go语言有一定的基础，会很习惯地使用Context作为上下文信息的传递：无论是内部函数的调用，还是RPC的调用，这就会产生一种错觉：<strong>context的传递是水到渠成的</strong>。</p><p>这位同学的调用链路是 Go程序 - MQ - Go程序，发现context中的trace-id丢失了。</p><blockquote><p>trace-id用于分布式的链路追踪</p></blockquote><p>分析这个问题不难，有很多种思路，但我比较建议大家从底层实现去理解：</p><ol><li>context的本质，是一种key-value的数据结构；</li><li>服务之间的调用，本质上是一种网络上的二进制数据的传递，而<strong>context信息肯定是保存在其中的</strong>；</li><li>HTTP是一种二进制数据上的协议表达格式，我们常见的RESTful API 的 json数据是填入到body中，但HTTP协议还有很多地方可以保存数据，尤其是HTTP Header。context信息大概率是被保存在Header里的；</li></ol><p><strong>Go语言的Client将context封装到Header里，Server将context从Header中解析出来</strong>。</p><blockquote><p>默认的官方库是不会写直接写的，需要做一层浅封装：</p><p>发送前，从ctx中将对应的k-v填入到header；</p><p>收到后，从header中提取k-v，写入到context。</p></blockquote><p>要验证一下上面的猜想很简单，我强烈大家用最底层的方式：<strong>Wireshark抓包</strong>。事实也如我们的预期，Go语言的ctx传递正是用这种方式实现的。而MQ这种第三方组件，往往不会去解析这种特定的Header，所以会发生丢失。</p><p>这时，我们有什么样的解决方案呢？</p><ol><li>制定标准。这也是OpenTracing等规范推崇的，对广大的开发者来说非常友好，尤其是跨语言的情况，但这块非常依赖生态，需要大量的SDK，整体来说推进进度比较难。（这就体现了Service Mesh的价值）</li><li>显示传递。相当于把关键信息填到HTTP的body里，对具体代码的实现来说侵入性很强，但不失为中小型公司快速落地的方案；遇到一些不支持标准的第三方软件，我们也往往只能采用这种方式。</li></ol><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg&quot; alt=&quot;2022-01&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2022-01-17-C
      
    
    </summary>
    
      <category term="每日技术分享" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Daily-Sharing" scheme="http://example.com/tags/Daily-Sharing/"/>
    
  </entry>
  
  <entry>
    <title>五分钟技术小分享 - 2022Week02</title>
    <link href="http://example.com/2022/01/10/sharing-5min/2022-01/2022Week02/"/>
    <id>http://example.com/2022/01/10/sharing-5min/2022-01/2022Week02/</id>
    <published>2022-01-10T04:00:00.000Z</published>
    <updated>2022-01-15T13:28:52.005Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg" alt="2022-01"></p><h2 id="2022-01-10-Unix设计哲学概览"><a href="#2022-01-10-Unix设计哲学概览" class="headerlink" title="2022-01-10 Unix设计哲学概览"></a>2022-01-10 Unix设计哲学概览</h2><p>Unix设计哲学在程序员的圈子里经久不衰，备受追捧。而<code>Go</code>语言背后有很多<code>Unix</code>与<code>C语言</code>的影子，三位创始人Rob Pike（罗伯. 派克），Ken Thompson（肯. 汤普森）和Robert Griesemer（罗伯特. 格利茨默）都是这两块领域的泰山北斗。了解Unix的设计哲学，对写出优秀的代码很有帮助。</p><ul><li>英文资料 - <a href="https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html">https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html</a></li><li>中文wiki - <a href="https://zh.wikipedia.org/wiki/Unix%E5%93%B2%E5%AD%A6">https://zh.wikipedia.org/wiki/Unix%E5%93%B2%E5%AD%A6</a></li></ul><h3 id="Doug-McIlroy的总结"><a href="#Doug-McIlroy的总结" class="headerlink" title="Doug McIlroy的总结"></a>Doug McIlroy的总结</h3><blockquote><p>Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface.</p><p>做一件事，做好它。让程序能够互相协同工作。应该让程序处理文本数据流，因为这是一个通用的接口。</p></blockquote><p>作为管道机制的发明者，Doug McIlroy对这块的解释重点很具有管道特色。这里，我们聚焦于一个点：<strong>做好一件事</strong>。</p><p>将其拆分一下，主要分为两块：</p><ol><li><strong>做好。</strong>做一件事，可能只需要10分的能力；而做好，则需要100分的能力（但 <code>做好</code> 这个标准，尽可能地按照自己的认知上限去做，才可能有成长）。</li><li><strong>一件事。</strong>怎么定义一件事呢？边界的定义就难倒了很多人。这个非常考验能力，更具体可能需要<code>case by case</code>去看。</li></ol><h3 id="Rob-Pike的总结"><a href="#Rob-Pike的总结" class="headerlink" title="Rob Pike的总结"></a>Rob Pike的总结</h3><blockquote><ol><li>你永远不会知道你的程序会在什么地方耗费时间。程序的瓶颈常常出现在意想不到的地方，因此在你确信找到瓶颈后再动手优化代码吧。</li><li>测试代码。只有在你详细测试了代码，并且发现一部分代码耗费了绝大部分的运行时间时再对程序作速度优化。</li><li>功能全面的算法（fancy algorithm）在处理小规模问题时效率很低，这是因为算法时间效率中的常量很大，而问题往往规模很小。除非你知道你遇到的常常是复杂的情况，否则就让代码丑陋但是简单而高效吧。（即使问题规模确实很大，也首先尝试第二条规则。）</li><li>功能全面的算法比简单的算法更容易产生bug，更难实现。尽量使用简单的算法和数据结构。</li><li>数据决定一切。如果选择的数据结构能很好的管理数据，算法部分往往不言自明。记住，数据结构，而非算法，才是编程的关键。</li><li>没有第六条规则。</li></ol></blockquote><p>按照wiki上的说法，1、2可以归纳为 <strong>过早的优化是一切罪恶的根源</strong>，3、4可以理解为 <strong>疑惑不定之时最适合穷举</strong>。</p><p>而第五条就非常有意思，也就是 <strong>数据结构比算法更重要</strong>。</p><p>这点，和我们在刷算法题时认知相反 - 在做算法题目时，我们往往已经得到了一个具体的数据结构，要做的更多是根据这个数据结构选择合适的算法。当数据结构确定时，可选择的算法就很有限了，这也大大缩小了题解的范围。</p><p>在复杂的场景中，我们首先得确定数据结构，这一步尤为复杂：</p><ol><li>复合 - 数据结构往往是复合的、嵌套的，单一的数据结构很少见；</li><li>抓住核心 - 可用数据结构解往往有多种，关键是识别其中决定性的因素；</li><li>不确定性 - 最优解的数据结构，往往会根据时间变化而变化；</li><li>简单性 - 性能最优解并不一定是最终的解，实际工程中多考虑简单性；</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关于Unix的设计哲学还有很多优秀的见解，但综合起来，可以归纳为<code>KISS</code>原则，也就是<strong>简单性</strong>。希望大家能在工程实践中，多多思考怎么保证简单性，对做出优秀的设计会很有启发。</p><h2 id="2022-01-11-CNCF-CrossPlane"><a href="#2022-01-11-CNCF-CrossPlane" class="headerlink" title="2022-01-11 CNCF-CrossPlane"></a>2022-01-11 CNCF-CrossPlane</h2><p>今天我们一起来看CNCF中的第二个项目 - <code>CrossPlane</code> 。它位于CNCF全景图中<code>Kubernetes</code>旁，受众比较小。</p><p>先看一段来自官网 <a href="https://crossplane.io/">https://crossplane.io/</a> 的信息：</p><blockquote><p> Crossplane is an open source Kubernetes add-on that enables platform teams to assemble infrastructure from multiple vendors, and expose higher level self-service APIs for application teams to consume, without having to write any code.</p></blockquote><p>我们依旧抽取其中关键的词进行解析：</p><ul><li><code>Kubernetes add-on</code> CrossPlane的定位是<code>Kubernetes</code>的插件，并非一个独立的平台</li><li><code>assemble infrastructure from multiple vendors</code> 统一封装多个依赖方的基础设施</li><li><code>expose higher level self-service APIs</code> 暴露高层接口</li></ul><p>然后，官方描述了五个关键性的特征：</p><ul><li>Provision and manage cloud infrastructure and services using kubectl</li><li>There is a flavor of infrastructure for everyone on Crossplane</li><li>Publish simplified infrastructure abstractions for your applications</li><li>The Universal Cloud API</li><li>Run Crossplane anywhere</li></ul><p>概括起来，可以定义为：<strong>使用 kubectl 封装了各类云的API，来统一管理基础设施、服务和应用</strong>。</p><p>我们从具体的实践角度来看，统一封装接口往往只是加分项，而核心在于 <strong>支持的云基础设施与服务的范围</strong>。</p><p>从 <a href="https://crossplane.io/docs/v1.6/getting-started/provision-infrastructure.html">官方文档</a> 可以看到，<code>CrossPlane</code>主要支持了亚马逊云、谷歌云、微软云等厂商。可以看到，这款产品主要面向的是<strong>国外的公有云厂商</strong>。这其实也决定了<code>CrossPlane</code>更多面向的是国外开发者。</p><p>学习<code>CrossPlane</code>的更多细节，对我们来说暂时没有更大的意义。我们可以尝试着从其理念中得到以下启发：</p><ol><li><strong>对接各类云厂商是复杂的。</strong>尽管<code>CNCF</code>统一了大致上的理念，但细节上的实现各有不同；尤其是结合了账号、权限、资源分配等各类特性后，对接起来的复杂度很高。</li><li><strong>如果一层不能解决，那就加一层。</strong> 直接对接各类公有云复杂度很高，也会为<code>Kubernetes</code>这个核心项目带来大量侵入性极强的代码。这时，引入另一个项目作为<strong>防腐层</strong>，很具有扩展意义。</li><li><strong>一个核心项目不一定需要做成大型平台，更重要的是它的特性符合整个生态的发展理念。</strong></li></ol><h2 id="2022-01-12-微服务架构特征"><a href="#2022-01-12-微服务架构特征" class="headerlink" title="2022-01-12 微服务架构特征"></a>2022-01-12 微服务架构特征</h2><p>今天的话题将围绕着一篇谈论微服务架构的文章展开。下面给出原文链接，以及一个翻译的版本：</p><ul><li>原文 - <a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a></li><li>中文翻译 - <a href="https://blog.51cto.com/u_15127669/4175353">https://blog.51cto.com/u_15127669/4175353</a> </li></ul><p>文中给出了以下九个微服务特征：</p><ol><li>Componentization via Services 通过服务来实现组件化</li><li>Organized around Business Capabilities 围绕业务能力构建</li><li>Products not Projects 面向产品，而不是面向项目</li><li>Smart endpoints and dumb pipes 终端智能化，通讯轻量化</li><li>Decentralized Governance 分散治理</li><li>Decentralized Data Management 数据去中心化管理</li><li>Infrastructure Automation 基础设施自动化</li><li>Design for failure 容错性设计</li><li>Evolutionary Design 演进式设计</li></ol><p>这些点，每个抛出来都可以写一篇长文。建议有兴趣的各位可以阅读原文，结合自己的实践多多思考。</p><p>这里，我选择三个最近感触比较深的点，自己也曾经陷入过的认知误区，在这里和大家聊聊：</p><h3 id="围绕业务能力构建"><a href="#围绕业务能力构建" class="headerlink" title="围绕业务能力构建"></a>围绕业务能力构建</h3><p>业务能力的概念很抽象，虽然我们会经常提及，但在实践过程中又往往容易忽略。</p><p>从系统的角度来看，业务能力往往就是对外呈现的功能，对应到内部的技术模块，往往已经决定了七七八八。如何将这些技术模块做合理的拆分与合并，就是微服务架构需要考量的点。这里我谈谈最近比较有心得的三个考量点：</p><ul><li>拆分高频变化与低频变化</li><li>分离计算密集型和IO密集型</li><li>基础能力尽早引入业界的通用模块</li></ul><p>当然，还有更多的内容，需要大家在实践中摸索。</p><h3 id="终端智能化，通讯轻量化"><a href="#终端智能化，通讯轻量化" class="headerlink" title="终端智能化，通讯轻量化"></a>终端智能化，通讯轻量化</h3><p>这一点在云原生的服务中体现得淋漓尽致：以<strong>RPC</strong>、<strong>Service Mesh</strong>、<strong>服务发现</strong>等技术为代表。</p><p>终端体现在<code>Pod</code>这一层，也就是对一个具体运行的App来说，通过Istio、CoreDNS等技术将分布式的服务做到和单体应用一致，然后通过轻量级的通讯方案，如HTTP进行交互。这种方式的优点很明显：</p><ol><li>分布式服务之间的通讯复杂度最高的部分，由专用的、成熟的组件，引入到Pod层面完成；</li><li>开发者的代码实现只需要关心RPC的数据出入，复杂度大幅度降低；</li></ol><p>目前云原生的Service Mesh技术还未完全形成行业标准，相信很快随着它的落地，将迎来微服务的又一波热潮。</p><h3 id="容错性设计"><a href="#容错性设计" class="headerlink" title="容错性设计"></a>容错性设计</h3><p>容错性设计，也就是为错误而设计，这一点很反直觉。</p><p>作为一名开发者，我们实现功能的思路往往是按照顺序的逻辑步骤；一个一个步骤的串联，才能保证最后的功能实现。但这个时候，如果要我们去关注各类错误的发生，小到网络波动、程序崩溃，大到机房断电，很容易无所适从。</p><p>这里，我谈谈自己的理解：<strong>主要从发生的概率与影响的严重程度来思考，不要过度追求细节</strong>。这里有一个很重要的权衡点 - **健壮性 **与 <strong>简单性</strong> ：一般来说，要保证程序足够健壮，会引入各种异常的容错性设计，增加系统的复杂度，但这一点并不是绝对的。</p><p><strong>从系统整体功能的维度，虽然看起来增加了复杂度，但通过分层、模块化、服务拆分等方式，分而治之 - 一些简单的模块用简单的规则组合成一个大模块，可维护性远远高于一个复杂的模块。</strong></p><h2 id="2022-01-13-CNCF-CoreDNS"><a href="#2022-01-13-CNCF-CoreDNS" class="headerlink" title="2022-01-13 CNCF-CoreDNS"></a>2022-01-13 CNCF-CoreDNS</h2><p><code>CoreDNS</code>是CNCF全景图中 <strong>协调与服务发现</strong> 模块的核心项目，在<code>Kubernetes</code>1.12版本之后成为了默认的DNS服务。熟悉<code>CoreDNS</code>是掌握<code>Kubernetes</code>必不可少的技能。</p><p>照例，我们先一起看下其核心定义，非常简洁明了：</p><blockquote><p>官网 - CoreDNS: DNS and Service Discovery</p><p>CNCF - CoreDNS is a DNS server that chains plugins</p></blockquote><p>今天，我们将围绕一个关键词<code>chains plugins</code> - <strong>链式插件</strong> 展开，这也是<code>CoreDNS</code>实现的核心特性。</p><p>官方对这个特性的定义如下，</p><blockquote><p>CoreDNS chains plugins. Each plugin performs a DNS function, such as Kubernetes service discovery, prometheus metrics, rewriting queries, or just serving from zone files. And many more.</p></blockquote><p>从中不难看出，<code>CoreDNS</code>将各种<code>DNS</code>的功能抽象成一个插件，进行链式调用。</p><p>我们用 <a href="https://github.com/coredns/coredns">官方github上的Corefile</a> 来了解这个特性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example.org:1053 &#123;</span><br><span class="line">    file /var/lib/coredns/example.org.signed</span><br><span class="line">    transfer &#123;</span><br><span class="line">        to * 2001:500:8f::53</span><br><span class="line">    &#125;</span><br><span class="line">    errors</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. &#123;</span><br><span class="line">    any</span><br><span class="line">    forward . 8.8.8.8:53</span><br><span class="line">    errors</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>当访问<code>example.org:1053</code> 时，依次触发 file、transfer、errors、log四个插件</li><li>访问其余DNS时，依次触发 any、forward、errors、log四个插件</li></ol><p>上面的语法与<code>nginx</code>非常类似，而作者实际上是参考<code>Caddy</code>软件进行设计的，有兴趣的可以查阅相关资料，例如这个 <a href="https://mritd.com/2021/06/30/understand-caddyfile-syntax/">博客</a>。</p><p>链式调用是一种表述形式非常强的语法：<strong>它以一个大众容易接受的顺序逻辑，讲述了一个完整的调用过程，将各个细节也描述地很清晰</strong>。</p><p>既然链式调用的描述方式那么棒，为什么目前没有大规模地推广到各类工具上呢？这里，我谈谈个人的三个理解：</p><ol><li><strong>核心模块支持插件化</strong> - 链式调用需要动态加载各类插件，这一点对核心的模块要求很高，很多软件设计之初就决定了很难走插件化的道路；</li><li><strong>无需兼容历史问题</strong> - 很多的工具都存在大量的历史版本，很难做到完全兼容这种表达形式；而<code>CoreDNS</code>在设计之初就强制采用这种规范，没有历史包袱；</li><li><strong>每个插件的输入与输出保持一致</strong> - 作为一种链式调用，为了保证前者输入可以作为后者输出，两者支持的数据格式必须一样（可以参考Unix中的管道）。DNS服务的功能比较简单，可以保证一致；</li></ol><p>同样的，Corefile这种声明方式，也或多或少带来了一些问题，例如：</p><ol><li><strong>文件解析的复杂性</strong>（这点与链式调用本身无关） - 比如数据类型的问题，很难确定文件中的<code>5</code>是数字还是字符串；</li><li><strong>链式调用很难解决前后有依赖的情况</strong> - 如调用A插件的结果有个特别的输出，用于插件B的输入时，很难解决；</li><li><strong>长链式调用的复杂度</strong> - 如果链式调用过长，一方面带来了异常情况下排查问题的复杂度，另一方面很容易出现性能问题；</li></ol><p><code>CoreDNS</code>的成功，<strong>链式调用插件</strong> 这个特性只体现了简单性的理念，并不是关键性的原因，而更多地是依赖大量开箱即用的<a href="https://coredns.io/plugins/">插件</a>。</p><h2 id="2022-01-14-不可变基础设施"><a href="#2022-01-14-不可变基础设施" class="headerlink" title="2022-01-14 不可变基础设施"></a>2022-01-14 不可变基础设施</h2><p>看起来，这功能描述与<code>CICD</code>流程差不多，但使用体验差距很大。在传统的模式下，我们执行的是一个<strong>具体的动作</strong>，比如扩1个应用、升级2个程序等；而在k8s里，使用者只要<strong>声明最终的预期状态</strong>，比如5个应用运行v1.0版本的程序，那么整个系统该扩容还是缩容、该升级还是回滚，都由k8s自行根据当前状态进行判断。</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>ab4ea1c14f669e0e42040689da7aa074c4e479f3</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>云原生有五大代表性的技术 - <strong>容器、服务网格、微服务、不可变基础设施和声明式 API</strong>。相对于其余四种概念，不可变基础设施 - <code>Immutable Infrastructure</code> 更难理解，今天我们来一起看看。</p><blockquote><p>入门可以参考这篇文章 - <a href="https://zhuanlan.zhihu.com/p/382203966">https://zhuanlan.zhihu.com/p/382203966</a> </p></blockquote><p>网上可搜索到的<strong>不可变基础设施</strong>定义有很多，这里我选择一个比较有代表性的：</p><blockquote><p>Immutable infrastructure refers to servers (or VMs) that are never modified after deployment.</p></blockquote><p>从开发者的角度来看，不可变基础设施是一个很棒的概念。如果用一个词总结它的优点，那就是 <strong>时间与空间上的一致性</strong>。</p><p>如果有一个传统应用希望改造成适配 <strong>不可变基础设施</strong> 的场景，那么会有哪些常见的改造点呢？</p><ol><li>将传统应用的运行环境打造成一个具体的服务器，例如虚拟机、容器；</li><li>重点分析该应用的输出形式，让其与 <strong>服务器无关</strong>；</li></ol><p>第二点有些抽象，这里我举三个具体的例子：</p><ol><li>本地缓存 - 转移到分布式缓存服务；</li><li>本地保存的文件 - 转移到分布式存储服务中；</li><li>本地日志 - 将原来打印到本地文件的日志服务，重定向到标准输出，由日志采集的side-car收集后统一汇总；</li></ol><p>但在实际的工程中，追求 <strong>不可变基础设施</strong> 很难完全落地，我们可以适当地做一些权衡：</p><ol><li>如果日志不允许落盘对部分程序的改造成本很高，那么我们可以用ELK等一套日志收集方案做准实时的同步，保证日志可丢失；</li><li>如果完全依赖分布式缓存对性能压力过大，那么就建立一套分布式缓存与本地缓存的自动同步机制，保证重启后本地缓存丢失，仍可以恢复；</li></ol><p>不难看出，只要我们保证应用在基础设施上产生的数据 <strong>可在任意时间丢失</strong>，就能实现了一定程度上 <strong>应用无状态化</strong>，也能保证了<strong>不可变基础设施</strong>的落地。</p><p><strong>不可变基础设施</strong>是一种理念，具体落地的技术非常依赖容器或虚拟机，以及分布式存储等配套设施。我们没有必要把它作为一种技术标准去强制执行，而应该结合现状，选择性地朝着这个方向不断优化。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg&quot; alt=&quot;2022-01&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2022-01-10-U
      
    
    </summary>
    
      <category term="每日技术分享" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Daily-Sharing" scheme="http://example.com/tags/Daily-Sharing/"/>
    
  </entry>
  
  <entry>
    <title>五分钟技术小分享 - 2022Week01</title>
    <link href="http://example.com/2022/01/04/sharing-5min/2022-01/2022Week01/"/>
    <id>http://example.com/2022/01/04/sharing-5min/2022-01/2022Week01/</id>
    <published>2022-01-04T04:00:00.000Z</published>
    <updated>2022-01-11T06:50:57.175Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg" alt="2022-01"></p><h2 id="2022-01-04-Go1-18概览"><a href="#2022-01-04-Go1-18概览" class="headerlink" title="2022-01-04 Go1.18概览"></a>2022-01-04 Go1.18概览</h2><p>在2021年年底，<code>Go</code>推出了<code>1.18Beta</code>版本。由于正式版本没有完全敲定，普通开发人员没有必要研究到底层实现，但如果能先形成一个全局上的认知，能帮助我们领先一步。</p><p>关于1.18的核心改动，是 <strong>对泛型(Generics)的支持</strong>。Go语言的泛型语法比较简单，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> numeric <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="keyword">type</span> <span class="keyword">int</span>, <span class="keyword">int8</span>, <span class="keyword">int16</span>, <span class="keyword">int32</span>, <span class="keyword">int64</span>, <span class="keyword">uint</span>, <span class="keyword">uint8</span>, <span class="keyword">uint16</span>, <span class="keyword">uint32</span>, <span class="keyword">uint64</span>, <span class="keyword">float32</span>, <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span>[<span class="title">T</span> <span class="title">numeric</span>]<span class="params">(a, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要在实际工程上落地，还有很多考量点，我这边重点提三点：</p><ol><li><strong>主流IDE的支持</strong> - 包括Goland与VSCode，尽量帮助开发者能在编码时发现问题；</li><li><strong>历史库的迁移与兼容</strong> - 实现泛型后，许多主流库会有大量的冗余函数，如何提供迁移方案，值得我们去关注；</li><li><strong>泛型的最佳工程实践</strong> - 作为一种新特性，Go的泛型如何应用在工程中、尤其是复杂工程中，需要一定的实践摸索，并总结规律（可借鉴其余支持泛型的语言）；</li></ol><p>除了泛型，另外一个比较大的特性就是<code>Fuzzy Testing</code>。</p><p>这个特性是为<strong>单元测试提供更全面的数据输入</strong>，这样就能覆盖更多的case，提前发现问题。关键词<code>Fuzzy</code>支持的主要特性是将一个输入参数，<strong>从具体的值变成范围</strong>，如原先输入<code>a=1</code>，现在支持<code>a</code>输入范围为<code>[-10,10]</code>。在跑单元测试时，大量的<code>Fuzzy</code>肯定会带来一定的性能压力，这时可以引入一定的并发特性。</p><p>总体来说，<code>Go1.18</code>对工程侧的影响更多地是提高代码的 <strong>简洁性</strong>。新特性的学习成本很低，我们不用过于急着引入，可以多花时间学习底层原理。</p><blockquote><p><strong>Go Blog</strong> - <a href="https://go.dev/blog/go1.18beta1">https://go.dev/blog/go1.18beta1</a></p><p><strong>Medium</strong> - <a href="https://betterprogramming.pub/golang-1-18-what-you-need-to-know-a5701f7e14ab">https://betterprogramming.pub/golang-1-18-what-you-need-to-know-a5701f7e14ab</a></p></blockquote><h2 id="2022-01-05-CNCF-概览"><a href="#2022-01-05-CNCF-概览" class="headerlink" title="2022-01-05 CNCF-概览"></a>2022-01-05 CNCF-概览</h2><p>CNCF作为云原生的代表性组织，提供了大量开源的软件，以及配套的、开箱即用的解决方案。有很多朋友对CNCF和云原生的认识可能仍停留在新闻报道里。今天，我先带大家在整体上入个门，后续选择具有代表性的软件进行分析。</p><blockquote><p>由于篇幅所限，我的分享只会提重点知识，帮大家建立这部分的知识框架，更详细的内容需要大家自行学习。</p></blockquote><p>CNCF的概览可以参考这个全景图 - <a href="https://landscape.cncf.io/%EF%BC%8C%E6%9B%B4%E6%96%B0%E8%BF%AD%E4%BB%A3%E9%9D%9E%E5%B8%B8%E9%A2%91%E7%B9%81%E3%80%82%E5%85%B6%E4%B8%AD%EF%BC%8C%E6%9C%80%E6%A0%B8%E5%BF%83%E7%9A%84%E4%B8%BA%E4%B8%8B%E9%9D%A2%E4%BA%94%E5%9D%97%EF%BC%9A">https://landscape.cncf.io/，更新迭代非常频繁。其中，最核心的为下面五块：</a></p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/landscape.png" alt="landscape"></p><ul><li>App Definition and Development 应用定义与开发<ul><li>Database 数据库</li><li>Streaming &amp; Messaging 流处理和消息通信</li><li>Application Definition &amp; Image Build 应用定义与镜像构建</li><li>Continuous Integration &amp; Delivery 持续集成与交付</li></ul></li><li>Orchestration &amp; Management 编排和管理<ul><li>Scheduling &amp; Orchestration 调度与编排</li><li>Coordination &amp; Service Discovery 协调与服务发现</li><li>Remote Procedure Call 远程过程调用</li><li>Service Proxy 服务代理</li><li>API Gateway API网关</li><li>Service Mesh 服务网格</li></ul></li><li>RunTime 运行时<ul><li>Cloud Native Storage 云原生存储</li><li>Container Runtime 容器运行时</li><li>Cloud Native Network 云原生网络</li></ul></li><li>Provisioning 提供者<ul><li>Automation &amp; Configuration 自动化与配置</li><li>Container Registry 容器注册</li><li>Security &amp; Compliance 安全与合规</li><li>Key Management 密钥管理</li></ul></li><li>Observability and Analysis 可观察性和分析<ul><li>Monitoring 监控</li><li>Logging 日志</li><li>Tracing 跟踪</li><li>Chaos Engineering 混沌工程</li></ul></li></ul><p>其余还包括Kubernetes的平台提供商、Serverless、成员、认证的服务提供商等周边内容，并不在我们讨论的范围之内。但从基金会来看，它提供了一整套生态，非常有助于落地。</p><p>那么，如何认识这五块呢？其实Landscape提供了很好的图形效果，我们只要记住两点：</p><ol><li><strong>应用定义与开发</strong>、<strong>编排和管理</strong>、<strong>运行时</strong>、<strong>提供者</strong> 这四块是自上而下的核心链路，下层为上层提供能力支撑</li><li><strong>Observability and Analysis</strong> 是核心链路旁边的重要支撑</li></ol><p>相信到这里，你对CNCF已经有了初步认识。</p><h2 id="2022-01-06-《我做系统架构的一些原则》From-陈皓"><a href="#2022-01-06-《我做系统架构的一些原则》From-陈皓" class="headerlink" title="2022-01-06 《我做系统架构的一些原则》From 陈皓"></a>2022-01-06 《我做系统架构的一些原则》From 陈皓</h2><p>今天，给大家推荐一篇来自左耳朵耗子-陈皓的<a href="https://coolshell.cn/articles/21672.html">文章</a>。</p><ol><li>关注于真正的收益而不是技术本身</li><li>以应用服务和 API 为视角，而不是以资源和技术为视角</li><li>选择最主流和成熟的技术</li><li>完备性会比性能更重要</li><li>制定并遵循服从标准、规范和最佳实践</li><li>重视架构扩展性和可运维性</li><li>对控制逻辑进行全面收口</li><li>不要迁就老旧系统的技术债务</li><li>不要依赖自己的经验，要依赖于数据和学习</li><li>千万要小心 X – Y 问题，要追问原始需求</li><li>激进胜于保守，创新与实用并不冲突</li></ol><p>以上11点，理解会因人而异，我重点挑三个争议性比较大的聊聊，其余的内容建议大家阅读原文。</p><h3 id="完备性会比性能更重要"><a href="#完备性会比性能更重要" class="headerlink" title="完备性会比性能更重要"></a>完备性会比性能更重要</h3><p>借用书中的一句话：<strong>使用最科学严谨的技术模型为主，并以不严谨的模型作为补充</strong>，也就是先紧后松。</p><p>有不少开发者在实际工程中的实践往往相反：为了追求快速落地，会希望毕其功于一役，引入所谓的“一站式解决方案”（如例子中NoSQL），但实践下来引入大量的问题，让后人叫苦不迭。</p><p>关于这个问题，我个人有三个思考：</p><ul><li><strong>不断提高自己的基础能力</strong>。很多架构上的局限性，往往是设计者停留于自己的舒适区，不愿意往前一步。</li><li><strong>分清主次、合理分工。</strong> 在设计时，我们要分清楚核心功能和非核心功能，懂得取舍，将功能交由合适的模块或软件。</li><li><strong>功能的实现不是对应到单模块，而是整个系统的涌现。</strong>性能问题的解法不仅仅限于单个软件，而是有一整套生态，可以多去查一些大厂的分享。</li></ul><h3 id="不要迁就老旧系统的技术债务"><a href="#不要迁就老旧系统的技术债务" class="headerlink" title="不要迁就老旧系统的技术债务"></a>不要迁就老旧系统的技术债务</h3><p>为了缩小讨论范围，我对这里 <strong>技术债务</strong> 做一个收口：不仅仅是指有弊端的技术问题，更是需要投入时间精力等成本去维护。有技术债务，不代表就一定要去还，而需要一个契机 - <strong>维护的成本 &gt; 修复的收益</strong>。</p><p>举个例子，某个程序写得很烂，性能很差：</p><ul><li>前期可以通过扩容快速解决，上线后业务收益很高，那就是 成本大于收益，不需要排到最高优先级去修复；</li><li>但随着业务收益稳定下来，增长只有个位数，但发现在机器上投入的成本很高，通过优化预计能缩容50%，可以让总收益提升20%，那这时还技术债务的优先级就很高了。</li></ul><p>还技术债，技术能力只是一个基本，以下两点更为重要：</p><ul><li>评估成本与收益，尽可能地做到有数据支撑，有助于决策者下决心还债；</li><li>用更长远、更广维度地看待技术债务问题，不要拆东墙补西墙。</li></ul><h3 id="激进胜于保守，创新与实用并不冲突"><a href="#激进胜于保守，创新与实用并不冲突" class="headerlink" title="激进胜于保守，创新与实用并不冲突"></a>激进胜于保守，创新与实用并不冲突</h3><p>这个观点是很aggressive的，遇到这样的观念冲突时，决策者找不到客观标准去评估，就很难有二义性的定义：要么激进，要么保守；要么创新，要么实用。这种情况下，我遇到过的比较好的解法有两种：</p><ol><li>决策者自身技术能力强，能掌控团队技术的大致走向。</li><li>决策者和执行者之间培养出足够的信任，适当评审与把控，放权实践。</li></ol><p>第一种情况在实际工作场景中并不多见，尤其当团队规模很大时，就像CTO往往不是公司技术最强的那位。所以，我更倾向于大家多尝试第二种途径。</p><p>当然，我也遇到过很多效果不好的解法，比如说：决策者既然不清楚怎么做才好，那就找2个执行者进行battle，一个代表创新方，另一个代表保守方。也许在少数情况下，最后能帮助决策者找到正确的方向；但更多的实际场景中，会产生如下问题：</p><ul><li>两个执行者碰撞越来越激烈，但始终谁也说服不了谁</li><li>决策者越听越迷茫，不知道该如何抉择</li></ul><p>在我看来，这类决策者往往是偏管理，技术上的掌控力不足，导致在决策时没有足够的倾向性；同时，与执行者之间的信任也不足，就希望把决策这件事下移、尝试着走平衡之道。</p><p>我个人的想法是：先选择一个能力相对优秀的执行者，认真评估其方案，然后交由对方执行；最后哪怕失败了，也可以通过复盘改进，想想下次如何更好地决策，更好地把控方案；当然，如果你认为纯粹是执行者的问题，那就换个可信赖的人。</p><h2 id="2022-01-07-CNCF-Kubernetes"><a href="#2022-01-07-CNCF-Kubernetes" class="headerlink" title="2022-01-07 CNCF-Kubernetes"></a>2022-01-07 CNCF-Kubernetes</h2><p>今天，我们一起来看看CNCF中的最核心项目 - <code>Kubernetes</code>。<code>Kubernetes</code>相关内容非常庞大，我们依旧关注聚焦于核心能力。</p><p><code>Kubernetes</code> 位于CNCF核心的 <strong>调度与编排</strong> 模块，也就是整个解决方案的基石。在CNCF上的介绍为：</p><blockquote><p>Kubernetes is an open-source system for automating deployment, scaling, and management of containerized applications.</p></blockquote><p>对这个定义，我们关注两个点：</p><ul><li><code>automating deployment, scaling, and management</code> 自动化的部署、扩缩容和管理，这是k8s核心能力；</li><li><code>containerized applications</code> 容器化应用，这是k8s操作的基本对象；</li></ul><p>为了更好地介绍Kubernetes，我对<a href="https://kubernetes.io/">官方首页</a>描述中的关键特性再做一些更详细地说明：</p><h3 id="Automated-rollouts-and-rollbacks"><a href="#Automated-rollouts-and-rollbacks" class="headerlink" title="Automated rollouts and rollbacks"></a>Automated rollouts and rollbacks</h3><p>自动化扩缩容和升级回滚。这个特性是k8s最核心的，也是大规模推广的根本原因。</p><p>看起来，这功能描述与<code>CICD</code>流程差不多，但使用体验差距很大。在传统的模式下，我们执行的是一个<strong>具体的动作</strong>，比如扩1个机器、升级2个程序等；而在k8s里，使用者只要<strong>声明最终的预期状态</strong>，比如5台机器运行v1.0版本的程序，那么整个系统该扩容还是缩容、该升级还是回滚，都由k8s自行根据当前状态进行判断。</p><p>这个，就是云原生的一大特性：<strong>声明式API</strong> ，而不是传统上的<strong>命令式API</strong>。</p><blockquote><p>声明式API不一定比命令式API好。在应用程序开发时，命令式API更容易理解。</p></blockquote><h3 id="Service-discovery-and-load-balancing"><a href="#Service-discovery-and-load-balancing" class="headerlink" title="Service discovery and load balancing"></a>Service discovery and load balancing</h3><p>服务发现与负载均衡。这个功能很大程度上减少了分布式软件运行模式的复杂性。</p><p>服务发现，以前非常依赖<code>zookeeper</code>/<code>etcd</code>等这类注册中心，往往需要侵入到业务代码；而负载均衡，则很依赖<code>nginx</code>这类软件，并在上面做复杂配置。</p><p>当然，k8s给出的只是通用解法，对一些具备很强业务属性的服务发现与负载均衡，仍需要程序自行实现。</p><h3 id="Storage-orchestration"><a href="#Storage-orchestration" class="headerlink" title="Storage orchestration"></a>Storage orchestration</h3><p>存储编排。存储的编排是k8s重点演进的功能。</p><p>k8s抽象了存储概念，从传统的本地存储扩展为分布式云存储，对上层应用屏蔽了存储这块的复杂度。</p><h3 id="Designed-for-extensibility"><a href="#Designed-for-extensibility" class="headerlink" title="Designed for extensibility"></a>Designed for extensibility</h3><p>为扩展性而设计。</p><p>扩展性是k8s非常重视的点，无论是开放出容器、网络、存储等接口规范，还是像自定义资源(CRD)等插件的开放，都体现出了一种开放的精神，也是k8s如今能作为云原生标志性的软件的立足之本。</p><p>有一个点希望大家认识到：k8s的成功不是简单地因为开放性，更重要的是，它定义的这些开放性的规范与接口，都是<code>Google</code>经过实践总结出来的经验，符合主流厂商的趋势与开发者的需求。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg&quot; alt=&quot;2022-01&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2022-01-04-G
      
    
    </summary>
    
      <category term="每日技术分享" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Daily-Sharing" scheme="http://example.com/tags/Daily-Sharing/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 12.【Go实体框架】Facebook开源ent概览</title>
    <link href="http://example.com/2021/12/31/go-tip/go-tip-12/"/>
    <id>http://example.com/2021/12/31/go-tip/go-tip-12/</id>
    <published>2021-12-31T04:00:00.000Z</published>
    <updated>2021-12-31T15:11:30.691Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="Ent概览"><a href="#Ent概览" class="headerlink" title="Ent概览"></a>Ent概览</h2><p><strong>Simple, yet powerful ORM for modeling and querying data.</strong></p><p><code>Ent</code>作为一款由<code>Facebook</code>开源的库，官方定义为<code>An entity framework for Go</code>。从整个微服务框架来看，它更准确的定位应是 <strong>数据模型层的工具库</strong>。了解<code>Ent</code>这款企业级工具的大致实现，不仅有助于我们在技术选型时拓宽视野，也能帮助我们能更好地认识数据模型层。</p><span id="more"></span><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="Schema-As-Code"><a href="#Schema-As-Code" class="headerlink" title="Schema As Code"></a>Schema As Code</h3><blockquote><p>Simple API for modeling any database schema as Go objects. </p></blockquote><p>从定义来看这个特性非常棒 - <code>Ent</code> 可以将各种异构数据库映射到Go语言的结构体。</p><p>但在实际的开发中，如果你对各类数据库有深入的理解，就会清楚地知道这个特性在对数据库特性有一定要求时，框架层面就很难满足了。</p><h3 id="Easily-Traverse-Any-Graph"><a href="#Easily-Traverse-Any-Graph" class="headerlink" title="Easily Traverse Any Graph"></a>Easily Traverse Any Graph</h3><blockquote><p>Run queries, aggregations and traverse any graph structure easily.</p></blockquote><p>强调对图结构的 <strong>查询、聚合和遍历</strong>。这里的图数据库和传统的关系型数据库差别不小，有兴趣的朋友可搜索<strong>图数据库</strong>的相关概念。</p><h3 id="Statically-Typed-And-Explicit-API"><a href="#Statically-Typed-And-Explicit-API" class="headerlink" title="Statically Typed And Explicit API"></a>Statically Typed And Explicit API</h3><blockquote><p>100% statically typed and explicit API using code generation.</p></blockquote><p>利用代码生成的能力，保证静态类型和显示声明的API。</p><h3 id="特性总结"><a href="#特性总结" class="headerlink" title="特性总结"></a>特性总结</h3><p>三大特性，分别从 <strong>支持的数据库能力集</strong>、<strong>针对图形数据处理能力</strong> 和 <strong>代码生成的输出形式</strong>，描述了<code>Ent</code>框架的优点。</p><p>这里，我会更聚焦于第二点中的关键词：<strong>图形数据</strong>。让我们带着对三个特性的初印象，开始了解相关官方示例。</p><h2 id="Ent实践"><a href="#Ent实践" class="headerlink" title="Ent实践"></a>Ent实践</h2><blockquote><p>Ent工具的使用方式并不是本篇的重点，具体的操作方法我会放在链接里，文中只给出关键性的内容</p></blockquote><h3 id="1-创建实体"><a href="#1-创建实体" class="headerlink" title="1.创建实体"></a>1.创建实体</h3><p>链接 - <a href="https://entgo.io/docs/getting-started/#create-your-first-entity">https://entgo.io/docs/getting-started/#create-your-first-entity</a> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u, err := client.User.</span><br><span class="line">        Create().</span><br><span class="line">        SetAge(<span class="number">30</span>).</span><br><span class="line">        SetName(<span class="string">&quot;a8m&quot;</span>).</span><br><span class="line">        Save(ctx)</span><br></pre></td></tr></table></figure><p>代码和<code>GORM</code>非常类似，但不支持复杂结构体的传入，面对大量参数时比较麻烦。</p><h3 id="2-查询实体"><a href="#2-查询实体" class="headerlink" title="2.查询实体"></a>2.查询实体</h3><p>链接 - <a href="https://entgo.io/docs/getting-started/#query-your-entities">https://entgo.io/docs/getting-started/#query-your-entities</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u, err := client.User.</span><br><span class="line">        Query().</span><br><span class="line">        Where(user.Name(<span class="string">&quot;a8m&quot;</span>)).</span><br><span class="line">        <span class="comment">// `Only` fails if no user found,</span></span><br><span class="line">        <span class="comment">// or more than 1 user returned.</span></span><br><span class="line">        Only(ctx)</span><br></pre></td></tr></table></figure><p>基本同上，表达方式还是很明确的。但对于<code>Only</code>这种新引入的关键词，对新人来说有学习成本。</p><h3 id="3-Edge相关"><a href="#3-Edge相关" class="headerlink" title="3.Edge相关"></a>3.Edge相关</h3><ul><li><a href="https://entgo.io/docs/getting-started/#add-your-first-edge-relation">https://entgo.io/docs/getting-started/#add-your-first-edge-relation</a></li><li><a href="https://entgo.io/docs/getting-started/#add-your-first-inverse-edge-backref">https://entgo.io/docs/getting-started/#add-your-first-inverse-edge-backref</a></li><li><a href="https://entgo.io/docs/getting-started/#create-your-second-edge">https://entgo.io/docs/getting-started/#create-your-second-edge</a></li></ul><p>我们以一个复杂Edge为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cars, err := client.Group.</span><br><span class="line">        Query().</span><br><span class="line">        Where(group.Name(<span class="string">&quot;GitHub&quot;</span>)). <span class="comment">// (Group(Name=GitHub),)</span></span><br><span class="line">        QueryUsers().                <span class="comment">// (User(Name=Ariel, Age=30),)</span></span><br><span class="line">        QueryCars().                 <span class="comment">// (Car(Model=Tesla, RegisteredAt=&lt;Time&gt;), Car(Model=Mazda, RegisteredAt=&lt;Time&gt;),)</span></span><br><span class="line">        All(ctx)</span><br></pre></td></tr></table></figure><p>从表达式上来看，就是查询Group、然后关联查询User、最后再查到Car。</p><p>首先，我们要认识到 - <strong>抛开背后的实现，这种表达方式很简洁</strong>。</p><p>如果底层是<code>MySQL</code>，这里至少关联了三张实体表（JOIN），很容易引起性能问题。这个问题也就是上面所说的，<strong>框架屏蔽了异构数据库</strong>而导致的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Github - <a href="https://github.com/ent/ent">https://github.com/ent/ent</a></p><p>官网 - <a href="https://entgo.io/">https://entgo.io/</a></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>通过相关资料和简单实操，我对于<code>Ent</code>框架的定位是 - <strong>一个面向图数据库的ORM框架</strong>。相信随着图数据库的逐渐成熟，<code>Ent</code>会更具价值。但考虑到以下两点：</p><ol><li>图数据库的成熟周期还需要一段时间，当前的维护成本高；</li><li>在非图数据库上使用<code>Ent</code>，对开发者的要求很高，既要了解<code>Ent</code>对不同数据库的底层实现，又要懂数据库原理。</li></ol><blockquote><p>举个例子，ent的部分Edge特性需要依赖数据库的外键，但如今主流数据库的实践，倡导去外键，而是将相关逻辑转移到程序代码里。</p></blockquote><p>所以，我不建议将<code>Ent</code>引入到项目中。关于<code>Ent</code>更多的细节需要大家自行阅读和实践。</p><p>这里，我抛出一个自己的理解：<strong>从编程语言框架层面，不应过度基础设施的复杂度。从异构数据库来说，它们的特性、维护方式、设计模式都各不相同，应寻找每种数据库对应的工具库，而不应期望毕其功于一役。</strong></p><p>换一句话，如果期望一个工具库能适配十种数据库，那么换一种角度，这十种数据库更应该被封装成一种数据库。<strong>通用性如果能沉淀在基础设施上，价值远大于在工具库上做适配。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Ent</code>能在Facebook等公司与Kratos框架上沉淀，证明了它具备实际工程落地的能力，但对使用者的要求很高，很难具备普适性。</p><p>前文为了表达个人想法，我在论述观点时会相对态度鲜明，但并非对<code>Ent</code>持有否定态度。相反地，从具体的实现细节来看，<code>Ent</code>给了我不少启发，尤其是强调静态类型，能看出它对性能的追求。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Ent概览&quot;&gt;&lt;a href=&quot;#Ent概览&quot; class=&quot;headerlink&quot; title=&quot;Ent概览&quot;&gt;&lt;/a&gt;Ent概览&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Simple, yet powerful ORM for modeling and querying data.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ent&lt;/code&gt;作为一款由&lt;code&gt;Facebook&lt;/code&gt;开源的库，官方定义为&lt;code&gt;An entity framework for Go&lt;/code&gt;。从整个微服务框架来看，它更准确的定位应是 &lt;strong&gt;数据模型层的工具库&lt;/strong&gt;。了解&lt;code&gt;Ent&lt;/code&gt;这款企业级工具的大致实现，不仅有助于我们在技术选型时拓宽视野，也能帮助我们能更好地认识数据模型层。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 11.【初始化代码生成】Wire进阶使用</title>
    <link href="http://example.com/2021/12/28/go-tip/go-tip-11/"/>
    <id>http://example.com/2021/12/28/go-tip/go-tip-11/</id>
    <published>2021-12-28T04:00:00.000Z</published>
    <updated>2021-12-30T05:45:34.823Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="Wire进阶"><a href="#Wire进阶" class="headerlink" title="Wire进阶"></a>Wire进阶</h2><p>通过上一篇的讲解，我们已经掌握<code>wire</code>工具的基本用法了。但应用在实际工程中，这些基本功能还是有很多局限性。</p><p>在这一篇，我们一起看看Google推出的<code>wire</code>的进阶使用方法，并总结出一套实践思路。</p><span id="more"></span><h2 id="进阶示例"><a href="#进阶示例" class="headerlink" title="进阶示例"></a>进阶示例</h2><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p><code>Set</code>特性比较直观：组合几个<code>Provider</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> BasicSet = wire.NewSet(NewGreeter, NewMessage)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">wire.Build(BasicSet)</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般应用在初始化对象比较多的情况下，减少<code>Injector</code>里的信息。</p><h3 id="绑定接口"><a href="#绑定接口" class="headerlink" title="绑定接口"></a>绑定接口</h3><p>接口这个特性在面向对象编程时非常有意义，我们来看一个具体的示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象出一个 Messager 的接口</span></span><br><span class="line"><span class="keyword">type</span> Messager <span class="keyword">interface</span> &#123;</span><br><span class="line">Name() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Message 是Messager的一个具体实现</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Message)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;message&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMessage</span><span class="params">()</span> *<span class="title">Message</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Message&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Greeter的初始化依赖的是Messager接口，而不是Message这个实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeter</span><span class="params">(m Messager)</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;Message: m&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Greeter <span class="keyword">struct</span> &#123;</span><br><span class="line">Message Messager</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Greeter)</span> <span class="title">Greet</span><span class="params">()</span> <span class="title">Messager</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> g.Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，我们要做的就是在<code>NewGreeter(m Messager)</code>初始化时，用<code>Message</code>这个具体实现来代替<code>Messager</code>接口。这里，我们就在<code>wire.go</code>里引入了 <strong>绑定</strong> 这个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wire.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> BasicSet = wire.NewSet(</span><br><span class="line">NewGreeter,</span><br><span class="line">wire.Bind(<span class="built_in">new</span>(Messager), <span class="built_in">new</span>(*Message)),</span><br><span class="line">NewMessage,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">wire.Build(BasicSet)</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire_gen.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">message := NewMessage()</span><br><span class="line">greeter := NewGreeter(message)</span><br><span class="line"><span class="keyword">return</span> greeter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造结构体"><a href="#构造结构体" class="headerlink" title="构造结构体"></a>构造结构体</h3><p>上面的例子里，我们都定义了具体的构造函数，也就是Provider。但实际开发过程中，我们经常会遇到只有一个具体的结构体，而没有定义具体的函数。这时我们可以采用 <strong>构造结构体的特性</strong>。例如，我们定义一个<code>MyGreeter</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyGreeter <span class="keyword">struct</span> &#123;</span><br><span class="line">Msg Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeMyGreeter</span><span class="params">()</span> *<span class="title">MyGreeter</span></span> &#123;</span><br><span class="line">wire.Build(</span><br><span class="line">NewMessage,</span><br><span class="line">wire.Struct(<span class="built_in">new</span>(MyGreeter), <span class="string">&quot;Msg&quot;</span>),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> &amp;MyGreeter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire_gen.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeMyGreeter</span><span class="params">()</span> *<span class="title">MyGreeter</span></span> &#123;</span><br><span class="line">message := NewMessage()</span><br><span class="line">myGreeter := &amp;MyGreeter&#123;</span><br><span class="line">Msg: message,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> myGreeter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定值"><a href="#绑定值" class="headerlink" title="绑定值"></a>绑定值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyGreeter <span class="keyword">struct</span> &#123;</span><br><span class="line">X   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeMyGreeter</span><span class="params">()</span> *<span class="title">MyGreeter</span></span> &#123;</span><br><span class="line">wire.Build(</span><br><span class="line">wire.Value(&amp;MyGreeter&#123;X: <span class="number">42</span>&#125;),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> &amp;MyGreeter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire_gen.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeMyGreeter</span><span class="params">()</span> *<span class="title">MyGreeter</span></span> &#123;</span><br><span class="line">myGreeter := _wireMyGreeterValue</span><br><span class="line"><span class="keyword">return</span> myGreeter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">_wireMyGreeterValue = &amp;MyGreeter&#123;X: <span class="number">42</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="获取结构体中的字段"><a href="#获取结构体中的字段" class="headerlink" title="获取结构体中的字段"></a>获取结构体中的字段</h3><p>这块比较简单，就是从一个结构体里提取一个Public的field，作为一个<code>Provider</code>，这里给出一个简单的示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    S <span class="keyword">string</span></span><br><span class="line">    N <span class="keyword">int</span></span><br><span class="line">    F <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire_gen.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">injectedMessage</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    wire.Build(</span><br><span class="line">        provideFoo,</span><br><span class="line">        wire.FieldsOf(<span class="built_in">new</span>(Foo), <span class="string">&quot;S&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清理函数"><a href="#清理函数" class="headerlink" title="清理函数"></a>清理函数</h3><p>清理函数利用了函数变量的特性，将资源释放函数抛出来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">provideFile</span><span class="params">(log Logger, path Path)</span> <span class="params">(*os.File, <span class="keyword">func</span>()</span>, <span class="title">error</span>)</span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="keyword">string</span>(path))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    cleanup := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Log(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f, cleanup, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="1-区别类型"><a href="#1-区别类型" class="headerlink" title="1.区别类型"></a>1.区别类型</h3><p>采用类型别名，和标准类型区分开来，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MySQLConnectionString <span class="keyword">string</span></span><br></pre></td></tr></table></figure><h3 id="2-可选结构体"><a href="#2-可选结构体" class="headerlink" title="2. 可选结构体"></a>2. 可选结构体</h3><p>当一个<code>Injector</code>需要多个<code>Provider</code>时，将这些<code>Provider</code>集中到一个<code>Option</code>的结构体，即组合多个参数，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Messages is the set of recommended greetings.</span></span><br><span class="line">    Messages []Message</span><br><span class="line">    <span class="comment">// Writer is the location to send greetings. nil goes to stdout.</span></span><br><span class="line">    Writer io.Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-合理使用Provider-Sets"><a href="#3-合理使用Provider-Sets" class="headerlink" title="3.合理使用Provider Sets"></a>3.合理使用Provider Sets</h3><p>Set集合了多个Provider效率很高，具体实践过程中要根据实际情况出发，参考 <a href="https://github.com/google/wire/blob/main/docs/best-practices.md#provider-sets-in-libraries%E3%80%82">https://github.com/google/wire/blob/main/docs/best-practices.md#provider-sets-in-libraries。</a></p><p>总体来说把握一个原则：<code>In general, prefer small provider sets in a library. </code> 即Set尽量小，多多考虑复合。</p><h3 id="4-Mocking"><a href="#4-Mocking" class="headerlink" title="4.Mocking"></a>4.Mocking</h3><p>Mock这块主要是用于测试，官方给出了两个途径：</p><ul><li>Pass mocks to the injector</li><li>Return the mocks from the injector</li></ul><p>初看可能不容易理解，我们结合实际代码就能了解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 途径1 - 即依赖项以参数注入，这样返回的app和正常的app完全一致</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMockedAppFromArgs</span><span class="params">(mt timer)</span> *<span class="title">app</span></span> &#123;</span><br><span class="line">wire.Build(appSetWithoutMocks)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 途径2 - 内部增加mock的具体field，会与app中的对应变量绑定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMockedApp</span><span class="params">()</span> *<span class="title">appWithMocks</span></span> &#123;</span><br><span class="line">wire.Build(mockAppSet)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> appWithMocks <span class="keyword">struct</span> &#123;</span><br><span class="line">app app</span><br><span class="line">mt  *mockTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体来说，我个人比较推荐使用方案1，它能保证mock对象的使用方式和真实对象完全一致，能屏蔽很多复杂度。在一个复杂系统中，底层的mock对象可以很容易应用到高层。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Github - <a href="https://github.com/google/wire">https://github.com/google/wire</a></p><p>Blog - <a href="https://go.dev/blog/wire">https://go.dev/blog/wire</a> </p><p>Package Doc - <a href="https://pkg.go.dev/github.com/google/wire">https://pkg.go.dev/github.com/google/wire</a></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>通过这一篇，我们能看到<code>wire</code>很多进阶的能力，其实还有一部分特性并未在文档中说明，可以参考package doc学习。</p><p>我更建议大家可以从单元测试的角度切入，去理解这个工具的实践：</p><ol><li><strong>自底向上地考虑wire的实践</strong>：尤其是db、redis这些基础工具，底层的mock会为上层的mock带来巨大便利；</li><li><strong>不断抽离和组合对象中的依赖</strong>：依赖小到某个关键变量、大到某个外部服务，也同时注意组合相似度高的依赖项到<code>Set</code>；</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>wire</code>的核心是依赖注入，对整个框架的可测试性来说是根基，对<code>Go</code>语言这类静态编译的语言尤为重要。</p><p><code>Java</code>语言有一整套强大的<code>JVM</code>引擎，可以在运行时做各种复杂操作；而静态语言在编写时就决定了程序的基本运行方式，从简单性来说很棒 - <strong>所见即所得</strong>，但也说明了不应有复杂的运行时。这时，一个良好的依赖注入机制对<code>Go</code>语言尤为重要。</p><p>那么，<code>Wire</code>引入的DI思想对<code>Go</code>语言来说可以称得上是<code>银弹</code>，但我们更应该重视基础库的<code>Mock</code>能力，毕竟没有底层能力、就没有高层建设。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Wire进阶&quot;&gt;&lt;a href=&quot;#Wire进阶&quot; class=&quot;headerlink&quot; title=&quot;Wire进阶&quot;&gt;&lt;/a&gt;Wire进阶&lt;/h2&gt;&lt;p&gt;通过上一篇的讲解，我们已经掌握&lt;code&gt;wire&lt;/code&gt;工具的基本用法了。但应用在实际工程中，这些基本功能还是有很多局限性。&lt;/p&gt;
&lt;p&gt;在这一篇，我们一起看看Google推出的&lt;code&gt;wire&lt;/code&gt;的进阶使用方法，并总结出一套实践思路。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 10.【初始化代码生成】Wire工具基础讲解</title>
    <link href="http://example.com/2021/12/25/go-tip/go-tip-10/"/>
    <id>http://example.com/2021/12/25/go-tip/go-tip-10/</id>
    <published>2021-12-25T04:00:00.000Z</published>
    <updated>2021-12-28T11:53:19.286Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="Wire概览"><a href="#Wire概览" class="headerlink" title="Wire概览"></a>Wire概览</h2><p>在讲解Kratos的过程中，我们引入了google推出的wire这个工具。我们先阅读一下官方的定义：</p><p><strong>Wire is a code generation tool that automates connecting components using dependency injection.</strong></p><p>从关键词入手：</p><ul><li><strong>code generation 代码生成</strong>，一方面说明了有学习成本，需要了解这个工具的原理；另一方面，也说明了它的目标是消除重复性的coding</li><li><strong>automates connecting components 自动连接组件</strong>，明确了wire工具的目标是将多个对象组合起来</li><li><strong>dependency injection 依赖注入</strong>，指明了wire实现自动连接组件的思想。依赖注入是一个很强大的功能，我会在下面结合具体的case聊一聊</li></ul><p>我们从具体的case着手，学习wire这个工具。</p><span id="more"></span><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><h3 id="常规实现"><a href="#常规实现" class="headerlink" title="常规实现"></a>常规实现</h3><p>我简化了官方的示例，给出一个注释后的代码，方便大家阅读：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// Part-1 Message对象</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMessage</span><span class="params">()</span> <span class="title">Message</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Message(<span class="string">&quot;Hi there!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Part-2 Greeter对象,依赖Message</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeter</span><span class="params">(m Message)</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;Message: m&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Greeter <span class="keyword">struct</span> &#123;</span><br><span class="line">Message Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Greeter)</span> <span class="title">Greet</span><span class="params">()</span> <span class="title">Message</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> g.Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">message := NewMessage()</span><br><span class="line">greeter := NewGreeter(message)</span><br><span class="line"></span><br><span class="line">greeter.Greet()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的调用很直观，分为3步：</p><ol><li>用<code>NewMessage</code>创建<code>Message</code>对象</li><li>通过<code>NewGreeter</code>方法，将<code>Message</code>对象注入到<code>Greeter</code>对象里</li><li>调用<code>Greeter</code>的方法，其实内部用到了前面注入的<code>Message</code>对象</li></ol><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入的详细定义可以参考链接 - <a href="https://en.wikipedia.org/wiki/Dependency_injection%EF%BC%8C%E6%88%91%E5%B0%B1%E4%B8%8D%E8%B5%98%E8%BF%B0%E4%BA%86%E3%80%82%E8%BF%99%E9%87%8C%E6%88%91%E7%94%A8%E5%85%B7%E4%BD%93%E7%9A%84case%E8%BF%9B%E8%A1%8C%E5%AF%B9%E6%AF%94%EF%BC%8C%E6%96%B9%E4%BE%BF%E5%A4%A7%E5%AE%B6%E7%90%86%E8%A7%A3%EF%BC%9A">https://en.wikipedia.org/wiki/Dependency_injection，我就不赘述了。这里我用具体的case进行对比，方便大家理解：</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Greeter <span class="keyword">struct</span> &#123;</span><br><span class="line">Message Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeter</span><span class="params">(m Message)</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;Message: m&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Greeter)</span> <span class="title">Greet</span><span class="params">()</span> <span class="title">Message</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> g.Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Greeter)</span> <span class="title">Greet</span><span class="params">()</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">g.Message = NewMessage()</span><br><span class="line"><span class="keyword">return</span> g.Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完例子，可能大家对DI已经有个初步的概念了，我这边再重复一下关键点：</p><ol><li><code>Greeter</code>的方法<code>Greet()</code>会依赖内部的<code>Message</code>对象，所以我们说 - <strong>Greeter的实现依赖Message</strong></li><li><code>Message</code>的初始化分为两种：创建Greeter对象前和调用Greet方法时，前者被称为<strong>依赖注入</strong>，相当于<strong>在初始化时把依赖项注入进去，而不是使用时再创建</strong>。</li><li>DI，最直接的好处就是可以很方便地调整这个注入项，比如Greet升级成GreetV2，或者单测的MockGreet。</li></ol><h3 id="使用wire生成代码"><a href="#使用wire生成代码" class="headerlink" title="使用wire生成代码"></a>使用wire生成代码</h3><p>我们先安装wire工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/google/wire/cmd/wire</span><br></pre></td></tr></table></figure><p>再编写一个<code>wire.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//+build wireinject</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/google/wire&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">wire.Build(NewGreeter, NewMessage)</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行命令<code>wire gen</code>生成wire_gen.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code generated by Wire. DO NOT EDIT.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate go run github.com/google/wire/cmd/wire</span></span><br><span class="line"><span class="comment">//+build !wireinject</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// Injectors from wire.go:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">message := NewMessage()</span><br><span class="line">greeter := NewGreeter(message)</span><br><span class="line"><span class="keyword">return</span> greeter</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，可以在<code>main</code>函数里使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">greeter := InitializeGreeter()</span><br><span class="line"></span><br><span class="line">greeter.Greet()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wire的大致实现"><a href="#wire的大致实现" class="headerlink" title="wire的大致实现"></a>wire的大致实现</h3><p>可以看到，wire这个工具基本能力就体现在<code>wire.Build(NewGreeter, NewMessage)</code>里，把这里面的两个初始化函数串联了起来，形成了一个整体的InitializeGreeter。</p><h2 id="基本扩展"><a href="#基本扩展" class="headerlink" title="基本扩展"></a>基本扩展</h2><h3 id="带error的处理"><a href="#带error的处理" class="headerlink" title="带error的处理"></a>带error的处理</h3><p>我们新增一个方法，初始化结果里增加一个error返回值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Part-3 Greeter对象,依赖Message,并且返回error方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeterV2</span><span class="params">(m Message)</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> m == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;, errors.New(<span class="string">&quot;empty message&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;Message: m&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>wire.go</code>里调整函数返回值增加一个error</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line">wire.Build(NewGreeterV2, NewMessage)</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在<code>wire_gen.go</code>里生成了带error的新方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeterV2</span><span class="params">()</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line">message := NewMessage()</span><br><span class="line">greeter, err := NewGreeterV2(message)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> greeter, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增加一个入参"><a href="#增加一个入参" class="headerlink" title="增加一个入参"></a>增加一个入参</h3><p>我们新增一个方法，增加一个name的入参</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Part-3 Greeter对象,依赖Message和参数name,并且返回error方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeterV3</span><span class="params">(m Message, name <span class="keyword">string</span>)</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;, errors.New(<span class="string">&quot;empty name&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;Message: m&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wire.go</code>里也增加一个<code>string</code>类型的入参（变量名可以任意）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeterV3</span><span class="params">(greetName <span class="keyword">string</span>)</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line">wire.Build(NewGreeterV3, NewMessage)</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后生成对应的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeterV3</span><span class="params">(greetName <span class="keyword">string</span>)</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line">message := NewMessage()</span><br><span class="line">greeter, err := NewGreeterV3(message, greetName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> greeter, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Provider和Injector"><a href="#Provider和Injector" class="headerlink" title="Provider和Injector"></a>Provider和Injector</h2><p>Wire里面提了两个关键性的概念，为了方便大家阅读文档时能快速理解，我这里再专门说明下：</p><ul><li><strong>Provider</strong> - 即各个初始化函数，如<code>NewXXX</code></li><li><strong>Injector</strong> - 即Initial的函数，将各个Provider注入到wire中，生成一个新的初始化函数</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Github - <a href="https://github.com/google/wire">https://github.com/google/wire</a></p><p>DI - <a href="https://en.wikipedia.org/wiki/Dependency_injection">https://en.wikipedia.org/wiki/Dependency_injection</a></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><code>wire</code>工具的实现逻辑很清晰 - <strong>按一定规则组装多个Provider到Injector中</strong>。</p><p>生成的代码 <strong>结构简单而具有规律</strong>，所以用代码生成技术很有价值，既减少了重复性工作，又能引入DI的思想方便程序的扩展。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，我们对wire的基础用法已经了然于胸，但更多的价值需要深入理解DI这个概念，最好能结合到具体的工程实践上。如果你对这块还没有太深刻的理解，建议结合网上的相关资料了解DI在工程中的价值，会让你使用wire这个工具时更有感触。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Wire概览&quot;&gt;&lt;a href=&quot;#Wire概览&quot; class=&quot;headerlink&quot; title=&quot;Wire概览&quot;&gt;&lt;/a&gt;Wire概览&lt;/h2&gt;&lt;p&gt;在讲解Kratos的过程中，我们引入了google推出的wire这个工具。我们先阅读一下官方的定义：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Wire is a code generation tool that automates connecting components using dependency injection.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从关键词入手：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;code generation 代码生成&lt;/strong&gt;，一方面说明了有学习成本，需要了解这个工具的原理；另一方面，也说明了它的目标是消除重复性的coding&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;automates connecting components 自动连接组件&lt;/strong&gt;，明确了wire工具的目标是将多个对象组合起来&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dependency injection 依赖注入&lt;/strong&gt;，指明了wire实现自动连接组件的思想。依赖注入是一个很强大的功能，我会在下面结合具体的case聊一聊&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们从具体的case着手，学习wire这个工具。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 8.【浅析微服务框架】Go-Micro概览</title>
    <link href="http://example.com/2021/12/20/go-tip/go-tip-8/"/>
    <id>http://example.com/2021/12/20/go-tip/go-tip-8/</id>
    <published>2021-12-20T04:00:00.000Z</published>
    <updated>2021-12-20T11:27:55.226Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="Go-Micro框架概况"><a href="#Go-Micro框架概况" class="headerlink" title="Go Micro框架概况"></a>Go Micro框架概况</h2><p>截止到本文发布时，Go-Micro在github上的star数达到了10.8k，也已经累计发布了v1、v2、v3这三个大版本，目前前两个已经停止维护。</p><p>本文主要以最新的技术视角去看待这个框架，所以会集中目光在v3版本。本文包含大量个人的主观观点，请大家选择性听取，更欢迎与我讨论。</p><span id="more"></span><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><strong>Micro is a distributed cloud operating system built for real world programming.</strong></p><p>Micro框架的定义里有个关键词：distributed cloud operating system - 分布式云操作系统。这是一个很<strong>重量级</strong>的定义，我们根据它的官方介绍了解，从这10个核心模块入手，理解这个框架的功能。</p><blockquote><p>本人对这个框架研究不深，主要参考官方提供的资料，如果有认知偏差，欢迎大家多多指正~</p></blockquote><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/micro-3.0.png" alt="micro"></p><h2 id="Micro的十大核心模块"><a href="#Micro的十大核心模块" class="headerlink" title="Micro的十大核心模块"></a>Micro的十大核心模块</h2><h3 id="1-Auth-认证授权"><a href="#1-Auth-认证授权" class="headerlink" title="1. Auth 认证授权"></a>1. Auth 认证授权</h3><p>认证授权是一个很基础的模块，但放在一个微服务的框架里，我个人认为不太合适。为什么呢？</p><ol><li><strong>大部分的微服务的Auth模块，往往是网关层的一种能力</strong>。也就是说，一般我们在请求入口处做一次Auth即可，接下来我们就认为消息可靠、无需检查；</li><li><strong>如果Auth模块必须嵌入到每个服务，更应该采用Service Mesh的side-car模式</strong>。借用Istio的能力，尽可能不要侵入应用的代码；</li><li><strong>Auth</strong>会有很多方式，ACL/RBAC/ABAC，往往会和公司内部的系统强结合（如人员管理），抽象为一个组件很难满足通用性和扩展性；</li></ol><p>所以，常规的微服务框架中，会有个专门的Auth服务，管理权限、认证等功能。</p><h3 id="2-Build编译模块"><a href="#2-Build编译模块" class="headerlink" title="2.Build编译模块"></a>2.Build编译模块</h3><p>编译功能放在微服务框架不合适，它更应该与CICD结合起来，交由专门的编译部署平台，实现快速交付。</p><h3 id="3-Broker消息管道"><a href="#3-Broker消息管道" class="headerlink" title="3.Broker消息管道"></a>3.Broker消息管道</h3><p>从官方的介绍来看，Broker基本与MQ的功能一致，即发布和订阅消息。</p><p>作为跨服务异步通信的主流方式，MQ在中大型工程中被广泛使用，Broker概念的抽象可以让使用者不用过于关心底层具体采用的技术。</p><h3 id="4-Config动态配置"><a href="#4-Config动态配置" class="headerlink" title="4.Config动态配置"></a>4.Config动态配置</h3><p>Config定义为动态配置和密码，可类比为配置中心，或者K8s中的ConfigMap与Secret。这个模块的功能更多的是对配置能力的抽象。</p><h3 id="5-Events事件流"><a href="#5-Events事件流" class="headerlink" title="5.Events事件流"></a>5.Events事件流</h3><p>事件流中有三个关键词：<strong>顺序、重放和持久化</strong>。这三个特性与MQ的特性基本一致，可以认为是Broker一个具体的实践。</p><p>这里抽象出一个事件流的概念，主要强调的是 <strong>可靠性</strong>。</p><h3 id="6-Network网络"><a href="#6-Network网络" class="headerlink" title="6.Network网络"></a>6.Network网络</h3><p>网络是计算机中很大的一块，这里特指服务内的网络隔离与路由。我个人认为个定义过于宽泛，很容易引起误解。</p><p>从云原生的划分来看，这块更应该放在Service Mesh部分。</p><h3 id="7-Registry注册"><a href="#7-Registry注册" class="headerlink" title="7.Registry注册"></a>7.Registry注册</h3><p>服务注册这部分包括两块：</p><ol><li>服务提供方把服务信息注册到中心节点</li><li>服务调用方从中心节点获取服务提供方的信息进行调用</li></ol><p>这服务注册与发现的工作，K8s等这类Paas平台已经封装得很完善了；而如果公司没有提供Paas平台，也可以通过etcd等注册中心快速实现。这部分也不建议重复建设。</p><h3 id="8-Runtime运行时"><a href="#8-Runtime运行时" class="headerlink" title="8.Runtime运行时"></a>8.Runtime运行时</h3><p>云时代以容器为核心构建服务，进程的声明周期就可以通过Pod快捷管理。官方对Runtime的描述，更像是CICD+K8s调度服务的综合描述。</p><h3 id="9-Store存储"><a href="#9-Store存储" class="headerlink" title="9.Store存储"></a>9.Store存储</h3><p>官方定义为支持过期+CRUD的K-V存储，用来保证无状态性。</p><p>我们可以很直接与Redis类比，相当于<strong>把有状态的数据放在公共的缓存里</strong>。</p><h3 id="10-Plugins插件化"><a href="#10-Plugins插件化" class="headerlink" title="10.Plugins插件化"></a>10.Plugins插件化</h3><p>插件化的概念很宽，框架并没有明确说明。</p><p>从实现来说，任何一个组件最好都可以支持插件化，如router、存储、消息通知等，可以支持自定义log plugins。</p><h2 id="模块总览"><a href="#模块总览" class="headerlink" title="模块总览"></a>模块总览</h2><p>前面的十大模块有很多与云平台的基础功能重合。为了更具有针对性地讨论，我们先聊清楚前提，这样才能更聚焦于框架上。</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>从当前主流与未来趋势来看，<strong>微服务框架应基于基础云平台能力，不应有过多的交集</strong>。基础平台能力主要包括两块：</p><ul><li><p>整套Devops流程（如代码版本管理、编译、部署、运行）</p></li><li><p>基础的云Paas平台（以k8s为代表）</p></li></ul><blockquote><p>虽然对很多基础建设不完善的团队来说，上面两者的落地会有挑战，但从长远发展来看，不应将由基础平台的维护的功能交由微服务框架。</p><p>而如果追求短期内快速落地项目，我更建议这些团队借主流公有云服务的能力。</p></blockquote><h3 id="三大分类"><a href="#三大分类" class="headerlink" title="三大分类"></a>三大分类</h3><ol><li>不合适引入到微服务框架中：Build、Config、Runtime</li><li>通过Service Mesh实现：Auth、Network、Registry</li><li>微服务框架的关键特性：Broker、Events、Store、Plugins</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>Micro框架提供了二进制工具micro，可以查看server、config、store等信息。虽然看起来使用起来很方便，但其实有诸多限制；比如说，线上环境的服务器，开发者往往没有权限登录。</p><p>从整体来说，Micro是一个限制性很大的框架，主要特点是：</p><ol><li>适合基础平台不完善的团队，框架提供了很多基础平台的功能；</li><li>使用框架的初始成本低，但后续切换成本、排查问题成本极高，高度依赖micro的生态；</li><li>Micro屏蔽了底层实现细节，虽然能在一定程度上提效，但遇到性能、扩展性、底层原理等问题时，很难解决。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整体来说，我不建议以Micro作为新项目切入时的框架。如果用一个词概括原因，我会用 - <strong>不够透明</strong>。一方面，Micro的门槛不低、需要了解它一整套特有的概念；另一方面，后续团队的维护成本也很高，对个人提升也很有限。</p><p>维护成本这个概念也许有的同学不能理解，我以Store为例（假设背后选用Redis作为存储）</p><ul><li>如果采用Micro框架，我们必须阅读相关代码（重点是封装部分），了解它的封装与底层，结合micro+redis工具排查</li><li>如果调用的是Redis的官方库，那只要保证调用方式正确，那就只需要你掌握Redis的原理即可</li></ul><p>前者的排查链路需要框架+redis，后者只需要排查redis。我个人对编程语言框架有一个认知：<strong>不应过度屏蔽通用中间件的细节，如Redis、Kafka、MySQL等，往往直接在中间件查询问题，比通过框架查询问题更为高效</strong>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Github - <a href="https://github.com/micro/micro">https://github.com/micro/micro</a></p><p>文档 - <a href="https://micro.mu/introduction">https://micro.mu/introduction</a></p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Go-Micro框架概况&quot;&gt;&lt;a href=&quot;#Go-Micro框架概况&quot; class=&quot;headerlink&quot; title=&quot;Go Micro框架概况&quot;&gt;&lt;/a&gt;Go Micro框架概况&lt;/h2&gt;&lt;p&gt;截止到本文发布时，Go-Micro在github上的star数达到了10.8k，也已经累计发布了v1、v2、v3这三个大版本，目前前两个已经停止维护。&lt;/p&gt;
&lt;p&gt;本文主要以最新的技术视角去看待这个框架，所以会集中目光在v3版本。本文包含大量个人的主观观点，请大家选择性听取，更欢迎与我讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 9.【浅析微服务框架】Kratos概览</title>
    <link href="http://example.com/2021/12/20/go-tip/go-tip-9/"/>
    <id>http://example.com/2021/12/20/go-tip/go-tip-9/</id>
    <published>2021-12-20T04:00:00.000Z</published>
    <updated>2021-12-27T12:50:20.363Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="Kratos框架概况"><a href="#Kratos框架概况" class="headerlink" title="Kratos框架概况"></a>Kratos框架概况</h2><p>截止到本文发布时，Kratos在github上的star数达到了15.9k。其中，在2021年7月，也正式推出了v2这个大版本。</p><p>本人并不是Kratos的重度使用者，主要会通过官方介绍对它的特性进行剖析。接下来的内容依旧包含大量主观认知，可能会对官方文档有理解上的偏差，欢迎大家与我讨论。</p><span id="more"></span><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><strong>Kratos is a web application framework with expressive, elegant syntax. We’ve already laid the foundation.</strong></p><p>Kratos的官网上的介绍比较朴实，但有两个词值得我们关注 - <strong>富有表现力的</strong>、<strong>优雅的</strong>。一般在微服务框架里，我们看到最多的形容词，往往来自下面两个维度：</p><ul><li>开发者维度：比如简单易用、组件丰富</li><li>工程化维度：比如高效、通用性强</li></ul><p>但Kratos的切入点是框架层面的能力，尤其是<code>elegant</code>这个词，隐含了作者对代码洁癖的追求。接下来，我们具体剖析这个框架。</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/kratos.png" alt="Kratos"></p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p> 参考 <a href="https://go-kratos.dev/docs/intro/layout%EF%BC%8C%E6%88%91%E4%BB%AC%E5%AF%B9%E5%85%B3%E9%94%AE%E7%9B%AE%E5%BD%95%E5%81%9A%E4%B8%80%E4%B8%8B%E5%88%86%E6%9E%90%E3%80%82">https://go-kratos.dev/docs/intro/layout，我们对关键目录做一下分析。</a></p><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── api // 下面维护了微服务使用的proto文件以及根据它们所生成的go文件</span><br><span class="line">│  └── helloworld</span><br><span class="line">│      └── v1</span><br><span class="line">│          ├── error_reason.pb.go</span><br><span class="line">│          ├── error_reason.proto</span><br><span class="line">│          ├── error_reason.swagger.json</span><br><span class="line">│          ├── greeter.pb.go</span><br><span class="line">│          ├── greeter.proto</span><br><span class="line">│          ├── greeter.swagger.json</span><br><span class="line">│          ├── greeter_grpc.pb.go</span><br><span class="line">│          └── greeter_http.pb.go</span><br></pre></td></tr></table></figure><p>从目录结构看到，里面包含了三类文件：</p><ul><li><code>*.proto</code> 原始IDL文件</li><li><code>*.go</code> 利用protoc工具生成的go文件，包括http和grpc的服务相关代码</li><li><code>*.swagger.json</code> 利用工具生成的swagger接口文档</li></ul><p>这部分的实现全是基于开源的<code>protobuf</code>解决方案，对开发者很友好。这里提一个点：<strong>尽可能地用目录区分原始IDL文件与生成的文件</strong>。我简单列举两个优点：</p><ol><li>让开发者更聚焦于原始IDL文件 - 其余文件均是从proto文件自动生成出来的，不应过多关注。</li><li>有利于IDL文件的传播 - proto文件可以快速生成其余语言的代码，独立文件夹更有利于扩散给外部调用者。</li></ol><h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── cmd  // 整个项目启动的入口文件</span><br><span class="line">│  └── server</span><br><span class="line">│      ├── main.go</span><br><span class="line">│      ├── wire.go  // 我们使用wire来维护依赖注入</span><br><span class="line">│      └── wire_gen.go</span><br></pre></td></tr></table></figure><p>cmd简单来说就是main函数入口。</p><h3 id="internal-biz"><a href="#internal-biz" class="headerlink" title="internal/biz"></a>internal/biz</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── internal  // 该服务所有不对外暴露的代码，通常的业务逻辑都在这下面，使用internal避免错误引用</span><br><span class="line">│   ├── biz   // 业务逻辑的组装层，类似 DDD 的 domain 层，data 类似 DDD 的 repo，而 repo 接口在这里定义，使用依赖倒置的原则。</span><br><span class="line">│  │  ├── README.md</span><br><span class="line">│  │  ├── biz.go</span><br><span class="line">│  │  └── greeter.go</span><br></pre></td></tr></table></figure><p>internal目录是go语言的一个特性，内部代码不会暴露给外部。</p><p>biz被理解为业务逻辑的组装层，如果能正确地理解这个概念，就能把握整个框架的分层设计了。我们从两个关键词来理解这个biz目录的设计：</p><ol><li>业务逻辑 - 业务逻辑包括但不限于单个对象的增删改查，会处理很多进阶的内容，例如：<ol><li>复合对象操作，如操作对象A后，再操作对象B</li><li>特殊逻辑，如创建A对象失败时，等待10s后再创建</li><li>并发策略，如并发访问对象A和对象B</li></ol></li><li>组装层 - 重点在于组装底层基础的代码，如CRUD，而不是在biz层直接去操作数据库等</li></ol><p>整体来说，biz这一层应重点考虑<strong>业务逻辑的信息密度</strong>，让业务开发者的重点放在这一层，把基础实现往下沉。</p><h3 id="internal-data"><a href="#internal-data" class="headerlink" title="internal/data"></a>internal/data</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── internal  // 该服务所有不对外暴露的代码，通常的业务逻辑都在这下面，使用internal避免错误引用</span><br><span class="line">│  ├── data  // 业务数据访问，包含 cache、db 等封装，实现了 biz 的 repo 接口。我们可能会把 data 与 dao 混淆在一起，data 偏重业务的含义，它所要做的是将领域对象重新拿出来，我们去掉了 DDD 的 infra层。</span><br><span class="line">│  │  ├── README.md</span><br><span class="line">│  │  ├── data.go</span><br><span class="line">│  │  └── greeter.go</span><br></pre></td></tr></table></figure><p>data被理解为缓存与数据库的封装，与底层数据存储相关，一般都是跟着数据库的类型适配。</p><h3 id="internal-server"><a href="#internal-server" class="headerlink" title="internal/server"></a>internal/server</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── internal  // 该服务所有不对外暴露的代码，通常的业务逻辑都在这下面，使用internal避免错误引用</span><br><span class="line">│  ├── server  // http和grpc实例的创建和配置</span><br><span class="line">│  │  ├── grpc.go</span><br><span class="line">│  │  ├── http.go</span><br><span class="line">│  │  └── server.go</span><br></pre></td></tr></table></figure><p>前面IDL文件（protobuf）生成了RPC方法的接口（interface），这里就是RPC方法的具体实现。</p><h3 id="internal-service"><a href="#internal-service" class="headerlink" title="internal/service"></a>internal/service</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── internal  // 该服务所有不对外暴露的代码，通常的业务逻辑都在这下面，使用internal避免错误引用</span><br><span class="line">│  └── service  // 实现了 api 定义的服务层，类似 DDD 的 application 层，处理 DTO 到 biz 领域实体的转换(DTO -&gt; DO)，同时协同各类 biz 交互，但是不应处理复杂逻辑</span><br><span class="line">│      ├── README.md</span><br><span class="line">│      ├── greeter.go</span><br><span class="line">│      └── service.go</span><br></pre></td></tr></table></figure><p>service被定义成对数据结构的处理层。</p><h2 id="架构概览"><a href="#架构概览" class="headerlink" title="架构概览"></a>架构概览</h2><p>Kratos里包含了大量组件，很多模块都与前面Go-Micro的有共同之处，我就不再赘述了。而且通过上面的目录层面的划分，重点是api -&gt; server -&gt; service -&gt; biz -&gt; data 的调用逻辑。</p><p>这里，我们关注两个重要特性：</p><ol><li>wire - <a href="https://go-kratos.dev/docs/guide/wire">https://go-kratos.dev/docs/guide/wire</a></li><li>ent - <a href="https://go-kratos.dev/docs/guide/ent">https://go-kratos.dev/docs/guide/ent</a></li></ol><p>这两块内容比较多，我会单独出两篇文章进行分享。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Github - <a href="https://github.com/go-kratos/kratos">https://github.com/go-kratos/kratos</a> </p><p>文档 - <a href="https://go-kratos.dev/docs/">https://go-kratos.dev/docs/</a></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>Kratos是一个典型的 <strong>基于完善的基建</strong> 而成的Go语言开发框架，可以发现它有3个关键点：</p><ol><li>RPC层复用protobuf的能力</li><li>底层依赖Kubernetes的能力</li><li>各类工具复用开源库的能力</li></ol><p>很多中大型公司的内部框架都是按照这种思路实现的，只是会封装一些公司通用能力，比如通用的RPC能力。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整体来说，Kratos的实现与我推崇的理念基本一致，即复用生态+平台的能力。</p><p>在一些细节的技术选型上会存在差异，例如Kratos更注重Bilibili公司的历史沉淀，而我会更关注社区的当前主流实现，并抛开包袱、尽可能地实现自动化。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Kratos框架概况&quot;&gt;&lt;a href=&quot;#Kratos框架概况&quot; class=&quot;headerlink&quot; title=&quot;Kratos框架概况&quot;&gt;&lt;/a&gt;Kratos框架概况&lt;/h2&gt;&lt;p&gt;截止到本文发布时，Kratos在github上的star数达到了15.9k。其中，在2021年7月，也正式推出了v2这个大版本。&lt;/p&gt;
&lt;p&gt;本人并不是Kratos的重度使用者，主要会通过官方介绍对它的特性进行剖析。接下来的内容依旧包含大量主观认知，可能会对官方文档有理解上的偏差，欢迎大家与我讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 13.监控组件Prometheus的引入</title>
    <link href="http://example.com/2021/12/12/go-framework/go-framework-13/"/>
    <id>http://example.com/2021/12/12/go-framework/go-framework-13/</id>
    <published>2021-12-12T04:00:00.000Z</published>
    <updated>2021-12-14T11:02:59.538Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>作为云原生程序监控的标准组件，Prometheus支持了各类Paas、Saas平台，并提供了一整套采集+存储+展示的解决方案。</p><p>今天我们专注于自定义服务中的Prometheus的监控，在框架中引入Prometheus相关的组件。关于更细致的使用方式，我会给出相关的链接，有兴趣进一步学习Prometheus的同学可以边参考资料边实践。</p><span id="more"></span><h2 id="v0-8-0：监控组件Prometheus的引入"><a href="#v0-8-0：监控组件Prometheus的引入" class="headerlink" title="v0.8.0：监控组件Prometheus的引入"></a>v0.8.0：监控组件Prometheus的引入</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.8.0">https://github.com/Junedayday/micro_web_service/tree/v0.8.0</a> </p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>引入prometheus组件，提供标准与自定义的metrics。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>metrics接口的开放</li><li>示例counter的初始化</li><li>示例counter的计数</li><li>学习Prometheus监控使用方法</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">    |-- order                            对应idl/order服务，同上</span><br><span class="line">     |-- swagger.json                    openapiv2的接口文档</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">   |-- order                           业务order定义，同时干</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">   |-- metrics                         新增：自定义监控指标</span><br><span class="line">   |-- model                           model层基本定义由gormer自动生成</span><br><span class="line">   |-- mysql                           MySQL连接，支持日志打印</span><br><span class="line">   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义，新增参数校验逻辑</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- format.sh                      新增：格式化代码的脚本</span><br><span class="line">|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- gormer.yaml                    将gormer中的参数移动到这里</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br><span class="line">|-- swagger.sh                     生成openapiv2的相关脚本</span><br></pre></td></tr></table></figure><h2 id="1-metrics接口的开放"><a href="#1-metrics接口的开放" class="headerlink" title="1.metrics接口的开放"></a>1.metrics接口的开放</h2><p>Prometheus官方推荐的metrics开放方式为http。将它引入到程序中的代码如下面几行，不过有几个点值得注意：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  mux := http.NewServeMux()</span><br><span class="line">  mux.Handle(<span class="string">&quot;/metrics&quot;</span>, promhttp.Handler())</span><br><span class="line">  http.ListenAndServe(fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, config.Viper.GetInt(<span class="string">&quot;server.prometheus.port&quot;</span>)), mux)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><ol><li><code>http.ListenAndServe</code> 函数是阻塞的，所以需要开一个goroutine。</li><li>为了保证Prometheus的指标监控不与应用的http服务冲突，这里采用了端口隔离，也就是另起一个http服务。</li><li><code>Go</code> 的 <code>http</code> 库如果要支持多port的运行，需要引入<code>mux</code>的概念；默认会注册到http库中的<code>DefaultServeMux</code>。</li></ol><p>为了验证我们的metrics已经正常running，我们可以调用一个curl请求查看一下（具体返回结果不细讲）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例的metrics起在8083端口</span></span><br><span class="line">curl --request GET &#x27;http://127.0.0.1:8083/metrics&#x27;</span><br></pre></td></tr></table></figure><h2 id="2-示例counter的初始化"><a href="#2-示例counter的初始化" class="headerlink" title="2.示例counter的初始化"></a>2.示例counter的初始化</h2><p>我们先以一个最简单的counter累加器为例，实现一个自定的指标监控。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> metrics</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/prometheus/client_golang/prometheus&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">prometheus.MustRegister(OrderList)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> OrderList = prometheus.NewCounterVec(</span><br><span class="line">prometheus.CounterOpts&#123;</span><br><span class="line">Name: <span class="string">&quot;order_list_counter&quot;</span>,</span><br><span class="line">Help: <span class="string">&quot;List Order Count&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">&quot;service&quot;</span>&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>代码的逻辑比较简单，我们注意以下三个关键点：</p><ol><li><code>OrderLis</code>t 是一个全局变量，方便使用方调用；</li><li><code>NewCounterVec</code> 表示这个Counter是一个向量，包括了两块 - opts和labels<ol><li>opts包括Name和Help，Name是metrics唯一的名称，Help是metrics的帮助信息</li><li>labels是用来过滤、聚合功能的关键参数，提前声明有利于存储端进行优化（可类比数据库索引）</li></ol></li><li><code>prometheus.MustRegister(OrderList)</code> 是将metrics注册到prometheus的全局变量里，与main函数里的注册对应</li></ol><h2 id="3-示例counter的计数"><a href="#3-示例counter的计数" class="headerlink" title="3.示例counter的计数"></a>3.示例counter的计数</h2><p>从指标的定义可以看到，我们设计的这个metrics是为了统计订单查询接口的次数，于是我们在代码侧引入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">ListOrders</span><span class="params">(ctx context.Context, req *order.ListOrdersRequest)</span> <span class="params">(*order.ListOrdersResponse, error)</span></span> &#123;</span><br><span class="line">metrics.OrderList.With(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;service&quot;</span>: <span class="string">&quot;example&quot;</span>&#125;).Inc()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是一个链式调用，包括两块：</p><ol><li>With，也就是label信息，用一个map[string]string填入，是个通用功能；</li><li>Inc，即计数+1，这个方法和具体的metrics类型相关。</li></ol><p>接着，我们调用两次对应的接口，可以从metrics信息中看到下面的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># HELP order_list_counter List Order Count</span><br><span class="line"># TYPE order_list_counter counter</span><br><span class="line">order_list_counter&#123;service=&quot;example&quot;&#125; 2</span><br></pre></td></tr></table></figure><p>除非程序重启，否则这个Counter会不断累加。</p><h2 id="4-学习Prometheus监控使用方法"><a href="#4-学习Prometheus监控使用方法" class="headerlink" title="4.学习Prometheus监控使用方法"></a>4.学习Prometheus监控使用方法</h2><p>Prometheus监控埋点的使用方式比较直观，上手难度不大。如果你希望进一步了解这块，我推荐两个核心的资料：</p><ul><li>Prometheus官网 - <a href="https://prometheus.io/docs/introduction/overview/">https://prometheus.io/docs/introduction/overview/</a></li><li>Prometheus的Go语言官方库 - <a href="https://github.com/prometheus/client_golang">https://github.com/prometheus/client_golang</a></li></ul><p>这两份资料是英文的，可能对部分同学来说学成本比较高，可以考虑先去搜索一些中文翻译文档、了解梗概后，再回过头来看这两篇。如果你希望深入了解Prometheus，必须要仔细看这两块内容，保证实时性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对接Prometheus的自定义metrics是一个应用程序很常见的功能，例如业务指标埋点。在埋点的过程中，有一个大误区需要刚接触Prometheus的同学注意：把计算的工作交给Prometheus引擎，而不要放在你开发的程序里。</p><p>例如，你希望计算某个订单的成功率，你不应该用一个metrics对应成功率，而应该给出两个指标，即订单总量和成功的订单量（也可以放在一个指标中，用label区分成功与否），交由Prometheus进行计算，方便后续的各种metrics的扩展。</p><p>更多Prometheus的实践，需要大家边学习边实践。如果反响热烈，我也会抽几讲谈谈Prometheus。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;作为云原生程序监控的标准组件，Prometheus支持了各类Paas、Saas平台，并提供了一整套采集+存储+展示的解决方案。&lt;/p&gt;
&lt;p&gt;今天我们专注于自定义服务中的Prometheus的监控，在框架中引入Prometheus相关的组件。关于更细致的使用方式，我会给出相关的链接，有兴趣进一步学习Prometheus的同学可以边参考资料边实践。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
</feed>
