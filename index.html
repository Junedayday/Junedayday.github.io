<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"8.0.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="Blog信息">
<meta property="og:type" content="website">
<meta property="og:title" content="Junedayday Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Junedayday Blog">
<meta property="og:description" content="Blog信息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Junedayday">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Junedayday Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Junedayday Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">六月天天的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Junedayday</p>
  <div class="site-description" itemprop="description">Blog信息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/25/go-study/go-study-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/25/go-study/go-study-7/" class="post-title-link" itemprop="url">Go语言学习路线 - 7.进阶篇:一名软件工程师的价值沉淀</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-07-25 12:00:00 / 修改时间：17:31:20" itemprop="dateCreated datePublished" datetime="2021-07-25T12:00:00+08:00">2021-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p>
<h2 id="阶段性的思考"><a href="#阶段性的思考" class="headerlink" title="阶段性的思考"></a>阶段性的思考</h2><p>通过前面几讲的分享，相信大家已经能清楚地看到一名普通软件工程师的发展路线：<strong>不断学习技能，提高研发效能，实现业务功能</strong>。</p>
<p>如果我们尝试回头看，可能会对自己的定位存在疑问：这些日常CRUD的开发工作，很多不具备太高的技术难度，可以靠人力堆积来实现。那么，如何在研发团队里打造自己的<strong>技术壁垒</strong>、体现个人价值呢？</p>
<p>下面，我将分多个层面和大家聊聊，大家可以根据自己的发展目标和工作环境，选择性地发展几项。今天的内容会抛开编程语言之争，从更高的维度来看问题。</p>
<h2 id="1-专项业务领域"><a href="#1-专项业务领域" class="headerlink" title="1. 专项业务领域"></a>1. 专项业务领域</h2><p><strong>业务往往与公司的赢利点挂钩</strong>，决定了公司的生死存亡，所以业务驱动了公司里的很多事情，包括晋升、组织架构等。</p>
<p>大多数的开发者往往长期投入在公司的业务相关开发，或是满足产品的迭代，或是满足甲方的需求。从结果来看，业务开发是最容易看到成果的，可以与具体的增长和营收挂钩。那么，业务领域的开发者需要关注什么呢？我也列举三点</p>
<ul>
<li>产品设计 - 具备<strong>产品的规划与设计</strong>能力，将业务开发的经验沉淀为对产品的理解</li>
<li>业务架构 - 能将<strong>软件架构适配业</strong>务，也能根据公司的基础能力灵活调整</li>
<li>权衡能力 - <strong>权衡技术与业务的冲突</strong>，能保证业务快速实现的同时，尽可能地减少技术债</li>
</ul>
<h2 id="2-专项技术领域"><a href="#2-专项技术领域" class="headerlink" title="2. 专项技术领域"></a>2. 专项技术领域</h2><p>技术人常常期望能<strong>抛开烦杂的业务需求，长期在一个技术领域深耕</strong>，例如专职研究存储系统、网络架构、云原生架构、大数据引擎等。这里，我希望有此类想法的同学先想清楚一个问题：你究竟是厌倦了做需求迭代，还是真正喜欢某项技术？</p>
<p>深耕专项的技术领域，遇到的挑战很多，我列举三个比较重要的：</p>
<ul>
<li>评价产出 - 思考如何将<strong>技术变现</strong>，在公司中体现自己的<strong>能力价值</strong></li>
<li>承载业务 - <strong>对接并服务</strong>各个业务团队，根据具体场景做优化、适配等工作</li>
<li>探索前景 - <strong>紧跟并探索</strong>技术发展前景，方向准确，并长期坚持</li>
</ul>
<h2 id="3-团队领导力"><a href="#3-团队领导力" class="headerlink" title="3. 团队领导力"></a>3. 团队领导力</h2><p>合作与分工是所有团队都面临的问题。随着一名工程师的经验与资历的提升，都会直接或间接地带领团队去实现目标。</p>
<p>那怎么考验一个人的<strong>团队领导力</strong>呢？一般会更关注以下三点：</p>
<ul>
<li>能力提升 - 保证资深员工能有效地将<strong>经验与技能</strong>传递给新人，自身也有足够的发展空间</li>
<li>合理用人 - <strong>如何管理性格、能力各异的成员，尽可能实现产出最大化</strong></li>
<li>落地文化 - 一个团队如果要长久发展，必须得形成<strong>文化价值观</strong>，并聚拢一批认同这个价值观的成员</li>
</ul>
<h2 id="4-研发效能管理"><a href="#4-研发效能管理" class="headerlink" title="4. 研发效能管理"></a>4. 研发效能管理</h2><p>如今，<strong>软件工程日益精细化</strong>，公司越来越重视研发效能的管理，而非当初那种野蛮地堆人力、抢占市场。</p>
<p>研发效能的管理分为多个方向，例如：</p>
<ul>
<li>项目/需求/故障管理 - 用平台跟进项目进度、投入人力</li>
<li>CICD/devops - 各类自动化的工具平台，促进研发与运维一体化，让研发对整个生命周期负责</li>
<li>基础框架/库 - 加速研发对接日志、监控、部署等平台</li>
<li>流程平台化 - 将公司内的各种日常流程落地为平台</li>
</ul>
<h2 id="5-安全"><a href="#5-安全" class="headerlink" title="5. 安全"></a>5. 安全</h2><p>安全是一个很有意思的话题，大部分人的认知是：<strong>在没有问题时，安全一文不值；在出现问题后，安全又是至关重要的</strong>。</p>
<p>安全领域门槛很高，会有专属于自己的一个小圈子。绝大多数的开发者并不需要过多掌握安全相关的技能，只需了解一些常规的安全技能，在日常研发中有意识地加以重视：</p>
<ul>
<li>网络安全 - 常见的<code>HTTPS</code>、证书、<code>Sync Flooding</code>等</li>
<li>数据安全 - 加解密、备份</li>
<li>编程相关 - SQL注入、核心参数校验、审计功能</li>
</ul>
<h2 id="6-稳定性"><a href="#6-稳定性" class="headerlink" title="6. 稳定性"></a>6. 稳定性</h2><p>在项目投入生产使用后，<strong>稳定性</strong>逐渐成为一项重要指标，它与公司的营收直接相关。</p>
<p>在某个程度上，稳定性与安全非常类似，<strong>不出问题时，大家都不care稳定性，都想着快速迭代；出现问题后，又想法设法维持稳定</strong>。那如何体现一个人在稳定性上的能力呢？</p>
<ul>
<li>代码研发 - 从实际代码出发，保证核心功能的<strong>健壮性和可扩展性</strong></li>
<li>软件架构 - 软件架构稳定，既能保证<strong>功能迭代</strong>，也能随着规模扩大保证<strong>性能稳定</strong></li>
<li>工作流程 - 从功能迭代、需求上线、故障处理等流程出发，控制风险</li>
</ul>
<h2 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h2><p>以上六点，是作为开发者的价值点沉淀。我比较赞同一个观点：<strong>对公司的价值输出，决定了你的绩效；而对自己能力的沉淀，决定了你的市场价值</strong>。所以，绝大多数的人更应该把关注点放在自身的能力沉淀。</p>
<p>不过，我这边也针对一个极端的观点做一下修正：<strong>不要花太多心思在公司工作上，而是多提升自身能力。</strong></p>
<p>公司评定一个人包括两块：工作产出与自身能力。光有能力而没有足够产出，是可以让我们在当前岗位上表现达到中上，却很难让自己获得晋升、进而到一个更高的位置去锻炼自己。</p>
<p>个人能力毕竟有限，必须截止公司的力量，才能产出更大的价值；反之，如果你的产出全部依赖公司平台，也就是说脱离了平台你的价值大打折扣，那也是一个非常严重的问题。</p>
<p>我比较建议，在 <strong>保证自己能在当前岗位成为TOP10%的前提下，多多提升自己</strong>。</p>
<p>如果在工作中投入了100%的时间与精力，却依旧达不到TOP10%的业绩产出，这也是很多人遇到的问题。此时，我建议<strong>减少纯工作上的投入，多花时间提升个人能力</strong>。哪怕会在短期内会导致绩效的不如意，但能换来长期良好的职业发展。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本篇和大家聊了很多关于个人长期发展的话题，也探讨了个人与公司上的冲突问题。</p>
<p>如果用一句话总结，我会选择：<strong>软件工程师的价值沉淀是一个长期过程，核心是锻炼自身能力，也要借助公司的平台来帮助自己更快地成长</strong>。</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/21/go-study/go-study-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/21/go-study/go-study-6/" class="post-title-link" itemprop="url">Go语言学习路线 - 6.提效篇:不懈地追求提升研发效率</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-21 12:00:00" itemprop="dateCreated datePublished" datetime="2021-07-21T12:00:00+08:00">2021-07-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-25 12:30:02" itemprop="dateModified" datetime="2021-07-25T12:30:02+08:00">2021-07-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p>
<h2 id="为什么要追求研发效能"><a href="#为什么要追求研发效能" class="headerlink" title="为什么要追求研发效能"></a>为什么要追求研发效能</h2><p>在<strong>入门篇</strong>与<strong>基础篇</strong>之后，我选择做了这一讲<strong>提效篇</strong>。而在提效篇的推出之前，我也开启<a target="_blank" rel="noopener" href="https://junedayday.github.io/tags/Go-Tip/">Go语言技巧系列</a>的更新，着重分享一些具体的工程化实例，包括错误处理、Go Module等。</p>
<p>也许有读者会好奇为什么会把提效篇放在这里，在我看来，<strong>如果工程师已经度过了入门阶段，就应该重点关注研发效能</strong>。</p>
<blockquote>
<p>严格意义来说，基础篇的<strong>分层思想</strong>，就是一个很有效的提升研发效能的手段。</p>
</blockquote>
<p><strong>研发效能</strong>涉及的面很广，但这里我们聚焦于讨论<strong>软件编码阶段</strong>的工作，专注于提升工程师在开发阶段的效率。</p>
<p>提升了研发效能后，我不太建议大家去<strong>主动接手更多的开发工作</strong>，而是<strong>投入到不断地学习和提升自己，持续提高效率，实现正反馈循环</strong>。至于投入到哪些方面更有价值，则是我今天分享的重点。</p>
<h2 id="培养意识是核心"><a href="#培养意识是核心" class="headerlink" title="培养意识是核心"></a>培养意识是核心</h2><p>我并不想直接聊提效的各种手段与方法，因为这些都是停留在 <strong>术</strong> 的阶段，大概率会随着时间变化而变化。那什么是 <strong>道</strong> 呢？我相信是工程师的思想意识。</p>
<p>举四个比较关键的点：</p>
<h3 id="保持一颗追求“偷懒”的心"><a href="#保持一颗追求“偷懒”的心" class="headerlink" title="保持一颗追求“偷懒”的心"></a>保持一颗追求“偷懒”的心</h3><p>提高效率的最大原动力是为了“偷懒”，这一点很容易理解。但难的是在重复性的日常工作下，我们如何能够抵抗住“混一天是一天”的躺平心态，想方设法地缩短现有的工作时间。</p>
<h3 id="对知识的开闭原则"><a href="#对知识的开闭原则" class="headerlink" title="对知识的开闭原则"></a>对知识的开闭原则</h3><p>软件工程里有开闭原则OCP，我们对待知识也要有一定的“开闭心态”：</p>
<ul>
<li><strong>开放 - 对待知识的初始心态要开放，海纳百川。</strong>要做到这一点很难，我们要抛开原有的观念，才能对有一个客观的认知。</li>
<li><strong>封闭 - 使用知识时前反复斟酌，考虑周全。</strong>要推广、实践一个技术点，不仅仅是技术本身的问题，还要考虑人员因素、团队现状、公司发展、投入产出比等现实性的问题。</li>
</ul>
<h3 id="原理决定选择，选择重于实现"><a href="#原理决定选择，选择重于实现" class="headerlink" title="原理决定选择，选择重于实现"></a>原理决定选择，选择重于实现</h3><p>如今，开源社区已经提供了各种现成工具，日常功能的实现已经基本没有技术瓶颈，这时更考验人的是如何适应后续的<strong>可扩展性</strong>。选择<code>MySQL</code>还是<code>ES</code>，选择 <code>官方sql库</code> 还是比较重量级的<code>GORM</code>库，都是很值得考量的点。</p>
<p><strong>不同选择代表着不同的发展方向</strong>，这个与我们的职业发展一样，一旦开了头，很难改变路线。所以，在做选择之前，我们要尽可能地了解背后的原理，根据自己的应用场景进行选择。</p>
<h3 id="脚踏实地，追求技术最优解"><a href="#脚踏实地，追求技术最优解" class="headerlink" title="脚踏实地，追求技术最优解"></a>脚踏实地，追求技术最优解</h3><p>技术人在<strong>面向业务编程时，常常会做技术上的妥协</strong>。固然，我们应脚踏实地从业务出发去做技术，但如果你对业务有了自己的理解，有了更优解，哪怕需要多几天的开发周期，你也应该尝试说服周围人，这样更能体现你的<strong>技术和业务的领导力</strong>。</p>
<h2 id="提效1-编程语言"><a href="#提效1-编程语言" class="headerlink" title="提效1 - 编程语言"></a>提效1 - 编程语言</h2><p>虽然这是一篇关于<code>Go</code>语言的学习路线，但我希望大家不要把目光局限于这一门语言。</p>
<p>比如，在日常开发、部署、故障排查的过程中，<code>Shell</code>是一个高频的工具；面对大数据处理场景时，用<code>Go</code>语言开发需要造大量轮子，远不如<code>Java</code>体系高度的成熟度；<code>Python</code>在做测试脚本的开发时颇具效率，也有大量的成熟的软件平台。</p>
<p><strong>对普通开发人员来说，逆主流是个大忌！</strong></p>
<h2 id="提效2-RPC框架"><a href="#提效2-RPC框架" class="headerlink" title="提效2 - RPC框架"></a>提效2 - RPC框架</h2><p>目前在开源社区中，最主流的RPC框架是<code>Gin</code>，可以通过<a target="_blank" rel="noopener" href="https://github.com/gin-gonic/gin">链接</a>进行访问。如果你是一个初学者、公司也没有一个成熟的框架，那就毫不犹豫地选择这个吧！</p>
<p>同时，以<code>gRPC</code>为核心的<code>gRPC-Gateway</code>方案，是我比较推荐的进阶方案，相对<code>Gin</code>而言学习难度会高一些，大家可以通过这个<a target="_blank" rel="noopener" href="https://github.com/grpc-ecosystem/grpc-gateway">链接</a>进行访问。它的优点是支持<code>http1.x</code>和<code>http2.0</code>，跨语言的解决方案<code>protobuffer</code>，以及大量的插件化工具（尤其是自动生成接口文档）。</p>
<p>最后，如果你所在的公司已有一个成熟的RPC框架，那就毫不犹豫地使用它吧！同时，你也可以学习<code>Gin</code>和<code>gRPC-Gateway</code>中优点，尝试往公司框架中贡献一些特性，提升自己的技术影响力。</p>
<blockquote>
<p>关于第二个gRPC-Gateway方案，后续我会在<strong>Go语言技巧系列</strong>中花几章进行介绍。</p>
</blockquote>
<h2 id="提效3-工具库"><a href="#提效3-工具库" class="headerlink" title="提效3 - 工具库"></a>提效3 - 工具库</h2><p><code>Go</code>语言在开源社区有广泛的现成工具库，但没有如<code>Spring</code>全家桶那般形成标准，往往需要我们自行挑选。</p>
<p>我们固然可以从百度中搜索出一个解决方案直接使用，也可以直接搜索一个使用率最高的库，但<strong>知其所以然</strong>更加重要。我非常建议大家在使用对应的工具库前，多花点时间学习底层原理，如使用<code>GORM</code>前先掌握<code>MySQL</code>的基础。</p>
<p>工具库这部分的学习是长期的工作，也是我后续分享的碎片知识点。</p>
<h2 id="提效4-IDE"><a href="#提效4-IDE" class="headerlink" title="提效4 - IDE"></a>提效4 - IDE</h2><p>我非常建议新手朋友使用<code>IDE</code>，也就是<code>Goland</code>。</p>
<p>虽然重度依赖IDE会带来限制，但往往利大于弊，例如：</p>
<ul>
<li>在内存中缓存数据，实现快速跳转</li>
<li><code>go fmt/goimports</code>等格式化代码的工具</li>
<li>引入<code>Golint</code>进行静态代码扫描</li>
<li><code>Refactor</code>重构等特性，在大型项目中很有价值</li>
<li>快速生成单元测试、接口、实现等</li>
<li>利用<code>Live Template</code>特性，给常用代码生成模板</li>
<li>断点调试</li>
</ul>
<p>如果你一上手就直接用<code>VSCode</code>、甚至<code>Vim</code>，你可能根本不清楚有这么多工具可以帮助你提升工程质量。当你熟练掌握后，就可以将这些特性作为插件引入到<code>VSCode</code>与<code>Vim</code>中。</p>
<h2 id="提效5-辅助工具"><a href="#提效5-辅助工具" class="headerlink" title="提效5 - 辅助工具"></a>提效5 - 辅助工具</h2><p>在日常研发时，有许多辅助性的工具，在特定场景带来意想不到的帮助，需要大家结合自己的场景选择：</p>
<ul>
<li>开发环境</li>
<li><code>git</code>命令与工作流</li>
<li><code>markdown</code>文档写作</li>
<li>个人任务管理</li>
<li><code>chrome/wireshark/postman</code>等网络相关工具</li>
<li><code>shell</code>排查性能问题</li>
</ul>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>提效是一个长期的工作，需要我们长期摸索前进。</p>
<p><strong>提效篇</strong>只是一个开始，更多的相关内容，我会放到 <a target="_blank" rel="noopener" href="https://junedayday.github.io/tags/Go-Tip/">Go语言技巧系列</a> 里，欢迎大家持续关注。</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/19/go-leetcode/go-leetcode-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/go-leetcode/go-leetcode-4/" class="post-title-link" itemprop="url">Go算法实战 - 4.【寻找两个正序数组的中位数LeetCode-4】</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-07-19 12:00:00 / 修改时间：19:50:31" itemprop="dateCreated datePublished" datetime="2021-07-19T12:00:00+08:00">2021-07-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="Leetcode-4-寻找两个正序数组的中位数"><a href="#Leetcode-4-寻找两个正序数组的中位数" class="headerlink" title="Leetcode-4 寻找两个正序数组的中位数"></a>Leetcode-4 寻找两个正序数组的中位数</h2><p>原题链接 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在解这个题之前，我们要注意<strong>奇数和偶数</strong>的边界情况。</p>
<ul>
<li>奇数2n+1个，我们要取第n+1小的数</li>
<li>偶数2n个，我们要取第n和n+1小的数</li>
</ul>
<p>在Go语言中，因为是强类型的，切片<code>nums1</code>与<code>nums2</code>是整数，返回值则是浮点数</p>
<blockquote>
<p>这是我们遇到的第一道hard级别的题目，让我们一起尝试攻克它！</p>
</blockquote>
<h2 id="基本解法"><a href="#基本解法" class="headerlink" title="基本解法"></a>基本解法</h2><h3 id="常规思路1-逐个寻找"><a href="#常规思路1-逐个寻找" class="headerlink" title="常规思路1 - 逐个寻找"></a>常规思路1 - 逐个寻找</h3><p>常规思路来看，我们就是找第X小的数，那我们就一个一个找：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    length1, length2 := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="comment">// 注意，这里是向下取整</span></span><br><span class="line">    mid := (length1 + length2) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区分一下奇数与偶数，奇数为mid+1，偶数为mid/mid+1</span></span><br><span class="line">    <span class="comment">// 奇数为2n+1个，mid=n,这样下一个就是中位数</span></span><br><span class="line">    <span class="comment">// 偶数为2n个，mid=n，所以处理一下，让mid=n-1，这样接下来两个就是中位数</span></span><br><span class="line">    <span class="keyword">var</span> isOdd <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">if</span> (length1 + length2) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        isOdd = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mid =  mid - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> i1, i2 <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 移动两个索引i1与i2，找到最小的mid个</span></span><br><span class="line">    <span class="comment">// 关键是注意两个边界情况的判定</span></span><br><span class="line">    <span class="keyword">for</span> mid &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i1 &gt;= <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">            i2++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> i2 &gt;= <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">            i1++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i1] &gt; nums2[i2] &#123;</span><br><span class="line">            i2++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i1++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mid--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到mid后下一个</span></span><br><span class="line">    <span class="keyword">var</span> n1 <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> i1 &gt;= <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">        n1 = nums2[i2]</span><br><span class="line">        i2++</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> i2 &gt;= <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">        n1 = nums1[i1]</span><br><span class="line">        i1++</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i1] &gt; nums2[i2] &#123;</span><br><span class="line">        n1 = nums2[i2]</span><br><span class="line">        i2++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n1 = nums1[i1]</span><br><span class="line">        i1++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 奇数直接返回结果</span></span><br><span class="line">    <span class="keyword">if</span> isOdd &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(n1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偶数找到再下一个，再返回</span></span><br><span class="line">    <span class="keyword">var</span> n2 <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> i1 &gt;= <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">        n2 = nums2[i2]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> i2 &gt;= <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">        n2 = nums1[i1]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i1] &gt; nums2[i2] &#123;</span><br><span class="line">        n2 = nums2[i2]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n2 = nums1[i1]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(n1 + n2) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码很长，但性能不差，因为都是顺序的逻辑。</p>
<p>分析一下复杂度，空间复杂度是O(1)，时间复杂度为O(m+n)，其中m=len(nums1)，n=len(nums2)。</p>
<h3 id="常规思路2-排序后直接根据索引查找"><a href="#常规思路2-排序后直接根据索引查找" class="headerlink" title="常规思路2 - 排序后直接根据索引查找"></a>常规思路2 - 排序后直接根据索引查找</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="comment">// Go里面不支持对 []int 直接进行排序，必须通过 sort.IntSlice 做一次转化</span></span><br><span class="line">    <span class="keyword">var</span> intSlice sort.IntSlice</span><br><span class="line">    intSlice = <span class="built_in">append</span>(intSlice, nums1...)</span><br><span class="line">    intSlice = <span class="built_in">append</span>(intSlice, nums2...)</span><br><span class="line"></span><br><span class="line">    sort.Sort(intSlice)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(intSlice) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 注意这里的索引，切勿再+1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(intSlice[<span class="built_in">len</span>(intSlice) / <span class="number">2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(intSlice[<span class="built_in">len</span>(intSlice) / <span class="number">2</span> - <span class="number">1</span>] + intSlice[<span class="built_in">len</span>(intSlice) / <span class="number">2</span> ]) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我个人觉得Go语言里的排序函数<code>sort.Sort</code>对使用者的体验不是很好，尤其是对一些基础类型的支持。</p>
<p>这个解法的问题是对nums1和nums2进行了重新排序，没有充分利用nums1与nums2为<strong>有序数组</strong>这个条件。</p>
<h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><h3 id="递归的基本思路"><a href="#递归的基本思路" class="headerlink" title="递归的基本思路"></a>递归的基本思路</h3><p>我们注意到，这道题中给出的两个数组都是 <strong>已排序</strong> 的，所以可以利用<strong>数组的随机访问</strong>特性，做一定的加速。</p>
<p>这道题的问题是取中位数，但由于<strong>数组长度的奇偶性</strong>问题，这个中位数很难递归。所以，我们需要将问题做一个转化，实现<strong>找到第K小的数字</strong>，也就是下面的<code>findKthSortedArrays</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    length1, length2 := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="comment">// 奇数可以一步计算得出</span></span><br><span class="line">    <span class="keyword">if</span> (length1 + length2) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthSortedArrays(nums1, nums2, (length1 + length2) / <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 偶数的拆分为两个子问题</span></span><br><span class="line">    <span class="keyword">return</span> (findKthSortedArrays(nums1, nums2, (length1 + length2) / <span class="number">2</span>) +</span><br><span class="line">        findKthSortedArrays(nums1, nums2, (length1 + length2) / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    length1, length2 := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="comment">// 技巧1：保证nums1比nums2长，能减少下面很多条件的判断</span></span><br><span class="line">    <span class="keyword">if</span> length1 &lt; length2 &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthSortedArrays(nums2, nums1, k)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> length2 == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(nums1[k - <span class="number">1</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> k == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nums1[<span class="number">0</span>] &gt; nums2[<span class="number">0</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">float64</span>(nums2[<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(nums1[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们要保证i1和i2都要小于k，否则下面很难递归</span></span><br><span class="line">    i2 := k / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> i2 &gt; length2 &#123;</span><br><span class="line">      i2 = length2</span><br><span class="line">    &#125;</span><br><span class="line">    i1 := k - i2</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归的核心思路</span></span><br><span class="line">    <span class="keyword">if</span> nums1[i1 - <span class="number">1</span>] &lt; nums2[i2 - <span class="number">1</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthSortedArrays(nums1[i1:], nums2, k - i1)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i1 - <span class="number">1</span>] &gt; nums2[i2 - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthSortedArrays(nums1, nums2[i2:], k - i2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(nums1[i1 - <span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决这道题的难点在于3点：</p>
<ul>
<li>大量<strong>边界条件</strong>的编写，很容易发生遗漏导致运行失败</li>
<li>第n个数字转化为数组索引时，自带一个<code>-1</code>操作，在递归时容易混淆</li>
<li>递归的核心思路：<strong>将第k个元素转化为2个数组的索引之和，并保证不小于各自数组的长度</strong></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解决本题的难点在于大量的条件判断，存在大量<code>if-else</code>的代码，很容易让我们在编写代码时产生混乱，常常需要大量的调试。</p>
<p>我个人比较推荐用<strong>常规解法1</strong>这种笨办法来思路梳理，完整地处理好各种边界条件。接下来，再通过<strong>进阶解法</strong>来提升自己的抽象水平。</p>
<p>恭喜我们，正式解决了第一道困难的Leetcode！</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/19/go-leetcode/go-leetcode-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/go-leetcode/go-leetcode-5/" class="post-title-link" itemprop="url">Go算法实战 - 5.【最长回文子串LeetCode-5】</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-19 12:00:00" itemprop="dateCreated datePublished" datetime="2021-07-19T12:00:00+08:00">2021-07-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-21 20:11:07" itemprop="dateModified" datetime="2021-07-21T20:11:07+08:00">2021-07-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="Leetcode-5-最长回文子串"><a href="#Leetcode-5-最长回文子串" class="headerlink" title="Leetcode-5 最长回文子串"></a>Leetcode-5 最长回文子串</h2><p>原题链接 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题中，我们也要注意<strong>奇数和偶数</strong>的边界情况。</p>
<h2 id="基本解法"><a href="#基本解法" class="headerlink" title="基本解法"></a>基本解法</h2><h3 id="枚举所有情况"><a href="#枚举所有情况" class="headerlink" title="枚举所有情况"></a>枚举所有情况</h3><p>刚拿到这道题时，我们很容易想到一个解法：</p>
<ul>
<li>枚举出s所有的子字符串</li>
<li>找到最长的回文串</li>
</ul>
<p>这个解法代码我就不专门写了，复杂度很高，但如果你想不到解决方案时，可以先写出这个解法，再逐步优化。</p>
<h3 id="利用递归拆分成子问题"><a href="#利用递归拆分成子问题" class="headerlink" title="利用递归拆分成子问题"></a>利用递归拆分成子问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找以s[0]为开头的最长回文子串</span></span><br><span class="line">    right := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> ; right &gt;= <span class="number">0</span>; right-- &#123;</span><br><span class="line">        <span class="comment">// 找到最长的回文子串就退出</span></span><br><span class="line">        <span class="keyword">if</span> isPalindrome(s[:right]) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用递归的方式获取s[1:]的长度，与上面的结果对比</span></span><br><span class="line">    subS := longestPalindrome(s[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(subS) &gt; right &#123;</span><br><span class="line">        <span class="keyword">return</span> subS</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[:right]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头尾两个指针不断往中间缩进</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果s长度为奇数，退出时刚好left=right，偶数则为 left &gt; right</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        <span class="keyword">if</span> s[left] != s[right] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        left++</span><br><span class="line">        right--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个解法的代码思路相对清晰，核心思路是将 <strong>以s[0]开头的回文字符串</strong> 与 <strong>s[1:]中最长回文子串</strong> 进行对比，其中后者是递归的子问题。</p>
<p>在有一定的算法基础后，我个人比较喜欢先用 <strong>递归思路去简化问题</strong>，将代码拆分成子问题，能大量地简化代码。</p>
<h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><h3 id="利用对称点"><a href="#利用对称点" class="headerlink" title="利用对称点"></a>利用对称点</h3><p>从回文串的特点来看，它存在一个对称点：</p>
<ul>
<li>长度为奇数2n+1的字符串，对称点为第n+1个字符</li>
<li>长度为偶数2n的字符串，对称点为第n与n+1个字符之间，我们不妨命名为空白blank</li>
</ul>
<p>所以，我们就对字符串s进行遍历，查找它的<strong>每个对称点上最长的回文串</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> longest <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// 是否为空白</span></span><br><span class="line">	<span class="comment">// 我们把字符串s看作为： s[0]-blank-s[1]-...-s[n-1]</span></span><br><span class="line">	<span class="keyword">var</span> isBlank <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">var</span> mid <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> mid &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">		<span class="keyword">var</span> sub <span class="keyword">string</span></span><br><span class="line">		<span class="keyword">if</span> isBlank &#123;</span><br><span class="line">			<span class="comment">// 空白的话，我们认为这个空白是在mid-1和mid之间的，从两边开始对比</span></span><br><span class="line">			sub = findLongestPalindromeByMid(s, mid<span class="number">-1</span>, mid)</span><br><span class="line">			isBlank = <span class="literal">false</span></span><br><span class="line">			mid++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 非空白的话，从索引mid的两边开始对比</span></span><br><span class="line">			sub = findLongestPalindromeByMid(s, mid<span class="number">-1</span>, mid+<span class="number">1</span>)</span><br><span class="line">			isBlank = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(sub) &gt; <span class="built_in">len</span>(longest) &#123;</span><br><span class="line">			longest = sub</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> longest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLongestPalindromeByMid</span><span class="params">(s <span class="keyword">string</span>, left, right <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// left和right就是两个指针，不断往两边移动，直到找到不相同的两个字符</span></span><br><span class="line">	<span class="keyword">for</span> left &gt;= <span class="number">0</span> &amp;&amp; right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">		<span class="keyword">if</span> s[left] != s[right] &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		left--</span><br><span class="line">		right++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意这里的索引，很容易搞混，我们要取的是left+1到right-1，这里切片后面的索引为right</span></span><br><span class="line">	<span class="keyword">return</span> s[left+<span class="number">1</span> : right]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="简化空白的处理"><a href="#简化空白的处理" class="headerlink" title="简化空白的处理"></a>简化空白的处理</h3><p>从上面的代码来看，空白的处理挺麻烦，我们可以直接从代码结构去优化。</p>
<p>大家可以仔细的阅读<code>isBlank</code>相关的代码，可以直接消除这个变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> longest <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> mid <span class="keyword">int</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> mid &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="comment">// 对称点为某个字符，长度为奇数</span></span><br><span class="line">        sub := findLongestPalindromeByMid(s, mid<span class="number">-1</span>, mid)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(sub) &gt; <span class="built_in">len</span>(longest) &#123;</span><br><span class="line">            longest = sub</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对称点为空白，长度为偶数</span></span><br><span class="line">        sub = findLongestPalindromeByMid(s, mid<span class="number">-1</span>, mid+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(sub) &gt; <span class="built_in">len</span>(longest) &#123;</span><br><span class="line">            longest = sub</span><br><span class="line">        &#125;</span><br><span class="line">        mid++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLongestPalindromeByMid</span><span class="params">(s <span class="keyword">string</span>, left, right <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> left &gt;= <span class="number">0</span> &amp;&amp; right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">if</span> s[left] != s[right] &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        left--</span><br><span class="line">        right++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s[left+<span class="number">1</span>:right]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划是算法中大量出现的一个解法，我们以这道题为例，进行探索。</p>
<blockquote>
<p>动态规划的细节请自行搜索，如 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/39948290">https://www.zhihu.com/question/39948290</a> </p>
</blockquote>
<h3 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// 边界条件判断</span></span><br><span class="line">	length := <span class="built_in">len</span>(s)</span><br><span class="line">	<span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 回文子串至少为1，即单个字符</span></span><br><span class="line">	begin, maxLen := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="comment">// 动态规划的关键数组dp</span></span><br><span class="line">	<span class="keyword">var</span> dp = <span class="built_in">make</span>([][]<span class="keyword">bool</span>, length)</span><br><span class="line">	<span class="keyword">for</span> k1 := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[k1] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, length)</span><br><span class="line">		<span class="keyword">for</span> k2 := <span class="keyword">range</span> dp[k1] &#123;</span><br><span class="line">			<span class="comment">// 初始化均为false</span></span><br><span class="line">			dp[k1][k2] = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 单个字符默认为回文串</span></span><br><span class="line">		dp[k1][k1] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> size := <span class="number">2</span>; size &lt;= length; size++ &#123;</span><br><span class="line">		<span class="keyword">for</span> start := <span class="number">0</span>; start &lt;= length-size; start++ &#123;</span><br><span class="line">			end := start + size - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果首位字符串相同</span></span><br><span class="line">			<span class="keyword">if</span> s[start] == s[end] &#123;</span><br><span class="line">				<span class="keyword">if</span> size == <span class="number">2</span> &#123;</span><br><span class="line">					<span class="comment">// 边界情况，即只有2个字符且相等</span></span><br><span class="line">					dp[start][end] = <span class="literal">true</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 核心：动态规划的核心推导函数</span></span><br><span class="line">					dp[start][end] = dp[start+<span class="number">1</span>][end<span class="number">-1</span>]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 更新最长回文子串</span></span><br><span class="line">			<span class="keyword">if</span> dp[start][end] &amp;&amp; size &gt; maxLen &#123;</span><br><span class="line">				maxLen = size</span><br><span class="line">				begin = start</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s[begin : begin+maxLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最核心的公式为<code>dp[start][end] = dp[start+1][end-1]</code>，其余都是对边界条件的处理。</p>
<p>但运行结果的效率偏低</p>
<ul>
<li>执行用时：104 ms, 在所有 Go 提交中击败了42.53%的用户</li>
<li>内存消耗：7 MB, 在所有 Go 提交中击败了24.68%的用户</li>
</ul>
<h3 id="优化1-优化条件分支"><a href="#优化1-优化条件分支" class="headerlink" title="优化1 优化条件分支"></a>优化1 优化条件分支</h3><p>我们分析一下上面的代码：从空间复杂度来看，动态规划的数组<code>dp</code>是不可或缺的，所以减少内存消耗比较困难了。</p>
<p>因此，我们把目光放在执行时间上，那么重点就是<code>for</code>循环里的代码复杂度。</p>
<p>我们注意到一个关键的变量<code>dp[start][end]</code>，对它进行改造</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(s)</span><br><span class="line">	<span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	begin, maxLen := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> dp = <span class="built_in">make</span>([][]<span class="keyword">bool</span>, length)</span><br><span class="line">	<span class="keyword">for</span> k1 := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[k1] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, length)</span><br><span class="line">		<span class="keyword">for</span> k2 := <span class="keyword">range</span> dp[k1] &#123;</span><br><span class="line">			dp[k1][k2] = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		dp[k1][k1] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> size := <span class="number">2</span>; size &lt;= length; size++ &#123;</span><br><span class="line">		<span class="keyword">for</span> start := <span class="number">0</span>; start &lt;= length-size; start++ &#123;</span><br><span class="line">			end := start + size - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> s[start] == s[end] &#123;</span><br><span class="line">				<span class="keyword">if</span> size == <span class="number">2</span> || dp[start+<span class="number">1</span>][end<span class="number">-1</span>] &#123;</span><br><span class="line">					dp[start][end] = <span class="literal">true</span></span><br><span class="line">					<span class="comment">// 减少if-else的分支判断次数</span></span><br><span class="line">					<span class="keyword">if</span> size &gt; maxLen &#123;</span><br><span class="line">						maxLen = size</span><br><span class="line">						begin = start</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s[begin : begin+maxLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果很明显，代码执行时间减少</p>
<ul>
<li>执行用时：72 ms, 在所有 Go 提交中击败了50.93%的用户</li>
<li>内存消耗：7 MB, 在所有 Go 提交中击败了28.37%的用户</li>
</ul>
<h3 id="优化2-分析循环内代码执行逻辑"><a href="#优化2-分析循环内代码执行逻辑" class="headerlink" title="优化2 分析循环内代码执行逻辑"></a>优化2 分析循环内代码执行逻辑</h3><p>我们继续看代码里的<code>size &gt; maxLen</code>条件，发现会出现如下情况：</p>
<ul>
<li>如果一个字符有多个相同<code>size</code>的回文子串，这个<code>if</code>内的语句会被执行多次</li>
<li>但我们只需要获得最长的回文子串之一，所以只需要记录第一次即可</li>
</ul>
<p>于是我们尝试改造：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(s)</span><br><span class="line">	<span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	begin, maxLen := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> dp = <span class="built_in">make</span>([][]<span class="keyword">bool</span>, length)</span><br><span class="line">	<span class="keyword">for</span> k1 := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[k1] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, length)</span><br><span class="line">		<span class="keyword">for</span> k2 := <span class="keyword">range</span> dp[k1] &#123;</span><br><span class="line">			dp[k1][k2] = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		dp[k1][k1] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> size := <span class="number">2</span>; size &lt;= length; size++ &#123;</span><br><span class="line">		<span class="comment">// 用来表示对应size的字符串已经找到</span></span><br><span class="line">		founded := <span class="literal">false</span></span><br><span class="line">		<span class="keyword">for</span> start := <span class="number">0</span>; start &lt;= length-size; start++ &#123;</span><br><span class="line">			end := start + size - <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> s[start] == s[end] &#123;</span><br><span class="line">				<span class="keyword">if</span> size == <span class="number">2</span> || dp[start+<span class="number">1</span>][end<span class="number">-1</span>] &#123;</span><br><span class="line">					dp[start][end] = <span class="literal">true</span></span><br><span class="line">					<span class="comment">// 只记录第一个即可</span></span><br><span class="line">					<span class="keyword">if</span> !founded &amp;&amp; size &gt; maxLen &#123;</span><br><span class="line">						maxLen, begin = size, start</span><br><span class="line">						founded = <span class="literal">true</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s[begin : begin+maxLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：80 ms, 在所有 Go 提交中击败了49.30%的用户</li>
<li>内存消耗：7 MB, 在所有 Go 提交中击败了31.54%的用户</li>
</ul>
<p>然而，执行结果告诉我们这部分的优化无明显效果，甚至还降低了评分。但我们无需沮丧，<strong>因为这道题针对的是小规模场景的算法题，这个思路可能在大规模的计算场景下带来很明显的提升</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Leetcode第五题的难度不高，也让我们初次接触了 <strong>动态规划</strong> 这个思路。</p>
<p>同时，我们也遇到了一个<strong>“失败的优化案例”</strong>。这也从侧面告诉了我们，<strong>抛开具体场景的优化都是不可靠的</strong>。</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/14/go-leetcode/go-leetcode-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/14/go-leetcode/go-leetcode-3/" class="post-title-link" itemprop="url">Go算法实战 - 3.【无重复字符的最长子串LeetCode-3】</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-14 12:00:00" itemprop="dateCreated datePublished" datetime="2021-07-14T12:00:00+08:00">2021-07-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-15 15:02:07" itemprop="dateModified" datetime="2021-07-15T15:02:07+08:00">2021-07-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="Leetcode-3-无重复字符的最长子串"><a href="#Leetcode-3-无重复字符的最长子串" class="headerlink" title="Leetcode-3 无重复字符的最长子串"></a>Leetcode-3 无重复字符的最长子串</h2><p>原题链接 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="递归解题思路"><a href="#递归解题思路" class="headerlink" title="递归解题思路"></a>递归解题思路</h2><p>从函数签名<code>func lengthOfLongestSubstring(s string) int </code>来看，我们可以将问题拆分成子问题</p>
<ol>
<li>首字符<ol>
<li>包含s[0]的最长无重复子串</li>
<li>lengthOfLongestSubstring(s[1:n])</li>
</ol>
</li>
<li>尾字符<ol>
<li>lengthOfLongestSubstring(s[0:n-1])</li>
<li>包含s[n]的最长无重复子串</li>
</ol>
</li>
</ol>
<h3 id="利用首字符的递归问题"><a href="#利用首字符的递归问题" class="headerlink" title="利用首字符的递归问题"></a>利用首字符的递归问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// guard clauses，也就是卫语句，在递归中非常重要</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局的字符串，用于保存</span></span><br><span class="line">    <span class="keyword">var</span> mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := mp[s[i]]; ok &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// 找到重复的，直接退出</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mp[s[i]] = i <span class="comment">// 没找到重复的，加上这个子串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    length := lengthOfLongestSubstring(s[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">if</span> i &gt; length &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归的解法可读性较佳，但实际的时间复杂度会比较高，因为它的每一次 <strong>递归操作都要维护一个新的数据栈</strong>。</p>
<h2 id="非递归实现思路"><a href="#非递归实现思路" class="headerlink" title="非递归实现思路"></a>非递归实现思路</h2><h3 id="先用“笨办法”实现"><a href="#先用“笨办法”实现" class="headerlink" title="先用“笨办法”实现"></a>先用“笨办法”实现</h3><p>我们先不追求<strong>复杂度</strong>，先写一个简单的解法，搭建出解题框架：</p>
<p>从左往右看字符串s，如果我们限制了起始字符，然后逐个往右查找、找到第一个重复字符串，就是最长子串。</p>
<p>所以，如果s为<code>b1b2b3...bn</code>，它就能被拆解为 <strong>起始字符为<code>b1</code>，<code>b2</code>,<code>b3</code> …. <code>bn</code>这样n个子问题中的最大值</strong>。</p>
<p>于是，我们尝试写一下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 遍历s，以i作为起始点，找到最长的子串</span></span><br><span class="line">    <span class="comment">// 注意：在string中如果用range的方法遍历，类型不是byte，而是rune</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">        mp[s[i]] = i</span><br><span class="line">        <span class="comment">// j 作为一个从i往后移动的游标，找到第一个重复的词或者达到len(s)，也就是末尾</span></span><br><span class="line">        <span class="keyword">var</span> j <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(s); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> _, ok := mp[s[j]]; ok &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="comment">// 找到重复的，直接退出</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mp[s[j]] = j <span class="comment">// 没找到重复的，加上这个子串</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 算出以i为起点的最长子串</span></span><br><span class="line">        length := j - i</span><br><span class="line">        <span class="keyword">if</span> length &gt; max &#123;</span><br><span class="line">            max = length</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面存在一些边界条件的判定，需要大家认证思考。</p>
<h3 id="从核心map切入"><a href="#从核心map切入" class="headerlink" title="从核心map切入"></a>从核心map切入</h3><p>在上面的解法中，我们用到了一个<code>map[byte]int</code>，用来保存 <strong>字符与位置的映射关系</strong>。但在整个循环的过程中，我们反复地<code>var mp = make(map[byte]int)</code>创建了空间。</p>
<p>由于s是一个固定的字符串，我们可以换一个思路尝试，先写出一个纯过程式的代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 全局的字符串，用于保存</span></span><br><span class="line">    <span class="keyword">var</span> mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="comment">// Case1: 这是一个暂时未出现过的字符</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := mp[s[i]]; !ok &#123;</span><br><span class="line">            length := i - left + <span class="number">1</span> <span class="comment">// 到最左边的距离</span></span><br><span class="line">            <span class="keyword">if</span> length &gt; max &#123;</span><br><span class="line">                max = length</span><br><span class="line">            &#125;</span><br><span class="line">            mp[s[i]] = i <span class="comment">// 不存在的新元素，直接添加进来</span></span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// 打断逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Case2: 这是一个出现过的重复字符</span></span><br><span class="line">        length := i - left + <span class="number">1</span> <span class="comment">// 到最左边的距离</span></span><br><span class="line">        length2 := i - mp[s[i]] <span class="comment">// 到上一个重复字符串的距离</span></span><br><span class="line">        <span class="keyword">if</span> length &gt; length2 &#123;</span><br><span class="line">            length = length2 <span class="comment">// 取较短值</span></span><br><span class="line">            left = mp[s[i]] + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> length &gt; max &#123;</span><br><span class="line">            max = length</span><br><span class="line">        &#125;</span><br><span class="line">        mp[s[i]] = i <span class="comment">// 更新索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理一下最后一个字符串</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) - left &gt; max &#123;</span><br><span class="line">        max = <span class="built_in">len</span>(s) - left </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码的关键实现在于<strong>两个索引index</strong>：</p>
<ol>
<li><code>i</code>，用于遍历s</li>
<li><code>left</code>，0 &lt;= left &lt;= i，s[left:i]是<strong>不存在重复字符的字符串</strong>，其中left尽量取最小。换一个说法，s[left:i]是<strong>以s[i]为右节点的、无重复的、最长的子字符串</strong>。</li>
</ol>
<p>我们再回头看一下上面的代码，可读性有不少改进空间，我们尝试做一下优化，让可读性更好：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        length := i - left + <span class="number">1</span> <span class="comment">// 到最左边的距离</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := mp[s[i]]; ok &#123;</span><br><span class="line">            length2 := i - mp[s[i]] <span class="comment">// 到上一个重复字符串的距离</span></span><br><span class="line">            <span class="keyword">if</span> length &gt; length2 &#123;</span><br><span class="line">                length = length2</span><br><span class="line">                left = mp[s[i]] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> length &gt; max &#123;</span><br><span class="line">            max = length</span><br><span class="line">        &#125;</span><br><span class="line">        mp[s[i]] = i </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) - left &gt; max &#123;</span><br><span class="line">        max = <span class="built_in">len</span>(s) - left </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改动点并不大，但抽离了不少共性的代码，整体的性能有所提升。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面对<strong>明显可用递归方案解决</strong>的题目时，个人比较推荐的解题思路是：</p>
<ul>
<li><strong>用递归的解决方案理清思路，写出一个可用的方案，此时不要关注性能</strong></li>
<li><strong>从复杂度的角度思考，哪部分的工作是重复性的，提取出一个非递归的方案</strong></li>
</ul>
<p>如果一开始就去抠所谓的最佳方案，很容易陷入细节问题，而丢失了全局视野。</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/10/go-leetcode/go-leetcode-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/10/go-leetcode/go-leetcode-1/" class="post-title-link" itemprop="url">Go算法实战 - 1.【两数相加LeetCode-2】递归解法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-10 12:00:00" itemprop="dateCreated datePublished" datetime="2021-07-10T12:00:00+08:00">2021-07-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-11 12:32:17" itemprop="dateModified" datetime="2021-07-11T12:32:17+08:00">2021-07-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="Leetcode-2-两数相加"><a href="#Leetcode-2-两数相加" class="headerlink" title="Leetcode-2 两数相加"></a>Leetcode-2 两数相加</h2><p>原题链接 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="keyword">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了能保证代码都能执行，我会贴出所有代码，<strong>重点会用注释着重说明</strong>。</p>
<h2 id="递归实现的思路"><a href="#递归实现的思路" class="headerlink" title="递归实现的思路"></a>递归实现的思路</h2><h3 id="简化问题"><a href="#简化问题" class="headerlink" title="简化问题"></a>简化问题</h3><p>这道题的难点在于处理<strong>进位</strong>。那我们就先<strong>简化问题、把框架搭起来</strong>，看看先不考虑进位的大致代码怎么写的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// 先判断边界情况</span></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val</span><br><span class="line">        node.Next = addTwoNumbers(l1.Next, l2.Next)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val </span><br><span class="line">        node.Next = addTwoNumbers(l1.Next, l2)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val </span><br><span class="line">        node.Next = addTwoNumbers(l1, l2.Next)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这块代码有个问题- 当<code>l1</code>和<code>l2</code>都为空时，还会进入一次<code>addTwoNumbers</code>，导致最高位必定是0。</p>
<p>所以，我们需要保证<strong>最高位不要产生一个冗余，也就是l1和l2都为nil时，不要再进入addTwoNumbers函数</strong>。</p>
<h3 id="修复最高位的问题"><a href="#修复最高位的问题" class="headerlink" title="修复最高位的问题"></a>修复最高位的问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="comment">// 这里l1和l2作为指针传递下去</span></span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val </span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果都为空，无需继续处理</span></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续处理下一个节点</span></span><br><span class="line">    node.Next = addTwoNumbers(l1, l2)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="递归函数增加进位参数carry"><a href="#递归函数增加进位参数carry" class="headerlink" title="递归函数增加进位参数carry"></a>递归函数增加进位参数carry</h3><p>进位carry是一个在不同位中传递的参数，所以必须要加到函数签名中，所以我们得对递归函数进行改造。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的函数参数 carry</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val + carry</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + carry</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val + carry</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newCarry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> node.Val &gt; <span class="number">9</span> &#123;</span><br><span class="line">        node.Val = node.Val - <span class="number">10</span></span><br><span class="line">        newCarry = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; newCarry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, newCarry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="边界条件修复"><a href="#边界条件修复" class="headerlink" title="边界条件修复"></a>边界条件修复</h3><p>到了这里，我们看似完成了功能，但还有个边界条件没有修复：引入进位后，当<code>l1/l2</code>为nil，carry为1时，我们很容易就修复了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val + carry</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + carry</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val + carry</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        node.Val = carry <span class="comment">// 修复进位的边界问题</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newCarry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> node.Val &gt; <span class="number">9</span> &#123;</span><br><span class="line">        node.Val = node.Val - <span class="number">10</span></span><br><span class="line">        newCarry = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; newCarry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, newCarry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="持续优化"><a href="#持续优化" class="headerlink" title="持续优化"></a>持续优化</h2><p>首先，先明确一下优化的原则：</p>
<p><strong>我并不是单纯地为了提升性能而去优化，而是更应该从全局入手，考虑代码的可读性和扩展性！</strong></p>
<p>所以，下面的优化并不一定是性能最优的，但或多或少可能让你感受到代码的迭代升级。</p>
<h3 id="A-复用变量"><a href="#A-复用变量" class="headerlink" title="A - 复用变量"></a>A - 复用变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val + carry</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + carry</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val + carry</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.Val = carry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node.Val &gt; <span class="number">9</span> &#123;</span><br><span class="line">        node.Val = node.Val - <span class="number">10</span></span><br><span class="line">        carry = <span class="number">1</span> <span class="comment">// 复用carry变量</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; carry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, carry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除<code>newCarry</code>变量，节省了内存。</p>
<p>虽然这点改进很小，但我想表达的重点是：<strong>大家不要小看变量的复用，尤其是在一些递归调用的场景下，能节省大量的空间。</strong>上面的<code>l1</code>与<code>l2</code>这两个指针也进行了变量的复用。</p>
<h3 id="B-增加位操作，去除if-else分支"><a href="#B-增加位操作，去除if-else分支" class="headerlink" title="B - 增加位操作，去除if-else分支"></a>B - 增加位操作，去除if-else分支</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val + carry</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + carry</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val + carry</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.Val = carry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> <span class="comment">// 引入位操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; carry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, carry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="C-增加代码的扩展性（推荐）"><a href="#C-增加代码的扩展性（推荐）" class="headerlink" title="C - 增加代码的扩展性（推荐）"></a>C - 增加代码的扩展性（推荐）</h3><p>在这个代码里，我们只支持2个<code>ListNode</code>的相加，就引入了4个<code>if-else</code>的分支，这就很难支持大量<code>ListNode</code>的扩展。</p>
<p><strong>总体来说，我个人推荐这个解法，它的思路很清晰，也不会出现边界问题。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val += l1.Val</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val += l2.Val</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Val += carry</span><br><span class="line">    carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> <span class="comment">// 引入位操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; carry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, carry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实战化特性"><a href="#实战化特性" class="headerlink" title="实战化特性"></a>实战化特性</h2><p>在实际的项目中，我们会希望这个函数的扩展性能更好，例如支持多个输入参数。</p>
<h3 id="引入不定参数的特性"><a href="#引入不定参数的特性" class="headerlink" title="引入不定参数的特性"></a>引入不定参数的特性</h3><p>我们进一步改造成<strong>不定参数</strong>形式的函数签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(<span class="number">0</span>, l1, l2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不定参数必须是最后一个函数签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(carry <span class="keyword">int</span>, nodes ...*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">        <span class="keyword">if</span> nodes[k] != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += nodes[k].Val</span><br><span class="line">            nodes[k] = nodes[k].Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Val += carry</span><br><span class="line">    carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> <span class="comment">// 引入位操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断所有node是否为空</span></span><br><span class="line">    <span class="keyword">var</span> isEnd = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">        <span class="keyword">if</span> nodes[k] != <span class="literal">nil</span> &#123;</span><br><span class="line">            isEnd = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> isEnd &amp;&amp; carry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(carry, nodes...)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/10/go-leetcode/go-leetcode-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/10/go-leetcode/go-leetcode-2/" class="post-title-link" itemprop="url">Go算法实战 - 2.【两数相加LeetCode-2】非递归解法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-10 12:00:00" itemprop="dateCreated datePublished" datetime="2021-07-10T12:00:00+08:00">2021-07-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-13 10:56:50" itemprop="dateModified" datetime="2021-07-13T10:56:50+08:00">2021-07-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="Leetcode-2-两数相加"><a href="#Leetcode-2-两数相加" class="headerlink" title="Leetcode-2 两数相加"></a>Leetcode-2 两数相加</h2><p>原题链接 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></p>
<p>我们继续看上一个题目，这次我们尝试写一个非递归的解法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="keyword">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了能保证代码都能执行，我会贴出所有代码，<strong>重点会用注释着重说明</strong>。</p>
<blockquote>
<p>我个人认为，非递归比递归写法更加麻烦，所以放到了第二讲。一开始直接上手用非递归的解法，很容易迷失在 边界条件 和 循环条件 中，排查问题也比较麻烦。</p>
</blockquote>
<h2 id="非递归实现的思路"><a href="#非递归实现的思路" class="headerlink" title="非递归实现的思路"></a>非递归实现的思路</h2><h3 id="简化问题"><a href="#简化问题" class="headerlink" title="简化问题"></a>简化问题</h3><p>我们不考虑进位问题，看看大致的代码架构：</p>
<h3 id="不考虑进位的解法"><a href="#不考虑进位的解法" class="headerlink" title="不考虑进位的解法"></a>不考虑进位的解法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// 哨兵节点，也就是作为初始化的节点</span></span><br><span class="line">    <span class="comment">// 在单向链表时引入这个哨兵，有利于我们找到起始的点</span></span><br><span class="line">    <span class="keyword">var</span> sentinel = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="comment">// walker节点，也就是用于遍历的节点</span></span><br><span class="line">    <span class="keyword">var</span> walker = sentinel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l1.Val</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l2.Val</span><br><span class="line">            l2l1 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把node追加到后面，walker继续往后走</span></span><br><span class="line">        walker.Next = node</span><br><span class="line">        walker = walker.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentinel.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="增加进位参数carry"><a href="#增加进位参数carry" class="headerlink" title="增加进位参数carry"></a>增加进位参数carry</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sentinel = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> walker = sentinel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l1.Val</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        node.Val += carry</span><br><span class="line">        carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> <span class="comment">// 利用位操作</span></span><br><span class="line"></span><br><span class="line">        walker.Next = node</span><br><span class="line">        walker = walker.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentinel.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般情况下，<strong>非递归的实现会比递归的性能更高，但可读性较差</strong>。</p>
<ol>
<li>非递归减少了函数的堆栈，所以性能更高；</li>
<li>递归通过递归函数简化了复杂度，而非递归则需要循环；</li>
</ol>
<h2 id="持续优化"><a href="#持续优化" class="headerlink" title="持续优化"></a>持续优化</h2><h3 id="A-简单优化代码结构（推荐）"><a href="#A-简单优化代码结构（推荐）" class="headerlink" title="A - 简单优化代码结构（推荐）"></a>A - 简单优化代码结构（推荐）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sentinel = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> walker = sentinel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">        node.Val = carry <span class="comment">// 将carry直接放到初始化位置</span></span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l1.Val</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将两个指针赋值放在一起，含义比较清晰</span></span><br><span class="line">        <span class="comment">// 建议此类表达式尽量用于 多个强相关的变量 赋值，而不要贪图方便</span></span><br><span class="line">        walker.Next, walker = node, node </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentinel.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>内存消耗：4.7 MB, 在所有 Go 提交中击败了29.47%的用户</li>
</ul>
<h3 id="B-进一步节省空间"><a href="#B-进一步节省空间" class="headerlink" title="B - 进一步节省空间"></a>B - 进一步节省空间</h3><p>至此，其实我们的代码已经相当简洁了，但有同学追求更好的数据。</p>
<p>这里，我们可以看一下，因为<code>l1</code>和<code>l2</code>这两个链表相加后，新的链表长度肯定是大于这两者的。所以，我们可以尝试复用一下其中一个链表，节省一下内存空间。这里，我们尝试复用一下链表<code>l1</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> walker = l1</span><br><span class="line"></span><br><span class="line">    <span class="comment">// walker用于遍历l1，而l1指针自身不动，用于返回</span></span><br><span class="line">    <span class="keyword">for</span> walker != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Val += l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        walker.Val += carry </span><br><span class="line"></span><br><span class="line">        carry, walker.Val = walker.Val/<span class="number">10</span>, walker.Val%<span class="number">10</span> </span><br><span class="line">        walker = walker.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的整体逻辑是正确的，但存在边界问题：如果<code>l1</code>比<code>l2</code>短时，后续的元素怎么生成？</p>
<p>于是，我们就有了改进：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> walker = l1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> walker != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Val += l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        walker.Val += carry </span><br><span class="line"></span><br><span class="line">        carry, walker.Val = walker.Val/<span class="number">10</span>, walker.Val%<span class="number">10</span> </span><br><span class="line">        <span class="comment">// 当walker下个节点为nil时，但后续节点还需要继续遍历，就新建一个Node</span></span><br><span class="line">        <span class="keyword">if</span> walker.Next == <span class="literal">nil</span> &amp;&amp; (l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            walker.Next = <span class="built_in">new</span>(ListNode)</span><br><span class="line">        &#125;</span><br><span class="line">        walker = walker.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>内存消耗：4.4 MB, 在所有 Go 提交中击败了96.97%的用户</li>
</ul>
<h3 id="C-再次节省空间"><a href="#C-再次节省空间" class="headerlink" title="C - 再次节省空间"></a>C - 再次节省空间</h3><p>从上一个例子不难想到，我们还有继续优化的空间：如果<code>l2</code>比<code>l1</code>长时，我们想办法把walker节点指向<code>l2</code>，于是就有了下面的代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 由于两个链表均为非空，所以初始化会简单一点</span></span><br><span class="line">    <span class="keyword">var</span> sentinel = l1</span><br><span class="line">    <span class="keyword">var</span> walker = l1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// walker与l1为统一节点时，Val已经有值了</span></span><br><span class="line">            <span class="keyword">if</span> walker != l1 &#123;</span><br><span class="line">                walker.Val += l1.Val</span><br><span class="line">            &#125;</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> walker != l2 &#123;</span><br><span class="line">                walker.Val += l2.Val</span><br><span class="line">            &#125;</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        walker.Val += carry </span><br><span class="line"></span><br><span class="line">        carry, walker.Val = walker.Val/<span class="number">10</span>, walker.Val%<span class="number">10</span> </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里就是去找下一个walker节点，先看l1，再看l2，最后看carry位有没有</span></span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Next = l1</span><br><span class="line">            walker = walker.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Next = l2</span><br><span class="line">            walker = walker.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> carry &gt; <span class="number">0</span> &#123;</span><br><span class="line">            walker.Next = <span class="built_in">new</span>(ListNode)</span><br><span class="line">            walker = walker.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentinel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再次做一个简单的优化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> sentinel, walker = l1, l1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> walker != l1 &#123;</span><br><span class="line">                walker.Val += l1.Val</span><br><span class="line">            &#125;</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> walker != l2 &#123;</span><br><span class="line">                walker.Val += l2.Val</span><br><span class="line">            &#125;</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        walker.Val += carry </span><br><span class="line">        carry, walker.Val = walker.Val/<span class="number">10</span>, walker.Val%<span class="number">10</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Next = l1</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Next = l2</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> carry &gt; <span class="number">0</span> &#123;</span><br><span class="line">            walker.Next = <span class="built_in">new</span>(ListNode)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从循环中跳出，也就是l1/l2为nil,carry=0</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将上面三个判断分支中的共性提取出</span></span><br><span class="line">        walker = walker.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentinel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在解单向链表的问题时，<code>Sentinel哨兵</code> + <code>Walker遍历</code>是一个很好的组合。</p>
<ul>
<li><code>Sentinel</code>放在单向链表的起始，指向我们的链表，能解决很多初始情况问题，例如链表本身为<code>nil</code></li>
<li><code>Walker</code>是一个遍历指针，聚焦于<code>walker = walker.Next</code>这个关键的移动操作</li>
</ul>
<p>总体来说，非递归的代码可读性会比递归的差一点，比较考验程序员的解题思路。</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/09/go-tip/go-tip-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/09/go-tip/go-tip-6/" class="post-title-link" itemprop="url">Go语言技巧 - 6.【深入Go Module】探索最小版本选择的机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-09 12:00:00" itemprop="dateCreated datePublished" datetime="2021-07-09T12:00:00+08:00">2021-07-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-10 10:24:32" itemprop="dateModified" datetime="2021-07-10T10:24:32+08:00">2021-07-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg" alt="Go-Study"></p>
<h2 id="从一个示例讲起"><a href="#从一个示例讲起" class="headerlink" title="从一个示例讲起"></a>从一个示例讲起</h2><p>用一个简单列表来表示我们的模块A依赖：</p>
<ul>
<li>B1<code>v1.0.0</code><ul>
<li>C1<code>v1.1.0</code></li>
<li>C2 <code>v1.2.0</code></li>
</ul>
</li>
<li>B2 <code>v1.2.0</code><ul>
<li>C1<code>v1.1.2</code></li>
<li>C3 <code>v1.2.0</code></li>
</ul>
</li>
</ul>
<p>表示 <em>A依赖B1与B2，而B1又依赖C1、C2，B2依赖C1、C3</em>。</p>
<p>这里，我们把关注点放到有争议的C1，它存在两个版本<code>v1.1.0</code>与<code>v1.1.2</code>。而最终A选择的是<code>v1.1.2</code>版本的C1。</p>
<ul>
<li>B1<code>v1.0.0</code><ul>
<li><del>C1<code>v1.1.0</code></del></li>
<li>C2 <code>v1.2.0</code></li>
</ul>
</li>
<li>B2 <code>v1.2.0</code><ul>
<li>C1<code>v1.1.2</code></li>
<li>C3 <code>v1.2.0</code></li>
</ul>
</li>
</ul>
<h3 id="问题1：为什么要选择较高版本的C1？"><a href="#问题1：为什么要选择较高版本的C1？" class="headerlink" title="问题1：为什么要选择较高版本的C1？"></a>问题1：为什么要选择较高版本的C1？</h3><p>也许你会疑惑，为什么原则名字叫<strong>最小版本选择</strong>，但反而选择了较高那个版本呢？</p>
<p>我们要明确一点，<strong>最小版本选择</strong>这个概念不是应用在这个场景的！</p>
<p>从两个版本号的语义来看，<code>v1.1.2</code>和<code>v1.1.0</code>的主版本号都是<code>v1</code>，说明是向下兼容的。所以我们自然会选择较高的<code>v1.1.2</code>，毕竟如果用了<code>v1.1.0</code>，可能导致B2具体的代码不可用。</p>
<h3 id="问题2：如果同时出现了v1和v2怎么办？"><a href="#问题2：如果同时出现了v1和v2怎么办？" class="headerlink" title="问题2：如果同时出现了v1和v2怎么办？"></a>问题2：如果同时出现了v1和v2怎么办？</h3><p>如果场景变化，C1的依赖版本为<code>v1.1.0</code>和<code>v2.0.0</code>，也就是大版本发生了变化。</p>
<p>从版本号的语义来看，两者是<strong>不兼容</strong>的！所以，这时不会出现<strong>高版本覆盖低版本</strong>的情况。</p>
<p>这时，就会出现依赖2个版本的C1。</p>
<h3 id="问题3：那什么是最小版本选择中的“最小”呢？"><a href="#问题3：那什么是最小版本选择中的“最小”呢？" class="headerlink" title="问题3：那什么是最小版本选择中的“最小”呢？"></a>问题3：那什么是最小版本选择中的“最小”呢？</h3><p>在C1这个库中，我们能看到很多tag，例如<code>v1.1.0</code>，<code>v1.1.1</code>，<code>v1.1.2</code>，<code>v1.1.3</code>。而我们用到的是<code>v1.1.2</code>和<code>v1.1.0</code>。</p>
<p>从兼容性来看，<code>v1.1.3</code>肯定能兼容前面的版本。但这时，根据<strong>最小版本选择</strong>，我们引用到<code>v1.1.2</code>。</p>
<p>为什么要用这个最小版本原则，而不是每次都去拉取最新的tag？大家不妨思考思考，我这里列两个我能想到的点：</p>
<ol>
<li>保证项目依赖的稳定性：如果存在某个依赖库高频更新，会导致整个项目也频繁升级，造成风险；</li>
<li>完全向下兼容并不可靠：毕竟软件存在不稳定性，最新的tag很有可能会导致代码变更；</li>
</ol>
<h2 id="结合源码巩固知识点"><a href="#结合源码巩固知识点" class="headerlink" title="结合源码巩固知识点"></a>结合源码巩固知识点</h2><p>在阅读源码之前，我们先明确本次阅读源码的预期：<strong>不要为了掌握所有代码细节而读代码，而是希望能通过了解这部分功能的一个大致实现，巩固理论知识</strong>。</p>
<p>这里，我以<code>go语言1.15.11</code>版本为例，具体的代码路径在<code>src/cmd/go/internal/modcmd</code>下。</p>
<p><code>go mod tidy</code>是整理Go Module最常用的指令之一，这里我们就来看看<code>tidy.go</code>文件。</p>
<h3 id="tidy的简介"><a href="#tidy的简介" class="headerlink" title="tidy的简介"></a>tidy的简介</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cmdTidy = &amp;base.Command&#123;</span><br><span class="line">	UsageLine: <span class="string">&quot;go mod tidy [-v]&quot;</span>,</span><br><span class="line">	Short:     <span class="string">&quot;add missing and remove unused modules&quot;</span>,</span><br><span class="line">	Long: <span class="string">`</span></span><br><span class="line"><span class="string">Tidy makes sure go.mod matches the source code in the module.</span></span><br><span class="line"><span class="string">It adds any missing modules necessary to build the current module&#x27;s</span></span><br><span class="line"><span class="string">packages and dependencies, and it removes unused modules that</span></span><br><span class="line"><span class="string">don&#x27;t provide any relevant packages. It also adds any missing entries</span></span><br><span class="line"><span class="string">to go.sum and removes any unnecessary ones.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The -v flag causes tidy to print information about removed modules</span></span><br><span class="line"><span class="string">to standard error.</span></span><br><span class="line"><span class="string">	`</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tidy</code>主要是把缺失的module加入到模块中，并删除弃用的modules。加上<code>-v</code>的标记位，就能把信息打印到标注错误。</p>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p>核心的数据结构为，储存Go Module的路径Path和版本Version:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Version <span class="keyword">struct</span> &#123;</span><br><span class="line">	Path <span class="keyword">string</span></span><br><span class="line">	Version <span class="keyword">string</span> <span class="string">`json:&quot;,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而加载模块的代码，则是下面的<code>mvs.Req</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cmd/go/internal/mvs</span></span><br><span class="line">mvs.Req(Target, direct, &amp;mvsReqs&#123;buildList: keep&#125;)</span><br></pre></td></tr></table></figure>

<p>这个函数的功能，我进行了一定的简化，大家关注重点标注出来的几行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Req</span><span class="params">(target module.Version, base []<span class="keyword">string</span>, reqs Reqs)</span> <span class="params">([]module.Version, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 保存模块与其依赖module的map，用map是为了防止依赖库重复</span></span><br><span class="line">	reqCache := <span class="keyword">map</span>[module.Version][]module.Version&#123;&#125;</span><br><span class="line">	reqCache[target] = <span class="literal">nil</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第一次遍历：walk函数，用于遍历整个依赖</span></span><br><span class="line">	<span class="keyword">var</span> walk <span class="function"><span class="keyword">func</span><span class="params">(module.Version)</span> <span class="title">error</span></span></span><br><span class="line">	walk = <span class="function"><span class="keyword">func</span><span class="params">(m module.Version)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="comment">// 获取m的依赖库required，保存到map中</span></span><br><span class="line">		required, err := reqs.Required(m)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		reqCache[m] = required</span><br><span class="line">    <span class="comment">// 继续遍历依赖的依赖，保证不缺失</span></span><br><span class="line">		<span class="keyword">for</span> _, m1 := <span class="keyword">range</span> required &#123;</span><br><span class="line">			<span class="keyword">if</span> err := walk(m1); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		postorder = <span class="built_in">append</span>(postorder, m)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 真正运行第一次walk的地方</span></span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> list &#123;</span><br><span class="line">		<span class="keyword">if</span> err := walk(m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二次遍历：再次定义一个walk函数，取最大的版本号</span></span><br><span class="line">	have := <span class="keyword">map</span>[module.Version]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">	walk = <span class="function"><span class="keyword">func</span><span class="params">(m module.Version)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> have[m] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		have[m] = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> _, m1 := <span class="keyword">range</span> reqCache[m] &#123;</span><br><span class="line">			walk(m1)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	max := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> list &#123;</span><br><span class="line">		<span class="keyword">if</span> v, ok := max[m.Path]; ok &#123;</span><br><span class="line">      <span class="comment">// 只保存较大的版本号</span></span><br><span class="line">      <span class="comment">// 而v1与v2的问题也是在这里解决的：两者的Path路径不同</span></span><br><span class="line">			max[m.Path] = reqs.Max(m.Version, v)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			max[m.Path] = m.Version</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 真正运行第二次walk的地方</span></span><br><span class="line">	<span class="keyword">var</span> min []module.Version</span><br><span class="line">	<span class="keyword">for</span> _, path := <span class="keyword">range</span> base &#123;</span><br><span class="line">		m := module.Version&#123;Path: path, Version: max[path]&#125;</span><br><span class="line">		min = <span class="built_in">append</span>(min, m)</span><br><span class="line">		walk(m)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 根据名称排序</span></span><br><span class="line">	sort.Slice(min, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> min[i].Path &lt; min[j].Path</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> min, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>



<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>Minimal version selection (MVS)</strong> 的整体实现看起来不复杂，但其实里面做了很多兼容性的工作，尤其是<code>indirect</code>和<code>incompatible</code>等特性。这其实在另一层面提醒了我们：<strong>一项功能尽可能在前期做好设计，靠后期补救往往会增加大量兼容性的工作</strong>。</p>
<p>整个Go Module的核心实现在于2点：</p>
<ol>
<li>2个<code>walk</code>函数，一个用于查找所有依赖，另一个选择最大依赖版本；</li>
<li>选择最大依赖版本的核心依赖一个map，<code>max[m.Path] = reqs.Max(m.Version, v)</code></li>
</ol>
<p>至此，对Go Module的讲解告一段落了。而更多的细节问题，需要大家结合上一篇提到的排查问题工具，边实践、边加深理解。</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/03/go-tip/go-tip-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/03/go-tip/go-tip-5/" class="post-title-link" itemprop="url">Go语言技巧 - 5.【初探Go Module】Go语言的版本管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-07-03 12:00:00 / 修改时间：12:52:42" itemprop="dateCreated datePublished" datetime="2021-07-03T12:00:00+08:00">2021-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg" alt="Go-Study"></p>
<h2 id="Go-Mod的官方说明"><a href="#Go-Mod的官方说明" class="headerlink" title="Go Mod的官方说明"></a>Go Mod的官方说明</h2><p>Go语言自从推出了<code>go mod</code>作为版本管理工具后，结束Go语言版本管理工具的纷争，实现了大一统。</p>
<p>相信有很多人都对这个版本管理的机制都有基础的概念、但并不深入。而官方把最核心的实现，都放在这一篇 <a target="_blank" rel="noopener" href="https://golang.org/ref/mod">https://golang.org/ref/mod</a> 文档中。</p>
<p>今天，我们一起来读读这一篇文章。</p>
<h2 id="快速入门-5篇介绍Go-Mod系列的官方博客"><a href="#快速入门-5篇介绍Go-Mod系列的官方博客" class="headerlink" title="快速入门 - 5篇介绍Go Mod系列的官方博客"></a>快速入门 - 5篇介绍Go Mod系列的官方博客</h2><p>新手直接阅读这篇文章的门槛有点高，我建议可以先看看下面这五篇较为通俗的官方博客，能帮助我们了解一些背景知识。</p>
<h3 id="1-using-go-modules"><a href="#1-using-go-modules" class="headerlink" title="1. using-go-modules"></a>1. using-go-modules</h3><p><a target="_blank" rel="noopener" href="https://blog.golang.org/using-go-modules">https://blog.golang.org/using-go-modules</a> </p>
<ol>
<li><code>go.mod</code>放在项目的根目录，抛弃原来的<code>GOPATH</code></li>
<li>用<code>MAJOR.MINOR.PATCH</code>格式管理版本，详细可参考<a target="_blank" rel="noopener" href="https://semver.org/">Semantic Versioning 2.0.0</a></li>
<li>用<code>go.sum</code>保证依赖文件被完整下载（如果公司搭建私有库就会出现校验问题，需要关闭GOSUM）</li>
<li>项目内部的库，不再是相对路径，而用的是 <code>go mod模块名</code> + <code>相对路径</code> ，定义更加清晰</li>
</ol>
<blockquote>
<p>第四点的价值很大，可读性大大提高，我们可以将一整个path来辅助命名，如 market/order，前者market可以帮助后者order的含义做一定补充</p>
</blockquote>
<h3 id="2-migrating-to-go-modules"><a href="#2-migrating-to-go-modules" class="headerlink" title="2. migrating-to-go-modules"></a>2. migrating-to-go-modules</h3><p><a target="_blank" rel="noopener" href="https://blog.golang.org/migrating-to-go-modules">https://blog.golang.org/migrating-to-go-modules</a></p>
<p>将项目迁移到go mod，主要讲的是对接老的版本管理系统，如<code>godeps</code>。</p>
<h3 id="3-publishing-go-modules"><a href="#3-publishing-go-modules" class="headerlink" title="3. publishing-go-modules"></a>3. publishing-go-modules</h3><p><a target="_blank" rel="noopener" href="https://blog.golang.org/publishing-go-modules">https://blog.golang.org/publishing-go-modules</a></p>
<p>版本命名规则：推荐不稳定版本用<code>v0.x.x</code>开始，稳定后改成<code>v1.x.x</code>。</p>
<p><strong>pseudo-version</strong> 直译为假的版本，一般是直接依赖branch，而不是按规范依赖tag</p>
<h3 id="4-v2-go-modules"><a href="#4-v2-go-modules" class="headerlink" title="4. v2-go-modules"></a>4. v2-go-modules</h3><p><a target="_blank" rel="noopener" href="https://blog.golang.org/v2-go-modules">https://blog.golang.org/v2-go-modules</a></p>
<p>注意主版本名为<code>v2</code>之后的，项目里对应的要新增一个<code>v2</code>或者更高版本号的目录。</p>
<blockquote>
<p>我个人感觉升级到v2这种方式不太友好，需要我们再维护一整个目录</p>
</blockquote>
<h3 id="5-module-compatibility"><a href="#5-module-compatibility" class="headerlink" title="5. module-compatibility"></a>5. module-compatibility</h3><p><a target="_blank" rel="noopener" href="https://blog.golang.org/module-compatibility">https://blog.golang.org/module-compatibility</a></p>
<ol>
<li>用不定参数<code>...</code>的特性提高函数的入参扩展性</li>
<li>引入函数式的参数，也就是将具体的执行逻辑作为参数，传递进来</li>
<li>引入<code>Option types</code>模式，更详细地可以参考我的<a target="_blank" rel="noopener" href="https://junedayday.github.io/2021/02/20/go-patterns/go-patterns-5/">文章</a></li>
<li>用接口<code>interface</code>分离调用和实现</li>
<li>如果结构体<code>struct</code>明确不能对比，就用一个<code>doNotCompare</code>的<code>field</code>来告诉调用者</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> doNotCompare [<span class="number">0</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">        doNotCompare</span><br><span class="line">        X <span class="keyword">int</span></span><br><span class="line">        Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第五点非常有意思，也就是要求我们在前期设计对象时，就要考虑清楚这个对象后续的特性，比如示例中的是否可以对比</p>
</blockquote>
<h2 id="从go-mod的文件格式讲起"><a href="#从go-mod的文件格式讲起" class="headerlink" title="从go.mod的文件格式讲起"></a>从go.mod的文件格式讲起</h2><p>进入正题，我们来一起看看<code>go.mod</code>，它的定义简单示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module example.com/my/thing</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require example.com/other/thing v1.0.2</span><br><span class="line">require example.com/new/thing/v2 v2.3.4</span><br><span class="line">exclude example.com/old/thing v1.2.3</span><br><span class="line">replace example.com/bad/thing v1.4.5 =&gt; example.com/good/thing v1.4.5</span><br><span class="line">retract [v1.9.0, v1.9.5]</span><br></pre></td></tr></table></figure>

<p>IDE会帮助你格式化，记住以下关键词即可（重点为前三个）</p>
<ol>
<li><strong>module</strong> - go mod init指令定义的<strong>库名</strong></li>
<li><strong>go</strong> - <strong>要求go语言的最低版本</strong>，会影响到后面依赖库的下载</li>
<li><strong>require</strong> - <strong>必备库</strong>，也就是代码中直接import的部分</li>
<li><strong>replace</strong> - <strong>替换库</strong>，在重构时挺好用（比如某个开源组件有问题，内部fork了一版，直接replace即可）</li>
<li><strong>retract</strong> <strong>撤回版本</strong>，告诉调用本库的项目，部分版本有严重问题、不要引用</li>
</ol>
<blockquote>
<p>go mod 底层实现依赖 - <strong>MVS</strong> 最小版本选择。</p>
<p>这个特性很有意思，后续单独来讲讲这块，一开始就不深入到细节了</p>
</blockquote>
<h2 id="加深理解-incompatible和indirect"><a href="#加深理解-incompatible和indirect" class="headerlink" title="加深理解 - incompatible和indirect"></a>加深理解 - incompatible和indirect</h2><p>在我们整理<code>go.mod</code>文件时，经常能看到两个奇怪的字符<code>indirect</code>和<code>incompatible</code>。我们来详细地分析一下。</p>
<h3 id="incompatible-兼容v2及以上的版本号"><a href="#incompatible-兼容v2及以上的版本号" class="headerlink" title="incompatible - 兼容v2及以上的版本号"></a>incompatible - 兼容v2及以上的版本号</h3><p>上面我们已经讲过，如果一个库的tag为v1以上，如v2，就必须得创建一个v2的目录。例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require example.com/new/thing/v2 v2.3.4</span><br></pre></td></tr></table></figure>

<p>这就要求我们在项目<code>example.com/new/thing</code>下新建v2目录，再存放代码。但是，很多库往往只是升级个主版本号，并不会去新建目录、还需要迁移代码。为了兼容这个情况，就会引入<code>+incompatible</code>。例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require example.com/new/thing v2.3.4+incompatible</span><br></pre></td></tr></table></figure>

<h3 id="indirect-未在go-mod里定义、但间接调用的库"><a href="#indirect-未在go-mod里定义、但间接调用的库" class="headerlink" title="indirect - 未在go.mod里定义、但间接调用的库"></a>indirect - 未在go.mod里定义、但间接调用的库</h3><p>我们先聊一个简单的场景：<strong>当前项目为A，调用了项目B，B又调用了C。对A进行编译，需要B和C的相关代码</strong>。</p>
<p>在完全规范的项目中：</p>
<ul>
<li><strong>条件1</strong> - A的go.mod里包含B</li>
<li><strong>条件2</strong> - B的go.mod里包含C</li>
</ul>
<p>在编译A时，会在go.mod找到B的信息，所以B是<code>require</code>字段；而C的信息已经被维护在B的go.mod里了，不需要在A的go.mod里维护。</p>
<p>而什么样的情况会发生indirect呢？它对应的是 <strong>条件2</strong> 缺失的场景</p>
<ol>
<li>B<strong>没有启用Go Module</strong>，采用的是老项目管理方式</li>
<li>B的<strong>go.mod部分缺失</strong>，未填写模块C</li>
</ol>
<blockquote>
<p>最常见的部分缺失场景是：项目虽然有go.mod，但实际编译不走Go Module，而是如vendor目录等方式</p>
</blockquote>
<p>用一句话总结，<strong>A库无法根据B库的<code>go.mod</code>找到C库</strong>。</p>
<h2 id="常见命令介绍"><a href="#常见命令介绍" class="headerlink" title="常见命令介绍"></a>常见命令介绍</h2><p>相关的指令有很多，我重点分两块来说：</p>
<p>先是<strong>高频使用</strong>的命令：</p>
<h3 id="用go-mod-init初始化项目"><a href="#用go-mod-init初始化项目" class="headerlink" title="用go mod init初始化项目"></a>用go mod init初始化项目</h3><p>初始化项目，保证module名称与git路径一致。</p>
<p>例如 <code>go mod init github.com/example/a</code></p>
<h3 id="用go-get下载指定依赖库与版本"><a href="#用go-get下载指定依赖库与版本" class="headerlink" title="用go get下载指定依赖库与版本"></a>用go get下载指定依赖库与版本</h3><p>常见的flags</p>
<ul>
<li><strong>-d</strong> 只更新<code>go.mod</code>中的依赖，轻量级</li>
<li><strong>-u</strong> 更新指定库与依赖它的库，全量</li>
</ul>
<p>例如<code>go get -d github.com/example/b</code></p>
<h3 id="根据go-mod下载依赖库go-mod-download-vendor"><a href="#根据go-mod下载依赖库go-mod-download-vendor" class="headerlink" title="根据go.mod下载依赖库go mod download/vendor"></a>根据go.mod下载依赖库go mod download/vendor</h3><p>其中download是下载到Go Module的缓存中，而vendor是下载到vendor依赖路径。官方推荐前者。</p>
<p>我经常会去手动编辑<code>go.mod</code>文件，然后用这个指令刷新一下依赖库</p>
<h3 id="整理依赖go-mod-tidy"><a href="#整理依赖go-mod-tidy" class="headerlink" title="整理依赖go mod tidy"></a>整理依赖go mod tidy</h3><p>整理并更新go mod的依赖信息，保证当前的<code>go.mod</code>为最新。</p>
<p>然后是<strong>排查依赖库问题</strong>用到的：</p>
<h3 id="查看库的支持版本go-list"><a href="#查看库的支持版本go-list" class="headerlink" title="查看库的支持版本go list"></a>查看库的支持版本go list</h3><ul>
<li><code>go list -m all</code> 查看本项目的所有依赖库与版本</li>
<li><code>go list -m -versions &#123;module名&#125;</code> 查看module支持的版本号</li>
<li><code>go list -m -json &#123;module名&#125;@&#123;版本号&#125;</code> 用json格式查看指定module版本号的信息，如创建时间</li>
</ul>
<h3 id="查看当前库的依赖关系go-mod-graph"><a href="#查看当前库的依赖关系go-mod-graph" class="headerlink" title="查看当前库的依赖关系go mod graph"></a>查看当前库的依赖关系go mod graph</h3><p>查看所有go mod的依赖，一般在查依赖关系时用到</p>
<h3 id="查看指定库是怎么被依赖的go-mod-why"><a href="#查看指定库是怎么被依赖的go-mod-why" class="headerlink" title="查看指定库是怎么被依赖的go mod why"></a>查看指定库是怎么被依赖的go mod why</h3><p>查指定库是怎么被依赖的</p>
<h3 id="查看二进制文件的依赖信息go-version-m"><a href="#查看二进制文件的依赖信息go-version-m" class="headerlink" title="查看二进制文件的依赖信息go version -m"></a>查看二进制文件的依赖信息go version -m</h3><p>查看指定（go文件编译的）二进制文件的版本信息</p>
<h2 id="设置GOPRXOY"><a href="#设置GOPRXOY" class="headerlink" title="设置GOPRXOY"></a>设置GOPRXOY</h2><p>大部分人使用<code>go.mod</code>的最大问题是无法下载代码库，也就是代理的设置，网上也有很多教程，我这边给三个我常用的：</p>
<ol>
<li>阿里云：GOPROXY=<a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/goproxy,direct">https://mirrors.aliyun.com/goproxy,direct</a></li>
<li>七牛云：GOPROXY=<a target="_blank" rel="noopener" href="https://goproxy.cn,direct/">https://goproxy.cn,direct</a></li>
<li>全球代理：GOPROXY=<a target="_blank" rel="noopener" href="https://goproxy.io,direct/">https://goproxy.io,direct</a></li>
</ol>
<blockquote>
<p>公司私有库需要私有代理。</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本讲的内容到这里就告一段落了，相信通过这篇文章，大家已经能应对绝大部分Go Module的场景。</p>
<p>下一讲，我会重点讲Go Module最核心的 <strong>Minimal version selection (MVS)</strong> 机制。</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/27/go-tip/go-tip-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/27/go-tip/go-tip-4/" class="post-title-link" itemprop="url">Go语言技巧 - 4.【错误的三种处理】探索不同代码风格背后的哲学</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-27 12:00:00" itemprop="dateCreated datePublished" datetime="2021-06-27T12:00:00+08:00">2021-06-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-11 21:53:40" itemprop="dateModified" datetime="2021-07-11T21:53:40+08:00">2021-07-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg" alt="Go-Study"></p>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>通过前面两讲，我们对错误的认知已经超过很多人了。让我们继续去看看常见项目中对错误的处理方式，探索背后的深意。</p>
<p>在介绍具体的处理方式前，我们先来模拟一个场景：我们要去动物园进行一次游玩，主要行为有</p>
<ul>
<li>进入动物园</li>
<li>参观熊猫</li>
<li>参观老虎</li>
<li>离开动物园</li>
</ul>
<h2 id="第一种风格-经典Go语言的处理模式"><a href="#第一种风格-经典Go语言的处理模式" class="headerlink" title="第一种风格 - 经典Go语言的处理模式"></a>第一种风格 - 经典Go语言的处理模式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次旅游</span></span><br><span class="line"><span class="keyword">type</span> ZooTour1 <span class="keyword">interface</span> &#123;</span><br><span class="line">	Enter() error <span class="comment">// 进入</span></span><br><span class="line">	VisitPanda(panda *Panda) error <span class="comment">// 看熊猫</span></span><br><span class="line">	VisitTiger(tiger *Tiger) error <span class="comment">// 看老虎</span></span><br><span class="line">	Leave() error <span class="comment">// 离开</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tour1</span><span class="params">(t ZooTour1, panda *Panda, tiger *Tiger)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := t.Enter(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;Enter failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := t.VisitPanda(panda); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessagef(err, <span class="string">&quot;VisitPanda failed, panda is %v&quot;</span>, panda)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := t.VisitTiger(tiger); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessagef(err, <span class="string">&quot;VisitTiger failed, tiger is %v&quot;</span>, tiger)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := t.Leave(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;Leave failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个处理风格非常经典。我们先不深入讨论，看完下一种后再做对比。</p>
<h2 id="第二种风格-类似Try-Catch的代码风格"><a href="#第二种风格-类似Try-Catch的代码风格" class="headerlink" title="第二种风格 - 类似Try-Catch的代码风格"></a>第二种风格 - 类似Try-Catch的代码风格</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ZooTour2 <span class="keyword">interface</span> &#123;</span><br><span class="line">	Enter()</span><br><span class="line">	VisitPanda(panda *Panda)</span><br><span class="line">	VisitTiger(tiger *Tiger)</span><br><span class="line">	Leave()</span><br><span class="line"></span><br><span class="line">	Err() error <span class="comment">// 统一处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tour2</span><span class="params">(t ZooTour2, panda *Panda, tiger *Tiger)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	t.Enter()</span><br><span class="line">	t.VisitPanda(panda)</span><br><span class="line">	t.VisitTiger(tiger)</span><br><span class="line">	t.Leave()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := t.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;ZooTour failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一整块的代码风格非常类似<strong>Try Catch</strong>，即先写业务逻辑，在最后对错误进行集中处理。</p>
<blockquote>
<p>标准库中的<code>bufio.Scanner</code>就是参考这种方式实现的。</p>
</blockquote>
<p>不过，由于Go语言对error的处理没有往外抛的机制，所以需要专门针对error做处理：</p>
<blockquote>
<p>新手千万不要把panic的机制和错误处理混为一谈。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZooTour的具体实现，需要保存一个error</span></span><br><span class="line"><span class="keyword">type</span> myZooTour <span class="keyword">struct</span> &#123;</span><br><span class="line">	err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *myZooTour)</span> <span class="title">VisitPanda</span><span class="params">(panda *Panda)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 遇到错误就要直接返回，再处理其余逻辑</span></span><br><span class="line">	<span class="keyword">if</span> t.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="两种风格的对比"><a href="#两种风格的对比" class="headerlink" title="两种风格的对比"></a>两种风格的对比</h2><p>如果分别用一个词来形容前两种风格，我倾向于：</p>
<ol>
<li><strong>过程式的调用</strong></li>
<li><strong>集中处理错误</strong></li>
</ol>
<p>两种风格无法说清孰优孰劣，但有各自适宜的场景，我们来列举两种：</p>
<h3 id="不关注错误的发生，而关注错误发生后的统一处理"><a href="#不关注错误的发生，而关注错误发生后的统一处理" class="headerlink" title="不关注错误的发生，而关注错误发生后的统一处理"></a>不关注错误的发生，而关注错误发生后的统一处理</h3><p>内部存在大量的<code>VisitXXX</code>的函数，业务不关注发生错误的处理逻辑，而是关注整个流程完成后对error的处理。</p>
<p>例如，调用过程中如果出现了某个动物不在的问题，我们不关心，继续访问下一个，最后统一处理一下，看看有多少动物是不在的，打印一下即可。</p>
<p>这时，第二种处理方式明显会更简洁。</p>
<blockquote>
<p>一般推荐在工具类中采用这种方式，处理的内容比较直观，不会有太多异常case</p>
</blockquote>
<h3 id="错误有多种分类，会影响到程序的运行逻辑"><a href="#错误有多种分类，会影响到程序的运行逻辑" class="headerlink" title="错误有多种分类，会影响到程序的运行逻辑"></a>错误有多种分类，会影响到程序的运行逻辑</h3><p>例如<code>VisitPanda(panda *Panda)</code> 可能产生的错误分2类：</p>
<ul>
<li><p>不影响主流程：例如发现panda不见了，但还要接着继续参观其余动物</p>
</li>
<li><p>影响主流程：例如突然收到动物园闭园的通知，不能参观其余动物了</p>
</li>
</ul>
<p>这时，如果我们采用第二种风格，就得在每个函数内部加上很多特殊的业务逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *myZooTour)</span> <span class="title">VisitTiger</span><span class="params">(tiger *Tiger)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 要针对特定error进行处理</span></span><br><span class="line">	<span class="keyword">if</span> t.err != <span class="literal">nil</span> &amp;&amp; t.err != ErrorPandaMissing &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很有可能出现一个问题：<strong>把Panda相关的error放到了Tiger里</strong>。</p>
<p>所以，<strong>当错误的类型会影响到代码的运行逻辑，更适合第一种方案</strong>。</p>
<blockquote>
<p>一般情况下，我们的业务代码都是复杂的，这时候更适合写过程性的代码。</p>
</blockquote>
<h2 id="第三种风格-函数式编程"><a href="#第三种风格-函数式编程" class="headerlink" title="第三种风格 - 函数式编程"></a>第三种风格 - 函数式编程</h2><p>借用1中的接口定义，我们将它改造成函数式的风格：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFunc <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEnterFunc</span><span class="params">()</span> <span class="title">MyFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.Enter()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewVisitPandaFunc</span><span class="params">(panda *Panda)</span> <span class="title">MyFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.VisitPanda(panda)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewVisitTigerFunc</span><span class="params">(tiger *Tiger)</span> <span class="title">MyFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.VisitTiger(tiger)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLeaveFunc</span><span class="params">()</span> <span class="title">MyFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.Leave()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用代码示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tour3</span><span class="params">(t ZooTour1, panda *Panda, tiger *Tiger)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> actions = []MyFunc&#123;</span><br><span class="line">		NewEnterFunc(),</span><br><span class="line">		NewVisitPandaFunc(panda),</span><br><span class="line">		NewVisitTigerFunc(tiger),</span><br><span class="line">		NewLeaveFunc(),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ContinueOnError(t, actions)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContinueOnError</span><span class="params">(t ZooTour1, funcs []MyFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">    <span class="keyword">if</span> err := f(t);err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// continue</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BreakOnError</span><span class="params">(t ZooTour1, funcs []MyFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">    <span class="keyword">if</span> err := f(t);err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提的是</p>
<ul>
<li><code>ContinueOnError</code>表示遇到了error只记录下来，但整个流程继续往下跑</li>
<li><code>BreakOnError</code>表示遇到了error就直接break，不再跑接下来的<code>MyFunc</code></li>
</ul>
<h2 id="方案三背后的思想与延伸"><a href="#方案三背后的思想与延伸" class="headerlink" title="方案三背后的思想与延伸"></a>方案三背后的思想与延伸</h2><p>函数式编程最直观的一个特点是 <strong>延迟执行</strong>，也就是在引用<code>MyFunc</code>处不运行，在<code>ContinueOnError</code>或<code>BreakOnError</code>里才是真正执行的地方。</p>
<p>这个延迟执行的特性，在这里还能达到一个很有意思的效果 - <strong>分离关注点</strong>。</p>
<h3 id="关注点1-数据结构"><a href="#关注点1-数据结构" class="headerlink" title="关注点1 - 数据结构"></a>关注点1 - 数据结构</h3><p>样例中的<code>[]MyFunc</code>是一个切片，可以简单地理解为<strong>串行执行</strong>，也就是<code>MyFunc</code>执行完一个，再执行下一个。</p>
<p>我们可以引入更多的数据结构，例如<code>[][]MyFunc</code>，那就可以理解为增加了一层：</p>
<p>每一层中的<code>[]MyFunc</code>，代表这里面的所有<code>MyFunc</code>是平级的，也就可以采用一定的并发模式来加速执行。</p>
<h3 id="关注点2-执行逻辑"><a href="#关注点2-执行逻辑" class="headerlink" title="关注点2 - 执行逻辑"></a>关注点2 - 执行逻辑</h3><p>以<code>ContinueOnError</code>或<code>BreakOnError</code>为例，它们都是对各种<code>MyFunc</code>的处理逻辑。我们还可以引入更多的执行逻辑，比如：</p>
<ul>
<li>容忍特定错误的情况</li>
<li>对错误发生的数量有容忍上限</li>
<li>保证一定的并发模式</li>
</ul>
<h3 id="流水线的模式"><a href="#流水线的模式" class="headerlink" title="流水线的模式"></a>流水线的模式</h3><p>以我们常见的开发流水线为例，常见的包括：代码检查、单元测试、编译、CodeReview、自动化部署等。</p>
<p>这时，数据结构可以用来表示<strong>流水线的结构</strong>，执行逻辑可以用来表示<strong>流水线对异常的处置</strong>。</p>
<p>比如说，我们可以编排为一种串行执行的逻辑：</p>
<ol>
<li>代码检查</li>
<li>单元测试</li>
<li>编译</li>
<li>CodeReview</li>
<li>自动化部署</li>
</ol>
<p>我们想要加速整个流程，可以考虑修改为：</p>
<ol>
<li>检查<ol>
<li>代码检查</li>
<li>单元测试</li>
<li>编译</li>
</ol>
</li>
<li>CodeReview</li>
<li>自动化部署</li>
</ol>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文介绍了三种对error的处理方式，代码实现相对简单，大家更需要关注背后的适用场景。</p>
<p>其中，第三种方式是一个很有意思的设计模式，可以帮助大家理解函数式编程的价值。</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junedayday</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

<div class=BbeiAn-info">
  浙ICP备 -
  <a target="_blank" rel="noopener" href="http://www.miitbeian.gov.cn/">19051676号-1</a>
  </a>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  















  








  

  

</body>
</html>
