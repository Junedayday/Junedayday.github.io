<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Junedayday Blog</title>
  
  <subtitle>六月天天的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-12-28T13:59:26.848Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Junedayday</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go-Buf教程 - 0.总览</title>
    <link href="http://example.com/2022/12/28/go-buf/go-buf-0/"/>
    <id>http://example.com/2022/12/28/go-buf/go-buf-0/</id>
    <published>2022-12-28T04:00:00.000Z</published>
    <updated>2022-12-28T13:59:26.848Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><p><code>buf</code>是一个很棒的基于<code>protobuf</code>来建立微服务API体系的工具。</p><p>我个人是<code>buf</code>的重度用户，并已在多个企业级的项目中落地。但是，鉴于<code>buf</code>以下三个特点，网上的相关教程很少：</p><ol><li>资料基本由英文文档构成</li><li>更新迭代快，有很多新增或已过时的特性</li><li>有一定的技术门槛（如熟悉<code>protobuf</code>生态）</li></ol><p>今天开始，我将以<code>Go</code>语言为背景，开启一个<code>buf</code>套件相关的教程。整个教程会分为四大篇章，分别回答以下问题：</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/buf-0.png"></p><span id="more"></span><p>本文将作为索引篇章，持续更新，帮助大家快速找到想要看的内容。</p><p>通过本教程，你将获得：</p><ul><li>掌握<code>buf</code>工具为代表的高效RPC框架（微服务框架的核心）</li><li><code>Go</code>语言的实战讲解</li><li>编程设计思想</li></ul><p>以下为本系列的目录：</p><ul><li>背景篇</li><li>入门篇</li><li>实战篇</li><li>高级篇</li></ul><p>欢迎有疑问的小伙伴可以通过下面的联系方式和我交流。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;buf&lt;/code&gt;是一个很棒的基于&lt;code&gt;protobuf&lt;/code&gt;来建立微服务API体系的工具。&lt;/p&gt;
&lt;p&gt;我个人是&lt;code&gt;buf&lt;/code&gt;的重度用户，并已在多个企业级的项目中落地。但是，鉴于&lt;code&gt;buf&lt;/code&gt;以下三个特点，网上的相关教程很少：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;资料基本由英文文档构成&lt;/li&gt;
&lt;li&gt;更新迭代快，有很多新增或已过时的特性&lt;/li&gt;
&lt;li&gt;有一定的技术门槛（如熟悉&lt;code&gt;protobuf&lt;/code&gt;生态）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天开始，我将以&lt;code&gt;Go&lt;/code&gt;语言为背景，开启一个&lt;code&gt;buf&lt;/code&gt;套件相关的教程。整个教程会分为四大篇章，分别回答以下问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/buf-0.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Buf" scheme="http://example.com/tags/Go-Buf/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习 - RPC篇:gRPC-Gateway定制mux选项</title>
    <link href="http://example.com/2022/12/27/go-study/go-rpc-6/"/>
    <id>http://example.com/2022/12/27/go-study/go-rpc-6/</id>
    <published>2022-12-27T04:00:00.000Z</published>
    <updated>2022-12-28T13:24:41.573Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>通过上一讲，我们对gRPC的拦截器有了一定的认识，也能定制出很多通用的中间件。</p><p>但在大部分的业务系统中，我们面向的还是HTTP协议。那么，今天我们就从gRPC-Gateway的mux选项出发，一起来看看一些很实用的特性。</p><span id="more"></span><h2 id="ServeMux"><a href="#ServeMux" class="headerlink" title="ServeMux"></a>ServeMux</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/grpc-ecosystem/grpc-gateway/v2/runtime&quot;</span></span><br><span class="line"></span><br><span class="line">gwMux := runtime.NewServeMux()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServeMux</span><span class="params">(opts ...ServeMuxOption)</span> *<span class="title">ServeMux</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将目标聚焦于这个<code>ServeMux</code>：</p><ol><li>目前官方区分v1和v2版本，版本不一致会导致很多编译上的问题</li><li>入参包括多个<code>option</code>选项函数，用于定制想要的mux内容</li></ol><p>具体的内容可以参考<code>ServeMux</code>的数据结构，我这里挑选几个重点的能力：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 这个是server的核心实现：即注册的handlerf</span></span><br><span class="line">handlers                  <span class="keyword">map</span>[<span class="keyword">string</span>][]handler</span><br><span class="line">  <span class="comment">// 1、转发正常响应</span></span><br><span class="line">forwardResponseOptions    []<span class="function"><span class="keyword">func</span><span class="params">(context.Context, http.ResponseWriter, proto.Message)</span> <span class="title">error</span></span></span><br><span class="line">  <span class="comment">// 2、序列化工具</span></span><br><span class="line">marshalers                marshalerRegistry</span><br><span class="line">  <span class="comment">// 3、进入时（http-&gt;grpc）的header匹配规则</span></span><br><span class="line">incomingHeaderMatcher     HeaderMatcherFunc</span><br><span class="line">  <span class="comment">// 4、返回时（grpc-&gt;http）的header匹配规则</span></span><br><span class="line">outgoingHeaderMatcher     HeaderMatcherFunc</span><br><span class="line">  <span class="comment">// 5、metadata的转换（从http转成grpc的md）</span></span><br><span class="line">metadataAnnotators        []<span class="function"><span class="keyword">func</span><span class="params">(context.Context, *http.Request)</span> <span class="title">metadata</span>.<span class="title">MD</span></span></span><br><span class="line">  <span class="comment">// 6、错误处理</span></span><br><span class="line">errorHandler              ErrorHandlerFunc</span><br><span class="line">  <span class="comment">// 7、流式错误处理</span></span><br><span class="line">streamErrorHandler        StreamErrorHandlerFunc</span><br><span class="line">  <span class="comment">// 8、路由错误</span></span><br><span class="line">routingErrorHandler       RoutingErrorHandlerFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合一下，核心能力其实包括2块：</p><ol><li>Header数据的处理</li><li>返回消息的处理（包括正常情况和错误情况）</li></ol><h2 id="Header的数据处理"><a href="#Header的数据处理" class="headerlink" title="Header的数据处理"></a>Header的数据处理</h2><h3 id="HTTP与gRPC协议头匹配"><a href="#HTTP与gRPC协议头匹配" class="headerlink" title="HTTP与gRPC协议头匹配"></a>HTTP与gRPC协议头匹配</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTTP -&gt; gRPC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithIncomingHeaderMatcher</span><span class="params">(fn HeaderMatcherFunc)</span> <span class="title">ServeMuxOption</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gRPC -&gt; HTTP</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithOutgoingHeaderMatcher</span><span class="params">(fn HeaderMatcherFunc)</span> <span class="title">ServeMuxOption</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HeaderMatcherFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure><p>这个函数只做一个简单的映射，我们可以通过下面的例子开快速了解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入参：header key</span></span><br><span class="line"><span class="comment">// 出参：返回header key，以及是否返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CustomMatcher</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> key &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;some-special-key&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> key, <span class="literal">true</span> </span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;deprecated-key&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">false</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 默认的匹配规则</span></span><br><span class="line"><span class="keyword">return</span> runtime.DefaultHeaderMatcher(key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将HTTP头转成gRPC头"><a href="#将HTTP头转成gRPC头" class="headerlink" title="将HTTP头转成gRPC头"></a>将HTTP头转成gRPC头</h3><p>上面的<code>matcher</code>只是做一个key的映射，如果<code>Header</code>里包括更复杂的部分（例如Cookie），需要引入下面函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithMetadata</span><span class="params">(annotator <span class="keyword">func</span>(context.Context, *http.Request)</span> <span class="title">metadata</span>.<span class="title">MD</span>) <span class="title">ServeMuxOption</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(serveMux *ServeMux)</span></span> &#123;</span><br><span class="line">serveMux.metadataAnnotators = <span class="built_in">append</span>(serveMux.metadataAnnotators, annotator)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意两个点：</p><ol><li>只做协议转换，不做逻辑处理（逻辑处理交给gRPC层的中间件统一处理）</li><li><code>metadata.MD</code>的底层数据结构为<code>map[string][]string</code>，与HTTP Header很类似</li></ol><p>下面给出一个HTTP的Cookie处理示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  HTTP_COOKIE_TOKEN = <span class="string">&quot;http_cookie&quot;</span></span><br><span class="line">  MD_TOKEN = <span class="string">&quot;md_cookie&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleCookieMetadataAnnotator</span><span class="params">(ctx context.Context, r *http.Request)</span> <span class="params">(md metadata.MD)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 从HTTP的cookie中读出对应的数据</span></span><br><span class="line">  c, err := r.Cookie(ODIN_JWT_TOKEN)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将值放到md里，方便在后续提取</span></span><br><span class="line"><span class="keyword">return</span> metadata.Pairs(MD_TOKEN, c.Value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回数据处理"><a href="#返回数据处理" class="headerlink" title="返回数据处理"></a>返回数据处理</h2><h3 id="正确返回"><a href="#正确返回" class="headerlink" title="正确返回"></a>正确返回</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithForwardResponseOption</span><span class="params">(forwardResponseOption <span class="keyword">func</span>(context.Context, http.ResponseWriter, proto.Message)</span> <span class="title">error</span>) <span class="title">ServeMuxOption</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确返回时，核心的数据结构为 <code>protoMessage</code>。我们不妨做一个封装：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HTTPResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">Errno <span class="keyword">int</span>         <span class="string">`json:&quot;errno&quot;`</span></span><br><span class="line">Msg   <span class="keyword">string</span>      <span class="string">`json:&quot;msg&quot;`</span></span><br><span class="line">Data  <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GatewayResponseModifier</span><span class="params">(ctx context.Context, w http.ResponseWriter, resp proto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 返回的数据，在外层同一封装了数据结构HTTPResponse，对一些历史项目兼容有很棒的效果</span></span><br><span class="line">  newResp := &amp;HTTPResponse&#123;</span><br><span class="line">    Data: resp,</span><br><span class="line">  &#125;</span><br><span class="line">pbData, _ := json.Marshal(newResp)</span><br><span class="line">  w.Write(pbData)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误返回"><a href="#错误返回" class="headerlink" title="错误返回"></a>错误返回</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithErrorHandler</span><span class="params">(fn ErrorHandlerFunc)</span> <span class="title">ServeMuxOption</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误处理在整个RPC框架中扮演了非常重要的角色，我们不妨通过如下例子来了解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GatewayErrModifier</span><span class="params">(ctx context.Context, mux *runtime.ServeMux, m runtime.Marshaler, w http.ResponseWriter, r *http.Request, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 提取error</span></span><br><span class="line">s, ok := status.FromError(err)</span><br><span class="line"><span class="comment">// 非标准错误</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">runtime.DefaultHTTPErrorHandler(ctx, mux, m, w, r, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对各类错误增加定制的逻辑</span></span><br><span class="line"><span class="keyword">switch</span> s.Code() &#123;</span><br><span class="line"><span class="keyword">case</span> codes.Unauthenticated:</span><br><span class="line"><span class="comment">// 示例：认证失败，可以加入重定向的逻辑</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">runtime.DefaultHTTPErrorHandler(ctx, mux, m, w, r, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下重点：</p><ol><li><code>error</code>尽可能用<code>gRPC</code>标准的错误<code>Status</code>表示</li><li><code>gRPC</code>的标准错误，对错误码code有一套定义（参考<code>google.golang.org/grpc/codes</code>），类似于<code>HTTP</code>的状态码</li><li>错误码code要尽量少，过多没有意义<ol><li>标准错误码尽可能复用，如资源找不到、权限不足等</li><li>业务错误码可以独立，一般一个系统定义1个即可</li></ol></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文重点介绍了<code>gRPC-Gateway</code>中2类<code>ServeMux</code>，也演示了对应的示例，大家能理解其基本用法即可。</p><p>后续，随着整体项目的落地，我会增加一些日常项目中常见的定制需求，帮助大家更好地认识RPC框架的能力。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;通过上一讲，我们对gRPC的拦截器有了一定的认识，也能定制出很多通用的中间件。&lt;/p&gt;
&lt;p&gt;但在大部分的业务系统中，我们面向的还是HTTP协议。那么，今天我们就从gRPC-Gateway的mux选项出发，一起来看看一些很实用的特性。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 17.【Go工程化测试】业务项目中的Go单元测试心得</title>
    <link href="http://example.com/2022/12/06/go-tip/go-tip-17/"/>
    <id>http://example.com/2022/12/06/go-tip/go-tip-17/</id>
    <published>2022-12-06T04:00:00.000Z</published>
    <updated>2022-12-07T14:23:57.623Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>在网上搜索 <strong>Go单元测试</strong>，我们能找到各种开源工具和方法技巧，也可以照葫芦画瓢、快速地写出示例test case。但回到具体的工程项目里，当我们面对代码里的各种CRUD、接口与实现、内外部依赖时，往往发现很难写出有效的单元测试，空有一身技巧却无从下手。</p><p>我也被这个问题困扰许久，也反复在多个项目里折腾，发现要将单元测试落地到项目中，有一条被忽视的<code>gap</code>。下面我分享一下个人的思路。</p><p>Go单元测试的具体语法，本文会一笔带过，想了解细节的同学可以自行搜索。</p><span id="more"></span><h2 id="0-从业务项目的分层聊起"><a href="#0-从业务项目的分层聊起" class="headerlink" title="0. 从业务项目的分层聊起"></a>0. 从业务项目的分层聊起</h2><p>本文暂不讨论工具类项目，而是聚焦于结构相对复杂的业务类项目。</p><blockquote><p>偏基础工具类的代码库，写单元测试的逻辑会比较直观，也更注重性能等场景。</p></blockquote><p>业务项目通常会进行分层，本文以一个简化后的三层结构为例：</p><ul><li>请求/响应处理层 - Controller</li><li>业务领域层 - Service（Domain/Logic）</li><li>数据访问层 - Dao（Model）</li></ul><blockquote><p>很多复杂的分层可认为是上面的的一种变体。</p></blockquote><p>写Go单元测试的具体语法，本文会一笔带过，想了解细节的同学可以自行搜索。</p><h2 id="1-单元测试的外部依赖问题"><a href="#1-单元测试的外部依赖问题" class="headerlink" title="1. 单元测试的外部依赖问题"></a>1. 单元测试的外部依赖问题</h2><p>在业务开发时，有句玩笑话：如果你坚持写单测，最终会变成Postman工程师。虽然这话带有戏谑的色彩，但我们不妨想想它背后的逻辑：</p><h3 id="1-1-从“捷径”到放弃"><a href="#1-1-从“捷径”到放弃" class="headerlink" title="1.1 从“捷径”到放弃"></a>1.1 从“捷径”到放弃</h3><p>一个项目中的代码是层层调用的，我们以一个满足上述分层的服务为例：</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-unittest-func.png"></p><p>从调用栈来看，写一个顶层函数的单测，既能包括本层代码、又能覆盖下面各层，在最上层（Controller）写单元测试似乎成了最优解。这时，开发者会遇到一个常见问题 - <strong>代码的层层调用，很难屏蔽外部的依赖项</strong>，尤其是MySQL/Redis等中间件和自研服务。</p><p>接下来是我的经历，相信能引起不少人的共鸣：</p><p><strong>阶段一：依赖测试环境的服务写单测，立杆见影地跑通单测、覆盖率也不错。</strong></p><blockquote><p>我的想法：“巧妙的变通”</p><p>虽说从单元测试的定义来说，不应依赖外部服务，但不妨把这当作是一种变通，又快又方便。</p></blockquote><p><strong>阶段二：外部服务引入的问题越来越多，严格检查结果的单测很难通过，只能不断删减检查项，导致单测的质量和覆盖率越来越差。</strong></p><blockquote><p>我的想法：对外部环境不得已的“妥协”</p><p>外部服务既不稳定，又往往是有状态的，很难支撑单元测试里的各种case。单测能跑通总比跑不通好，单测质量下降并不是我偷懒，而是外部因素的不可控。</p></blockquote><p><strong>阶段三：单测能发现的问题越来越少，还不如用Postman手动请求并观察结果来得有效。食之无味，弃之可惜，单测就只作为评估绩效的指标了。</strong></p><blockquote><p>我的想法：复杂业务项目里的单元测试没什么价值，就仅仅作为一个绩效指标算了。</p><p>对项目来说，单测失去了发现问题的能力；对开发者来说，那就只是应付性地去达成单测覆盖率的指标了。</p></blockquote><p>所以，为了保证单测的价值长期有效，我们要 <strong>尽可能地屏蔽外部系统的依赖</strong>；而对外部依赖的测试，尽可能地交由更高层面的接口测试、功能测试、系统联调等途径去保障。</p><h3 id="1-2-如何屏蔽外部依赖"><a href="#1-2-如何屏蔽外部依赖" class="headerlink" title="1.2 如何屏蔽外部依赖"></a>1.2 如何屏蔽外部依赖</h3><p>屏蔽外部依赖，业界主要有两种解法：</p><ol><li><strong>容器技术</strong> - 将外部依赖转为内部项，跟随单元测试的生命周期</li><li><strong>代码mock</strong> - 拦截对外部依赖的调用，获得可预期的返回结果</li></ol><p>第一个解法比较取巧，本质上仍是依赖外部服务，只是由单元测试掌控它们的生命周期。这种方案对于验证中间件相关的功能确实非常方便，但长期维护的成本不低，慎用。（后文会再次提及）</p><p>第二个解法是单元测试最为推荐的方式，即常说的 mock/打桩。mock的具体方案依赖编程语言、框架以及对应的生态。例如在<code>Spring</code>里写单测很方便，包括：</p><ol><li>底层JVM强大的运行时能力</li><li>Spring的依赖注入</li><li>社区中成熟的各中间件Mock</li></ol><p>而Go语言在这块并没有得天独厚的优势。下面，我分享一个社区中比较推荐的解法。</p><h3 id="1-3-适配Go语言的单测方案"><a href="#1-3-适配Go语言的单测方案" class="headerlink" title="1.3 适配Go语言的单测方案"></a>1.3 适配Go语言的单测方案</h3><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-unittest-di.png"></p><p>图中的重点内容如下：</p><ol><li>三个虚箭头<ol><li>Service层的对象依赖Dao层的接口</li><li>Dao层接口的业务实现，由开发者自行编写代码</li><li>Dao层接口的mock实现，由 <a href="https://github.com/golang/mock">gomock</a> 自动生成</li></ol></li><li>依赖注入DI<ol><li>业务对象在初始化时注入想要的实现，遵循<code>IoC</code>的设计原则</li><li>正常情况下，注入业务实现；单元测试时，注入mock实现</li><li>一般可利用google的<a href="https://github.com/google/wire">wire</a>工具来自动化地生成依赖注入的代码</li></ol></li></ol><p>Mock实现无需依赖外部，我们利用面向对象的特性轻松地解决了这个问题。在复杂的工程中，还应注意两点：</p><ol><li>DI应和业务的抽象结合起来，不要只当作单纯的一种解耦的工具。</li><li>业务领域层往往内部也会分为多层（参考DDD），优先梳理上下文关系，才能设计好DI的实现。</li></ol><blockquote><p>DI是一个非常重要的解耦手段，但Go语言的框架无法强限制，往往只能靠“制定规范”， 如 <a href="https://go-kratos.dev/">Kratos</a>。</p></blockquote><h3 id="1-4-一个DI示例"><a href="#1-4-一个DI示例" class="headerlink" title="1.4 一个DI示例"></a>1.4 一个DI示例</h3><p>service层</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 依赖dao层的接口</span></span><br><span class="line">  dao.DaoReader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitBook</span><span class="params">(reader dao.DaoReader)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Reader&#123;reader&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dao层</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dao</span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">type</span> DaoReader <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务实现</span></span><br><span class="line"><span class="keyword">type</span> MyReader DaoReader</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyReader</span><span class="params">()</span> <span class="title">DaoReader</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;MyReader&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mock_dao层（建议另起一个目录）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成mock的示例命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从dao/reader.go中的interface生成</span></span><br><span class="line">mockgen -source=dao/reader.go -destination=mock_dao/reader.go</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码为自动生成，并进行了简化</span></span><br><span class="line"><span class="keyword">package</span> mock_dao</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MockDaoReader <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMockDaoReader</span><span class="params">(ctrl *gomock.Controller)</span> *<span class="title">MockDaoReader</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;MockDaoReader&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，就有了正常情况下与单元测试情况下的依赖注入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"><span class="comment">// 正常的注入</span></span><br><span class="line">reader := InitBook(dao.NewMyReader())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试的注入</span></span><br><span class="line">mockReader := mock_dao.NewMockDaoReader(gomock.NewController(t))</span><br><span class="line">reader := InitBook(mockReader)</span><br></pre></td></tr></table></figure><h2 id="2-在有限的时间内，探索“最有价值”的单元测试"><a href="#2-在有限的时间内，探索“最有价值”的单元测试" class="headerlink" title="2. 在有限的时间内，探索“最有价值”的单元测试"></a>2. 在有限的时间内，探索“最有价值”的单元测试</h2><h3 id="2-1-一个代码覆盖率的问题"><a href="#2-1-一个代码覆盖率的问题" class="headerlink" title="2.1 一个代码覆盖率的问题"></a>2.1 一个代码覆盖率的问题</h3><p>在开发过程中，上层代码对下层的代码调用往往有具有限制，如限制了传参的类型、数量、范围。以下面的代码为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上层</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  s, _ := sum(a,b)</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下层</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// case1 - a/b 为int</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// case2 - a/b 为float</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// case3 - a/b 为string</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，上层<code>Sum</code>函数的入参限制，会导致下层<code>sum</code>中被调用到的代码很有限。因此，在上层<code>Sum</code>进行单元测试，会导致下层<code>sum</code>函数的测试不完全。</p><p>这个代码覆盖率的问题是不可规避的。我们不难得出，在分层场景下，<strong>要使某层代码的覆盖率最高，尽量在同层编写单元测试</strong>。那么，如果要让整个项目的代码覆盖率达到100%，每层的单测都得写，相信没几个公司经得起这样的投入。</p><p>时间有限，我们该如何寻找“最有价值”的单元测试呢？</p><h3 id="2-2-明确核心目标-保障业务逻辑"><a href="#2-2-明确核心目标-保障业务逻辑" class="headerlink" title="2.2 明确核心目标 - 保障业务逻辑"></a>2.2 明确核心目标 - 保障业务逻辑</h3><p>一个业务项目的代码，最重要的自然是保障业务逻辑。从前面三个分层的职责来看，<strong>Service层是我们要聚焦的重点，它的代码测试覆盖度无疑是要优先保障的</strong>。</p><p>于是，我们优先在Service层写了完整的单测，覆盖率也很高，但回头看到Controller/Dao层代码的覆盖率很低：</p><ul><li>上层Controller的代码无法从Service层调用到，单测覆盖率为0</li><li>下层Dao层的里的业务实现代码也没有被调用（依赖注入的是mock实现），单测覆盖率也很低</li></ul><p>既然我们的核心目标是 <strong>保障业务逻辑</strong>，那么，我们不妨从分层的角度分析一下：Controller层与Dao层的代码对核心业务逻辑的影响有多大？</p><h3 id="2-3-Controller-Dao层的单元测试思路"><a href="#2-3-Controller-Dao层的单元测试思路" class="headerlink" title="2.3 Controller/Dao层的单元测试思路"></a>2.3 Controller/Dao层的单元测试思路</h3><p>我们先看看这两层的主要功能：</p><ul><li>Controller层是做的是协议解析和数据转化，如HTTP根据Header里的content-type解析到对应结构体</li><li>Dao层主要负责的工作是数据持久化，比如MySQL里的CRUD<ul><li>为了方便讨论，我们对Dao层做一下延伸，认为与外部应用的RPC交互也是一种Dao层操作</li></ul></li></ul><p>这两层都具备一个共同特征：<strong>高度重复性的基础工作</strong>，非常适合建设公共的工具库。于是，Controller/Dao层的建设思路往往会分两步走：</p><ol><li>沉淀并维护公共的工具库 ，并保证其单元测试覆盖率<ol><li>Controller层的RPC框架</li><li>Dao层的MySQL ORM/服务SDK</li></ol></li><li>Controller/Dao层主要工作就是去调用工具库，并适配其接口</li></ol><p>在这种模式下，Controller与Dao层发生的问题可以得到有效控制：</p><ol><li>工具库本身 - 引用优秀的开源库或自建，保证测试完备，自身很少出错（有问题就统一升级）</li><li>工具库的调用 - 依赖库设计的调用方式与使用者的经验</li><li>Controller/Dao层自身代码 - 只做简单的工具库调用与数据结构的转换</li></ol><blockquote><p>第2点中的工具库设计很重要，建议多考虑一下设计模式与Go语言强类型的特点，能提高用户体验：</p><p>比如说，工具库里要传一个时间类型的参数，可以将入参设计为 <code>duration int</code> （参数类型只有数字），但更好的方式是<code>duration time.Duration</code>（参数类型同时包含了数字+单位）。</p></blockquote><p>所以，对不熟悉框架的同学，在早期可以投入一些时间写写Controller/Dao层的单测，了解相关工具库的实现；而随着经验的积累，Controller/Dao层会专注于做2件事：</p><ul><li>选择合适的工具库进行调用</li><li>数据转化（从一个结构体转化到另一个结构体）</li></ul><p>随着项目的迭代，Controller/Dao层会变得越来越“薄”，投入单测的意义就没那么大了。</p><h3 id="2-4-评价指标"><a href="#2-4-评价指标" class="headerlink" title="2.4 评价指标"></a>2.4 评价指标</h3><p>至此，我们明确了以 <strong>保障核心业务逻辑</strong> 为单元测试的目标，并以 <strong>业务领域层</strong> 作为核心的单元测试覆盖对象，项目单元测试覆盖率指标也相对明确了，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定service路径下的所有文件，来计算单测覆盖率</span></span><br><span class="line">go test ./service/...  -coverprofile=profile.cov</span><br><span class="line">go tool cover -html=profile.cov -o coverage.html</span><br></pre></td></tr></table></figure><p>之后，就是一个不断迭代的过程了。整体的业务项目与工具库呈现如下：</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-unittest-framework-new.png"></p><h2 id="3-单元测试的相关实践"><a href="#3-单元测试的相关实践" class="headerlink" title="3.  单元测试的相关实践"></a>3.  单元测试的相关实践</h2><h3 id="3-1-Controller层不应向下传递协议类参数"><a href="#3-1-Controller层不应向下传递协议类参数" class="headerlink" title="3.1 Controller层不应向下传递协议类参数"></a>3.1 Controller层不应向下传递协议类参数</h3><p>我们先看两段代码：</p><p>标准HTTP的handler</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FooHandler</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">  service.Foo(w, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">  fmt.Fprint(w, <span class="string">&quot;my response&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gin框架的Handler</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FooHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">service.Foo(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  c.JSON(<span class="number">200</span>, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种代码都将协议相关的数据结构<code>http.ResponseWriter</code> 、<code>http.Request</code> 、 <code>gin.Context</code> 传递到了业务领域层。从功能开发来说完全正确，但大幅提升了业务领域层<code>Foo</code>函数单测的难度。</p><p>再看<code>protobuf</code>方案，通过预定义的接口文档与代码生成技术，让controller层的定义变成了如下形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(ctx context.Context, req *proto.FooRequest)</span> <span class="params">(resp *proto.FooResponse, err error)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务自定义的Controller层已经实现了与协议解耦，开发者无需关心协议是<code>HTTP</code>还是<code>gRPC</code>，数据格式是<code>json</code>还是<code>form</code>等。Controller层的这个优势，自然保证了Service层与协议无关。</p><p>所以，<code>protobuf</code> 为代表的的IDL方案，对业务领域层的单测更为友好。</p><h3 id="3-2-Dao层的业务实现高频出错，怎么写单测？"><a href="#3-2-Dao层的业务实现高频出错，怎么写单测？" class="headerlink" title="3.2 Dao层的业务实现高频出错，怎么写单测？"></a>3.2 Dao层的业务实现高频出错，怎么写单测？</h3><p>在理想状态，Dao层出现问题的概率很小，但实际情况中有诸多限制：</p><ul><li>dao层包含很多业务逻辑</li><li>开发者使用工具库的经验少，CRUD常常犯错</li><li>历史项目，dao层很难调整，工具库也常常出错</li></ul><p>当你评估Dao层的单测会给整个项目带来足够的收益时，自然可以添加Dao层的单测。这时，对于外部依赖的问题，有如下2种方式：</p><ol><li>优先使用容器，可利用<code>testing.Main</code>的特性来创建和销毁（类似python中的<code>setUp</code>和<code>tearDown</code>）</li><li>如果不得不依赖测试环境，尽可能地用<code>defer</code>的特性去清理单测产生的数据</li></ol><p>长期维护这两个方案，都比较费时费力。</p><h3 id="3-3-Go的单测有哪些好用的库或者工具？"><a href="#3-3-Go的单测有哪些好用的库或者工具？" class="headerlink" title="3.3 Go的单测有哪些好用的库或者工具？"></a>3.3 Go的单测有哪些好用的库或者工具？</h3><ol><li>Mock类<ol><li><a href="https://github.com/golang/mock">gomock</a> 官方推荐的工具，可以从接口生成mock代码</li><li><a href="https://github.com/agiledragon/gomonkey">Go Monkey</a> 可以对特定函数进行打桩，一般用于特定错误的模拟</li></ol></li><li>接口相关<ol><li><a href="https://github.com/google/wire">wire</a> 解决依赖注入的利器</li><li><a href="https://www.jetbrains.com/help/go/extract-interface-dialog.html">Goland的提取接口</a> 从具体实现中，提取出接口定义，重构代码的利器</li></ol></li><li>写单元测试<ol><li><a href="https://pkg.go.dev/testing#hdr-Main">testing.Main</a> 统一进行单测依赖项的初始化与销毁的工作，减少重复性代码</li><li><a href="https://github.com/cweill/gotests">gotests</a> 生成具体单元测试代码的框架，少写很多代码，已集成到<code>VSCode</code>/<code>Goland</code></li><li><a href="https://github.com/stretchr/testify">testify</a> 断言，可以减少单测的代码量，并增加可读性</li></ol></li><li>其它 - 发掘自己写单测时的高度重复性的代码，利用<code>go genereate</code>特性自动生成</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文讨论的业务代码是以<strong>对象</strong>为最小维度的。如果对象内部涉及到<code>goroutine</code>、<code>channel</code> 等特性，就需要在该对象的单测设计时有更多的考量，但不会影响整体项目的框架。</p><p>无论是框架分层、代码抽象，还是工具库的建设，单元测试都是高度依赖Go项目框架与规范的。<strong>良好的代码测试覆盖率是必须要框架适配的</strong>，生搬硬套往往让自己写单测写得很疲惫，也会让单元测试慢慢失去价值。</p><p>在Go项目中，要保证核心代码的高测试覆盖率，难度往往比需求开发高 - 往往过程性思维的CRUD，就能满足完成需求，而优秀的单元测试则为了保证测试的完备性，需要相当的抽象能力，并且持续重构。</p><p><strong>道阻且长，行则将至。</strong></p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h2&gt;&lt;p&gt;在网上搜索 &lt;strong&gt;Go单元测试&lt;/strong&gt;，我们能找到各种开源工具和方法技巧，也可以照葫芦画瓢、快速地写出示例test case。但回到具体的工程项目里，当我们面对代码里的各种CRUD、接口与实现、内外部依赖时，往往发现很难写出有效的单元测试，空有一身技巧却无从下手。&lt;/p&gt;
&lt;p&gt;我也被这个问题困扰许久，也反复在多个项目里折腾，发现要将单元测试落地到项目中，有一条被忽视的&lt;code&gt;gap&lt;/code&gt;。下面我分享一下个人的思路。&lt;/p&gt;
&lt;p&gt;Go单元测试的具体语法，本文会一笔带过，想了解细节的同学可以自行搜索。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习 - RPC篇:gRPC拦截器剖析</title>
    <link href="http://example.com/2022/11/17/go-study/go-rpc-5/"/>
    <id>http://example.com/2022/11/17/go-study/go-rpc-5/</id>
    <published>2022-11-17T04:00:00.000Z</published>
    <updated>2022-12-13T11:18:02.601Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>我们在前几讲提到过，优秀的RPC框架都提供了<code>middleware</code>的能力，可以减少很多重复代码的编写。在gRPC-Gateway的方案里，包括了两块中间件的能力：</p><ol><li>gRPC中的<code>ServerOption</code>，是所有gRPC+HTTP都会被处理</li><li>gRPC-Gateway中的<code>ServeMuxOption</code>，只有HTTP协议会被处理</li></ol><p>今天，我们先关注共同部分的<code>ServerOption</code>，它提供的能力最为全面，让我们一起了解下。</p><span id="more"></span><h2 id="官方实现"><a href="#官方实现" class="headerlink" title="官方实现"></a>官方实现</h2><p>在官方文件<code>google.golang.org/grpc/server.go</code>路径下，给出了很多公开的<code>ServerOption</code>方法。从本质上来说，这些方法都是为了修改服务端的一个核心数据结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> serverOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">creds                 credentials.TransportCredentials</span><br><span class="line">codec                 baseCodec</span><br><span class="line">cp                    Compressor</span><br><span class="line">dc                    Decompressor</span><br><span class="line">unaryInt              UnaryServerInterceptor</span><br><span class="line">streamInt             StreamServerInterceptor</span><br><span class="line">chainUnaryInts        []UnaryServerInterceptor</span><br><span class="line">chainStreamInts       []StreamServerInterceptor</span><br><span class="line">binaryLogger          binarylog.Logger</span><br><span class="line">inTapHandle           tap.ServerInHandle</span><br><span class="line">statsHandlers         []stats.Handler</span><br><span class="line">maxConcurrentStreams  <span class="keyword">uint32</span></span><br><span class="line">maxReceiveMessageSize <span class="keyword">int</span></span><br><span class="line">maxSendMessageSize    <span class="keyword">int</span></span><br><span class="line">unknownStreamDesc     *StreamDesc</span><br><span class="line">keepaliveParams       keepalive.ServerParameters</span><br><span class="line">keepalivePolicy       keepalive.EnforcementPolicy</span><br><span class="line">initialWindowSize     <span class="keyword">int32</span></span><br><span class="line">initialConnWindowSize <span class="keyword">int32</span></span><br><span class="line">writeBufferSize       <span class="keyword">int</span></span><br><span class="line">readBufferSize        <span class="keyword">int</span></span><br><span class="line">connectionTimeout     time.Duration</span><br><span class="line">maxHeaderListSize     *<span class="keyword">uint32</span></span><br><span class="line">headerTableSize       *<span class="keyword">uint32</span></span><br><span class="line">numServerWorkers      <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难从命名中推断到，上述结构体包含了认证、编解码、压缩、日志等各种配置，其中在初始化时有一些默认值。我们将目光聚焦于核心middleware能力的实现 - 拦截器（Interceptor）。</p><p>gRPC协议提供了两种RPC调用的方式：</p><ul><li><code>Unary</code>普通的单次调用</li><li><code>Stream</code>流式调用</li></ul><p>我们框架的RPC调用都来自gRPC-Gateway对<code>HTTP</code>协议的转发，是属于<code>Unary</code>这块，所以我们聚焦于<code>UnaryServerInterceptor</code>即可。而<code>chainUnaryInts</code>的数据结构为<code>[]UnaryServerInterceptor</code>，即支撑了链式<code>middleware</code>的调用，是自定义入口的关键。</p><p>使用示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := grpc.NewServer(</span><br><span class="line">grpc.ChainUnaryInterceptor(</span><br><span class="line"><span class="comment">// 各个拦截器</span></span><br><span class="line">),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="分析UnaryServerInterceptor"><a href="#分析UnaryServerInterceptor" class="headerlink" title="分析UnaryServerInterceptor"></a>分析UnaryServerInterceptor</h2><p>我们先一起看看这个函数的签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnaryServerInterceptor <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span></span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 1 - 前处理</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2 - 调用具体实现</span></span><br><span class="line">resp, err = handler(ctx, req)</span><br><span class="line">  <span class="comment">// 3 - 后处理</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行逻辑"><a href="#运行逻辑" class="headerlink" title="运行逻辑"></a>运行逻辑</h3><p>可以看到，整个代码分三步进行，其中handler这部分的实现是开发者编写的业务逻辑。</p><p>而当存在链式的拦截器时，这部分的实现类似于先入后出的逻辑：</p><ol><li>前处理1 -&gt; 前处理2 -&gt; … -&gt; 前处理n</li><li>具体代码实现</li><li>后处理n -&gt; 后处理n-1 -&gt; … -&gt; 后处理1</li></ol><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ol><li>ctx - 上下文</li><li>req - 入参</li><li>info - <code>Unray</code>调用的信息，主要是方法名</li><li>handler - 正常处理的函数</li><li>resp - 出参</li><li>err - 错误</li></ol><p>我们要了解这6个参数，才能真正地理解gRPC，进而合理地使用拦截器。下面，我挑选3个重点进行描述：</p><ol><li>我们无法直接使用ctx提取值，而是要用<code>metadata.FromIncomingContext(ctx)</code>提取出gRPC的metadata、再塞入到ctx中。什么是metadata呢？你可以把它简单地类比到HTTP的Header。</li><li>req与resp的类型与<code>protobuf</code>中定义的方法对应。不难猜到，对数据的序列化、反序列化等操作，是在拦截器之前工作的。</li><li>resp与err这两个返回参数尽可能规范：当<code>err != nil</code>时，调用方只需关注err；当<code>err == nil</code>时，resp才有意义。</li></ol><p>这里，我再额外补充两个容易陷入误区的点：</p><ol><li>gRPC-Gateway中也有拦截器的实现，但我们尽可能只做协议的转换：将HTTP Header转换到gRPC-Gateway。这样可以保证gRPC和HTTP的调用，数据处理逻辑用一个拦截器就可以完成，如用户认证。</li><li>尽可能只用err来表示错误，而不要在resp里封装errno等字段（我在下一篇也会给出对应兼容的方案）。这里的error用<code>google.golang.org/grpc/internal/status</code>生成，如<code>status.Error(codes.Unauthenticated, &quot;用户校验失败&quot;)</code>，这样错误才能兼容框架，同时具备错误码与错误信息。</li></ol><h2 id="示例拦截器"><a href="#示例拦截器" class="headerlink" title="示例拦截器"></a>示例拦截器</h2><p>分析完上述内容后，我们结合一些经典的拦截器，方便大家了解它的价值：</p><h3 id="日志拦截器"><a href="#日志拦截器" class="headerlink" title="日志拦截器"></a>日志拦截器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerLoggingInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 进入打印日志，确认入参</span></span><br><span class="line">log.Info()</span><br><span class="line"></span><br><span class="line">resp, err = handler(ctx, req)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理完打印日志，包括出参和error</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.Info()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个RPC调用最终会落成2个日志：</p><ol><li>进入时的Info日志</li><li>返回时<ol><li>正常，则打印Info日志</li><li>有错误，则打印Error日志</li></ol></li></ol><p>日志拦截器的对我们的日常开发意义非常大，核心思路是：<strong>通过日志的一入一出，快速定位问题</strong>。常见的如：</p><ol><li>先看进入时的日志，看看打印的参数是否如预期，如果有错往往先从协议排查，如字段命名</li><li>再看返回的日志，如果打印的输出和预期的一致，那往往是调用方的协议问题，如字段未解析</li><li>如果进入时的日志正确，但返回的打印异常，那就是<code>handler</code>的实现有问题</li></ol><h3 id="recovery拦截器"><a href="#recovery拦截器" class="headerlink" title="recovery拦截器"></a>recovery拦截器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerRecoveryInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">stacktrace := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">stacktrace = stacktrace[:runtime.Stack(stacktrace, <span class="literal">false</span>)]</span><br><span class="line"><span class="comment">// error及堆栈进行日志打印</span></span><br><span class="line">      log.Error()</span><br><span class="line">      </span><br><span class="line">err = status.Error(codes.Unavailable, <span class="string">&quot;系统异常&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着项目的迭代，<code>handler</code>里的实现很有可能出现会导致panic的代码，我们必须对这种异常兜底，而不是随便导致程序崩溃。</p><p>示例代码就是捕获对应的panic，输出到日志，返回给调用方<strong>系统异常</strong>。recovery是保证HTTP服务稳定的重要实现，其中的日志对开发者事后排查问题也提供了参考，是一个必备的工具利器。</p><h3 id="用户认证拦截器"><a href="#用户认证拦截器" class="headerlink" title="用户认证拦截器"></a>用户认证拦截器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  USER_TOKEN    = <span class="string">&quot;USER_TOKEN&quot;</span></span><br><span class="line">CTX_USERNAME  = <span class="string">&quot;CTX_USERNAME&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerAuthUnaryInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1. 提取出metadata</span></span><br><span class="line">md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.Unauthenticated, <span class="string">&quot;用户校验失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 2. parseUserName 从对应的metadata的Key里提取信息，解析出用户名</span></span><br><span class="line">userName, err := parseUserName(md.Get(USER_TOKEN)[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.Unauthenticated, <span class="string">&quot;用户校验失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 3. 将用户名塞入到ctx中</span></span><br><span class="line">ctx = context.WithValue(ctx, CTX_USERNAME, userName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 继续逻辑处理</span></span><br><span class="line"><span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在handler里，调用这个函数可以提取到用户名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserName</span><span class="params">(ctx context.Context)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctx.Value(CTX_USERNAME).(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关的步骤已经在代码注释里写得很清楚了，这里再补充3个细节：</p><ol><li>metadata的USER_TOKEN这个Key，按调用方，来源分2种情况：<ol><li>如果调用方是gRPC，那就要求调用方在metadata里填充这个Key</li><li>如果调用方是HTTP，需要人工将HTTP的Header映射到gRPC的metadata，这部分就是在gRPC-Gateway的中间件里实现</li></ol></li><li>示例中的1与2会对未认证的请求直接拦截 - 不会调用到具体handler的代码，直接返回错误给调用方</li><li>如果服务的接口要区分认证与无需认证，建议从<code>info.FullMethod</code>入手，即调用的方法名，也就是增加一段<code>if-else</code>的判断逻辑</li></ol><h3 id="数据校验拦截器"><a href="#数据校验拦截器" class="headerlink" title="数据校验拦截器"></a>数据校验拦截器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PGV里的结构，都实现了这个方法</span></span><br><span class="line"><span class="keyword">type</span> Validator <span class="keyword">interface</span> &#123;</span><br><span class="line">ValidateAll() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerValidationUnaryInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 如果接口实现了PGV的方法，就认为必须要进行校验</span></span><br><span class="line"><span class="keyword">if</span> r, ok := req.(Validator); ok &#123;</span><br><span class="line">err = r.ValidateAll()</span><br><span class="line">    <span class="comment">// 校验失败，则打印错误并返回参数校验失败</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.InvalidArgument, <span class="string">&quot;参数校验失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在protobuf里有一个非常有用的插件 - PGV，可参考<a href="https://github.com/bufbuild/protoc-gen-validate">Github</a>，它能帮助开发者快速实现对应的参数校验：</p><ul><li>简单的如整型要大于1，字符串要非空</li><li>复杂的如邮箱、IP等格式检查</li></ul><p>但是，它需要开发者手工判断一次。这时，我们就可以利用拦截器+接口，组装出一个参数校验的拦截器，而无需再每个<code>handler</code>中都去判定。</p><p>这个实现很简洁，也充分利用了接口的特性，是一个经典的拦截器实现。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天，我们对gRPC中的拦截器进行了分析，并给出了4个经典的拦截器代码实现。而<code>gin</code>等框架中的middleware实现思路也基本与其一致，差别主要在参数类型不一样。</p><p>gRPC拦截器能有效地收敛很多重复代码，保证框架的统一与高效；相反地，如果某个公共能力无法用拦截器实现，就非常值得我们反思了。</p><p>接下来，我们将视角转移到gRPC-Gateway方案，看看在针对HTTP方面又有哪些高效的middleware。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;我们在前几讲提到过，优秀的RPC框架都提供了&lt;code&gt;middleware&lt;/code&gt;的能力，可以减少很多重复代码的编写。在gRPC-Gateway的方案里，包括了两块中间件的能力：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;gRPC中的&lt;code&gt;ServerOption&lt;/code&gt;，是所有gRPC+HTTP都会被处理&lt;/li&gt;
&lt;li&gt;gRPC-Gateway中的&lt;code&gt;ServeMuxOption&lt;/code&gt;，只有HTTP协议会被处理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天，我们先关注共同部分的&lt;code&gt;ServerOption&lt;/code&gt;，它提供的能力最为全面，让我们一起了解下。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习 - RPC篇:深入gRPC-Gateway-探索常用数据类型</title>
    <link href="http://example.com/2022/11/03/go-study/go-rpc-4/"/>
    <id>http://example.com/2022/11/03/go-study/go-rpc-4/</id>
    <published>2022-11-03T04:00:00.000Z</published>
    <updated>2022-11-03T12:04:54.551Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>gRPC-Gateway的相关方案我们已经在上一篇详细描述。为了更方面地方便大家理解，我这边整理了一个最简化的git项目：<a href="https://github.com/Junedayday/grpc-gateway-buf-example/tree/v0.0.1">https://github.com/Junedayday/grpc-gateway-buf-example/tree/v0.0.1</a> </p><p>它主要包含两个特点：</p><ol><li>用buf工具构建项目</li><li>同时启动了gRPC和gRPC-Gateway服务，支持两种协议的调用</li></ol><p>今天，我们先迈出第一步：探索RPC服务中的数据类型。掌握常见的数据类型，灵活地运用到接口设计中，能帮助我们快速地提供优雅的接口类服务。</p><span id="more"></span><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p><code>protobuf</code>的基础数据类型可参考链接：<a href="https://developers.google.com/protocol-buffers/docs/proto3#scalar">https://developers.google.com/protocol-buffers/docs/proto3#scalar</a></p><p>这部分属于是<code>protobuf</code>的基础知识，如果对这块不清楚，可以花5~10分钟快速过一下。</p><h3 id="默认值问题"><a href="#默认值问题" class="headerlink" title="默认值问题"></a>默认值问题</h3><p>基础类型有一个很值得思考的问题：每一种基础类型都有一个<strong>默认值</strong>，如<code>string</code>的默认值为<code>&quot;&quot;</code>，<code>int32</code>的默认值是<code>0</code>。这就带来了一个问题：<strong>当一个字段被解析为默认值时，怎么区分是未传值，还是传的就是默认值</strong>？</p><p>举个具体的例子，比如我们的传入参数为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;a&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;b&quot;</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;b&quot;</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将数据定义为</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终解析到Go结构体中的<code>Foo.A</code>字段都为0，但是，调用方对 <code>未传值</code> 和 <code>默认值</code> 很可能有不同的定义。</p><p>这个问题有三种常规的解决思路：</p><ol><li>利用编程语言特性，区分 <code>未传值</code> 与 <code>默认值</code> 两种情况；</li><li>两边利用协议约定，保证<code>未传值</code> 与 <code>默认值</code>等同；</li><li>新增加描述性字段，表明相关字段是否生效；</li></ol><p>为了方便理解，我对上面三个case各举个例子：</p><h3 id="方案1-在编程语言中区分"><a href="#方案1-在编程语言中区分" class="headerlink" title="方案1 - 在编程语言中区分"></a>方案1 - 在编程语言中区分</h3><p>以<code>Go</code>语言为例，会利用指针的特性，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">A *<span class="keyword">int32</span></span><br><span class="line">B *<span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解析示例的json时，可以按如下方式进行区分：</p><ul><li>当为默认值0时，将A指向为0的指针</li><li>当未传值时，将A指为nil</li></ul><p>但是，这种实现对语言有一定要求：</p><ol><li>要求语言支持指针（<code>protobuf</code>目标是跨语言的RPC方案）</li><li>对指针变量的操作需要不少额外的判断、转化操作</li></ol><p>虽然方案1的普适性不高，但在Go语言的开源项目中很常见，比如各种共有云的Go SDK。</p><h3 id="方案2-协议约定效果等同"><a href="#方案2-协议约定效果等同" class="headerlink" title="方案2 - 协议约定效果等同"></a>方案2 - 协议约定效果等同</h3><p>方案2更多是一种内部约定。比如，定义了一个数据</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int64</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">float</span> price = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双方约定了：无论字段传的是默认值还是未传值，我们都按默认值处理。</p><p>但是，在接口中，我们会高频地复用数据结构。例如，Book这个数据结构在创建时没有问题，但将这个结构用在更新接口时，往往会有如下思路：</p><ul><li>如果是默认值，接口是希望将这个字段修改为默认值，如name为空</li><li>如果未传值，接口是希望不更改这个字段，即不要修改name字段</li></ul><p>所以，在方案2时，我们只能二选一：当遇到默认值时，要么认为是不改、要么认为是改成默认值。而如果要兼容，那就新增字段或者新增结构。</p><p>方案2虽然存在局限性，但是频率最高的使用方式：毕竟一般情况下调用方就几个，双方简单沟通一下就可以解决问题。但如果面向成百上千的调用方时，这个解释成本就很高了。</p><p>下面的方案3则是对其的一种演进：</p><h3 id="方案3-新增加描述性字段"><a href="#方案3-新增加描述性字段" class="headerlink" title="方案3 - 新增加描述性字段"></a>方案3 - 新增加描述性字段</h3><p>基于方案2，我们可以直接增加一个字段进行标识（类似于一种掩码的效果），如<code>mask=[&quot;id&quot;,&quot;name&quot;]</code>，表示：</p><ul><li><code>id</code>,<code>name</code>这两个字段生效</li><li><code>price</code>字段不生效</li></ul><p>这时，前面的问题就得以解决：</p><ul><li>如果希望修改name为空，mask中增加name字段</li><li>如果不希望修改name，mask中不出现name字段</li></ul><p>这个实现，就是Google推荐的<code>FieldMask</code>的实现思路，下面我们会再次说明。</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p><code>protobuf</code>的枚举的是一种可读性很强的定义，可以参考如下链接了解：<a href="https://developers.google.com/protocol-buffers/docs/proto3#enum">https://developers.google.com/protocol-buffers/docs/proto3#enum</a></p><p>需要注意的是，官方推荐的将默认值0定义为<code>XXX_UNSPECIFIED</code>（即不在规定中，不具备实际意义），如</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Corpus</span> </span>&#123;</span><br><span class="line">  CORPUS_UNSPECIFIED = <span class="number">0</span>;</span><br><span class="line">  CORPUS_UNIVERSAL = <span class="number">1</span>;</span><br><span class="line">  CORPUS_WEB = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现思路与上面的方案2很像：规定默认值为未规定的，是一个无需关心的情况。这就要求使用方尽可能地使用非默认值的枚举值，减少歧义。</p><h2 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h2><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ErrorStatus</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> google.protobuf.Any details = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Any</code>可以简单理解为<code>protobuf</code>协议中的任意类型（但必须是由proto定义的）。我们可以从两个问题来理解它：</p><ul><li><code>Any</code>如何保证兼容性？<ul><li>内部将数据转化成了byte数组，就能存储任意数据了</li></ul></li><li><code>Any</code>如何解析到特定的proto结构？<ul><li>结合上面的byte数组和对应定义的proto文件</li></ul></li></ul><p>因此，传递的数据包含2个字段：</p><ul><li>byte数组，表示具体数据</li><li>proto文件的定义，比如 <code> &quot;@type&quot;: &quot;type.googleapis.com/junedayday.grpc_gateway_buf_example.echo_service.v1.EchoRequest&quot;</code></li></ul><p>但在实际场景中，<code>Any</code>使用并不方便，往往仅用在<code>protobuf</code>的内部协议中，不适合作为通用的API。</p><h3 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="keyword">oneof</span> unique_id &#123;</span><br><span class="line">    <span class="built_in">int64</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> uuid = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Oneof</code>适用的场景是多个字段中仅允许生效其中一个，这避免了理解上的冲突。例如，我们要查找书，每本书有2个唯一标识：<code>id</code>和<code>uuid</code>。</p><ul><li>如果传任意一个，我们能正常地查到</li><li>如果同时传了<code>id</code>和<code>uuid</code>，可能存在多种理解：<ul><li>同时根据两个条件查</li><li>先根据id查，未查到再根据uuid查</li><li>现根据uuid查，未查到再根据id查</li></ul></li></ul><p>从调用方来说，只能阅读你的接口文档，阅读各字段的注释。而<code>Oneof</code>字段呢，就在接口定义上直接告诉了你，二者只能选其一；如果你硬要传2个参数，就直接返回参数错误。</p><p><code>Oneof</code>特性看起来很好用，但实际接口开发中的使用频率很低，毕竟通过有效的注释或者接口拆分，也能解决这个问题。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message EchoRequest &#123;</span><br><span class="line">  <span class="keyword">map</span>&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map是一个很常用的特性，定义和使用也十分简单。如示例，就会自动对应到Go语言中的<code>map[string]string</code>。</p><p>但从API的设计来说，<code>map</code>这个容器有很高的扩展性，缺牺牲了一定的可读性，如key中代表的含义、有哪些限制等等，只能通过注释进行说明。</p><p>因此，<code>map</code>的特性要节制地使用，优先考虑用明确的结构定义来表示。</p><h2 id="扩展类型"><a href="#扩展类型" class="headerlink" title="扩展类型"></a>扩展类型</h2><h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/struct.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EchoRequest</span> </span>&#123;</span><br><span class="line">  google.protobuf.Value info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于<code>Any</code>，<code>Value</code>不需要依赖proto的定义，更趋近于通用意义上的泛型。它本质上是一种<code>Oneof</code>：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Value</span> </span>&#123;</span><br><span class="line">  <span class="keyword">oneof</span> kind &#123;</span><br><span class="line">    NullValue null_value = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">double</span> number_value = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">string</span> string_value = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">bool</span> bool_value = <span class="number">4</span>;</span><br><span class="line">    Struct struct_value = <span class="number">5</span>;</span><br><span class="line">    ListValue list_value = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部也提供了多个数据类型的转化，可按需调用，如<code>GetXXXValue()</code>。</p><h3 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/struct.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EchoRequest</span> </span>&#123;</span><br><span class="line">  google.protobuf.Struct info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Strcut</code>可快速对应到Go语言中的结构体，可以快速地转化为 <code>map[string]structpb.Value</code>。接下来的使用方式同上面的<code>Value</code>。</p><h3 id="FieldMask"><a href="#FieldMask" class="headerlink" title="FieldMask"></a>FieldMask</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/field_mask.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EchoRequest</span> </span>&#123;</span><br><span class="line">  google.protobuf.FieldMask field_mask = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FieldMask</code>就是上面基础类型中方案3的具体实现。它的定义很简单，就是一个字符串的数组：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">FieldMask</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">string</span> paths = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的每个元素，表示一个具体要生效的字段，支持多层的数据结构，如<code>a.b</code>。</p><h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><p>持续时间，需要一个数字+单位，如<code>2s</code>，减少了单位理解上的歧义。它由两个部分组成，很容易理解</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Duration</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int64</span> seconds = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> nanos = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TimeStamp"><a href="#TimeStamp" class="headerlink" title="TimeStamp"></a>TimeStamp</h3><p>时间处理是一个很麻烦的方式，我们往往是采用<code>string</code>的方式传递、然后再次解析，相对来说比较折腾。</p><p>而官方提供了如下方式</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/timestamp.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EchoRequest</span> </span>&#123;</span><br><span class="line">  google.protobuf.Timestamp time_stamp = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以利用<code>AsTime()</code>方法，快速地转化到Go语言中的<code>time.Time</code>结构，非常省力。对与输入方来说，时间要遵循 rfc3339 格式，如 <code>2006-01-02T15:04:05Z</code>。</p><p>虽然我们更常用<code>YYYY-MM-DD HH:mm:ss</code>来表示，但rfc3339更具兼容性，建议尽可能地尝试替换。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>除了基础类型和枚举，我对今天谈到了8种类型进行了简单的概括：</p><table><thead><tr><th align="center">数据类型</th><th align="center">使用频率</th><th align="center">可读性</th></tr></thead><tbody><tr><td align="center">Any</td><td align="center">低</td><td align="center">低</td></tr><tr><td align="center">Oneof</td><td align="center">中</td><td align="center">高</td></tr><tr><td align="center">map</td><td align="center">高</td><td align="center">中</td></tr><tr><td align="center">Value</td><td align="center">中</td><td align="center">低</td></tr><tr><td align="center">Struct</td><td align="center">中</td><td align="center">低</td></tr><tr><td align="center">FieldMask</td><td align="center">低</td><td align="center">高</td></tr><tr><td align="center">Duration</td><td align="center">高</td><td align="center">高</td></tr><tr><td align="center">TimeStamp</td><td align="center">高</td><td align="center">高</td></tr></tbody></table><p>同时，文中对默认值问题的分析，也希望能对大家在接口设计上有一定的启发。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;gRPC-Gateway的相关方案我们已经在上一篇详细描述。为了更方面地方便大家理解，我这边整理了一个最简化的git项目：&lt;a href=&quot;https://github.com/Junedayday/grpc-gateway-buf-example/tree/v0.0.1&quot;&gt;https://github.com/Junedayday/grpc-gateway-buf-example/tree/v0.0.1&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;它主要包含两个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用buf工具构建项目&lt;/li&gt;
&lt;li&gt;同时启动了gRPC和gRPC-Gateway服务，支持两种协议的调用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天，我们先迈出第一步：探索RPC服务中的数据类型。掌握常见的数据类型，灵活地运用到接口设计中，能帮助我们快速地提供优雅的接口类服务。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习 - RPC篇:gRPC-Gateway示例代码概览</title>
    <link href="http://example.com/2022/10/27/go-study/go-rpc-3/"/>
    <id>http://example.com/2022/10/27/go-study/go-rpc-3/</id>
    <published>2022-10-27T04:00:00.000Z</published>
    <updated>2022-10-28T02:40:27.317Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>gRPC-Gateway是gRPC生态的一环，用于对HTTP协议的扩展，是一套高性能、高扩展的开源RPC框架。</p><p>因此，要掌握gRPC-Gateway，必须要对gRPC有一定的基础，才能明白它的定位与价值。</p><span id="more"></span><h2 id="方案概览"><a href="#方案概览" class="headerlink" title="方案概览"></a>方案概览</h2><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/grpc-gateway.png"></p><p>整个方案分为两个方向：</p><h3 id="纵向-RPC协议调用"><a href="#纵向-RPC协议调用" class="headerlink" title="纵向 - RPC协议调用"></a>纵向 - RPC协议调用</h3><p>三个模块：</p><ul><li>调用方 - API Client</li><li>HTTP服务 - Reverse Proxy</li><li>gRPC服务 - Your gRPC service</li></ul><p>两个协议：</p><ul><li>HTTP - 客户端发起的是HTTP协议，传输到反向代理</li><li>gRPC - 反向代理与gRPC服务之间的协议是gRPC</li></ul><p>关键点：</p><ol><li>Reverse Proxy实现了的关键能力是：将HTTP协议转化为gRPC协议</li><li>可同时提供2个服务：HTTP和gRPC，只是HTTP服务的最终实现还是调用到了gRPC</li></ol><h3 id="横向-Protobuf的代码生成"><a href="#横向-Protobuf的代码生成" class="headerlink" title="横向 - Protobuf的代码生成"></a>横向 - Protobuf的代码生成</h3><ul><li>gRPC-Gateway部分：自动生成反向代理</li><li>gRPC部分：自动生成stub</li></ul><p>stub这个单词很有意思，相对准确的翻译是存根、残端，和面向对象中的 <strong>接口</strong> 有异曲同工之妙：<strong>提供了实现的框架，但具体实现仍交由开发者</strong>。</p><h3 id="开发工作"><a href="#开发工作" class="headerlink" title="开发工作"></a>开发工作</h3><p>对开发者来说，整个方案的工作分为两部分：</p><ol><li>RPC部分 - 编写<code>proto</code>文件</li><li>业务逻辑部分 - 编写gRPC中的<code>stub</code>的实现</li></ol><h2 id="开发思路"><a href="#开发思路" class="headerlink" title="开发思路"></a>开发思路</h2><h3 id="1-RPC开发-proto文件的编写"><a href="#1-RPC开发-proto文件的编写" class="headerlink" title="1. RPC开发 - proto文件的编写"></a>1. RPC开发 - proto文件的编写</h3><p>我们看一个官方github上的示例<code>proto</code>文件：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> your.service.v1;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;github.com/yourorg/yourprotos/gen/go/your/service/v1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/api/annotations.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">StringMessage</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">YourService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Echo(StringMessage) <span class="keyword">returns</span> (StringMessage) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      post: <span class="string">&quot;/v1/example/echo&quot;</span></span><br><span class="line">      body: <span class="string">&quot;*&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从上到下，对里面的语法做简单的分析：</p><ul><li>proto3版本</li><li>proto的包名称</li><li>生成Go语言代码后的Go Package</li><li>导入依赖的proto文件</li><li>Message - 表示RPC的数据结构，按规则生成到各语言的代码</li><li>Service - 一组RPC的抽象</li><li>rpc - 一个具体方法，包括 方法名（请求Message） returns （返回Message）</li><li>google.api.http - HTTP协议的定义，如示例中的方法和URL</li></ul><h3 id="2-代码生成"><a href="#2-代码生成" class="headerlink" title="2. 代码生成"></a>2. 代码生成</h3><p>如何将proto文件生成为Go语言的<code>stub</code>代码，官方提供了两个路径：</p><ul><li>buf（新方式，配置简单，推荐）</li><li>protoc（经典方式，配置较为复杂）</li></ul><p>具体的操作方法可以参考： <a href="https://github.com/grpc-ecosystem/grpc-gateway#usage">https://github.com/grpc-ecosystem/grpc-gateway#usage</a> 。</p><h3 id="3-业务实现"><a href="#3-业务实现" class="headerlink" title="3. 业务实现"></a>3. 业务实现</h3><p>代码生成的只是一个<code>stub</code>，具体实现需要我们自己编码。上述方法生成的函数签名大致如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Echo</span><span class="params">(ctx context.Context, request *proto.StringMessage)</span> <span class="title">returns</span> <span class="params">(response *proto.StringMessage, err error)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 自己实现的业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于其中的context与error，我在上一讲已经讲过大致的规范。而在gRPC-Gateway中怎么使用呢？我们会在具体示例中再去讲。</p><h3 id="4-main函数框架"><a href="#4-main函数框架" class="headerlink" title="4. main函数框架"></a>4. main函数框架</h3><p>1~3步骤将一个RPC请求的开发过程串联了起来，作为web服务的高频迭代部分。</p><p>但如果要作为一个完整的服务，还需要包括基础的server启动代码，很少需要改动。我们接着看官方的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;context&quot;</span></span><br><span class="line">  <span class="string">&quot;flag&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/golang/glog&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/grpc-ecosystem/grpc-gateway/v2/runtime&quot;</span></span><br><span class="line">  <span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">  <span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line"></span><br><span class="line">  gw <span class="string">&quot;github.com/yourorg/yourrepo/proto/gen/go/your/service/v1/your_service&quot;</span>  <span class="comment">// Update</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// command-line options:</span></span><br><span class="line">  <span class="comment">// gRPC server endpoint</span></span><br><span class="line">  grpcServerEndpoint = flag.String(<span class="string">&quot;grpc-server-endpoint&quot;</span>,  <span class="string">&quot;localhost:9090&quot;</span>, <span class="string">&quot;gRPC server endpoint&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  ctx := context.Background()</span><br><span class="line">  ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">  <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register gRPC server endpoint</span></span><br><span class="line">  <span class="comment">// Note: Make sure the gRPC server is running properly and accessible</span></span><br><span class="line">  mux := runtime.NewServeMux()</span><br><span class="line">  opts := []grpc.DialOption&#123;grpc.WithTransportCredentials(insecure.NewCredentials())&#125;</span><br><span class="line">  err := gw.RegisterYourServiceHandlerFromEndpoint(ctx, mux,  *grpcServerEndpoint, opts)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start HTTP server (and proxy calls to gRPC server endpoint)</span></span><br><span class="line">  <span class="keyword">return</span> http.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line">  <span class="keyword">defer</span> glog.Flush()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    glog.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要明确一点：这部分代码并没有包括gRPC服务的启动代码，它已经默认在<code>grpcServerEndpoint</code>这个地址+端口上启动了。如果没有进程隔离的强要求，我们可以在<code>main</code>函数中同时启动 gRPC server和gRPC-Gateway server。</p><p>gRPC-Gateway启动时有4个重要参数：</p><ul><li>mux，多路复用，功能最为强大，可以添加各种自定义的拦截器等</li><li>grpcServerEndpoint，将HTTP转换成gRPC，再发给gRPC的地址</li><li>opts，服务的启动选项</li><li>:8081，启动地址</li></ul><blockquote><p>关于gRPC部分内容可以参考： <a href="https://grpc.io/docs/languages/go/quickstart/">https://grpc.io/docs/languages/go/quickstart/</a></p></blockquote><h2 id="参考示例"><a href="#参考示例" class="headerlink" title="参考示例"></a>参考示例</h2><p>整套框架的完整示例可以参考这个文件 - <a href="https://github.com/Junedayday/micro_web_service/blob/master/main.go">https://github.com/Junedayday/micro_web_service/blob/master/main.go</a></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本篇重点是对gRPC-Gateway最基础的原理和使用进行了分析。</p><p>如果你能通过本篇文章，对这个方案有一个基本认识，那么接下来我会带你玩转这个框架。你也无需担心无法实践到日常项目中：gRPC-Gateway中的能力与gin等框架都是共通的，可以轻松地举一反三。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;gRPC-Gateway是gRPC生态的一环，用于对HTTP协议的扩展，是一套高性能、高扩展的开源RPC框架。&lt;/p&gt;
&lt;p&gt;因此，要掌握gRPC-Gateway，必须要对gRPC有一定的基础，才能明白它的定位与价值。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习 - RPC篇:gin框架的基础能力剖析</title>
    <link href="http://example.com/2022/09/26/go-study/go-rpc-2/"/>
    <id>http://example.com/2022/09/26/go-study/go-rpc-2/</id>
    <published>2022-09-26T04:00:00.000Z</published>
    <updated>2022-09-30T04:26:16.964Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><h2 id="gin框架"><a href="#gin框架" class="headerlink" title="gin框架"></a>gin框架</h2><p>gin是非常流行的一款HTTP框架。相较于原生的HTTP server，gin有很多改进点，主要在于3点：</p><ol><li>上手简单，开发思路与原生HTTP基本一致</li><li>引入多个工具库，提高了开发效率</li><li>生态丰富，有许多开源的组件</li></ol><p>围绕着gin框架，我们将展开今天的话题。</p><span id="more"></span><h2 id="示例Gin代码"><a href="#示例Gin代码" class="headerlink" title="示例Gin代码"></a>示例Gin代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求结构体</span></span><br><span class="line"><span class="keyword">type</span> MyRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">MyInfo <span class="keyword">string</span> <span class="string">`form:&quot;my_info&quot; json:&quot;my_info&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应结构体</span></span><br><span class="line"><span class="keyword">type</span> MyResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">Errno  <span class="keyword">int</span>    <span class="string">`json:&quot;errno&quot;`</span></span><br><span class="line">Result <span class="keyword">string</span> <span class="string">`json:&quot;result&quot;`</span></span><br><span class="line">MyInfo <span class="keyword">string</span> <span class="string">`form:&quot;my_info&quot; json:&quot;my_info&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b MyRequest</span><br><span class="line">err := c.Bind(&amp;b)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, MyResponse&#123;</span><br><span class="line">Errno: <span class="number">1</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, MyResponse&#123;</span><br><span class="line">Result: <span class="string">&quot;my result&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// gin server</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"><span class="comment">// 中间件</span></span><br><span class="line">r.Use(gin.CustomRecovery(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context, recovered <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err, ok := recovered.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">c.String(http.StatusInternalServerError, fmt.Sprintf(<span class="string">&quot;error: %s&quot;</span>, err))</span><br><span class="line">&#125;</span><br><span class="line">c.AbortWithStatus(http.StatusInternalServerError)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/data&quot;</span>, GetData)</span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键函数分析"><a href="#关键函数分析" class="headerlink" title="关键函数分析"></a>关键函数分析</h2><h3 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">GET</span><span class="params">(relativePath <span class="keyword">string</span>, handlers ...HandlerFunc)</span> <span class="title">IRoutes</span></span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">POST</span><span class="params">(relativePath <span class="keyword">string</span>, handlers ...HandlerFunc)</span> <span class="title">IRoutes</span></span></span><br></pre></td></tr></table></figure><p>Gin支持不同HTTP方法的路由注册，这对RESTful风格的代码编写带来了很大帮助。对于阅读代码的同学，可以快速地通过路由注册的列表，如<code>r.GET(&quot;/data&quot;, GetData)</code>，找到对应的方法。</p><h3 id="Handler函数"><a href="#Handler函数" class="headerlink" title="Handler函数"></a>Handler函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(*Context)</span></span></span><br></pre></td></tr></table></figure><p>Handler函数相较于标准库，看似从2个参数<code>Request</code> 和 <code>ResponseWriter</code> 转变成了一个参数 <code>Context</code>，简化了调用，但其实对调用者来说，复杂度并没有降低：</p><ol><li><code>Context</code> 包含大量数据结构</li><li><code>Context</code> 包含了大量的方法</li></ol><p>对于一名新手，在摸索出一条最佳实践路径前，学习成本不增反减。这主要是因为<code>gin.Context</code>过重。从编程角度来看，这个对象包含了过多信息，是个大而杂的工具集。</p><p>但不可否认的是，<code>gin</code>里提供了很多工具都比原生库好用，例如参数绑定、返回JSON数据。</p><h3 id="绑定参数Bind"><a href="#绑定参数Bind" class="headerlink" title="绑定参数Bind"></a>绑定参数Bind</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Bind</span><span class="params">(obj any)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>Bind中引入了泛型中的<code>any</code>特性，但使用和原先的<code>interface&#123;&#125;</code>完全一致：</p><p>调用方可以填任意值。但实际上，Bind中必须为一个指针类型的数据结构，但由于interface{}对入参没有任何编译时的限制，导致传参问题在运行时才会报错。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b MyRequest</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">c.Bind(&amp;b)</span><br><span class="line"><span class="comment">// 错误：编译正确，但运行时异常</span></span><br><span class="line">c.Bind(b)</span><br><span class="line">c.Bind(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="返回JSON数据"><a href="#返回JSON数据" class="headerlink" title="返回JSON数据"></a>返回JSON数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">JSON</span><span class="params">(code <span class="keyword">int</span>, obj any)</span></span></span><br></pre></td></tr></table></figure><p>该方法是返回HTTP状态码为code，并且将obj数据进行JSON序列化。</p><p>它的问题同Bind函数，这里就不再赘述了。</p><h3 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h3><p>gin框架提供了middleware的能力，它可以为整个Server提供一个公共能力的封装。有了middleware，整个server处理请求变成了：</p><p>middleware预处理 -&gt; handler -&gt; middleware后处理</p><ul><li><p>常见的预处理如</p><ul><li>参数校验</li><li>用户认证</li><li>panic恢复</li></ul></li><li><p>常见的后处理则如</p><ul><li>定制HTTP状态码</li><li>异常数据封装</li></ul></li></ul><p>总体来说，middleware能帮助用户减少重复性代码的编写，沉淀为公共能力，堪称web编程的一大利器。</p><h2 id="gin能力剖析"><a href="#gin能力剖析" class="headerlink" title="gin能力剖析"></a>gin能力剖析</h2><p>我们先看看gin的改进点：</p><ol><li>mux支持RESTful风格的接口定义</li><li><code>gin.Context</code>提供了大量的工具，简化解析、返回的相关代码</li><li>middleware可解决大量重复性的代码</li></ol><p>这三点对开发者带来了不小的帮助。但是，我们在使用<code>gin</code>作为开发工具时，仍有一些问题：</p><ol><li>大量的参数类型都是<code>interface&#123;&#125;</code>类型的数据结构，需要调用方自行保证</li><li><code>gin.Context</code>过大，学习和理解的成本很高</li><li>不少问题要在运行时才能发现，编译期无能为力</li></ol><p>这些弊端汇总起来，依旧是和handler的函数定义相关：<strong>没有充分地利用Go强类型、编译检查的特点，来提高程序的质量、降低开发者的学习成本</strong>。</p><h2 id="更简单的Handler框架"><a href="#更简单的Handler框架" class="headerlink" title="更简单的Handler框架"></a>更简单的Handler框架</h2><p>那么，什么样的Handler框架对用户来说效果更好呢？我这边给出一个函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BetterHandler</span><span class="params">(ctx context.Context, req *MyRequest)</span> <span class="params">(rsp *MyResponse, err error)</span></span></span><br></pre></td></tr></table></figure><p>我们依次看一下这些参数及其使用场景：</p><ol><li>ctx - 上下文，传递公共参数以及超时控制</li><li>req - 请求的参数结构</li><li>rsp - 响应的参数结构</li><li>err - 错误信息</li></ol><p>从整个RPC框架来看，它重点做了2件事：</p><ol><li>自动将http参数解析到ctx和req中<ol><li>解析规则按标准约定，如HTTP RESTful</li><li>一般是将Header里的信息放到ctx中，将URL+Body里的信息匹配到req结构体</li></ol></li><li>自动将rsp和err对应到HTTP响应中<ol><li>err=nil时，认为请求成功，将rsp序列化后、填入到HTTP Body中</li><li>err!=nil时，认为请求去失败，返回约定的协议（如异常状态码、异常HTTP的Body）</li></ol></li></ol><p><code>BetterHandler</code>是一个很棒的编程体验：</p><ol><li>无需关心解析参数与返回响应这两步的具体实现，统一由框架封装</li><li>函数的输入和输出都是强类型的，开发者有了一个明确的“模板”</li><li>将handler中的业务逻辑与RPC框架中协议部分解耦</li></ol><p>也许你一下子无法快速理解，但反复对比下，你会逐渐体会到其中的精妙。但是，使用这个框架前，我们要解决以下两个问题：</p><ol><li>URL与Handler的匹配逻辑</li><li>怎么约定解析请求和返回响应的协议</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天，我们一起看了gin框架的相关示例，编程体验比原生http库有了明显提升。gin的生态也给出了不少的优化方案或者插件，但由于框架本身限制，很难治本。</p><p>下一讲，我们将来看一个我最为推荐的RPC框架，分析一下其相关利弊。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;gin框架&quot;&gt;&lt;a href=&quot;#gin框架&quot; class=&quot;headerlink&quot; title=&quot;gin框架&quot;&gt;&lt;/a&gt;gin框架&lt;/h2&gt;&lt;p&gt;gin是非常流行的一款HTTP框架。相较于原生的HTTP server，gin有很多改进点，主要在于3点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上手简单，开发思路与原生HTTP基本一致&lt;/li&gt;
&lt;li&gt;引入多个工具库，提高了开发效率&lt;/li&gt;
&lt;li&gt;生态丰富，有许多开源的组件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;围绕着gin框架，我们将展开今天的话题。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习 - RPC篇:理解标准库HTTP的hander实现逻辑</title>
    <link href="http://example.com/2022/09/18/go-study/go-rpc-1/"/>
    <id>http://example.com/2022/09/18/go-study/go-rpc-1/</id>
    <published>2022-09-18T04:00:00.000Z</published>
    <updated>2022-09-30T04:26:20.595Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><h2 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h2><p>作为一名开发者，我们最常见的日常工作就是web类编程：即对于CRUD请求，开发相关的业务代码。</p><p>在Go语言中，常见的RPC包括HTTP/gRPC/Thrift等，但绝大多数的开发场景仍是基于HTTP。本文对RPC的讨论，主要是基于HTTP的场景。</p><p>如果我们能熟练地掌握一套主流RPC框架，至少能提升20%的开发效率，而优秀的框架能带来更大的帮助。提效是为了有更多时间提升个人能力，我们今天就先对RPC框架有一个概览。</p><span id="more"></span><h2 id="RPC的处理过程"><a href="#RPC的处理过程" class="headerlink" title="RPC的处理过程"></a>RPC的处理过程</h2><p>对一个web程序来说，它的核心功能就是处理一个请求。一个RPC的处理流程可以简单划分为3块：</p><ol><li>解析请求数据</li><li>业务逻辑处理</li><li>返回结果</li></ol><p>这个看似简单的流程，在实际开发过程中会遇到很多问题。抛开业务逻辑，我们重点看一下1、3两步：</p><p>解析请求数据：</p><ol><li>要理解HTTP协议的标准，了解URL/Header/Body里的数据信息，如Content-Type</li><li>定义这个请求的数据结构，将数据 <strong>反序列化</strong> 到程序中的结构体</li></ol><p>返回结果：</p><ol><li>定义请求的返回数据结构，将程序中的结构体 <strong>序列化</strong></li><li>异常情况下，如业务处理错误、程序崩溃等，如何保证返回的数据结构一致</li></ol><p>简单来说，这两步的功能可以概括为：<strong>如何将数据按定义的标准，进行序列化与反序列化</strong>。</p><blockquote><p>常见的序列化工具如json/xml/protobuf等，新手主要了解 json 即可。</p></blockquote><p>接下来，我们来看看标准库对请求的处理。</p><h2 id="Go标准库的示例代码"><a href="#Go标准库的示例代码" class="headerlink" title="Go标准库的示例代码"></a>Go标准库的示例代码</h2><p>我们先来看标准HTTP库，它的实现是我们学习RPC的基础：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/router&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">  <span class="keyword">type</span> MyRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">type</span> MyResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">    Errno <span class="keyword">int</span> <span class="string">`json:&quot;errno&quot;`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> resp = <span class="built_in">new</span>(MyResponse)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 解析参数</span></span><br><span class="line">  <span class="keyword">var</span> req MyRequest</span><br><span class="line">  b, err := ioutil.ReadAll(request.Body)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    resp.Errno = <span class="number">1</span></span><br><span class="line">    b, _ = json.Marshal(resp)</span><br><span class="line">    writer.Write(b)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  json.Unmarshal(b, &amp;req)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 业务逻辑处理</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 返回结果</span></span><br><span class="line">  b, _ = json.Marshal(resp)</span><br><span class="line">  writer.Write(b)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="两个关键参数"><a href="#两个关键参数" class="headerlink" title="两个关键参数"></a>两个关键参数</h3><p>响应 <code>http.ResponseWriter</code> 与 请求<code>*http.Request</code>。这两个参数里面包含了许多信息，我这里列举最常用的几个：</p><ol><li>结构体Request<ol><li>Method - http方法</li><li>URL - http URL</li><li>Header - http头</li><li>Body - http消息体</li></ol></li><li>接口ResponseWriter<ol><li>Write - 写Body</li><li>WriteHeader - 写状态码</li></ol></li></ol><h2 id="开发思路"><a href="#开发思路" class="headerlink" title="开发思路"></a>开发思路</h2><p>我们梳理一下，一个新的HTTP接口的开发是什么样的逻辑：</p><h3 id="1-如何匹配到handler"><a href="#1-如何匹配到handler" class="headerlink" title="1.如何匹配到handler"></a>1.如何匹配到handler</h3><p>示例就是<code>/router</code>这个路由匹配，但实际情况中会更复杂：</p><ol><li>如前缀匹配、模糊匹配等</li><li>按照RESTful协议，不同Method的处理逻辑不一样</li></ol><p>对于第二点，我们自然也可以通过在handler函数中增加<code>if-else</code>的逻辑来覆盖，但这么写下来，显然会增加handler函数的复杂程度。</p><p>从RPC的编程术语来说，我们称这个匹配逻辑为<code>mux</code>，即多路复用。于是，我们就发现了http标准库中的2大优化点：</p><ol><li>更灵活的URL匹配逻辑</li><li>mux支持HTTP Method的区分</li></ol><h3 id="2-解析参数"><a href="#2-解析参数" class="headerlink" title="2.解析参数"></a>2.解析参数</h3><p>解析参数可以分解为3个问题：</p><ol><li>参数来源于哪？如URL/Header/Body</li><li>参数要怎么解析？如json/form/xml</li><li>参数要解析到那个Go结构体？</li></ol><p>有经验的朋友能深刻体会其中的繁琐（这部分工作不难，但很费开发与排查问题的时间）。比如说，在写业务层代码时，发现某个参数没有解析到，我们要分析的点非常多，包括协议问题、字段名称、字段类型、解析的工具库等等。</p><p>对于程序员来说，当然是希望尽可能地将这部分高度重复的工作进行简化，提升效率。</p><h3 id="3-返回结果"><a href="#3-返回结果" class="headerlink" title="3.返回结果"></a>3.返回结果</h3><p>返回数据的代码看过去很简单，就是将数据序列化后返回。</p><p>但是，难点在于异常情况下的处理：例如，当handler中某个逻辑出错时，我们要怎么返回数据呢？最常见的方案，就是增加一个特殊的字段进行标记，如错误码<code>errno</code>，不为0时表示错误，为0时才表示正确、再去解析数据结构。</p><h2 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h2><p>上述3点没有什么技术上的难度，但在稍微复杂点的web程序时，会遇到什么问题呢？我们再次一起看看handler这个函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span></span><br></pre></td></tr></table></figure><p>如果你随意编写一个handler，也可以轻松编译通过，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，最主要的问题是在于：<strong>没办法对开发者在编写HTTP接口时，提供一定的强制规范</strong>。</p><h3 id="质量低-容易失误"><a href="#质量低-容易失误" class="headerlink" title="质量低 - 容易失误"></a>质量低 - 容易失误</h3><p>由于handler这层的无法强制性地标准化，容易出现下限很低的失误，例如：</p><ol><li>用错了请求的数据结构，尤其是ctrl+c/ctrl+v</li><li>返回的数据结构没有强限制，完全可以自定义</li></ol><h3 id="效率低-重复编码"><a href="#效率低-重复编码" class="headerlink" title="效率低 - 重复编码"></a>效率低 - 重复编码</h3><p>对于解析参数和返回数据，往往需要大量的重复编码。这部分虽然可以通过封装一些库来缓解，但每个handler都至少仍有2个调用：</p><ul><li>解析数据的函数，如<code>Bind</code></li><li>返回数据的函数，如<code>WriteResponse</code></li></ul><p>而对于有异常情况的，如发生error，<code>WriteResponse</code>的调用量相应增加</p><h3 id="标准化低-内部实现各异"><a href="#标准化低-内部实现各异" class="headerlink" title="标准化低 - 内部实现各异"></a>标准化低 - 内部实现各异</h3><p>由于<code>handler</code>内的 <strong>解析请求</strong>和<strong>返回响应</strong> 没有任何代码限制，所以可以采用任意开源或自研的组件。</p><p>这些组件的实现各异，一旦扩散后很难收敛，很容易遇上不兼容的问题：</p><ul><li>如果只是程序内实现的不兼容，还可以通过修改完成兼容</li><li>但如果多个调用方发生了不兼容，那就很难控制了</li></ul><h3 id="测试难-单测难覆盖"><a href="#测试难-单测难覆盖" class="headerlink" title="测试难 - 单测难覆盖"></a>测试难 - 单测难覆盖</h3><p>整个handler的可测试性是很低的，构造一个单测堪比写一大串业务代码，调试时很复杂。</p><p>所以，开发者往往更愿意靠 启动go程序+postman发请求 这样相对重量级的接口测试。</p><h2 id="更大规模下的问题"><a href="#更大规模下的问题" class="headerlink" title="更大规模下的问题"></a>更大规模下的问题</h2><h3 id="实现与接口文档的不一致"><a href="#实现与接口文档的不一致" class="headerlink" title="实现与接口文档的不一致"></a>实现与接口文档的不一致</h3><p>随着平台的迭代，我们经常会去修改一些接口。</p><p>但在Go语言中，它无法直接生成接口文档（如swagger文档）。普遍的方案会利用注释，但注释依旧无法和代码里的实现保证强一致性（如接口文档为OrderV1，但实际已经升级到了OrderV2）。</p><h3 id="调用方的开发工作"><a href="#调用方的开发工作" class="headerlink" title="调用方的开发工作"></a>调用方的开发工作</h3><p>对于接口调用方，有4个工作是必须做的：</p><ol><li>定义URL/方法等</li><li>定义请求的数据结构</li><li>定义返回的数据结构</li><li>拼接处一个HTTP请求</li></ol><p>每个服务调用方，都需要重复地做这部分的工作。</p><p>这个问题可以通过统一建设公共库（SDK）来减轻，但SDK库如何与服务端的实现保证一致，是比较复杂的问题：例如新增了一个url+handler的处理逻辑，如何保证SDK会自动更新？</p><h3 id="业务逻辑的兼容性问题"><a href="#业务逻辑的兼容性问题" class="headerlink" title="业务逻辑的兼容性问题"></a>业务逻辑的兼容性问题</h3><p>业务逻辑往往是复杂的，我们更多的时间是投入在业务逻辑处理上，但传统的方式容易出现各种兼容性问题，比如：</p><p>开发者可能只是发现某个内部bug，改了某个字段的数据结构，但却导致所有调用方整个解析失败（如json.Unmarshal）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>也许，有的朋友看了上述问题，会觉得不以为然：<strong>如果能搞好工具库和标准，以上问题都能解决</strong>。</p><p>没错，上述问题都不致命，否则业界也早就出现明确的标准了。但是我们要考虑到两点：</p><ol><li>人员的不确定因素：不同的能力阶段、人员流动性</li><li>效率与质量：将开发时间更多地投入到业务逻辑上，提升质量</li></ol><p>就像是你要从上海到北京出差，你当然可以自驾、歪歪扭扭地沿着高速公路到达目的地，有很高的选择自由度；但有了更快的高铁路线，何乐而不为呢？毕竟，从出差这件事来看，最重要的是保证准时地到达目的地，</p><p>那么RPC的“高铁方案”是怎么样的呢？下一节我们继续展开。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;RPC框架&quot;&gt;&lt;a href=&quot;#RPC框架&quot; class=&quot;headerlink&quot; title=&quot;RPC框架&quot;&gt;&lt;/a&gt;RPC框架&lt;/h2&gt;&lt;p&gt;作为一名开发者，我们最常见的日常工作就是web类编程：即对于CRUD请求，开发相关的业务代码。&lt;/p&gt;
&lt;p&gt;在Go语言中，常见的RPC包括HTTP/gRPC/Thrift等，但绝大多数的开发场景仍是基于HTTP。本文对RPC的讨论，主要是基于HTTP的场景。&lt;/p&gt;
&lt;p&gt;如果我们能熟练地掌握一套主流RPC框架，至少能提升20%的开发效率，而优秀的框架能带来更大的帮助。提效是为了有更多时间提升个人能力，我们今天就先对RPC框架有一个概览。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>技术阅读摘要 - 5.Go语言面试概述类问题</title>
    <link href="http://example.com/2022/08/07/readings/go-digest-5/"/>
    <id>http://example.com/2022/08/07/readings/go-digest-5/</id>
    <published>2022-08-07T04:00:00.000Z</published>
    <updated>2022-08-14T04:20:00.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>目前，Go语言在中国市场虽然蓬勃发展，但相较于JAVA语言的成熟面试体系，Go缺少了很多“八股文”性质的资料，出现了两个问题：</p><ol><li>对新手来说，知识很难体系化；</li><li>对面试者来说，遇到的问题千奇百怪，甚至面试官之间的答案也不一样</li></ol><p>那么，我将挑选五个概述类的问题，并给出我的思考，希望能对大家带来帮助。</p><span id="more"></span><h2 id="1-谈谈你对Go语言的错误处理的思考"><a href="#1-谈谈你对Go语言的错误处理的思考" class="headerlink" title="1.谈谈你对Go语言的错误处理的思考"></a>1.谈谈你对Go语言的错误处理的思考</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在谈论这个话题前，我们最好先掌握两个知识点：</p><ol><li>了解以JAVA体系为代表的try-catch模式的错误处理方式</li><li>Go语言error封装的常见技巧</li></ol><p>我们的回答先围绕这两个点展开：</p><ol><li>Go语言对错误处理的设计是偏向于过程性的。虽然会牺牲一定的简洁性、增加代码冗余，但在阅读代码时，我们能明确地知道，错误是在方法的哪一行产生的；</li><li>推荐使用<code>github.com/pkg/errors</code>这个Go官方推荐的库（具体方法可以参考 <a href="https://junedayday.github.io/2021/05/07/go-tip/go-tip-3/">我的博客</a>）。简单来说，将错误进行堆栈化，丰富错误所包含的信息。</li></ol><p>关于这个问题，你要谈到的三个关键点是：</p><ol><li>error处理的代码会导致冗余，牺牲一定的简洁性，但阅读者可以清晰地看到错误产生的源头；</li><li>熟悉对error处理的技巧，如<code>bufio.Scanner</code>将error封装到结构体中；</li><li>官方思路 - 以<code>github.com/pkg/errors</code>为代表的，将error进行堆栈化处理；</li></ol><h2 id="2-谈谈你对Go程序故障的排查心得"><a href="#2-谈谈你对Go程序故障的排查心得" class="headerlink" title="2.谈谈你对Go程序故障的排查心得"></a>2.谈谈你对Go程序故障的排查心得</h2><p>线下问题相对简单，可以通过 <strong>单元测试</strong> 或者 <strong>代码调试</strong> 的手段进行排查。</p><p>我们讨论的重点是线上程序，我将思路分为3类：</p><ol><li>可观测性：重点是监控指标metrics与链路追踪tracing</li><li>Go语言自带的pprof：主要用来分析复杂的程序瓶颈</li><li>操作系统层面的工具：包括CPU、磁盘、网络等，如tracert、tcpdump等</li></ol><p>一般情况下，第1类成本最低，能解决绝大部分的问题，是稳定性重点建设的目标。</p><h2 id="3-你认为Go语言的弊端有什么？"><a href="#3-你认为Go语言的弊端有什么？" class="headerlink" title="3.你认为Go语言的弊端有什么？"></a>3.你认为Go语言的弊端有什么？</h2><p>我将从小到大、谈谈Go语言的三个问题（主要与JAVA进行对比）：</p><ol><li>基础库：基础库提供的能力比较受限，这就导致大量各异的轮子被发明出来，很难统一；</li><li>代码风格：风格迥异，如新手容易写出过程性的代码，资深人员会写出面向接口、高度抽象的代码；</li><li>编程框架：业界没有统一的Go框架，框架间思路也差异很大；</li></ol><p>总体来说，Go现状依然是百家齐鸣。这对语言的丰富性来说是个好事，但对工程项目来说，很难统一约束，<strong>多样性会导致可维护性变差</strong>。</p><h2 id="4-如何体现你的Go语言水平"><a href="#4-如何体现你的Go语言水平" class="headerlink" title="4.如何体现你的Go语言水平"></a>4.如何体现你的Go语言水平</h2><p>展示Go语言的能力发展分为两个方向：底层与上层。</p><p>底层能力包括：源码理解、GMP、性能问题、runtime、编译器等方向，体现出了计算机基础功底。一般来说，在底层这块进一步深钻的话，技术栈需要重点扩充操作系统与网络方向，而编程语言上也需要有一定C++的能力。</p><p>上层能力又可以区分为两块：工程化能力与特定业务领域的能力。通俗点说，工程化是怎么写出可维护的、优雅的Go代码，考验的是经验与基本功；特定业务领域能力则是掌握怎么用Go语言的特性或者特定库，去解决对应的领域问题，如云原生、区块链。</p><h2 id="5-什么样的项目适合用Go语言开发"><a href="#5-什么样的项目适合用Go语言开发" class="headerlink" title="5.什么样的项目适合用Go语言开发"></a>5.什么样的项目适合用Go语言开发</h2><p>单从语言来看，任何一门语言都具备可替代性。那么Go语言的核心竞争力是什么呢？我看重的是两点；<strong>业务生态与语言特性</strong>，其中生态的重要性远超语言特性。</p><p>先聊一下业务生态。成熟的生态会沉淀相关的工具或现成库，大幅度减少开发成本，逆主流的语言意味着重建生态。比如说，Kubernetes沉淀了Go相关的大量插件与工具，区块链领域也基本都是Go语言的天下。</p><p>在没有绝对统治力的生态下、或者重建生态的成本很低，语言自身的特性才有参考价值。比如在devops领域，常见的有Python、Go、PHP，以及少量的JAVA。这时，Go语言以学习成本低、高性能等因素，脱颖而出，成为首选。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文和大家聊了5个Go语言概述类问题，它们相对于底层问题更容易快速记忆。</p><p>希望能为大家在学习Go语言的过程中带来启发，也可以帮助大家在面试的回答中展现出亮点。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;目前，Go语言在中国市场虽然蓬勃发展，但相较于JAVA语言的成熟面试体系，Go缺少了很多“八股文”性质的资料，出现了两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对新手来说，知识很难体系化；&lt;/li&gt;
&lt;li&gt;对面试者来说，遇到的问题千奇百怪，甚至面试官之间的答案也不一样&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么，我将挑选五个概述类的问题，并给出我的思考，希望能对大家带来帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Digest" scheme="http://example.com/tags/Digest/"/>
    
  </entry>
  
  <entry>
    <title>etcd源码分析 - 5.【打通核心流程】EtcdServer消息的处理函数</title>
    <link href="http://example.com/2022/07/25/etcd/etcd-5/"/>
    <id>http://example.com/2022/07/25/etcd/etcd-5/</id>
    <published>2022-07-25T04:00:00.000Z</published>
    <updated>2022-07-26T02:45:32.730Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg"></p><p>在上一讲，我们梳理了<code>EtcdServer</code>的关键函数<code>processInternalRaftRequestOnce</code>里的四个细节。</p><p>其中，<code>wait.Wait</code>组件使用里，我们还遗留了一个细节实现，也就是请求的处理结果是怎么通过channel返回的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="comment">// 正常消息的返回，也就是我们本章要研究的</span></span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line"><span class="keyword">return</span> x.(*applyResult), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-cctx.Done():</span><br><span class="line">proposalsFailed.Inc()</span><br><span class="line">s.w.Trigger(id, <span class="literal">nil</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, s.parseProposeCtxErr(cctx.Err(), start)</span><br><span class="line"><span class="keyword">case</span> &lt;-s.done:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrStopped</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="明确问题与思路"><a href="#明确问题与思路" class="headerlink" title="明确问题与思路"></a>明确问题与思路</h2><p>我们回顾上节的问题，我们就是要找到下面两处操作的代码：</p><ol><li>往<code>ch</code>这个channel里发送了一个<code>*applyResult</code>结构的消息</li><li>对wait进行了Trigger操作</li></ol><p>常见思路分为两种：</p><ol><li>顺序思维 - 也就是自顶向下阅读代码，主要是找到调用的入口</li><li>逆向思维 - 通过IDE的代码跳转功能，查找关键函数的调用处，再向上找到对应的调用栈</li></ol><p>顺序思维不是一种源码阅读的常见行为，毕竟这需要我们非常了解源码的结构；而逆向思维，是我们快速定位到对应代码的最常见手段。</p><p>而为了加深对代码的理解，通常会采用 <strong>先逆向、理清代码调用逻辑，后顺序、理解代码层级设计</strong> 这样的两轮阅读。我们就针对今天的case来看看。</p><h2 id="逆向阅读-调用逻辑"><a href="#逆向阅读-调用逻辑" class="headerlink" title="逆向阅读 - 调用逻辑"></a>逆向阅读 - 调用逻辑</h2><h3 id="Trigger的调用"><a href="#Trigger的调用" class="headerlink" title="Trigger的调用"></a>Trigger的调用</h3><p>我们利用IDE，可以查到所有的Trigger调用代码，共计10处，可以先根据文件名快速理解：</p><ul><li>7处 <code>server.go</code> - 通用server部分</li><li>1处 <code>v2_server.go</code> - 针对v2版本协议</li><li>2处 <code>v3_server.go</code> - 针对v3版本协议（即我们阅读的<code>processInternalRaftRequestOnce</code>函数）</li></ul><p>于是，我们就跳转到<code> server.go</code>，查看这7个调用函数：</p><ul><li><p>configure - 2个Tigger</p><ul><li>配置相关，直接忽略</li></ul></li><li><p>apply - 1个Tigger</p><ul><li>发送的数据结构不为<code>*applyResult</code>，忽略</li></ul></li><li><p>applyEntryNormal - 4个Tigger</p><ul><li>前两个为V2版本</li><li>后两个为V3版本</li></ul></li></ul><p>确定了入口函数为<code>applyEntryNormal</code>，我们接下来就是去用IDE查找调用逻辑，不断跳转，查找它的调用栈了。</p><h3 id="调用栈分析"><a href="#调用栈分析" class="headerlink" title="调用栈分析"></a>调用栈分析</h3><ol><li>applyEntryNormal</li><li>apply</li><li>applyEntries</li><li>applyAll</li><li>run</li><li>start</li><li>Start</li><li>StartEtcd</li></ol><blockquote><p>序号越小，表示越底层</p></blockquote><p>这一块的代码跳转非常顺利，每一个方法基本都只有一个被调用方，我们可以快速地逐层查找，直到<code>main()</code>函数。接着，我们开始顺序阅读代码的过程。</p><h2 id="顺序阅读-代码设计"><a href="#顺序阅读-代码设计" class="headerlink" title="顺序阅读 - 代码设计"></a>顺序阅读 - 代码设计</h2><p><code>start</code>之前的方法很简单，我们直接从<code>run</code>方法开始看。</p><h3 id="EtcdServer-run"><a href="#EtcdServer-run" class="headerlink" title="(*EtcdServer) run()"></a>(*EtcdServer) run()</h3><p><code>run()</code>函数可以拆分为两部分，而关键的分界线是<code>go</code>语言里经典的<code>for+select</code>语法。在一个常驻的进程中，例如服务器，<code>for+select</code>是一个非常优雅的实现，里面的每一个case都是一种处理逻辑，类似IO复用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// 正常消息</span></span><br><span class="line">    <span class="keyword">case</span> ap := &lt;-s.r.apply():</span><br><span class="line">    <span class="comment">// 超时租约</span></span><br><span class="line">    <span class="keyword">case</span> leases := &lt;-expiredLeaseC:</span><br><span class="line">    <span class="comment">// 错误信号</span></span><br><span class="line">    <span class="keyword">case</span> err := &lt;-s.errorc:</span><br><span class="line">    <span class="comment">// 定时器</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-getSyncC():</span><br><span class="line">    <span class="comment">// 停止信号</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-s.stop:</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这种使用方法，有一个重点需要注意：<strong>每一个case中的处理耗时要尽可能地少（除了退出），这样才能保证程序的性能。</strong>尤其是对常见请求的处理，例如示例中的正常消息，要尽可能地短。</p><blockquote><p>缩短单个case的处理耗时有两种思路：性能优化 或 异步化。</p><p>后者看似很简单，比如开启一个goroutine，但很有可能破坏程序数据的一致性，需要慎重。</p></blockquote><p>正常消息的处理代码很短，即两行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行功能的函数，关键实现为applyAll，即下一层要看的代码</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(context.Context)</span></span> &#123; s.applyAll(&amp;ep, &amp;ap) &#125;</span><br><span class="line"><span class="comment">// sched是一个先入先出的调度方法，而Schedule只是把这个执行函数追加进去</span></span><br><span class="line"><span class="comment">// 这部分真正的执行在另一处，即出队列的地方，暂时无需关心</span></span><br><span class="line">sched.Schedule(f)</span><br></pre></td></tr></table></figure><h3 id="（-EtcdServer-applyAll"><a href="#（-EtcdServer-applyAll" class="headerlink" title="（*EtcdServer) applyAll()"></a>（*EtcdServer) applyAll()</h3><p>通过<code>applyEntries()</code>函数，将每一项<code>entry</code>应用到<code>etcd</code>服务上。</p><h3 id="EtcdServer-applyEntries"><a href="#EtcdServer-applyEntries" class="headerlink" title="(*EtcdServer) applyEntries()"></a>(*EtcdServer) applyEntries()</h3><p>通过<code>apply()</code>应用entry，这里有3个返回值：</p><ul><li>term - 轮次，这是raft协议相关</li><li>index - 索引</li><li>shouldstop - 是否停止</li></ul><h3 id="EtcdServer-apply"><a href="#EtcdServer-apply" class="headerlink" title="(*EtcdServer) apply()"></a>(*EtcdServer) apply()</h3><p>apply将多个entries进行处理，核心代码结构整理如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐个处理entries</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> es &#123;</span><br><span class="line">  e := es[i]</span><br><span class="line">  <span class="keyword">switch</span> e.Type &#123;</span><br><span class="line">    <span class="comment">// 常规消息</span></span><br><span class="line">    <span class="keyword">case</span> raftpb.EntryNormal:</span><br><span class="line">    <span class="comment">// 配置变更</span></span><br><span class="line">    <span class="keyword">case</span> raftpb.EntryConfChange:</span><br><span class="line">    <span class="comment">// 异常情况</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而常规消息里的三步处理也很容易理解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用普通entry的地方</span></span><br><span class="line">s.applyEntryNormal(&amp;e)</span><br><span class="line"><span class="comment">// 设置applied的索引位置，表示已经被应用</span></span><br><span class="line">s.setAppliedIndex(e.Index)</span><br><span class="line"><span class="comment">// 设置轮次term信息</span></span><br><span class="line">s.setTerm(e.Term)</span><br></pre></td></tr></table></figure><h3 id="EtcdServer-applyEntryNormal"><a href="#EtcdServer-applyEntryNormal" class="headerlink" title="(*EtcdServer) applyEntryNormal()"></a>(*EtcdServer) applyEntryNormal()</h3><p>整个函数比较长，但核心处理逻辑只有如下两块内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理raft请求，将结果返回到 *applyResult 中</span></span><br><span class="line"><span class="keyword">var</span> ar *applyResult</span><br><span class="line">needResult := s.w.IsRegistered(id)</span><br><span class="line"><span class="keyword">if</span> needResult || !noSideEffect(&amp;raftReq) &#123;</span><br><span class="line">  <span class="keyword">if</span> !needResult &amp;&amp; raftReq.Txn != <span class="literal">nil</span> &#123;</span><br><span class="line">    removeNeedlessRangeReqs(raftReq.Txn)</span><br><span class="line">  &#125;</span><br><span class="line">  ar = s.applyV3.Apply(&amp;raftReq)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用Trigger触发wait.Wait组件，将 *applyResult 发送出去</span></span><br><span class="line">s.goAttach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := &amp;pb.AlarmRequest&#123;</span><br><span class="line">    MemberID: <span class="keyword">uint64</span>(s.ID()),</span><br><span class="line">    Action:   pb.AlarmRequest_ACTIVATE,</span><br><span class="line">    Alarm:    pb.AlarmType_NOSPACE,</span><br><span class="line">  &#125;</span><br><span class="line">  s.raftRequest(s.ctx, pb.InternalRaftRequest&#123;Alarm: a&#125;)</span><br><span class="line">  s.w.Trigger(id, ar)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇重点是分享一种常见的阅读代码方式：<strong>自底向上</strong>+<strong>自顶向下</strong>。在阅读了EtcdServer处理请求后，将结果通过channel发送出去的整个逻辑，相关代码的调用链路见下图。</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd-4.png"></p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一讲，我们梳理了&lt;code&gt;EtcdServer&lt;/code&gt;的关键函数&lt;code&gt;processInternalRaftRequestOnce&lt;/code&gt;里的四个细节。&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;wait.Wait&lt;/code&gt;组件使用里，我们还遗留了一个细节实现，也就是请求的处理结果是怎么通过channel返回的。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 正常消息的返回，也就是我们本章要研究的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; x := &amp;lt;-ch:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x.(*applyResult), &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &amp;lt;-cctx.Done():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		proposalsFailed.Inc()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		s.w.Trigger(id, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, s.parseProposeCtxErr(cctx.Err(), start)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &amp;lt;-s.done:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, ErrStopped&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-etcd" scheme="http://example.com/tags/Go-etcd/"/>
    
  </entry>
  
  <entry>
    <title>etcd源码分析 - 4.【打通核心流程】processInternalRaftRequestOnce四个细节</title>
    <link href="http://example.com/2022/07/12/etcd/etcd-4/"/>
    <id>http://example.com/2022/07/12/etcd/etcd-4/</id>
    <published>2022-07-12T04:00:00.000Z</published>
    <updated>2022-07-14T05:46:26.285Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg"></p><p>在上一讲，我们继续梳理了<code>PUT</code>请求到<code>EtcdServer</code>这一层的逻辑，并大概阅读了其中的关键函数<code>processInternalRaftRequestOnce</code>。</p><p>这个方法里面有不少细节，我们今天就选择其中有价值的四点来看看。</p><span id="more"></span><h3 id="1-entry索引-appliedIndex与committedIndex"><a href="#1-entry索引-appliedIndex与committedIndex" class="headerlink" title="1. entry索引 - appliedIndex与committedIndex"></a>1. entry索引 - appliedIndex与committedIndex</h3><p>在etcd中，我们将每个客户端的操作（如PUT）抽象为一个日志项（entry）。如果这个操作生效，etcd就将这个entry项同步给其它etcd server，作为数据同步。</p><p>操作有顺序之分，于是服务端就保存了一个长entry数组，用一个关键的索引index来进行区分entry数组（即一个分界的标志），对entry状态进行分类：</p><ul><li>entry处于状态A - 小于等于索引的entry项</li><li>entry处于状态B - 大于索引的entry项</li></ul><blockquote><p>一般状态A和B都是互补的，即是一种二分类状态。</p></blockquote><p>而由于分布式的特性，entry不能立刻完成执行的，于是这里就区分出了两种状态，它们复用一个entry数组：</p><ul><li>已应用 - applied</li><li>已提交 - committed</li></ul><p>对应索引<code>appliedIndex</code>与<code>committedIndex</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数用atomic保证原子性</span></span><br><span class="line">ai := s.getAppliedIndex()</span><br><span class="line">ci := s.getCommittedIndex()</span><br><span class="line"><span class="comment">// 两者的差值，表示已应用但是未提交的entry数，不能太多</span></span><br><span class="line"><span class="keyword">if</span> ci &gt; ai+maxGapBetweenApplyAndCommitIndex &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>, ErrTooManyRequests</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>entry数组中的索引的一致性非常重要，尤其是在并发的场景下。而示例中的原子操作，其实是一种乐观锁的实现。</p><blockquote><p>更多的细节就涉及到分布式相关了，这里就不展开。</p></blockquote><h3 id="2-id生成器-idutil-Generator"><a href="#2-id生成器-idutil-Generator" class="headerlink" title="2.id生成器 - idutil.Generator"></a>2.id生成器 - idutil.Generator</h3><p><code>Generator</code>数据结构不复杂，它的设计详情都放在了备注里，我们可以自行阅读：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator generates unique identifiers based on counters, timestamps, and</span></span><br><span class="line"><span class="comment">// a node member ID.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The initial id is in this format:</span></span><br><span class="line"><span class="comment">// High order 2 bytes are from memberID, next 5 bytes are from timestamp,</span></span><br><span class="line"><span class="comment">// and low order one byte is a counter.</span></span><br><span class="line"><span class="comment">// | prefix   | suffix              |</span></span><br><span class="line"><span class="comment">// | 2 bytes  | 5 bytes   | 1 byte  |</span></span><br><span class="line"><span class="comment">// | memberID | timestamp | cnt     |</span></span><br></pre></td></tr></table></figure><p>在很多分布式系统中，都需要有一套唯一id生成器。etcd的这个方案相对简单，就是 成员id+时间戳 的组合方案。</p><blockquote><p>关于分布式唯一id，更全面的设计可以参考Snowflake，如 <a href="https://segmentfault.com/a/1190000020899379">https://segmentfault.com/a/1190000020899379</a> </p></blockquote><h3 id="3-认证模块-auth-AuthStore"><a href="#3-认证模块-auth-AuthStore" class="headerlink" title="3.认证模块 - auth.AuthStore"></a>3.认证模块 - auth.AuthStore</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">authInfo, err := s.AuthInfoFromCtx(ctx)</span><br></pre></td></tr></table></figure><p>认证功能在成熟软件中非常常见。在etcd，被独立到了<code>etcd/auth</code>模块中。这个模块的内部调用不复杂，功能就是从<code>context</code>中提取出 <strong>用户名+版本信息</strong>。</p><p>这个提取过程中值得注意的是，<code>AuthStore</code>是从<code>grpc</code>的<code>metadata</code>提取出想要的认证信息，而<code>metadata</code>类似于<code>HTTP1</code>协议中的header，是一种用KV形式保存和提取数据的结构。</p><blockquote><p>串联一下我们之前的思路，etcd通过grpc-gateway将HTTP1转化成了gRPC，那么就有一个 HTTP header到grpc metadata的映射过程，有兴趣的可以去研究一下。</p></blockquote><p>总体来说，etcd的认证模块做得很简单，也方便其接入service-mesh。</p><h3 id="4-多协程小工具-wait-Wait"><a href="#4-多协程小工具-wait-Wait" class="headerlink" title="4.多协程小工具 - wait.Wait"></a>4.多协程小工具 - wait.Wait</h3><p><code>wait.Wait</code>是一个很精巧的小工具，使用起来非常简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line">ch := s.w.Register(id)</span><br><span class="line">s.w.Trigger(id, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>我们可以在<code>etcd/pkg/wait</code>目录下看到它的具体实现，我提取了重点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过id，来等待和触发对应的事件。</span></span><br><span class="line"><span class="comment">// 注意使用的顺序：先等待，再触发。</span></span><br><span class="line"><span class="keyword">type</span> Wait <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 等待，即注册一个id</span></span><br><span class="line">Register(id <span class="keyword">uint64</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 触发，用一个id</span></span><br><span class="line">Trigger(id <span class="keyword">uint64</span>, x <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">IsRegistered(id <span class="keyword">uint64</span>) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现：读写锁+map数据结构</span></span><br><span class="line"><span class="keyword">type</span> list <span class="keyword">struct</span> &#123;</span><br><span class="line">l sync.RWMutex</span><br><span class="line">m <span class="keyword">map</span>[<span class="keyword">uint64</span>]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *list)</span> <span class="title">Register</span><span class="params">(id <span class="keyword">uint64</span>)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">w.l.Lock()</span><br><span class="line"><span class="keyword">defer</span> w.l.Unlock()</span><br><span class="line">ch := w.m[id]</span><br><span class="line"><span class="keyword">if</span> ch == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// go官方建议带buffer的channel尽量设置大小为1</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">w.m[id] = ch</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不允许重复</span></span><br><span class="line">log.Panicf(<span class="string">&quot;dup id %x&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发id的channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *list)</span> <span class="title">Trigger</span><span class="params">(id <span class="keyword">uint64</span>, x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">w.l.Lock()</span><br><span class="line">ch := w.m[id]</span><br><span class="line"><span class="built_in">delete</span>(w.m, id)</span><br><span class="line">  <span class="comment">// 取出ch后直接Unlock（可以思考一下与defer的区别）</span></span><br><span class="line">w.l.Unlock()</span><br><span class="line">  <span class="comment">// 如果触发的id不存在map里，就直接跳过这个判断</span></span><br><span class="line"><span class="keyword">if</span> ch != <span class="literal">nil</span> &#123;</span><br><span class="line">ch &lt;- x</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解<code>Wait</code>的实现之后，我们就知道在正常情况下，<code>Register</code>和<code>Trigger</code>必须一一对应。</p><p>但是，我们再往下看<code>processInternalRaftRequestOnce</code>这部分代码，发现了一个异常点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="comment">// 异常：没有找到Trigger，难道忘了？</span></span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line"><span class="keyword">return</span> x.(*applyResult), <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 正常：用Trigger退出</span></span><br><span class="line"><span class="keyword">case</span> &lt;-cctx.Done():</span><br><span class="line">proposalsFailed.Inc()</span><br><span class="line">s.w.Trigger(id, <span class="literal">nil</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, s.parseProposeCtxErr(cctx.Err(), start)</span><br><span class="line">  <span class="comment">// 正常：整个server停止，此时不用关心单个Trigger了</span></span><br><span class="line"><span class="keyword">case</span> &lt;-s.done:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrStopped</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们可以做个简单的猜测：在另一个goroutine中，这个etcd server进行了一个操作，包括下面两步：</p><ol><li>往<code>ch</code>这个channel里发送了一个<code>*applyResult</code>结构的消息</li><li>对wait进行了Trigger操作</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天我们进一步阅读了<code>processInternalRaftRequestOnce</code>中的四个细节，加强了etcd server对请求处理的印象。</p><p>etcd作为一款优秀的开源项目，其模块设计比较精巧，而阅读源码的同学也要掌握一个技巧：<strong>适当控制阅读深度</strong>。比如，在阅读<code>PUT</code>请求时，第一阶段阅读到<code>EtcdServer</code>的<code>processInternalRaftRequestOnce</code>这层即可：</p><ul><li>如果继续深入看<code>raftNode</code>等实现，很容易导致你的整体思路变成过程性的调用，学习不成体系</li><li>这时，回过头来巩固一下当前学习的部分，通过串联细节来加深印象，会对你梳理整体更有帮助</li></ul><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一讲，我们继续梳理了&lt;code&gt;PUT&lt;/code&gt;请求到&lt;code&gt;EtcdServer&lt;/code&gt;这一层的逻辑，并大概阅读了其中的关键函数&lt;code&gt;processInternalRaftRequestOnce&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个方法里面有不少细节，我们今天就选择其中有价值的四点来看看。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-etcd" scheme="http://example.com/tags/Go-etcd/"/>
    
  </entry>
  
  <entry>
    <title>etcd源码分析 - 3.【打通核心流程】PUT键值对的执行链路</title>
    <link href="http://example.com/2022/07/04/etcd/etcd-3/"/>
    <id>http://example.com/2022/07/04/etcd/etcd-3/</id>
    <published>2022-07-04T04:00:00.000Z</published>
    <updated>2022-07-05T12:10:59.849Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg"></p><p>在上一讲，我们一起看了etcd server是怎么匹配到对应的处理函数的，如果忘记了请回顾一下。</p><p>今天，我们再进一步，看看<code>PUT</code>操作接下来是怎么执行的。</p><span id="more"></span><h2 id="HTTP1部分"><a href="#HTTP1部分" class="headerlink" title="HTTP1部分"></a>HTTP1部分</h2><h3 id="request-KV-Put-0"><a href="#request-KV-Put-0" class="headerlink" title="request_KV_Put_0"></a>request_KV_Put_0</h3><p>整个函数主要分为两步：</p><ol><li>解析请求到<code>etcdserverpb.PutRequest</code>数据结构；</li><li><code>client</code>执行<code>PUT</code>操作；</li></ol><p>关于解析部分，我们暂时不用关心如何反序列化的（反序列化是一种可替换的插件，常见的如json/protobuffer/xml），重点看看它的数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PutRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">Key []<span class="keyword">byte</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=key,proto3&quot; json:&quot;key,omitempty&quot;`</span></span><br><span class="line">Value []<span class="keyword">byte</span> <span class="string">`protobuf:&quot;bytes,2,opt,name=value,proto3&quot; json:&quot;value,omitempty&quot;`</span></span><br><span class="line">Lease <span class="keyword">int64</span> <span class="string">`protobuf:&quot;varint,3,opt,name=lease,proto3&quot; json:&quot;lease,omitempty&quot;`</span></span><br><span class="line">PrevKv <span class="keyword">bool</span> <span class="string">`protobuf:&quot;varint,4,opt,name=prev_kv,json=prevKv,proto3&quot; json:&quot;prev_kv,omitempty&quot;`</span></span><br><span class="line">IgnoreValue <span class="keyword">bool</span> <span class="string">`protobuf:&quot;varint,5,opt,name=ignore_value,json=ignoreValue,proto3&quot; json:&quot;ignore_value,omitempty&quot;`</span></span><br><span class="line">IgnoreLease <span class="keyword">bool</span> <span class="string">`protobuf:&quot;varint,6,opt,name=ignore_lease,json=ignoreLease,proto3&quot; json:&quot;ignore_lease,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从我们执行的<code>etcdctl put mykey &quot;this is awesome&quot;</code>为例，不难猜到：</p><ul><li>Key - mykey</li><li>Value - this is awesome</li></ul><p>接下来，我们去看看client是如何执行<code>PUT</code>的。</p><h3 id="etcdserverpb-kVClient"><a href="#etcdserverpb-kVClient" class="headerlink" title="etcdserverpb.kVClient"></a>etcdserverpb.kVClient</h3><p><code>request_KV_Put_0</code>函数中的client是一个接口<code>KVClient</code>，包括Range/Put/DeleteRange/Txn/Compact五种操作。</p><blockquote><p>这里提一下，很多开源库将接口与其实现，用大小写来区分，来强制要求外部模块依赖其接口：</p><p>比如KVClient作为接口，而kVClient作为其实现是小写的，所以外部模块无法直接使用kVClient这个数据结构。</p></blockquote><p>它的实现可以很容易地翻阅代码找到，是<code>etcdserverpb.kVClient</code>。我们去看看对应的<code>PUT</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *kVClient)</span> <span class="title">Put</span><span class="params">(ctx context.Context, in *PutRequest, opts ...grpc.CallOption)</span> <span class="params">(*PutResponse, error)</span></span> &#123;</span><br><span class="line">out := <span class="built_in">new</span>(PutResponse)</span><br><span class="line">err := grpc.Invoke(ctx, <span class="string">&quot;/etcdserverpb.KV/Put&quot;</span>, in, out, c.cc, opts...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们就找到了HTTP调用gRPC的影子，也就是这个<code>Invoke</code>方法。</p><h2 id="gRPC部分"><a href="#gRPC部分" class="headerlink" title="gRPC部分"></a>gRPC部分</h2><h3 id="proto文件"><a href="#proto文件" class="headerlink" title="proto文件"></a>proto文件</h3><p>关于gRPC的调用部分，我比较推荐从最原始的<code>proto</code>文件开始阅读，主要包括2个文件：</p><ul><li><code>etcd/etcdserver/etcdserverpb/rpc.proto</code> 原始文件</li><li><code>etcd/etcdserver/etcdserverpb/rpc.pb.go</code> 生成文件</li></ul><p>从下面的定义可以看到HTTP1采用了<code>POST</code>方法，对应URL为<code>/v3/kv/put</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpc Put(PutRequest) returns (PutResponse) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v3/kv/put&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="etcdserverpb-RegisterKVServer"><a href="#etcdserverpb-RegisterKVServer" class="headerlink" title="etcdserverpb.RegisterKVServer"></a>etcdserverpb.RegisterKVServer</h3><p>我们要注意，proto文件及其生成的go代码只是定义了server的接口，具体的实现需要开发者自行编码实现，通过注册函数<code>RegisterKVServer</code>将两者串联起来。</p><p>查找该函数的调用，分为三个，各有用途：</p><ol><li><code>grpc.go</code> - server的调用处</li><li><code>grpc_proxy.go</code> - proxy代理模式，忽略</li><li><code>mockserver.go</code> - mock服务，忽略</li></ol><p>跳转到1对应的代码处，我们看到了注册函数<code>pb.RegisterKVServer(grpcServer, NewQuotaKVServer(s))</code>。</p><h3 id="NewQuotaKVServer"><a href="#NewQuotaKVServer" class="headerlink" title="NewQuotaKVServer"></a>NewQuotaKVServer</h3><p>进一步跳转，来到了<code>NewKVServer</code>函数中。</p><h3 id="NewKVServer"><a href="#NewKVServer" class="headerlink" title="NewKVServer"></a>NewKVServer</h3><p>这个函数新建了一个<code>kvServer</code>对象，它实现接口<code>etcdserverpb.KVServer</code>。我们再看对应的<code>PUT</code>方法。</p><h3 id="kvServer-Put"><a href="#kvServer-Put" class="headerlink" title="(*kvServer) Put"></a>(*kvServer) Put</h3><p><code>Put</code>方法代码很少：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *kvServer)</span> <span class="title">Put</span><span class="params">(ctx context.Context, r *pb.PutRequest)</span> <span class="params">(*pb.PutResponse, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := checkPutRequest(r); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp, err := s.kv.Put(ctx, r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, togRPCError(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.hdr.fill(resp.Header)</span><br><span class="line"><span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这里的<code>s.kv</code>，其定义为接口<code>etcdserver.RaftKV</code>，定义了如下五个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RaftKV <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 范围操作</span></span><br><span class="line">Range(ctx context.Context, r *pb.RangeRequest) (*pb.RangeResponse, error)</span><br><span class="line">  <span class="comment">// KV操作</span></span><br><span class="line">Put(ctx context.Context, r *pb.PutRequest) (*pb.PutResponse, error)</span><br><span class="line">  <span class="comment">// 删除范围</span></span><br><span class="line">DeleteRange(ctx context.Context, r *pb.DeleteRangeRequest) (*pb.DeleteRangeResponse, error)</span><br><span class="line">  <span class="comment">// 事务</span></span><br><span class="line">Txn(ctx context.Context, r *pb.TxnRequest) (*pb.TxnResponse, error)</span><br><span class="line">  <span class="comment">// 压缩</span></span><br><span class="line">Compact(ctx context.Context, r *pb.CompactionRequest) (*pb.CompactionResponse, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>etcd server集群之间采用的是RAFT协议，而<code>RaftKV</code>则是实现的关键。查找RaftKV的具体实现<code>EtcdServer</code>，我们就找到了如下代码：</p><h3 id="EtcdServer-Put"><a href="#EtcdServer-Put" class="headerlink" title="(*EtcdServer) Put"></a>(*EtcdServer) Put</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span> <span class="title">Put</span><span class="params">(ctx context.Context, r *pb.PutRequest)</span> <span class="params">(*pb.PutResponse, error)</span></span> &#123;</span><br><span class="line">ctx = context.WithValue(ctx, traceutil.StartTimeKey, time.Now())</span><br><span class="line">resp, err := s.raftRequest(ctx, pb.InternalRaftRequest&#123;Put: r&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resp.(*pb.PutResponse), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，这里将多种请求命令（如PUT/RANGE），都封装到了一个结构体<code>InternalRaftRequest</code>中。</p><p>我们继续跳转。</p><h3 id="EtcdServer-raftRequest"><a href="#EtcdServer-raftRequest" class="headerlink" title="(*EtcdServer) raftRequest"></a>(*EtcdServer) raftRequest</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span> <span class="title">raftRequest</span><span class="params">(ctx context.Context, r pb.InternalRaftRequest)</span> <span class="params">(proto.Message, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> s.raftRequestOnce(ctx, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，带<code>Once</code>关键字的函数，强调只执行一次，简单的可以用<code>sync.Once</code>函数实现，复杂的会结合<code>sync</code>和<code>atomic</code>进行针对性的设计。</p><p>我们再进一步跳转。</p><h3 id="EtcdServer-processInternalRaftRequestOnce"><a href="#EtcdServer-processInternalRaftRequestOnce" class="headerlink" title="(*EtcdServer) processInternalRaftRequestOnce"></a>(*EtcdServer) processInternalRaftRequestOnce</h3><p>这部分的代码我做了个精简，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起RAFT提案Propose（分布式共识算法的术语，不清楚的同学有个初步印象即可）</span></span><br><span class="line">err = s.r.Propose(cctx, data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监控的metrics，表示提案处于Pending计数+1，退出则-1</span></span><br><span class="line">proposalsPending.Inc()</span><br><span class="line"><span class="keyword">defer</span> proposalsPending.Dec()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理结果异步返回，分为三个情况</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="comment">// 正常返回结果</span></span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line"><span class="keyword">return</span> x.(*applyResult), <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 超时等异常处理</span></span><br><span class="line"><span class="keyword">case</span> &lt;-cctx.Done():</span><br><span class="line">proposalsFailed.Inc()</span><br><span class="line">s.w.Trigger(id, <span class="literal">nil</span>) <span class="comment">// GC wait</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, s.parseProposeCtxErr(cctx.Err(), start)</span><br><span class="line">  <span class="comment">// 被正常关闭</span></span><br><span class="line"><span class="keyword">case</span> &lt;-s.done:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrStopped</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="raftNode部分"><a href="#raftNode部分" class="headerlink" title="raftNode部分"></a>raftNode部分</h2><h3 id="raftNode-Propose"><a href="#raftNode-Propose" class="headerlink" title="(raftNode)Propose"></a>(raftNode)Propose</h3><p>如果我们对<code>Propose</code>方法感兴趣，就需要深入学习<code>raftNode</code>这一大块了，它是对RAFT协议的整体封装。</p><p>在<code>etcd</code>里，<code>raftNode</code>是一个比较独立的模块，我们会在后续模块专门分析。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过本篇的代码阅读，我们经历了 HTTP1 -&gt; gRPC -&gt; raftNode 三层，对整个<code>PUT</code>调用链有了一个基本印象。</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd-1-main-Page-3.drawio%20(1).png"></p><p>我在图中特别标注了一些关键的接口与实现。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一讲，我们一起看了etcd server是怎么匹配到对应的处理函数的，如果忘记了请回顾一下。&lt;/p&gt;
&lt;p&gt;今天，我们再进一步，看看&lt;code&gt;PUT&lt;/code&gt;操作接下来是怎么执行的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-etcd" scheme="http://example.com/tags/Go-etcd/"/>
    
  </entry>
  
  <entry>
    <title>etcd源码分析 - 2.【打通核心流程】PUT键值对匹配处理函数</title>
    <link href="http://example.com/2022/06/28/etcd/etcd-2/"/>
    <id>http://example.com/2022/06/28/etcd/etcd-2/</id>
    <published>2022-06-28T04:00:00.000Z</published>
    <updated>2022-07-04T07:24:07.791Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg"></p><p>在阅读了etcd server的启动流程后，我们对很多关键性函数的入口都有了初步印象。</p><p>那么，接下来我们一起看看对键值对的修改，在etcd server内部是怎么流转的。</p><span id="more"></span><h2 id="PUT键值对的HTTP请求"><a href="#PUT键值对的HTTP请求" class="headerlink" title="PUT键值对的HTTP请求"></a>PUT键值对的HTTP请求</h2><p>用<code>etcdctl</code>这个指令，我们可以快速地用命令<code>etcdctl put key value</code>发送PUT键值对的请求。</p><p>但<code>etcdctl</code>对请求做了封装，我们要了解原始的HTTP请求格式，才能方便地阅读相关代码。相关的途径有很多，比如抓包、读源码等，这里为了可阅读性，我给出一个<code>curl</code>请求。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L http://localhost:2379/v3/kv/put -X POST -d &#x27;&#123;&quot;key&quot;:&quot;mykey&quot;,&quot;value&quot;:&quot;myvalue&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure><p>主要关注如下三点：</p><ol><li>Method - <code>POST</code></li><li>URL -<code> /v3/kv/put</code></li><li>Body - <code>&#123;&quot;key&quot;:&quot;mykey&quot;,&quot;value&quot;:&quot;myvalue&quot;&#125;</code></li></ol><blockquote><p>这个请求是v3版本的，而v2版本的差异比较大，暂不细谈。</p></blockquote><h2 id="Mux的路由匹配"><a href="#Mux的路由匹配" class="headerlink" title="Mux的路由匹配"></a>Mux的路由匹配</h2><h2 id="背景知识介绍"><a href="#背景知识介绍" class="headerlink" title="背景知识介绍"></a>背景知识介绍</h2><p>为了更好地介绍下面的内容，我先介绍mux下的2个概念。</p><ul><li><code>pattern</code>指的是一种URL的匹配模式，最常见的如全量匹配、前缀匹配、正则匹配。当一个请求进来时，它会有自己的一个URL，去匹配<code>mux</code>中预先定义的多个<code>pattern</code>，找到一个最合适的。这是一种<strong>URL路由规则的实现</strong>。</li><li>当请求匹配到一个<code>pattern</code>后，就会执行它预定义的<code>handler</code>，也就是一个处理函数，返回结果。</li></ul><p>所以， <code>pattern</code>负责匹配，而<code>handler</code>负责执行。在不同语境下，它们的专业术语有所差异，大家自行对应即可。</p><h3 id="http-mux的创建"><a href="#http-mux的创建" class="headerlink" title="http mux的创建"></a>http mux的创建</h3><p>我们要找HTTP1.X的路由匹配逻辑，就回到了上一节最后看到的代码中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建路由匹配规则</span></span><br><span class="line">httpmux := sctx.createMux(gwmux, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建http server对象</span></span><br><span class="line">srvhttp := &amp;http.Server&#123;</span><br><span class="line">  Handler:  createAccessController(sctx.lg, s, httpmux),</span><br><span class="line">  ErrorLog: logger, <span class="comment">// do not log user error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个cumx.HTTP1是检查协议是否满足HTTP1</span></span><br><span class="line">httpl := m.Match(cmux.HTTP1())</span><br><span class="line"><span class="comment">// 运行server</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; errHandler(srvhttp.Serve(httpl)) &#125;()</span><br></pre></td></tr></table></figure><h3 id="（-serveCtx-createMux"><a href="#（-serveCtx-createMux" class="headerlink" title="（*serveCtx)createMux"></a>（*serveCtx)createMux</h3><p>本函数不长，但很容易让读源码的同学陷入误区，我们一起来看看。这块代码主要分为三段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sctx *serveCtx)</span> <span class="title">createMux</span><span class="params">(gwmux *gw.ServeMux, handler http.Handler)</span> *<span class="title">http</span>.<span class="title">ServeMux</span></span> &#123;</span><br><span class="line">httpmux := http.NewServeMux()</span><br><span class="line">  <span class="comment">// 1.注册handler</span></span><br><span class="line"><span class="keyword">for</span> path, h := <span class="keyword">range</span> sctx.userHandlers &#123;</span><br><span class="line">httpmux.Handle(path, h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.注册grpcGateway mux中的handler到/v3/路径下</span></span><br><span class="line"><span class="keyword">if</span> gwmux != <span class="literal">nil</span> &#123;</span><br><span class="line">httpmux.Handle(</span><br><span class="line"><span class="string">&quot;/v3/&quot;</span>,</span><br><span class="line">wsproxy.WebsocketProxy(</span><br><span class="line">gwmux,</span><br><span class="line">wsproxy.WithRequestMutator(</span><br><span class="line"><span class="comment">// Default to the POST method for streams</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ *http.Request, outgoing *http.Request)</span> *<span class="title">http</span>.<span class="title">Request</span></span> &#123;</span><br><span class="line">outgoing.Method = <span class="string">&quot;POST&quot;</span></span><br><span class="line"><span class="keyword">return</span> outgoing</span><br><span class="line">&#125;,</span><br><span class="line">),</span><br><span class="line">wsproxy.WithMaxRespBodyBufferSize(<span class="number">0x7fffffff</span>),</span><br><span class="line">),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 3.注册根路径下的handler</span></span><br><span class="line"><span class="keyword">if</span> handler != <span class="literal">nil</span> &#123;</span><br><span class="line">httpmux.Handle(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> httpmux</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一点，可以通过简单的代码阅读，看到是对<code>pprof</code>和<code>debug</code>这些通用功能的URL功能注册，也是一些用户自定义的<code>handler</code>注册，这就很好地对应到<code>sctx.userHandlers</code>这个变量的命名了。</p><p>第三点很快就能被排除，它注册的是对根路径下的handler。我们阅读代码，找到handler最原始的生成处，就能看到它是对version、metrcis这类handler的注册。</p><p>所以，我们的重点就放在了<code>gwmux</code>这个对象上。阅读它的创建过程，就得跳转到上层函数。</p><h3 id="serveCtx-registerGateway"><a href="#serveCtx-registerGateway" class="headerlink" title="(*serveCtx)registerGateway"></a>(*serveCtx)registerGateway</h3><p>在函数中，我们可以看到它注册了一个类型为<code>registerHandlerFunc</code>的handlers列表，包括如下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">handlers := []registerHandlerFunc&#123;</span><br><span class="line">etcdservergw.RegisterKVHandler, <span class="comment">// KV键值对的处理</span></span><br><span class="line">etcdservergw.RegisterWatchHandler, <span class="comment">// Watch监听</span></span><br><span class="line">etcdservergw.RegisterLeaseHandler, <span class="comment">// Lease租约</span></span><br><span class="line">etcdservergw.RegisterClusterHandler, <span class="comment">// 集群</span></span><br><span class="line">etcdservergw.RegisterMaintenanceHandler, <span class="comment">// 维护相关</span></span><br><span class="line">etcdservergw.RegisterAuthHandler, <span class="comment">// 认证</span></span><br><span class="line">v3lockgw.RegisterLockHandler, <span class="comment">// 锁</span></span><br><span class="line">v3electiongw.RegisterElectionHandler, <span class="comment">// 选举</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, h := <span class="keyword">range</span> handlers &#123;</span><br><span class="line">  <span class="keyword">if</span> err := h(ctx, gwmux, conn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们聚焦到PUT请求的处理，它自然走的是<code>etcdservergw.RegisterKVHandler</code>这个入口。</p><h3 id="RegisterKVHandler"><a href="#RegisterKVHandler" class="headerlink" title="RegisterKVHandler"></a>RegisterKVHandler</h3><p>本函数位于<code>etcd/etcdserver/etcdserverpb/gw/rpc.pb.gw.go</code>。它其实是用protobuf自动生成的，其中用到了<code>grpc-gateway</code>这个关键性技术，它的作用是将HTTP1的请求转换成gRPC，实现一个server可以同时支持HTTP1与gRPC，并且只写一份gRPC处理的代码即可。</p><blockquote><p>有兴趣地可以去看看 <a href="https://github.com/grpc-ecosystem/grpc-gateway">https://github.com/grpc-ecosystem/grpc-gateway</a> 项目。</p><p>大致调用链路为： HTTP1 -&gt; gRPC -&gt; 自己实现的handler</p></blockquote><h3 id="RegisterKVHandlerClient"><a href="#RegisterKVHandlerClient" class="headerlink" title="RegisterKVHandlerClient"></a>RegisterKVHandlerClient</h3><p>该函数是由proto文件生成的，这里我忽略了关于context的处理，提取关键性的内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mux.Handle(<span class="string">&quot;POST&quot;</span>, pattern_KV_Put_0, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request, pathParams <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 反序列化请求和序列化响应</span></span><br><span class="line">  inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)</span><br><span class="line">  <span class="comment">// 执行PUT请求</span></span><br><span class="line">  resp, md, err := request_KV_Put_0(rctx, inboundMarshaler, client, req, pathParams)</span><br><span class="line">  <span class="comment">// 返回结果</span></span><br><span class="line">  forward_KV_Put_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>序列化与反序列化存在多种选择，我们暂不深入，先来看看处理这部分的工作：</p><p>首先是如何匹配请求，也就是<code>http://localhost:2379/v3/kv/put</code>，对应如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern_KV_Put_0 = runtime.MustPattern(runtime.NewPattern(<span class="number">1</span>, []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">&quot;v3&quot;</span>, <span class="string">&quot;kv&quot;</span>, <span class="string">&quot;put&quot;</span>&#125;, <span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure><p>而最核心的处理，也就是解析PUT请求的函数<code>request_KV_Put_0</code>与返回处理结果的函数<code>forward_KV_Put_0</code>，我们放到下一讲再来看。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天我们看了<code>PUT</code>请求在etcd server中通过<code>mux</code>的匹配逻辑，思路参考下图。</p><p>在阅读代码期间，我们接触到了grpc-gateway这个技术方案，有兴趣的朋友可以参考我的<a href="https://junedayday.github.io/2021/08/19/go-framework/go-framework-1/">另一篇文章</a>。</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd-2-mux.drawio.png"></p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在阅读了etcd server的启动流程后，我们对很多关键性函数的入口都有了初步印象。&lt;/p&gt;
&lt;p&gt;那么，接下来我们一起看看对键值对的修改，在etcd server内部是怎么流转的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-etcd" scheme="http://example.com/tags/Go-etcd/"/>
    
  </entry>
  
  <entry>
    <title>etcd源码分析 - 1.【打通核心流程】etcd server的启动流程</title>
    <link href="http://example.com/2022/06/20/etcd/etcd-1/"/>
    <id>http://example.com/2022/06/20/etcd/etcd-1/</id>
    <published>2022-06-20T04:00:00.000Z</published>
    <updated>2022-06-27T05:55:00.438Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg"></p><p><code>etcd</code>的源码相对<code>Kubernetes</code>少了很多，但学习成本依旧在。</p><p>在第一阶段，我将从主流程出发，讲述一个<code>PUT</code>指令是怎么将数据更新到<code>etcd server</code>中的。今天，我们先来看看server是怎么启动的。</p><span id="more"></span><h2 id="etcd-server启动代码"><a href="#etcd-server启动代码" class="headerlink" title="etcd server启动代码"></a>etcd server启动代码</h2><p>运行<code>etcd server</code>的最简化代码为<code>./bin/etcd</code>，无需添加任何参数。我们就根据这个命令来阅读代码，看看启动的主逻辑是怎么样的。</p><h3 id="etcdmain-Main"><a href="#etcdmain-Main" class="headerlink" title="etcdmain.Main"></a>etcdmain.Main</h3><p>主入口函数中，只要我们能理解<code>os.Args</code>它的含义，就能快速地跳过中间代码，找到下一层函数的入口<code>startEtcdOrProxyV2()</code>。</p><h3 id="startEtcdOrProxyV2"><a href="#startEtcdOrProxyV2" class="headerlink" title="startEtcdOrProxyV2"></a>startEtcdOrProxyV2</h3><p>本函数较长，就比较考验我们的通读能力。在阅读这一块代码时，我一般会用到三个小技巧：</p><ol><li>忽略<code>err != nil</code>的判断分支，一般它们都是对异常case的处理；</li><li>忽略<code>变量 == 默认值</code>的判断分支，如<code>字符串变量 == &quot;&quot;</code>，这种多为对默认值的处理，如做变量初始化等；</li><li>寻找串联上下文的关键性变量，一般都会有明确的命名或注释；</li></ol><p>而在这块代码里呢，我们就能找到2个关键性的变量，以及相关的使用处：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示停止动作与错误的两个channel</span></span><br><span class="line"><span class="keyword">var</span> stopped &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> errc &lt;-<span class="keyword">chan</span> error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种模式：第一种是正常的etcd server，第二种是代理模式</span></span><br><span class="line"><span class="keyword">switch</span> which &#123;</span><br><span class="line"><span class="keyword">case</span> dirMember:</span><br><span class="line">stopped, errc, err = startEtcd(&amp;cfg.ec)</span><br><span class="line"><span class="keyword">case</span> dirProxy:</span><br><span class="line">err = startProxy(cfg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞并监听两个通道的地方</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> lerr := &lt;-errc:</span><br><span class="line"><span class="keyword">case</span> &lt;-stopped:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这部分的代码，我们就能定位到下一层的函数入口 - <code>startEtcd</code>。</p><h3 id="startEtcd"><a href="#startEtcd" class="headerlink" title="startEtcd"></a>startEtcd</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startEtcd</span><span class="params">(cfg *embed.Config)</span> <span class="params">(&lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, &lt;-<span class="keyword">chan</span> error, error)</span></span> &#123;</span><br><span class="line">e, err := embed.StartEtcd(cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">osutil.RegisterInterruptHandler(e.Close)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-e.Server.ReadyNotify(): <span class="comment">// wait for e.Server to join the cluster</span></span><br><span class="line"><span class="keyword">case</span> &lt;-e.Server.StopNotify(): <span class="comment">// publish aborted from &#x27;ErrStopped&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e.Server.StopNotify(), e.Err(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以从三个关键动作，来了解这个函数的功能：</p><ol><li>启动etcd，如果失败则通过<code>error</code>返回；</li><li>启动etcd后，本节点会加入到整个集群中，就绪后则通过channel<code>e.Server.ReadyNotify()</code>收到消息；</li><li>启动etcd后，如果遇到异常，则会通过channel<code>e.Server.StopNotify()</code>收到消息；</li></ol><p>另外，<code>osutil.RegisterInterruptHandler(e.Close)</code>这个函数注册了etcd异常退出的函数，里面涉及到一些汇编，有兴趣可以深入阅读。</p><h3 id="embed-StartEtcd"><a href="#embed-StartEtcd" class="headerlink" title="embed.StartEtcd"></a>embed.StartEtcd</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">StartEtcd</span><span class="params">(inCfg *Config)</span> <span class="params">(e *Etcd, err error)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们先简单地通读一下注释，可以了解到：<strong>本函数返回的Etcd并没有保证加入到集群，而是要等待channel通知</strong>。这就印证了上面的猜想。<code>StartEtcd</code>函数很长，我先解释两个关键词：</p><ol><li>peer - 英文翻译为同等地位的人，在当前语义下表示其余同等的etcd server节点，共同组成集群；</li><li>client - 即客户端，可以理解为发起etcd请求方，如程序；</li></ol><p>我们看到一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建 etcdserver.EtcdServer 对象</span></span><br><span class="line"><span class="keyword">if</span> e.Server, err = etcdserver.NewServer(srvcfg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> e, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动etcdserver</span></span><br><span class="line">e.Server.Start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接peer/client，以及提供metrics指标</span></span><br><span class="line"><span class="keyword">if</span> err = e.servePeers(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> e, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = e.serveClients(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> e, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = e.serveMetrics(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> e, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入Start方法，可以看到里面都是一些常驻的daemon程序，如监控版本/KV值，与我们关注的PUT操作的核心流程无关。所以，我们的目标就转移到<code>serveClients</code>函数。</p><h3 id="serveClients"><a href="#serveClients" class="headerlink" title="serveClients"></a>serveClients</h3><p>本函数的重点在于下面这段。这里有个变量叫<code>sctx</code>，就是server context的简写，是在前面<code>embed.StartEtcd</code>里初始化的，主要由context、日志、网络信息组成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, sctx := <span class="keyword">range</span> e.sctxs &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s *serveCtx)</span></span> &#123;</span><br><span class="line">    e.errHandler(s.serve(e.Server, &amp;e.cfg.ClientTLSInfo, h, e.errHandler, gopts...))</span><br><span class="line">  &#125;(sctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点理解下面这个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Etcd)</span> <span class="title">errHandler</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 第一次select，如果收到停止消息，则退出，否则到第二个select</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-e.stopc:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第二次select，一般情况下长期阻塞在这里：要么收到停止消息，要么将error从e.errc发送出去</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-e.stopc:</span><br><span class="line"><span class="keyword">case</span> e.errc &lt;- err:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="serveCtx-serve"><a href="#serveCtx-serve" class="headerlink" title="(*serveCtx)serve()"></a>(*serveCtx)serve()</h3><p><code>serve()</code>函数我们可以快速地通过缩进来阅读：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非安全，即HTTP</span></span><br><span class="line"><span class="keyword">if</span> sctx.insecure &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全，即HTTPS</span></span><br><span class="line"><span class="keyword">if</span> sctx.secure &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们关注的HTTP部分，又分为两块 - HTTP2和HTTP1。而每一个server都有一个关键变量：</p><p><code>mux</code>多路复用器 - 在web编程的场景下，往往指多个路由规则的匹配，最常见的如将URL映射到一个处理函数；而创建完<code>mux</code>后，将它注册到server中运行起来。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里，我们串联了整个<code>main</code>函数运行的相关代码，也建立了etcd server运行的主要逻辑，我也总结到了下面这张图中。</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd-1-main.drawio.png"></p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;etcd&lt;/code&gt;的源码相对&lt;code&gt;Kubernetes&lt;/code&gt;少了很多，但学习成本依旧在。&lt;/p&gt;
&lt;p&gt;在第一阶段，我将从主流程出发，讲述一个&lt;code&gt;PUT&lt;/code&gt;指令是怎么将数据更新到&lt;code&gt;etcd server&lt;/code&gt;中的。今天，我们先来看看server是怎么启动的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-etcd" scheme="http://example.com/tags/Go-etcd/"/>
    
  </entry>
  
  <entry>
    <title>etcd源码分析 - 0.搭建学习etcd的环境</title>
    <link href="http://example.com/2022/06/14/etcd/etcd-0/"/>
    <id>http://example.com/2022/06/14/etcd/etcd-0/</id>
    <published>2022-06-14T04:00:00.000Z</published>
    <updated>2022-07-04T06:12:40.046Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg"></p><p>之前，我在b站视频简单地讲述了etcd的功能与特性，有兴趣的可以参考<a href="https://www.bilibili.com/video/BV155411Y7Pq/">相关视频</a>。</p><p>但如果要更深入地研究etcd，就需要我们涉及到源码、并结合实践进行学习。那么，接下来，我将基于<code>v3.4</code>这个版本，做一期深入的环境搭建。</p><span id="more"></span><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>Macbook - 为了方便读代码与编译运行，也可自行搭建Ubuntu等可视化系统</li><li>Go语言 - v1.17，我选用的是v1.17.11</li><li>Goland/VSCode</li><li>etcd源码 - 建议用Github Desktop进行下载</li></ol><h2 id="基本调试"><a href="#基本调试" class="headerlink" title="基本调试"></a>基本调试</h2><p>为了保证etcd可运行，我们先在根目录上运行<code>go mod tidy</code>，保证依赖库没有问题。</p><p>接着，我们阅读<code>Makefile</code>文件，发现其提供了<code>make build</code>指令。运行后，在<code>bin</code>目录下生成了<code>etcd</code>/<code>etcdctl</code>/<code>etcdutl</code>三个可执行文件，并且打印出了版本信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./bin/etcd --version</span><br><span class="line">etcd Version: 3.4.18</span><br><span class="line">Git SHA: c2c9e7de0</span><br><span class="line">Go Version: go1.17.11</span><br><span class="line">Go OS/Arch: darwin/amd64</span><br><span class="line">./bin/etcdctl version</span><br><span class="line">etcdctl version: 3.4.18</span><br><span class="line">API version: 3.4</span><br></pre></td></tr></table></figure><p>我们暂时只关注<code>etcd</code>与<code>etcdctl</code>，可以简单地将两者理解为服务端与客户端。我们分别在两个终端进行操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行etcd server</span></span><br><span class="line">./bin/etcd</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 写入一个key</span></span><br><span class="line">./bin/etcdctl put mykey &quot;this is awesome&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取一个key</span></span><br><span class="line">./bin/etcdctl get mykey</span><br></pre></td></tr></table></figure><p>如果你能读取到对应的信息，那么就证明整个环境已经很好地运行起来了。</p><h2 id="从Makefile看Go的编译步骤"><a href="#从Makefile看Go的编译步骤" class="headerlink" title="从Makefile看Go的编译步骤"></a>从Makefile看Go的编译步骤</h2><p>在日常开发的过程中，我们对Go程序的编译往往只是一行简单的<code>go build</code>，但在大型工程中往往还不够。我们看看etcd做了什么。</p><h3 id="GIT-SHA"><a href="#GIT-SHA" class="headerlink" title="GIT_SHA"></a>GIT_SHA</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GIT_SHA=$(git rev-parse --short HEAD || echo &quot;GitNotFound&quot;)</span><br><span class="line">GO_LDFLAGS=&quot;$GO_LDFLAGS -X $&#123;REPO_PATH&#125;/version.GitSHA=$&#123;GIT_SHA&#125;&quot;</span><br></pre></td></tr></table></figure><p>这个参数是取git最新一次的commit的短hash，用来标识源码的版本，比如c2c9e7de0。</p><p>然后，将这个相对唯一的值，作为GO_LDFLAGS中的一个参数，打入到go程序中。</p><h3 id="ldflags"><a href="#ldflags" class="headerlink" title="ldflags"></a>ldflags</h3><p>在Makefile中的编译里，我们会用到<code>-ldflags &quot;$GO_LDFLAGS&quot;</code>这个参数。通过运行<code>go help build</code>，可以看到这么一段说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-ldflags &#x27;[pattern=]arg list&#x27;</span><br><span class="line">               arguments to pass on each go tool link invocation.</span><br></pre></td></tr></table></figure><p>也就是用key=value对的格式，将想要的信息传递给Go程序。</p><blockquote><p>ldflags可以记忆为 load flags，即将标记信息加载到程序中。</p></blockquote><h2 id="传递ldflags中的参数"><a href="#传递ldflags中的参数" class="headerlink" title="传递ldflags中的参数"></a>传递ldflags中的参数</h2><p><code>ldflags</code>传递参数的方式是 <code>package_path.variable_name=new_value</code>。</p><p>以示例中的build为例，这个值为<code>go.etcd.io/etcd/version.GitSHA=$&#123;GIT_SHA&#125;</code>，对应到三块：</p><ol><li>package_path = go.etcd.io/etcd/version</li><li>variable_name = GitSHA</li><li>new_value = ${GIT_SHA}</li></ol><p>所以，这里所做的就是将<code>go.etcd.io/etcd/version</code>这个package下的<code>GitSHA</code>变量替换为想要的值。我们去对应的代码里看，发现对应的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// MinClusterVersion is the min cluster version this etcd binary is compatible with.</span></span><br><span class="line">MinClusterVersion = <span class="string">&quot;3.0.0&quot;</span></span><br><span class="line">Version           = <span class="string">&quot;3.4.18&quot;</span></span><br><span class="line">APIVersion        = <span class="string">&quot;unknown&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Git SHA Value will be set during build</span></span><br><span class="line">GitSHA = <span class="string">&quot;Not provided (use ./build instead of go build)&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>所以，我们可以通过编译脚本实现代码中变量的替换。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>etcd的学习环境搭建并不复杂，主要是有一台Mac电脑。接下来，我们将逐步开始一起阅读代码。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前，我在b站视频简单地讲述了etcd的功能与特性，有兴趣的可以参考&lt;a href=&quot;https://www.bilibili.com/video/BV155411Y7Pq/&quot;&gt;相关视频&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但如果要更深入地研究etcd，就需要我们涉及到源码、并结合实践进行学习。那么，接下来，我将基于&lt;code&gt;v3.4&lt;/code&gt;这个版本，做一期深入的环境搭建。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-etcd" scheme="http://example.com/tags/Go-etcd/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 16.【Go泛型】何时使用泛型</title>
    <link href="http://example.com/2022/06/07/go-tip/go-tip-16/"/>
    <id>http://example.com/2022/06/07/go-tip/go-tip-16/</id>
    <published>2022-06-07T04:00:00.000Z</published>
    <updated>2022-06-09T12:31:52.330Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>本文重点依赖于 <a href="https://go.dev/blog/when-generics">https://go.dev/blog/when-generics</a> 这篇博客，有时间的可以自行阅读。</p><p>本文会结合个人的理解与经验，强调其中的重点。</p><span id="more"></span><h2 id="两个示例"><a href="#两个示例" class="headerlink" title="两个示例"></a>两个示例</h2><p>文章给出了两个示例，我们看一下签名，了解其功能即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 1</span></span><br><span class="line"><span class="comment">// 两个泛型Key,Val，Key是可比较的类型，而Val是任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapKeys</span>[<span class="title">Key</span> <span class="title">comparable</span>, <span class="title">Val</span> <span class="title">any</span>]<span class="params">(m <span class="keyword">map</span>[Key]Val)</span> []<span class="title">Key</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 2</span></span><br><span class="line"><span class="comment">// T表示任意类型，它被嵌入到具体的数据结构 Tree[T any] 和 node[T any] 中</span></span><br><span class="line"><span class="keyword">type</span> Tree[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    cmp  <span class="function"><span class="keyword">func</span><span class="params">(T, T)</span> <span class="title">int</span></span></span><br><span class="line">    root *node[T]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    left, right  *node[T]</span><br><span class="line">    val          T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *Tree[T])</span> <span class="title">find</span><span class="params">(val T)</span> **<span class="title">node</span>[<span class="title">T</span>]</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例一分析"><a href="#示例一分析" class="headerlink" title="示例一分析"></a>示例一分析</h2><p>示例一就是将泛型直接用到的 <strong>函数签名中的变量类型</strong>。</p><p>它的特点主要是：能力受限于基础类型，只有关键词any和comparable两种。所以，这种方式适合基础类型的基本操作，如针对map/slice的遍历、求和等。</p><p>文章也强调了：由于它无法在编译期用静态类型检查，所以在运行时会慢一点。这点性能损失对普通应用来说完全可以忽略。</p><h2 id="示例二分析"><a href="#示例二分析" class="headerlink" title="示例二分析"></a>示例二分析</h2><p>示例二非常重要，值得我们反复阅读。</p><p>先提炼一下，它的泛型<code>T</code>体现在两块：</p><ol><li>数据结构的命名 - <code>Tree[T any]</code>和<code> node[T any]</code>，这里的泛型不做任何限制，只表示<strong>数据结构</strong>；</li><li>关键性的计算功能 - <code>cmp  func(T, T) int</code>，这里是<strong>泛型T的计算能力的关键实现</strong>；</li></ol><p>所以，这就是一种 <strong>数据结构与计算分离的实现</strong>。</p><p>在这个例子中，泛型<code>T</code>表示任意类型。由于它的数据结构的不确定性，自然就无法进行计算；这时引入的<code>cmp</code>函数，则是将<code>T</code>的计算逻辑作为输入</p><h2 id="泛型中更倾向于用函数，而不是方法"><a href="#泛型中更倾向于用函数，而不是方法" class="headerlink" title="泛型中更倾向于用函数，而不是方法"></a>泛型中更倾向于用函数，而不是方法</h2><p>上面示例二明显比示例一更具通用性。我们重点分析一下<code>cmp</code>这个函数。</p><p>在传统的面向对象中，我们倾向于使用方法来定义某个功能，比如<code>(t1 T)cmp (t2 T) int </code>这样的方法，但这是有依赖的。试想一下，如果你接着写这个方法的实现，势必会写到<code>t1</code>与<code>t2</code>这两个数据结构的对比了。绕了一圈，我们还是不得不面对<code>func(T, T) int</code>这么一个函数。</p><p>所以，在Go泛型中，最有效的方式就是直接传入这个函数，由开发者自行实现。</p><h2 id="泛型与接口"><a href="#泛型与接口" class="headerlink" title="泛型与接口"></a>泛型与接口</h2><p>泛型和接口有不少相似之处，比如上面的泛型需要传入<code>cmp</code>这个一个对比函数，而如果用接口，往往也需要自己实现接口相关的方法。</p><p>但是，我们切勿混淆两者。我们仔细去思考两者的实现，会发现两者的关键性差异：</p><ul><li>泛型：泛型往往更强调的是数据结构的共同特征，相关的函数只是起到辅助功能，并且处理逻辑要完全一致；</li><li>接口：接口不关心具体的数据结构，而强调要实现对应的相关方法；</li></ul><p>所以，<strong>泛型更多的是从数据结构来思考共同特征，会偏向于过程性思维，适合底层的基础工具库；而接口则是用方法来抽象各种对象，是面向对象的思维，适合中、高层的编程</strong>。</p><h2 id="指导性原则"><a href="#指导性原则" class="headerlink" title="指导性原则"></a>指导性原则</h2><p>最后，作者总结了一个指导性原则：</p><p><strong>当你反复地写类似的代码时，而这些代码之间的差异只是数据结构不同，那你就可以考虑使用泛型。</strong></p><p>这里有2个特点：</p><ol><li><strong>反复性</strong>：如果只是写两三次就能解决的，就没必要使用泛型了；</li><li><strong>非逻辑类问题</strong>：如果是计算逻辑有差异，那也不能使用泛型；</li></ol><p>换一句话来说，<strong>先写重复性代码，再提炼成泛型</strong>，不要过早引入泛型。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说，Go的泛型提供了新的语法糖，主要针对底层库的提效，并非解决重复性coding的银弹。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h2&gt;&lt;p&gt;本文重点依赖于 &lt;a href=&quot;https://go.dev/blog/when-generics&quot;&gt;https://go.dev/blog/when-generics&lt;/a&gt; 这篇博客，有时间的可以自行阅读。&lt;/p&gt;
&lt;p&gt;本文会结合个人的理解与经验，强调其中的重点。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>技术阅读摘要 - 4.闲谈晋升</title>
    <link href="http://example.com/2022/06/04/readings/go-digest-4/"/>
    <id>http://example.com/2022/06/04/readings/go-digest-4/</id>
    <published>2022-06-04T04:00:00.000Z</published>
    <updated>2022-06-04T07:56:39.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>晋升是每个技术人都应该经历的一次洗礼。一般来说，分为提名、准备、述职、答辩这四个步骤。</p><p>尽管每个人的经历与体会都有不同，很难照搬硬套，但我相信只要是真心分享的经验，总会对人有帮助。接下来，我将从五个点展开。</p><span id="more"></span><h2 id="一切以如何被提名为前提"><a href="#一切以如何被提名为前提" class="headerlink" title="一切以如何被提名为前提"></a>一切以如何被提名为前提</h2><p>晋升提名分为自提名和领导提名，一般只建议走后面的渠道。</p><p>如何被提名，每个公司在不同阶段都有不同的标准，但有两点是必备的：绩效与能力。这个很容易理解，我就不赘述了。</p><p>除了以上两点，还有不少因素会左右被提名这件事，往往和组织结构息息相关：</p><ul><li>某团队很讲究先来后到，那么晋升往往就像排队</li><li>某领导很讲究团队和谐，那么“刺头们”往往要往后挪</li><li>某组织很看重稳定性，那么出一次事故，再多的功劳与能力都没用</li></ul><p>这类因素很多，这部分往往需要你融入团队后才能知道。如果你希望得到晋升，请尊重这个玩法：在作为基层的时候，不要与组织正面抗衡。这么说很有功利性色彩：要么适应、要么滚，没必要把自己撞得头破血流。</p><p>有一句话，我希望对大家有启发：<strong>你有再多的证据可以证明自己满足下一职级，也不代表你会被提名。</strong>晋升提名是一个分界线，请注意这个游戏的先后关系：先有提名，再准备材料向评委证明自己的能力。</p><h2 id="晋升提名后，先降低自己的预期"><a href="#晋升提名后，先降低自己的预期" class="headerlink" title="晋升提名后，先降低自己的预期"></a>晋升提名后，先降低自己的预期</h2><p>在准备的过程中，有不少因素会打击到人的心态。很多人会慢慢变得不自信，开始怀疑自己是不是有能力、有资格晋升，于是变得消极，甚至开始摆烂。</p><p>如何调节沮丧、低落的情绪，因人而异，不过有一点很明确 - 如果你具有足够的辨识能力的话，接受到外部反馈的因素越多，你的晋升述职效果就会被打磨得越好。但，当你过度失落时，你的分辨能力也会大幅下降。</p><p>这时，我建议不要再接收外部反馈的信息了。最简单的方式，就是只跟着直属领导的思路去写一份PPT，不与外界其他人交流。</p><p>我有个建议：<strong>拿到晋升名额，不代表你的当前思路是满足晋升述职的。</strong>不少人的失落，是因为他们觉得自己被提名后，过去的经历被贬得一文不值，就开始怀疑自己了。所以，一切清零，破而后立，降低自己的预期，能建立一个更好的心态。</p><h2 id="晋升材料是立足现在看过去"><a href="#晋升材料是立足现在看过去" class="headerlink" title="晋升材料是立足现在看过去"></a>晋升材料是立足现在看过去</h2><p>立足过去，我们写的往往是过程性的What。这部分材料像是一篇记叙文，讲你做了什么，所以拿到了什么样的成果，很难证明自己的能力：有没有更好的解法？这样的成果足够吗？你的认识是不是有局限性？</p><p>而立足现在，则能从更高的角度，去回答很多Why类问题。于是，整篇文章就变得像一篇论文，证明你的能力足以到下一个级别。在这个过程中，你会发现有很多以前的不足，有改进项，要基于现在的个人能力，适当包装。</p><p>所以，我们要明确思路：<strong>你做过什么，都体现在晋升名额里了；而你做事的能力，才是应该在晋升述职里体现的。</strong>从这个角度来看，丢掉80%以上无意义的工作内容也毫不可惜。</p><h2 id="晋升答辩不是PK，而是能力挖掘"><a href="#晋升答辩不是PK，而是能力挖掘" class="headerlink" title="晋升答辩不是PK，而是能力挖掘"></a>晋升答辩不是PK，而是能力挖掘</h2><p>并非所有的晋升评委都非常优秀，但可以肯定的是，绝大多数都是抱着善意的。</p><p>晋升述职的重点，就是评委的提问环节。一般来说，问题分两类：了解你的表达内容、发掘你的能力。前面的问题往往源于你的材料没有表述清楚，需要你快速、准确地传达内容。而后者，则是支撑你晋升成功的关键。</p><p>挖掘问题的能力，主要在于三个：细节、深度、广度。这类问题往往源于你的晋升材料，所以可以尝试着做一些伏笔，引导评委来问。</p><p>对于评委的提问，我们要明确：<strong>不要只回答问题，而是尽可能地感受评委的用意，表现出自己的能力</strong>。打铁还需自身硬，但良好的心态能有不少加分。</p><h2 id="晋升与面试里的表现形式"><a href="#晋升与面试里的表现形式" class="headerlink" title="晋升与面试里的表现形式"></a>晋升与面试里的表现形式</h2><p>晋升与面试其实有很多相似点，尤其是评判逻辑上：晋升是公司评定你的能力可以达到下一个级别，而面试则是公司评价你的能力可以为公司带来对应的效益。核心，都是在于个人能力。</p><p>那么，如何表现出个人能力呢？常见的方式有项目、业绩、技术难点、领导团队等，但两者的表现形式有明显差异：</p><p>晋升的表现形式必须遵循公司的玩法，关注点很有限。比如，下一个级别的重点指标是技术架构能力，那你花大篇幅写某个技术深度的研究，虽然很棒，但偏题了。</p><p>而面试呢，我们往往是一份简历、多处投递，这就考验我们材料的普适性，一般来说都要各个点均有涉及、并且有几处亮点。除此以外，在面试时，还需要针对面试官感兴趣的点，能快速地扩展，所以临场应变非常重要。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>晋升过程是一个很好回顾过去的机会，不仅仅是自己在反复推敲，也能接收来自高层管理的反馈。</p><p>晋升的目标自然是获得成功，但从长期来看，这个过程对你的成长更有帮助。</p><p>如果说要用一个词概括我的最大感触，那就是放弃：晋升阶段是一个很特殊的时期，适当放弃日常工作模式下的思维方式，才能让你更好地进入这个阶段。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;晋升是每个技术人都应该经历的一次洗礼。一般来说，分为提名、准备、述职、答辩这四个步骤。&lt;/p&gt;
&lt;p&gt;尽管每个人的经历与体会都有不同，很难照搬硬套，但我相信只要是真心分享的经验，总会对人有帮助。接下来，我将从五个点展开。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Digest" scheme="http://example.com/tags/Digest/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 7.【盛最多水的容器LeetCode-11】</title>
    <link href="http://example.com/2022/04/09/go-leetcode/go-leetcode-7/"/>
    <id>http://example.com/2022/04/09/go-leetcode/go-leetcode-7/</id>
    <published>2022-04-09T03:00:00.000Z</published>
    <updated>2022-04-09T03:40:31.591Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-11-盛最多水的容器"><a href="#Leetcode-11-盛最多水的容器" class="headerlink" title="Leetcode-11 盛最多水的容器"></a>Leetcode-11 盛最多水的容器</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/container-with-most-water/">https://leetcode-cn.com/problems/container-with-most-water/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 左右两个指针往中间逼近</span></span><br><span class="line">left, right := <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line"><span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line"><span class="keyword">var</span> area <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 哪边高度低，就挪哪边</span></span><br><span class="line"><span class="keyword">if</span> height[left] &lt; height[right] &#123;</span><br><span class="line">area = (right - left) * height[left]</span><br><span class="line">left++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">area = (right - left) * height[right]</span><br><span class="line">right--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> area &gt; max &#123;</span><br><span class="line">max = area</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-11-盛最多水的容器&quot;&gt;&lt;a href=&quot;#Leetcode-11-盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-11 盛最多水的容器&quot;&gt;&lt;/a&gt;Leetcode-11 盛最多水的容器&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water/&quot;&gt;https://leetcode-cn.com/problems/container-with-most-water/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxArea&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(height []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法实战" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 8.【三数之和LeetCode-15】</title>
    <link href="http://example.com/2022/04/09/go-leetcode/go-leetcode-8/"/>
    <id>http://example.com/2022/04/09/go-leetcode/go-leetcode-8/</id>
    <published>2022-04-09T03:00:00.000Z</published>
    <updated>2022-04-10T03:45:49.815Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-15-三数之和"><a href="#Leetcode-15-三数之和" class="headerlink" title="Leetcode-15 三数之和"></a>Leetcode-15 三数之和</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -2是保证至少留下2个数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 剪枝：最小值大于0时无需再遍历</span></span><br><span class="line"><span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 剪枝：最小值和前一个值一样时，上一个循环已经判断过，无需再判断</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// j,k 为两个指针，分别从最左边和最右边开始移动</span></span><br><span class="line">j, k := i+<span class="number">1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> j &lt; k &#123;</span><br><span class="line">left, right := nums[j], nums[k]</span><br><span class="line"><span class="keyword">if</span> nums[i]+nums[j]+nums[k] == <span class="number">0</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;nums[i], nums[j], nums[k]&#125;)</span><br><span class="line"><span class="comment">// 减枝：同值的话左边往右移，跳过 nums[j] == nums[j+1] 的情况</span></span><br><span class="line"><span class="keyword">for</span> j &lt; k &amp;&amp; nums[j] == left &#123;</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 减枝：同值的话右边往左移，跳过 nums[k] == nums[k-1] 的情况</span></span><br><span class="line"><span class="keyword">for</span> j &lt; k &amp;&amp; nums[k] == right &#123;</span><br><span class="line">k--</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[j]+nums[k] &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 和小于0，则增大最左边的j</span></span><br><span class="line">j++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 和大于0，则减少最右边的k</span></span><br><span class="line">k--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-15-三数之和&quot;&gt;&lt;a href=&quot;#Leetcode-15-三数之和&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-15 三数之和&quot;&gt;&lt;/a&gt;Leetcode-15 三数之和&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/3sum/&quot;&gt;https://leetcode-cn.com/problems/3sum/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;threeSum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nums []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; [][]&lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法实战" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 6.【正则表达式匹配LeetCode-10】</title>
    <link href="http://example.com/2022/04/09/go-leetcode/go-leetcode-6/"/>
    <id>http://example.com/2022/04/09/go-leetcode/go-leetcode-6/</id>
    <published>2022-04-09T00:00:00.000Z</published>
    <updated>2022-04-09T03:40:11.636Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-10-正则表达式匹配"><a href="#Leetcode-10-正则表达式匹配" class="headerlink" title="Leetcode-10 正则表达式匹配"></a>Leetcode-10 正则表达式匹配</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/regular-expression-matching/">https://leetcode-cn.com/problems/regular-expression-matching/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">row, col := <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp 就是核心的状态转移方程，这里注意要+1，是为了空字符串这个边界条件</span></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, row+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, col+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充dp[0]数组，也就是s为空字符串</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; col+<span class="number">1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// p为空字符串的情况</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line"><span class="comment">// 如果p[j-1]为*，则可以截断*和它前面的一个字符，表示匹配0个对应字符</span></span><br><span class="line">dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-2</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充整个dp数组，注意i和j在dp中不变，但对应到字符串s/p中都要-1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; row+<span class="number">1</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; col+<span class="number">1</span>; j++ &#123;</span><br><span class="line">            <span class="comment">// 最后一个字符是*的话</span></span><br><span class="line"><span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">                    <span class="comment">// *匹配上一个字符，要么截断s一个字符，要么去掉*和前一个字符</span></span><br><span class="line">dp[i][j] = dp[i][j<span class="number">-2</span>] || dp[i<span class="number">-1</span>][j]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果不匹配，则认为*没匹配上，只能去掉*和前一个字符</span></span><br><span class="line">dp[i][j] = dp[i][j<span class="number">-2</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line"><span class="comment">// 如果精确匹配或者匹配上了.，就各自截断后往前找</span></span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[row][col]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-10-正则表达式匹配&quot;&gt;&lt;a href=&quot;#Leetcode-10-正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-10 正则表达式匹配&quot;&gt;&lt;/a&gt;Leetcode-10 正则表达式匹配&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/regular-expression-matching/&quot;&gt;https://leetcode-cn.com/problems/regular-expression-matching/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isMatch&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(s &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;, p &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法实战" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
</feed>
