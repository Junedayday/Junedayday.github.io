<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Go语言微服务框架 - 1.搭建gRPC+HTTP的双重网关服务</title>
    <url>/2021/08/19/go-framework/go-framework-1/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p>
<p>大家好，我是六月天天。如题所述，从今天开始，我将和大家一起逐步完成一个微服务框架。</p>
<p>整个迭代过程会围绕着两个核心思想进行：</p>
<ol>
<li><strong>关注技术选型背后的思想</strong>。虽然最终某个技术选型的可能并不是你喜欢的方案（如RPC、日志、数据库等，你可以fork后自行调整），但我们更关注各个技术组件背后的原理与思想，<strong>选择的过程比结果更重要</strong>；</li>
<li><strong>聚焦于简单，关注可维护性</strong>。技术框架是项目的基础设施，也是排查复杂业务问题的根本，所以框架层的功能会尽量考虑简单易用，可以让我们花更多的心思在业务开发中。许多开源库提供了大量扩展功能，但我们使用时会尽量<strong>克制</strong>，减少学习和排查问题时的成本。</li>
</ol>
<p>微服务框架系列重点介绍框架的搭建过程，期间对一些细节技术点的讲解，会在另一个系列<strong>Go语言技巧系列</strong>中展开。</p>
<span id="more"></span>



<h2 id="v0-1-0：搭建gRPC-HTTP的双重网关服务"><a href="#v0-1-0：搭建gRPC-HTTP的双重网关服务" class="headerlink" title="v0.1.0：搭建gRPC+HTTP的双重网关服务"></a>v0.1.0：搭建gRPC+HTTP的双重网关服务</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.1.0">https://github.com/Junedayday/micro_web_service/tree/v0.1.0</a></p>
<p>gRPC-gateway官方Github <a href="https://github.com/grpc-ecosystem/grpc-gateway">https://github.com/grpc-ecosystem/grpc-gateway</a></p>
<blockquote>
<p>有很多朋友更喜欢使用Gin框架，但我依然选择了gRPC-gateway。</p>
<p>主要在于gRPC-gateway方案对接Google提供的各种开源插件生态都很棒。大家会在后面框架的迭代过程中慢慢体会到它的特性。</p>
<p>后续我也会对Gin做一些分析。</p>
</blockquote>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>完成RPC服务的框架的搭建</p>
<h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol>
<li><code>protobuffer</code>定义IDL（Interface Definition Language 接口定义语言）</li>
<li><code>buf</code>工具生成<code>Go</code>代码（包括数据结构和RPC相关服务）</li>
<li><code>Go</code>项目实现RPC服务（实现RPC接口）</li>
</ol>
<h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">	|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">	   |-- idl                             对应idl文件夹</span><br><span class="line">	      |-- demo                             对应idl/demo服务</span><br><span class="line">	         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">	         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">	         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">	|-- idl                            原始的idl定义</span><br><span class="line">	   |-- demo                            业务package定义</span><br><span class="line">	      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">	|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">	   |-- server                          服务器的实现</span><br><span class="line">	      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">	      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">	|-- buf.gen.yaml                   buf生成代码的定义</span><br><span class="line">	|-- buf.yaml                       buf工具安装所需的工具</span><br><span class="line">	|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">	|-- go.mod                         Go Module文件</span><br><span class="line">	|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure>

<h2 id="1-protobuffer定义IDL"><a href="#1-protobuffer定义IDL" class="headerlink" title="1. protobuffer定义IDL"></a>1. protobuffer定义IDL</h2><p>我们先看一下项目中的<code>demo.proto</code>文件，重点关注 <strong>rpc Echo(DemoRequest) returns (DemoResponse)</strong> 这个定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message DemoRequest &#123;</span><br><span class="line">   string value = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message DemoResponse &#123;</span><br><span class="line">   int32 code = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 样例服务</span><br><span class="line">service DemoService &#123;</span><br><span class="line">  // Echo 样例接口</span><br><span class="line">  rpc Echo(DemoRequest) returns (DemoResponse) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      post : &quot;/apis/demo&quot;</span><br><span class="line">      body : &quot;*&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>今天我们暂时不对<code>protobuffer</code>的语法做扩展讲解，只需要简单地了解下它的请求结构体<code>DemoRequest</code>和响应结构体<code>DemoResponse</code>。</p>
<h2 id="2-buf工具生成Go代码"><a href="#2-buf工具生成Go代码" class="headerlink" title="2. buf工具生成Go代码"></a>2. buf工具生成Go代码</h2><p>我们通过运行项目根目录中的<code>gen.sh</code>，会在<code>gen</code>目录下生成对应的Go语言代码。</p>
<p>这部分是自动化的工作，每次修改<code>proto</code>文件后需要运行。</p>
<blockquote>
<p>buf工具的安装请参考README.md，它是protoc的演进版本，不再需要大量flag参数，更加简单易用。</p>
<p>注意，如果修改了模块名，buf工具第一次初始化建议使用 buf beta mod init 指令</p>
</blockquote>
<h2 id="3-Go项目实现RPC服务"><a href="#3-Go项目实现RPC服务" class="headerlink" title="3.Go项目实现RPC服务"></a>3.Go项目实现RPC服务</h2><p>我们梳理一下整个逻辑，来看看这个<code>Go</code>程序是怎么提供RPC服务的。</p>
<ol>
<li>在<code>buf.gen.yaml</code>中定义了生成的2种服务， <code>go-grpc</code>和 <code>grpc-gateway</code>，分别表示<code>gRPC</code>和<code>HTTP</code></li>
<li><code>demo.proto</code>通过脚本，在<code>gen/idl/demo</code>生成了2个文件，<code>*_grpc.pb.go</code>和<code>*.pb.gw.go</code>，分别表示<code>gRPC</code>和<code>HTTP</code></li>
<li>在<code>main</code>函数中注册两个服务，分别为：<ol>
<li>gRPC - <code>demo.RegisterDemoServiceServer(s, &amp;server.Server&#123;&#125;)</code></li>
<li>HTTP - <code>demo.RegisterDemoServiceHandlerFromEndpoint(ctx, mux, *grpcServerEndpoint, opts)</code></li>
</ol>
</li>
<li>在<code>internal/server/server.go</code>中，<code>server.Server</code>需要实现<code>proto</code>中定义的方法，所以我们加入接口定义<code>demo.UnsafeDemoServiceServer</code></li>
<li>在<code>internal/server/demo.go</code>中，实现一个<code>func (s *Server) Echo(ctx context.Context, req *demo.DemoRequest) (*demo.DemoResponse, error)</code>方法</li>
</ol>
<h2 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h2><p>我们用简单的命令来运行，并用RPC访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译并运行</span></span><br><span class="line">go build &amp;&amp; ./micro_web_service </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 模拟HTTP请求</span></span><br><span class="line">curl --location --request POST &#x27;http://127.0.0.1:8081/apis/demo&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 收到返回值 &#123;<span class="string">&quot;code&quot;</span>:0&#125;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 而gRPC比较麻烦，是私有协议，我们查看一下对应的网络端口，发现正在监听，也就意味着正常运行</span></span><br><span class="line">netstat -an | grep 9090</span><br><span class="line">tcp4       0      0  127.0.0.1.9090         127.0.0.1.49266        ESTABLISHED</span><br><span class="line">tcp4       0      0  127.0.0.1.49266        127.0.0.1.9090         ESTABLISHED</span><br><span class="line">tcp46      0      0  *.9090                 *.*                    LISTEN </span><br></pre></td></tr></table></figure>



<h2 id="项目的私有化"><a href="#项目的私有化" class="headerlink" title="项目的私有化"></a>项目的私有化</h2><p>由于本项目只是一个框架，如果你希望修改为个人的项目，主要改动点在两处：</p>
<ol>
<li><code>go.mod</code>里的模块名，以及<code>Go</code>代码内部的import</li>
<li><code>proto</code>文件中定义的<code>go_package</code></li>
</ol>
<blockquote>
<p>建议用编辑工具全量替换</p>
</blockquote>
<h2 id="新增接口示例"><a href="#新增接口示例" class="headerlink" title="新增接口示例"></a>新增接口示例</h2><h3 id="添加proto定义"><a href="#添加proto定义" class="headerlink" title="添加proto定义"></a>添加proto定义</h3><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EmptyMessage</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Empty 空接口</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Empty(EmptyMessage) <span class="keyword">returns</span> (EmptyMessage) </span>&#123;</span><br><span class="line">  <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">    post : <span class="string">&quot;/apis/empty&quot;</span></span><br><span class="line">    body : <span class="string">&quot;*&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成Go文件"><a href="#生成Go文件" class="headerlink" title="生成Go文件"></a>生成Go文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash gen.sh</span><br></pre></td></tr></table></figure>

<h3 id="添加接口定义"><a href="#添加接口定义" class="headerlink" title="添加接口定义"></a>添加接口定义</h3><p>这时候，我们会发现<code>main.go</code>中有报错，即提示<code>server.Server</code>这个对象需要实现<code>Empty</code>方法。于是，我们在<code>internal/server/demo.go</code>里添加</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Empty</span><span class="params">(ctx context.Context, req *demo.EmptyMessage)</span> <span class="params">(*demo.EmptyMessage, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;demo.EmptyMessage&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试新接口"><a href="#测试新接口" class="headerlink" title="测试新接口"></a>测试新接口</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译并运行</span></span><br><span class="line">go build &amp;&amp; ./micro_web_service </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 模拟HTTP请求</span></span><br><span class="line">curl --location --request POST &#x27;http://127.0.0.1:8081/apis/empty&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回 &#123;&#125;</span> </span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>v0.1.0</code>版本是一个非常简单的web框架，只有样例的RPC接口。</p>
<p>开放<code>HTTP</code>接口是为了兼容传统方案，而<code>gRPC</code>则提供了高性能、跨语言的通信方案。从整个实现过程来看，我们只编写了一个具体的实现、也就是<code>Echo</code>这个方法，就完成了两种通信方式的兼容。</p>
<p><code>gRPC-Gateway</code>方案还有很多很棒的特性，我会在后续逐一介绍并引入。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>技术框架</category>
      </categories>
      <tags>
        <tag>Go-Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言微服务框架 - 11.接口的参数校验功能-buf中引入PGV</title>
    <url>/2021/11/11/go-framework/go-framework-11/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p>
<p>随着API在线文档的发布，服务的接口将会被开放给各种各样的调用方。</p>
<p>大量开发接口的朋友会经常遇到<strong>接口参数校验</strong>的问题。举个例子，我们希望将某个字段是必填的，如<code>name</code>，我们经常会需要做两步：</p>
<ol>
<li>在程序中加一个<strong>判断逻辑</strong>，当这个字段为空时返回错误给调用方</li>
<li>在接口文档中加上<strong>注释</strong>，告诉调用方这个参数必填</li>
</ol>
<p>一旦某项工作被拆分为两步，就很容易出现<strong>不一致性</strong>：对应到参数检查，我们会经常遇到文档和具体实现不一致，从而导致双方研发的沟通成本增加。那么，今天我将引入一个方案，实现两者的一致性。</p>
<blockquote>
<p>为了缩小讨论范围，我们将 <strong>参数校验</strong> 限定为简单规则。</p>
<p>而复合条件的检查（逻辑组合等），不在本次的讨论范围内，主要考虑到2点：</p>
<ol>
<li>要生成跨语言的方案，技术上比较难实现</li>
<li>复合条件往往是一种业务逻辑的检查，放在接口层面不合适</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="v0-7-1：接口的参数校验功能"><a href="#v0-7-1：接口的参数校验功能" class="headerlink" title="v0.7.1：接口的参数校验功能"></a>v0.7.1：接口的参数校验功能</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.7.1">https://github.com/Junedayday/micro_web_service/tree/v0.7.1</a></p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>在线接口文档提供参数校验的逻辑，并自动生成相关代码。</p>
<h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol>
<li>参数校验的技术选型</li>
<li>在buf中引入PGV</li>
<li>在框架中引入参数检查</li>
<li>buf格式检查</li>
</ol>
<h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">	|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">	   |-- idl                             对应idl文件夹</span><br><span class="line">	      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">	    	|-- order                            对应idl/order服务，同上</span><br><span class="line">     |-- swagger.json                    openapiv2的接口文档</span><br><span class="line">	|-- idl                            原始的idl定义</span><br><span class="line">	   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">	   |-- order                           业务order定义，同时干</span><br><span class="line">	|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">	   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">	   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">	   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">	   |-- model                           model层，定义对象的接口方法，具体实现在dao层</span><br><span class="line">	   |-- mysql                           MySQL连接</span><br><span class="line">	   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">	   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">	|-- buf.gen.yaml                   修改：buf生成代码的定义，新增参数校验逻辑</span><br><span class="line">	|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">	|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">	|-- go.mod                         Go Module文件</span><br><span class="line">	|-- gormer.yaml                    将gormer中的参数移动到这里</span><br><span class="line">	|-- main.go                        项目启动的main函数</span><br><span class="line">	|-- swagger.sh                     生成openapiv2的相关脚本</span><br></pre></td></tr></table></figure>

<h2 id="1-参数校验的技术选型"><a href="#1-参数校验的技术选型" class="headerlink" title="1.参数校验的技术选型"></a>1.参数校验的技术选型</h2><p>从搜索引擎可知，protobuf的主流参数校验采用两者：</p>
<ol>
<li>go-proto-validators <a href="https://github.com/mwitkow/go-proto-validators">https://github.com/mwitkow/go-proto-validators</a></li>
<li>protoc-gen-validate <a href="https://github.com/envoyproxy/protoc-gen-validate">https://github.com/envoyproxy/protoc-gen-validate</a></li>
</ol>
<p>这里，我们最终选用的是protoc-gen-validate（PGV），决定性的理由有两个：</p>
<ol>
<li>buf的官方文档更倾向于PGV - <a href="https://docs.buf.build/lint/rules/#custom-options">https://docs.buf.build/lint/rules/#custom-options</a></li>
<li>PGV由envoy背书，长期来看更具维护性</li>
</ol>
<h2 id="2-在buf中引入PGV"><a href="#2-在buf中引入PGV" class="headerlink" title="2.在buf中引入PGV"></a>2.在buf中引入PGV</h2><p>protoc-gen-validate（PGV）作为一款插件，它已经被集成在了buf工具中。这次，我们就从其调用的顺序，来理解一下buf里的重要文件：</p>
<h3 id="2-1-核心文件-buf-yaml"><a href="#2-1-核心文件-buf-yaml" class="headerlink" title="2.1 核心文件 - buf.yaml"></a>2.1 核心文件 - buf.yaml</h3><p>具体引用路径可以在buf库 - <a href="https://buf.build/">https://buf.build/</a> 搜索找到，然后在文件中里添加一个依赖项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">buf.build/envoyproxy/protoc-gen-validate</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-生成的定义文件-buf-gen-yaml"><a href="#2-2-生成的定义文件-buf-gen-yaml" class="headerlink" title="2.2 生成的定义文件 - buf.gen.yaml"></a>2.2 生成的定义文件 - buf.gen.yaml</h3><p>这个文件定义了我们要生成什么样的代码，具体增加如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">validate</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">gen</span></span><br><span class="line">    <span class="attr">opt:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">paths=source_relative</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lang=go</span></span><br></pre></td></tr></table></figure>

<p>其中，要注意opt选项要增加一个参数<code>lang=go</code>，类似的，我们也可以生成其余语言的代码。</p>
<h3 id="2-3-proto定义文件"><a href="#2-3-proto定义文件" class="headerlink" title="2.3 proto定义文件"></a>2.3 proto定义文件</h3><p>我们以分页参数为例，添加2条规则，即要求页码、每页数量均大于0。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;validate/validate.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ListOrdersRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">1</span> [(validate.rules).<span class="built_in">int32</span> = &#123;gt: <span class="number">0</span>&#125;];</span><br><span class="line">  <span class="built_in">int32</span> page_size = <span class="number">2</span>   [(validate.rules).<span class="built_in">int32</span> = &#123;gt: <span class="number">0</span>&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-生成相关代码"><a href="#2-4-生成相关代码" class="headerlink" title="2.4 生成相关代码"></a>2.4 生成相关代码</h3><p>因为我们引入了一个新的模块，所以先需要更新依赖，用来下载新模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">buf mod update</span><br><span class="line">buf generate</span><br></pre></td></tr></table></figure>

<h3 id="2-5-参数校验的代码"><a href="#2-5-参数校验的代码" class="headerlink" title="2.5 参数校验的代码"></a>2.5 参数校验的代码</h3><p>在2.3引入validate的数据结构定义，会生成一个<code>*.pb.validate.go</code>文件，我们截取两个关键函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ListOrdersRequest)</span> <span class="title">Validate</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.validate(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ListOrdersRequest)</span> <span class="title">ValidateAll</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.validate(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从命名不难看出，<code>Validate</code>是检查到有一个不符合规则就立刻返回，<code>ValidateAll</code>是校验完所有的参数后、将不符合的规则一起返回。这两种处理方式的差异主要在于：</p>
<ol>
<li>耗时：全量检查相对会花费更多的时间</li>
<li>返回的信息量：全量检查的error会包含更多信息</li>
</ol>
<p>从服务端的视角，更推荐全量检查，将所有字段的检查结果返回给调用方，方便对方一次性修正。</p>
<h2 id="3-在框架中引入参数检查"><a href="#3-在框架中引入参数检查" class="headerlink" title="3.在框架中引入参数检查"></a>3.在框架中引入参数检查</h2><h3 id="3-1-grpc拦截器"><a href="#3-1-grpc拦截器" class="headerlink" title="3.1 grpc拦截器"></a>3.1 grpc拦截器</h3><p>grpc提供了一套拦截器Interceptor的机制，类似于http router中的middleware。之前，我们已经引入了一个拦截器，用于打印trace相关的日志。那么这次又新增了一个拦截器，该如何处理呢？</p>
<p>参考grpc的代码，我们可以看到下面两个函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnaryInterceptor</span><span class="params">(i UnaryServerInterceptor)</span> <span class="title">ServerOption</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ChainUnaryInterceptor</span><span class="params">(interceptors ...UnaryServerInterceptor)</span> <span class="title">ServerOption</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中前者是单个拦截器，而后者是一种链式拦截器的概念。毫无疑问，我们需要扩充成多个拦截器。</p>
<h3 id="3-2-实现参数校验的拦截"><a href="#3-2-实现参数校验的拦截" class="headerlink" title="3.2 实现参数校验的拦截"></a>3.2 实现参数校验的拦截</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ValidateAll 对应 protoc-gen-validate 生成的 *.pb.validate.go 中的代码</span></span><br><span class="line"><span class="keyword">type</span> Validator <span class="keyword">interface</span> &#123;</span><br><span class="line">	ValidateAll() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerValidationUnaryInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r, ok := req.(Validator); ok &#123;</span><br><span class="line">		<span class="keyword">if</span> err := r.ValidateAll(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.InvalidArgument, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在拦截器中引入我们定义的插件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := grpc.NewServer(</span><br><span class="line">  grpc.ChainUnaryInterceptor(</span><br><span class="line">    grpc_opentracing.UnaryServerInterceptor(</span><br><span class="line">      grpc_opentracing.WithTracer(opentracing.GlobalTracer()),</span><br><span class="line">    ),</span><br><span class="line">    ServerValidationUnaryInterceptor,</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="3-3-具体调用示例"><a href="#3-3-具体调用示例" class="headerlink" title="3.3 具体调用示例"></a>3.3 具体调用示例</h3><p>我们尝试着传一个错误的接口参数，看看返回结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;invalid ListOrdersRequest.PageNumber: value must be greater than 0; invalid ListOrdersRequest.PageSize: value must be greater than 0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，结果中清晰地说明了不合规的两个参数，以及具体的规则，对调用方来说非常直观。</p>
<h2 id="4-buf格式检查"><a href="#4-buf格式检查" class="headerlink" title="4.buf格式检查"></a>4.buf格式检查</h2><p>随着buf工具的推进，我们引入了越来越多的内容，protobuf文件也新增了很多东西。这时，我们会希望能将protobuf的格式也能有一定的规范化。在buf之前，已经有prototool等工具，buf对此做了集成。</p>
<p>由于buf的lint检查有很多细节，建议酌情选用。以项目中我选择的为例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">lint:</span></span><br><span class="line">  <span class="attr">use:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">DEFAULT</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PACKAGE_VERSION_SUFFIX</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PACKAGE_DIRECTORY_MATCH</span></span><br><span class="line">  <span class="attr">rpc_allow_google_protobuf_empty_requests:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">rpc_allow_google_protobuf_empty_responses:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>包括两块：</p>
<ul>
<li>except排除了两个检查项，即要求protobuf的package带上版本后缀、与代码路径匹配</li>
<li>允许request和response设置为empty格式</li>
</ul>
<p>接下来，运行<code>buf lint</code>，会提示你需要修正的地方，逐一修改即可（很多是命名上的规范，增加可读性，推荐按插件的建议进行修改）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次框架的小迭代高度依赖了buf的生态体系，建议有时间的朋友可以再看看buf的文档链接 - <a href="https://docs.buf.build/introduction%E3%80%82buf%E5%B7%A5%E5%85%B7%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%A2%91%E7%8E%87%E6%AF%94%E8%BE%83%E9%AB%98%EF%BC%8C%E5%AF%B9%E5%85%B6%E6%96%B0%E7%89%B9%E6%80%A7%E4%BB%8D%E5%A4%84%E4%BA%8E%E8%A7%82%E6%9C%9B%E7%8A%B6%E6%80%81%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%B2%A1%E6%9C%89%E5%AE%8C%E5%85%A8%E6%8C%89%E7%85%A7%E5%85%B6Best">https://docs.buf.build/introduction。buf工具的迭代频率比较高，对其新特性仍处于观望状态，目前没有完全按照其Best</a> Practice推进。</p>
<p>回过头来，我们的参数检查方案依然存在一个明显问题：生成的swagger文档中没有对应的参数要求（Issue - <a href="https://github.com/grpc-ecosystem/grpc-gateway/issues/1093%EF%BC%89%E3%80%82%E5%A6%82%E6%9E%9C%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E9%95%BF%E6%9C%9F%E6%97%A0%E6%B3%95%E8%A7%A3%E5%86%B3%EF%BC%8C%E6%88%91%E4%B9%9F%E4%BC%9A%E7%BB%99%E5%87%BA%E4%B8%80%E5%A5%97%E8%87%AA%E5%B7%B1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82">https://github.com/grpc-ecosystem/grpc-gateway/issues/1093）。如果这个问题长期无法解决，我也会给出一套自己的解决方案。</a></p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>技术框架</category>
      </categories>
      <tags>
        <tag>Go-Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言微服务框架 - 10.接口文档-openapiv2的在线文档方案</title>
    <url>/2021/11/01/go-framework/go-framework-10/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p>
<p>随着项目的迭代，一个服务会开放出越来越多的接口供第三方调用。</p>
<p>虽然<code>protobuf</code>已经是通用性很广的IDL文件了，但对于未接触过这块的程序员来说，还是有很大的学习成本。在综合可读性和维护性之后，我个人比较倾向于使用oepnapiv2的方案，提供在线接口文档。</p>
<p>接下来，我们一起来看看这部分的实现。</p>
<span id="more"></span>

<h2 id="v0-7-0：接口文档-openapiv2的在线文档方案"><a href="#v0-7-0：接口文档-openapiv2的在线文档方案" class="headerlink" title="v0.7.0：接口文档-openapiv2的在线文档方案"></a>v0.7.0：接口文档-openapiv2的在线文档方案</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.7.0">https://github.com/Junedayday/micro_web_service/tree/v0.7.0</a></p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>项目提供在线接口文档，供第三方快速地了解接口细节。</p>
<h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol>
<li>了解buf的openapiv2的插件</li>
<li>用swagger工具合并文档</li>
<li>利用swagger相关容器提供在线文档</li>
</ol>
<blockquote>
<p>swagger 是 openapiv2 的一种具体实现，在下文可等同于一个概念。</p>
<p>可以参考swagger官网了解详情：<a href="https://swagger.io/specification/v2/">https://swagger.io/specification/v2/</a></p>
</blockquote>
<h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">	|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">	   |-- idl                             对应idl文件夹</span><br><span class="line">	      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">	    	|-- order                            对应idl/order服务，同上</span><br><span class="line">     |-- swagger.json                    新增：openapiv2的接口文档</span><br><span class="line">	|-- idl                            原始的idl定义</span><br><span class="line">	   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">	   |-- order                           业务order定义，同时干</span><br><span class="line">	|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">	   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">	   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">	   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">	   |-- model                           model层，定义对象的接口方法，具体实现在dao层</span><br><span class="line">	   |-- mysql                           MySQL连接</span><br><span class="line">	   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">	   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">	|-- buf.gen.yaml                   buf生成代码的定义，从v1beta升到v1</span><br><span class="line">	|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">	|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">	|-- go.mod                         Go Module文件</span><br><span class="line">	|-- gormer.yaml                    将gormer中的参数移动到这里</span><br><span class="line">	|-- main.go                        项目启动的main函数</span><br><span class="line">	|-- swagger.sh                     新增：生成openapiv2的相关脚本</span><br></pre></td></tr></table></figure>

<h2 id="1-了解buf的openapiv2的插件"><a href="#1-了解buf的openapiv2的插件" class="headerlink" title="1.了解buf的openapiv2的插件"></a>1.了解buf的openapiv2的插件</h2><p>从<a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/mapping/customizing_openapi_output/#other-plugin-options">gRPC-Gateway的文档</a>中，我们可以找到对应的buf插件使用方式：在<code>buf.gen.yaml</code>文件中，我们添加如下插件内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">openapiv2</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">gen/openapiv2</span></span><br></pre></td></tr></table></figure>

<p>运行<code>buf generate</code>后，在<code>gen/openapiv2</code>目录下会根据我们在<code>idl</code>文件中的目录结构，生成多个接口文档。</p>
<h2 id="2-用swagger工具合并文档"><a href="#2-用swagger工具合并文档" class="headerlink" title="2.用swagger工具合并文档"></a>2.用swagger工具合并文档</h2><p>用buf标准的openapiv2插件会生成多份swagger文档，管理多个文件对使用方来说并不方便。最佳的使用体验，就是能将多个文档合并起来，用一个API文档统一交付。</p>
<p>这里，我们借助goswagger工具，合并文档。工具具体的安装方式可参考链接：<a href="https://goswagger.io/install.html%E3%80%82">https://goswagger.io/install.html。</a></p>
<p>安装后，运行如下命令，生成到文件 gen/swagger.json：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 合并swagger文档</span></span><br><span class="line">swagger mixin gen/openapiv2/idl/*/*.json -o gen/swagger.json</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除原始文档</span></span><br><span class="line">rm -rf gen/openapiv2</span><br></pre></td></tr></table></figure>

<h2 id="3-利用swagger相关容器提供在线文档"><a href="#3-利用swagger相关容器提供在线文档" class="headerlink" title="3.利用swagger相关容器提供在线文档"></a>3.利用swagger相关容器提供在线文档</h2><p>在统一了swagger文件后，在线接口文档的实现方案有很多，例如swagger官网就可以提供简单的渲染。</p>
<p>这里，我用了个人比较常用的docker镜像redoc为例，搭建一个在线接口文档平台。</p>
<blockquote>
<p>该镜像更多的使用方式可参考：<a href="https://hub.docker.com/r/redocly/redoc/">https://hub.docker.com/r/redocly/redoc/</a> </p>
</blockquote>
<p>运行如下命令，即将swagger.json加载到镜像中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name swagger -it --rm -d -p 80:80 -v $(pwd)/gen/swagger.json:/usr/share/nginx/html/swagger.json -e SPEC_URL=swagger.json redocly/redoc</span><br></pre></td></tr></table></figure>

<p>我们在本地打开浏览器，输入 <a href="http://127.0.0.1/">http://127.0.0.1:80/</a> 就能看到文档。</p>
<blockquote>
<p>扩展点 - 公共的文档服务器：</p>
<p>我们往往更希望把文档放在一个公共的服务器上，可以简单地利用这两个关键技术实现：</p>
<ol>
<li><a href="https://hub.docker.com/r/redocly/redoc/">https://hub.docker.com/r/redocly/redoc/</a> 中的watch方案，即watch某个目录下的文件，根据文件变化实时更新接口</li>
<li>利用scp命令，将本地swagger.json上传到远端服务器</li>
</ol>
<p>更复杂点的方案，可以考虑结合git流程来实现。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们实现了一个关键性的功能：<strong>代码即接口文档</strong>，保证了接口文档随着代码更新的实时性。</p>
<p>同时，希望大家能够认识到接口文档的价值，最好能做到<strong>接口文档即代码</strong>，也就是将相关程序的逻辑尽可能地通过接口文档表达清楚。哪怕前期接口文档问题很多，只要我们不断迭代，后续总能趋于稳定，降低维护接口的成本。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>技术框架</category>
      </categories>
      <tags>
        <tag>Go-Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言微服务框架 - 12.ORM层的自动抽象与自定义方法的扩展</title>
    <url>/2021/12/02/go-framework/go-framework-12/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p>
<p>随着接口参数校验功能的完善，我们能快速定位到接口层面的参数问题；而应用服务的分层代码，也可以通过log的trace-id发现常见的业务逻辑问题。</p>
<p>但在最底层与数据库的操作，也就是对GORM的使用，经常会因为我们不了解ORM的一些细节，导致对数据的CRUD失败，或者没有达到预期效果。这时，我们希望能在ORM这一层也有一个通用的解决方案，来加速问题的排查。</p>
<p>趁这个机会，我们也对<code>gormer</code>这个工具再做一次迭代，添加新的功能。</p>
<span id="more"></span>

<h2 id="v0-7-2：ORM层的自动抽象与自定义方法的扩展"><a href="#v0-7-2：ORM层的自动抽象与自定义方法的扩展" class="headerlink" title="v0.7.2：ORM层的自动抽象与自定义方法的扩展"></a>v0.7.2：ORM层的自动抽象与自定义方法的扩展</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.7.2">https://github.com/Junedayday/micro_web_service/tree/v0.7.2</a></p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>gormer工具支持interface的抽象与自定义方法的扩展，并具备日志打印功能。</p>
<h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol>
<li>model层的自动抽象方案</li>
<li>dao层的代码实现</li>
<li>MySQL的SQL打印</li>
<li>关于gormer工具的迭代</li>
</ol>
<h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">	|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">	   |-- idl                             对应idl文件夹</span><br><span class="line">	      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">	    	|-- order                            对应idl/order服务，同上</span><br><span class="line">     |-- swagger.json                    openapiv2的接口文档</span><br><span class="line">	|-- idl                            原始的idl定义</span><br><span class="line">	   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">	   |-- order                           业务order定义，同时干</span><br><span class="line">	|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">	   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">	   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">	   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">	   |-- model                           修改：model层基本定义由gormer自动生成</span><br><span class="line">	   |-- mysql                           修改：MySQL连接，支持日志打印</span><br><span class="line">	   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">	   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">	|-- buf.gen.yaml                   buf生成代码的定义，新增参数校验逻辑</span><br><span class="line">	|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">	|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">	|-- go.mod                         Go Module文件</span><br><span class="line">	|-- gormer.yaml                    将gormer中的参数移动到这里</span><br><span class="line">	|-- main.go                        项目启动的main函数</span><br><span class="line">	|-- swagger.sh                     生成openapiv2的相关脚本</span><br></pre></td></tr></table></figure>

<h2 id="1-model层的自动抽象方案"><a href="#1-model层的自动抽象方案" class="headerlink" title="1.model层的自动抽象方案"></a>1.model层的自动抽象方案</h2><p>之前，我们在dao层已经实现了基本的CRUD相关代码，所以实现一个model层的定义很简单。但考虑到扩展性，也就是这个model层不仅仅需要简单的CRUD代码，还可能需要一些类似于<code>group by</code>等复杂sql，甚至包括子查询。</p>
<p>这时候，如果考虑全部用<code>gormer</code>工具自动生成的方案，那成本会很高，所以更建议分开维护的方案：简单的CRUD用自动代码生成的方式，而复杂SQL调用GORM库自行实现。我们来阅读代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// *.go 自动生成的代码，标准方法</span></span><br><span class="line"><span class="keyword">type</span> OrderModel <span class="keyword">interface</span> &#123;</span><br><span class="line">	AddOrder(ctx context.Context, order *gormer.Order) (err error)</span><br><span class="line">	QueryOrders(ctx context.Context, pageNumber, pageSize <span class="keyword">int</span>, condition *gormer.OrderOptions) (orders []gormer.Order, err error)</span><br><span class="line">	CountOrders(ctx context.Context, condition *gormer.OrderOptions) (count <span class="keyword">int64</span>, err error)</span><br><span class="line">	UpdateOrder(ctx context.Context, updated, condition *gormer.OrderOptions) (err error)</span><br><span class="line">	DeleteOrder(ctx context.Context, condition *gormer.OrderOptions) (err error)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Implement Your Method in ext model</span></span><br><span class="line">	OrderExtModel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *_ext.go 扩展方法</span></span><br><span class="line"><span class="keyword">type</span> OrderExtModel <span class="keyword">interface</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了保证自定义的ext代码不被覆盖，在gormer的代码里添加如下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果extFile已经存在，则不要覆盖</span></span><br><span class="line"><span class="keyword">if</span> _, err = os.Stat(extFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// 创建ext文件的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-dao层的代码实现"><a href="#2-dao层的代码实现" class="headerlink" title="2.dao层的代码实现"></a>2.dao层的代码实现</h2><p>dao层的代码基本同model层，分为<code>*.go</code>和<code>*_ext.go</code>两个。</p>
<p>为了保证dao层实现了model层的代码，我们也增加了一行代码，方便我们在编译期保证实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ model.OrderModel = NewOrderRepo(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-MySQL的SQL打印"><a href="#3-MySQL的SQL打印" class="headerlink" title="3.MySQL的SQL打印"></a>3.MySQL的SQL打印</h2><p>在GORM工具中，提供了一个callback的方式，让用户添加自定义的插件。具体可以参考 <a href="https://gorm.io/zh_CN/docs/write_plugins.html%E3%80%82%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%88%86%E4%B8%8B%E9%9D%A2%E4%B8%A4%E6%AD%A5%EF%BC%9A">https://gorm.io/zh_CN/docs/write_plugins.html。主要实现分下面两步：</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 - 操作SQL时，将ctx传入其中，用来传递一些通用参数，如traceid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">AddOrder</span><span class="params">(ctx context.Context, order *gormer.Order)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	repo.db.WithContext(ctx).</span><br><span class="line">		Table(gormer.OrderTableName).</span><br><span class="line">		Create(order)</span><br><span class="line">	err = repo.db.Error</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 - 在操作数据库后，注册对应的插件afterLog，用来打印SQL日志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitGorm</span><span class="params">(user, password, addr <span class="keyword">string</span>, dbname <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	dsn := fmt.Sprintf(<span class="string">&quot;%s:%s@tcp(%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>,</span><br><span class="line">		user, password, addr, dbname)</span><br><span class="line">	GormDB, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 结束后</span></span><br><span class="line">	_ = GormDB.Callback().Create().After(<span class="string">&quot;gorm:after_create&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line">	_ = GormDB.Callback().Query().After(<span class="string">&quot;gorm:after_query&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line">	_ = GormDB.Callback().Delete().After(<span class="string">&quot;gorm:after_delete&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line">	_ = GormDB.Callback().Update().After(<span class="string">&quot;gorm:after_update&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line">	_ = GormDB.Callback().Row().After(<span class="string">&quot;gorm:row&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line">	_ = GormDB.Callback().Raw().After(<span class="string">&quot;gorm:raw&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callBackLogName = <span class="string">&quot;zlog&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">afterLog</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line">	err := db.Error</span><br><span class="line">	ctx := db.Statement.Context</span><br><span class="line">	</span><br><span class="line">	sql := db.Dialector.Explain(db.Statement.SQL.String(), db.Statement.Vars...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		zlog.WithTrace(ctx).Errorf(<span class="string">&quot;sql=%s || error=%v&quot;</span>, sql, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	zlog.WithTrace(ctx).Infof(<span class="string">&quot;sql=%s&quot;</span>, sql)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>afterLog</code>这里，我们引用了插件，实现了自定义日志组件的打印。</p>
<h2 id="4-关于gormer工具的迭代"><a href="#4-关于gormer工具的迭代" class="headerlink" title="4.关于gormer工具的迭代"></a>4.关于gormer工具的迭代</h2><p>在这个小版本中，我们又对gormer工具做了一次迭代。从整个框架的维度来看，我们不仅仅是把它作为一种代码生成的工具，而是一种模块化的抽象能力，关注分层能力的建设。从SQL的log打印来看，我们可以区分出前后的差异：</p>
<p><strong>原先</strong> - 通过调用一个<code>公共函数</code>来打印，需要侵入到每个dao层的具体代码</p>
<p><strong>修改后</strong> - 通过插件注册到组件中，<strong>无需侵入到具体实现的代码</strong></p>
<p><strong>无侵入地实现自定义功能</strong>，这个特性对每个工具组件都非常重要，GORM这里就提供了一个很好的实现思路 - 注册插件，自定义hook。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次迭代的意义很大 - <strong>标志着<code>gormer</code>这个组件实现了自定义方法的可扩展</strong>（ext文件）。</p>
<p>接下来，我们还会持续地对<code>gormer</code>等low code工具持续优化，实现更多的功能。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>技术框架</category>
      </categories>
      <tags>
        <tag>Go-Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言微服务框架 - 13.监控组件Prometheus的引入</title>
    <url>/2021/12/12/go-framework/go-framework-13/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p>
<p>作为云原生程序监控的标准组件，Prometheus支持了各类Paas、Saas平台，并提供了一整套采集+存储+展示的解决方案。</p>
<p>今天我们专注于自定义服务中的Prometheus的监控，在框架中引入Prometheus相关的组件。关于更细致的使用方式，我会给出相关的链接，有兴趣进一步学习Prometheus的同学可以边参考资料边实践。</p>
<span id="more"></span>

<h2 id="v0-8-0：监控组件Prometheus的引入"><a href="#v0-8-0：监控组件Prometheus的引入" class="headerlink" title="v0.8.0：监控组件Prometheus的引入"></a>v0.8.0：监控组件Prometheus的引入</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.8.0">https://github.com/Junedayday/micro_web_service/tree/v0.8.0</a> </p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>引入prometheus组件，提供标准与自定义的metrics。</p>
<h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol>
<li>metrics接口的开放</li>
<li>示例counter的初始化</li>
<li>示例counter的计数</li>
<li>学习Prometheus监控使用方法</li>
</ol>
<h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">	|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">	   |-- idl                             对应idl文件夹</span><br><span class="line">	      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">	    	|-- order                            对应idl/order服务，同上</span><br><span class="line">     |-- swagger.json                    openapiv2的接口文档</span><br><span class="line">	|-- idl                            原始的idl定义</span><br><span class="line">	   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">	   |-- order                           业务order定义，同时干</span><br><span class="line">	|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">	   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">	   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">	   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">	   |-- metrics                         新增：自定义监控指标</span><br><span class="line">	   |-- model                           model层基本定义由gormer自动生成</span><br><span class="line">	   |-- mysql                           MySQL连接，支持日志打印</span><br><span class="line">	   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">	   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">	|-- buf.gen.yaml                   buf生成代码的定义，新增参数校验逻辑</span><br><span class="line">	|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">	|-- format.sh                      新增：格式化代码的脚本</span><br><span class="line">	|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">	|-- go.mod                         Go Module文件</span><br><span class="line">	|-- gormer.yaml                    将gormer中的参数移动到这里</span><br><span class="line">	|-- main.go                        项目启动的main函数</span><br><span class="line">	|-- swagger.sh                     生成openapiv2的相关脚本</span><br></pre></td></tr></table></figure>

<h2 id="1-metrics接口的开放"><a href="#1-metrics接口的开放" class="headerlink" title="1.metrics接口的开放"></a>1.metrics接口的开放</h2><p>Prometheus官方推荐的metrics开放方式为http。将它引入到程序中的代码如下面几行，不过有几个点值得注意：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  mux := http.NewServeMux()</span><br><span class="line">  mux.Handle(<span class="string">&quot;/metrics&quot;</span>, promhttp.Handler())</span><br><span class="line">  http.ListenAndServe(fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, config.Viper.GetInt(<span class="string">&quot;server.prometheus.port&quot;</span>)), mux)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<ol>
<li><code>http.ListenAndServe</code> 函数是阻塞的，所以需要开一个goroutine。</li>
<li>为了保证Prometheus的指标监控不与应用的http服务冲突，这里采用了端口隔离，也就是另起一个http服务。</li>
<li><code>Go</code> 的 <code>http</code> 库如果要支持多port的运行，需要引入<code>mux</code>的概念；默认会注册到http库中的<code>DefaultServeMux</code>。</li>
</ol>
<p>为了验证我们的metrics已经正常running，我们可以调用一个curl请求查看一下（具体返回结果不细讲）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例的metrics起在8083端口</span></span><br><span class="line">curl --request GET &#x27;http://127.0.0.1:8083/metrics&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="2-示例counter的初始化"><a href="#2-示例counter的初始化" class="headerlink" title="2.示例counter的初始化"></a>2.示例counter的初始化</h2><p>我们先以一个最简单的counter累加器为例，实现一个自定的指标监控。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> metrics</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/prometheus/client_golang/prometheus&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	prometheus.MustRegister(OrderList)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> OrderList = prometheus.NewCounterVec(</span><br><span class="line">	prometheus.CounterOpts&#123;</span><br><span class="line">		Name: <span class="string">&quot;order_list_counter&quot;</span>,</span><br><span class="line">		Help: <span class="string">&quot;List Order Count&quot;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	[]<span class="keyword">string</span>&#123;<span class="string">&quot;service&quot;</span>&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>代码的逻辑比较简单，我们注意以下三个关键点：</p>
<ol>
<li><code>OrderLis</code>t 是一个全局变量，方便使用方调用；</li>
<li><code>NewCounterVec</code> 表示这个Counter是一个向量，包括了两块 - opts和labels<ol>
<li>opts包括Name和Help，Name是metrics唯一的名称，Help是metrics的帮助信息</li>
<li>labels是用来过滤、聚合功能的关键参数，提前声明有利于存储端进行优化（可类比数据库索引）</li>
</ol>
</li>
<li><code>prometheus.MustRegister(OrderList)</code> 是将metrics注册到prometheus的全局变量里，与main函数里的注册对应</li>
</ol>
<h2 id="3-示例counter的计数"><a href="#3-示例counter的计数" class="headerlink" title="3.示例counter的计数"></a>3.示例counter的计数</h2><p>从指标的定义可以看到，我们设计的这个metrics是为了统计订单查询接口的次数，于是我们在代码侧引入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">ListOrders</span><span class="params">(ctx context.Context, req *order.ListOrdersRequest)</span> <span class="params">(*order.ListOrdersResponse, error)</span></span> &#123;</span><br><span class="line">	metrics.OrderList.With(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;service&quot;</span>: <span class="string">&quot;example&quot;</span>&#125;).Inc()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数是一个链式调用，包括两块：</p>
<ol>
<li>With，也就是label信息，用一个map[string]string填入，是个通用功能；</li>
<li>Inc，即计数+1，这个方法和具体的metrics类型相关。</li>
</ol>
<p>接着，我们调用两次对应的接口，可以从metrics信息中看到下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># HELP order_list_counter List Order Count</span><br><span class="line"># TYPE order_list_counter counter</span><br><span class="line">order_list_counter&#123;service=&quot;example&quot;&#125; 2</span><br></pre></td></tr></table></figure>

<p>除非程序重启，否则这个Counter会不断累加。</p>
<h2 id="4-学习Prometheus监控使用方法"><a href="#4-学习Prometheus监控使用方法" class="headerlink" title="4.学习Prometheus监控使用方法"></a>4.学习Prometheus监控使用方法</h2><p>Prometheus监控埋点的使用方式比较直观，上手难度不大。如果你希望进一步了解这块，我推荐两个核心的资料：</p>
<ul>
<li>Prometheus官网 - <a href="https://prometheus.io/docs/introduction/overview/">https://prometheus.io/docs/introduction/overview/</a></li>
<li>Prometheus的Go语言官方库 - <a href="https://github.com/prometheus/client_golang">https://github.com/prometheus/client_golang</a></li>
</ul>
<p>这两份资料是英文的，可能对部分同学来说学成本比较高，可以考虑先去搜索一些中文翻译文档、了解梗概后，再回过头来看这两篇。如果你希望深入了解Prometheus，必须要仔细看这两块内容，保证实时性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对接Prometheus的自定义metrics是一个应用程序很常见的功能，例如业务指标埋点。在埋点的过程中，有一个大误区需要刚接触Prometheus的同学注意：把计算的工作交给Prometheus引擎，而不要放在你开发的程序里。</p>
<p>例如，你希望计算某个订单的成功率，你不应该用一个metrics对应成功率，而应该给出两个指标，即订单总量和成功的订单量（也可以放在一个指标中，用label区分成功与否），交由Prometheus进行计算，方便后续的各种metrics的扩展。</p>
<p>更多Prometheus的实践，需要大家边学习边实践。如果反响热烈，我也会抽几讲谈谈Prometheus。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>技术框架</category>
      </categories>
      <tags>
        <tag>Go-Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言微服务框架 - 2.实现加载静态配置文件</title>
    <url>/2021/08/21/go-framework/go-framework-2/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p>
<p>我们的基础RPC服务已经正常运行，我们再来看下一个特性：配置文件的加载。</p>
<p>首先，我们要正确地认识到配置文件的重要性：<strong>在程序交付后，变更代码的成本很大；相对而言，变更配置文件的成本就比较小</strong>。但有的同学又走了另一个极端，也就是将大量的逻辑放入到配置文件中，导致<strong>配置文件膨胀</strong>，本质上就是将部分本应在代码中维护的内容转移到了配置文件，导致配置文件也很难维护。</p>
<p>今天，我们先将重点放到加载配置文件库的技术选型，顺便分享一些常见的问题。</p>
<span id="more"></span>

<h2 id="一个基础的加载配置文件示例"><a href="#一个基础的加载配置文件示例" class="headerlink" title="一个基础的加载配置文件示例"></a>一个基础的加载配置文件示例</h2><p>在<code>Go</code>语言中，用官方库就能快速实现配置文件的加载，下面就是一个简单的代码实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b, err := ioutil.ReadFile(<span class="string">&quot;config.json&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> config MyConfig</span><br><span class="line">err = json.Unmarshal(b, &amp;config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键的实现分为两块：</p>
<ol>
<li>读取文件中的数据</li>
<li>将数据解析到Go程序的对象中，作为可识别的数据结构，这里指定了数据类型为<code>json</code></li>
</ol>
<h2 id="v0-2-0：实现加载静态配置文件"><a href="#v0-2-0：实现加载静态配置文件" class="headerlink" title="v0.2.0：实现加载静态配置文件"></a>v0.2.0：实现加载静态配置文件</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.2.0">https://github.com/Junedayday/micro_web_service/tree/v0.2.0</a></p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>从配置文件中解析数据到程序中，并具备更高的可读性和扩展性。</p>
<h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol>
<li>命令行参数与配置文件的差异</li>
<li>github.com/spf13/viper的介绍</li>
<li>使用viper库的推荐方式</li>
</ol>
<h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><p><code>github.com/spf13/viper</code>中存在一个全局变量<code>var v *Viper</code>（<a href="https://github.com/spf13/viper/blob/v1.7.0/viper.go#L62">点击查看</a>），如果我们调用默认的viper包，其实就是将参数解析到这个全局变量中。</p>
<p>在具体的项目中，更推荐的方式是将这个变量保存到内部项目中，作为一个项目中的全局变量，所以我们会新建一个<code>viper.New()</code>。配置参数会被全局调用，为了保证不会发生<strong>循环依赖</strong>，我们就需要一个专门的<code>package</code>来保存这个全局变量，这里对应项目中的<code>internal/config/viper.go</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">	|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">	   |-- idl                             对应idl文件夹</span><br><span class="line">	      |-- demo                             对应idl/demo服务</span><br><span class="line">	         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">	         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">	         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">	|-- idl                            原始的idl定义</span><br><span class="line">	   |-- demo                            业务package定义</span><br><span class="line">	      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">	|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">	   |-- server                          服务器的实现</span><br><span class="line">	      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">	      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">	   |-- config                          新增：配置相关的文件夹</span><br><span class="line">	      |-- viper.go                         新增：viper的相关加载逻辑</span><br><span class="line">	|-- buf.gen.yaml                   buf生成代码的定义</span><br><span class="line">	|-- buf.yaml                       buf工具安装所需的工具</span><br><span class="line">	|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">	|-- go.mod                         Go Module文件</span><br><span class="line">	|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="1-命令行参数与配置文件的差异"><a href="#1-命令行参数与配置文件的差异" class="headerlink" title="1.命令行参数与配置文件的差异"></a>1.命令行参数与配置文件的差异</h2><p>命令行参数类似于<code>./demo --config=a.yaml --http_port=8080 --grpc_port=8081</code>，<code>Go</code>语言中自带<code>flag</code>包可供解析，开源的有<code>pflag</code>和相关的扩展工具，如<code>cobra</code>。</p>
<p>而配置文件则是<strong>将参数从文件解析到内存中</strong>，一般用读取文件+反序列化工具来使用。</p>
<p>同样是解析参数到程序里，我们该选择哪种方案呢？我们从可读性和可维护性来对比下：</p>
<ul>
<li>可读性：命令行参数是扁平化的，可读性远不如格式化后的配置文件</li>
<li>可维护性：配置文件增加了一个维护项，但成本不高</li>
</ul>
<p>所以，我个人倾向于的方案是：</p>
<ul>
<li>命令行参数：用于维护极少量关键性的参数，如配置文件的路径</li>
<li>配置文件：维护绝大多数的参数</li>
</ul>
<p>在某些极端的场景中，比如提供一个纯二进制文件作为工具，那不得不把所有配置参数都放入到命令行参数中。这并不是我们微服务框架要讨论的场景。所以，接下来我们重点讨论配置文件的加载。</p>
<blockquote>
<p>关于pflag相关的内容，在后续程序复杂到一定阶段后会引入。</p>
</blockquote>
<h2 id="2-github-com-spf13-viper的介绍"><a href="#2-github-com-spf13-viper的介绍" class="headerlink" title="2.github.com/spf13/viper的介绍"></a>2.github.com/spf13/viper的介绍</h2><p>对比上面的方案，我们来看一个业内使用最广的Go语言配置加载库<code>github.com/spf13/viper</code>的实现，对应的代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.SetConfigName(<span class="string">&quot;config&quot;</span>)        <span class="comment">// config file name without file type</span></span><br><span class="line">viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>)          <span class="comment">// config file type</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;./&quot;</span>)            <span class="comment">// config file path</span></span><br><span class="line"><span class="keyword">if</span> err := viper.ReadInConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在获取配置文件时，又采用key-value形式的语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.GetInt(<span class="string">&quot;server.grpc.port&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>详细的特性我会在<strong>Go语言技巧系列</strong>里说明，今天我们聚焦于工程侧的宏观特性，来聊聊这个库的优劣势：</p>
<h3 id="可选的参数序列化"><a href="#可选的参数序列化" class="headerlink" title="可选的参数序列化"></a>可选的参数序列化</h3><p>从<code>viper</code>库的源码中(<a href="https://github.com/spf13/viper/blob/v1.7.0/viper.go#L328">点击跳转</a>)，我们可以看到它支持多种<strong>本地文件类型</strong>与<strong>远程k-v数据库</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SupportedExts are universally supported extensions.</span></span><br><span class="line"><span class="keyword">var</span> SupportedExts = []<span class="keyword">string</span>&#123;<span class="string">&quot;json&quot;</span>, <span class="string">&quot;toml&quot;</span>, <span class="string">&quot;yaml&quot;</span>, <span class="string">&quot;yml&quot;</span>, <span class="string">&quot;properties&quot;</span>, <span class="string">&quot;props&quot;</span>, <span class="string">&quot;prop&quot;</span>, <span class="string">&quot;hcl&quot;</span>, <span class="string">&quot;dotenv&quot;</span>, <span class="string">&quot;env&quot;</span>, <span class="string">&quot;ini&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SupportedRemoteProviders are universally supported remote providers.</span></span><br><span class="line"><span class="keyword">var</span> SupportedRemoteProviders = []<span class="keyword">string</span>&#123;<span class="string">&quot;etcd&quot;</span>, <span class="string">&quot;consul&quot;</span>, <span class="string">&quot;firestore&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>我们先忽略远程的存储，先看一下最常用的几个序列化的库：</p>
<ol>
<li>JSON: 官方自带的<code>encoding/json</code></li>
<li>TOML: 开源的<code>github.com/pelletier/go-toml</code></li>
<li>YAML: 官方推荐的<code>gopkg.in/yaml.v2</code></li>
<li>INI：官方推荐的<code>gopkg.in/ini.v1</code></li>
</ol>
<p>在这四种技术选型时，我个人倾向于选择<code>JSON</code>和<code>YAML</code>。进一步斟酌时，虽然<code>JSON</code>的适用范围最广，但当配置文件复杂到一定程度时，<code>JSON</code>格式的配置文件很难通过换行来约束，当存在大量的嵌套时，可读性很差。所以，我个人比较推荐使用<code>YAML</code>格式的配置文件，一方面通过强制的换行约束，可读性很棒；另一方面云原生相关技术大量使用了<code>YAML</code>作为配置文件，尤其是<code>Kubernetes</code>中各种定义。</p>
<p>例如，我们将服务的端口改造到配置文件里，就成了：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">grpc:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8082</span></span><br></pre></td></tr></table></figure>

<p>对应的Go语言代码为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.GetInt(<span class="string">&quot;server.http.port&quot;</span>)</span><br><span class="line">viper.GetInt(<span class="string">&quot;server.grpc.port&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="可扩展的获取参数方法"><a href="#可扩展的获取参数方法" class="headerlink" title="可扩展的获取参数方法"></a>可扩展的获取参数方法</h3><p><code>viper</code>库提供的获取参数方式为<code>viper.Get&#123;type&#125;(&quot;&#123;level1&#125;.&#123;level2&#125;.&#123;level3&#125;...&quot;)</code>的格式。随着配置文件的扩大，也只需新增Get方法即可。</p>
<p>从获取参数的方法来看，它的设计分为3种：</p>
<ol>
<li>基本类型，直接提供Get{具体类型}的方法，如<code>GetInt</code>，<code>GetString</code>；</li>
<li>任意类型，提供<code>Get(key string) interface&#123;&#125; </code>，自行转化</li>
<li>复杂类型的反序列化，提供<code>UnmarshalKey</code>等方法，更方便地获取复杂结构</li>
</ol>
<p>我个人建议各位只使用第一类的方法，将配置文件这个模块做到最简化。毕竟，<strong>配置文件的复杂化很容易引入各种问题，占用大量的排查故障的时间</strong>。如果你的系统必须引入一套非常复杂的配置，那么我更建议将它独立成一个专门的服务，用来维护这套配置。</p>
<h2 id="3-使用viper库的推荐方式"><a href="#3-使用viper库的推荐方式" class="headerlink" title="3.使用viper库的推荐方式"></a>3.使用viper库的推荐方式</h2><p>如果你仔细地阅读viper相关的代码，你会发现它有很多超酷的特性。但今天，我想告诉各位：<strong>请克制地使用进阶的特性，最棒的特性往往是简洁的</strong>。</p>
<p>我们对照着官方的README文件中介绍的特性进行讲解。</p>
<h3 id="尽量避免手动设置的参数值"><a href="#尽量避免手动设置的参数值" class="headerlink" title="尽量避免手动设置的参数值"></a>尽量避免手动设置的参数值</h3><p><a href="https://github.com/spf13/viper#establishing-defaults">原文链接</a></p>
<p>用<code>viper.SetDefault</code>函数可以给某些参数设置默认值，如果只是少数的几个参数还是很容易维护的。但如果设置的值过多了，就会给阅读代码的人带来困扰：<strong>这个参数是来自配置文件，还是在代码某处手动设置的？</strong>也就是存在<strong>二义性</strong>，增加了排查问题的复杂度。</p>
<h3 id="明确配置文件的来源"><a href="#明确配置文件的来源" class="headerlink" title="明确配置文件的来源"></a>明确配置文件的来源</h3><p><a href="https://github.com/spf13/viper#reading-config-files">原文链接</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.AddConfigPath(<span class="string">&quot;/etc/appname/&quot;</span>)   <span class="comment">// path to look for the config file in</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;$HOME/.appname&quot;</span>)  <span class="comment">// call multiple times to add many search paths</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)               <span class="comment">// optionally look for config in the working directory</span></span><br></pre></td></tr></table></figure>

<p><code>viper</code>支持多个配置文件的路径，这虽然带来了便利性，但如果多个文件路径中都存在配置文件，那究竟以哪个为准？这也是一个<strong>二义性</strong>的问题，所以我个人更建议只设置一个，而这个路径由<code>flag</code>传入。</p>
<h3 id="静态配置与动态配置的分离"><a href="#静态配置与动态配置的分离" class="headerlink" title="静态配置与动态配置的分离"></a>静态配置与动态配置的分离</h3><p><a href="https://github.com/spf13/viper#watching-and-re-reading-config-files">原文链接</a></p>
<p><code>viper</code>提供了接口<code>viper.WatchConfig()</code>，可以监听文件的变化，然后做相应的调整。这个特性很酷，我们可以用它实现<strong>热加载</strong>。但这个特性很容易让人产生混淆：例如发生了某个BUG，如何确定当时的配置文件情况？其实，这就需要引入一定的<strong>版本管理</strong>机制。</p>
<p>我更建议采用<strong>静态配置和动态配置分离</strong>的方案，也就是配置文件负责静态的、固定的配置，一旦启动后只加载一次；而动态的配置放在带版本管理的配置中心里，具备热加载的特性。</p>
<p>所以，我不太建议在配置文件这里引入监听文件变化的特性。</p>
<h2 id="核心代码示例"><a href="#核心代码示例" class="headerlink" title="核心代码示例"></a>核心代码示例</h2><h3 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h3><p>从<code>flag</code>中解析出配置文件路径，传到<code>config</code>包中用于解析。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> configFilePath = flag.String(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;./&quot;</span>, <span class="string">&quot;config file path&quot;</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := config.Load(*configFilePath); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="internal-config-viper-go"><a href="#internal-config-viper-go" class="headerlink" title="internal/config/viper.go"></a>internal/config/viper.go</h3><p>加载的代码并不多，尽量保证配置信息的简洁易懂。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局Viper变量</span></span><br><span class="line"><span class="keyword">var</span> Viper = viper.New()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Load</span><span class="params">(configFilePath <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	Viper.SetConfigName(<span class="string">&quot;config&quot;</span>)       <span class="comment">// config file name without file type</span></span><br><span class="line">	Viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>)         <span class="comment">// config file type</span></span><br><span class="line">	Viper.AddConfigPath(configFilePath) <span class="comment">// config file path</span></span><br><span class="line">	<span class="keyword">return</span> Viper.ReadInConfig()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置使用方"><a href="#配置使用方" class="headerlink" title="配置使用方"></a>配置使用方</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">config.Viper.GetInt(<span class="string">&quot;server.grpc.port&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="使用viper库的注意事项"><a href="#使用viper库的注意事项" class="headerlink" title="使用viper库的注意事项"></a>使用viper库的注意事项</h2><p>在使用<code>viper</code>获取配置时，我们需要手动组装<code>key</code>，也就是<code>&quot;&#123;level1&#125;.&#123;level2&#125;.&#123;level3&#125;...&quot;</code>这种形式。这时，我们只能对照着原始配置文件逐个填充字段，一不小心填错、就会发生奇怪的问题。而如果采用的是将配置文件解析到结构体的方法，就能很容易地避免这个问题。</p>
<p>考虑到扩展性，官方库推荐的是手动组装key的方式，所以需要大家在认真查看这个<code>key</code>是否有效。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>加载静态配置文件是一个很常见的功能，<code>viper</code>提供了一套完整方案，兼具简洁和扩展性；与此同时，我们要学会<strong>克制</strong>，不要看到了<code>viper</code>中提供的各种特性、就想着应用到实际项目中，也就是常说的：<strong>手里拿了个锤子，看啥都是钉子</strong>。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>技术框架</category>
      </categories>
      <tags>
        <tag>Go-Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言微服务框架 - 3.日志库的选型与引入</title>
    <url>/2021/08/25/go-framework/go-framework-3/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p>
<p>日志是一个框架的重要组成部分，那今天我们一起来看看这部分。</p>
<p>衡量日志库有多个指标，我们今天重点关注两点：<strong>简单易用</strong> 与 <strong>高性能</strong>。简单易用是一个日志库能被广泛使用的必要条件，而<strong>高性能</strong>则是企业级的日志库非常重要的衡量点，也能在源码层面对我们有一定的启发。</p>
<span id="more"></span>

<h2 id="v0-3-0：日志库的选型与引入"><a href="#v0-3-0：日志库的选型与引入" class="headerlink" title="v0.3.0：日志库的选型与引入"></a>v0.3.0：日志库的选型与引入</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.3.0">https://github.com/Junedayday/micro_web_service/tree/v0.3.0</a></p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>选择一个开源的日志组件引入，支持常规的日志打印。</p>
<h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol start="3">
<li>三款开源日志库的横向对比</li>
<li>zap日志库的关键实现</li>
<li>关于日志参数的解析</li>
</ol>
<h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">	|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">	   |-- idl                             对应idl文件夹</span><br><span class="line">	      |-- demo                             对应idl/demo服务</span><br><span class="line">	         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">	         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">	         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">	|-- idl                            原始的idl定义</span><br><span class="line">	   |-- demo                            业务package定义</span><br><span class="line">	      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">	|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">	   |-- server                          服务器的实现</span><br><span class="line">	      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">	      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">	   |-- config                          配置相关的文件夹</span><br><span class="line">	      |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">     |-- zlog                            新增：封装日志的文件夹</span><br><span class="line">        |-- zap.go                           新增：zap封装的代码实现</span><br><span class="line">	|-- buf.gen.yaml                   buf生成代码的定义</span><br><span class="line">	|-- buf.yaml                       buf工具安装所需的工具</span><br><span class="line">	|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">	|-- go.mod                         Go Module文件</span><br><span class="line">	|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure>

<h2 id="1-三款开源日志库的横向对比"><a href="#1-三款开源日志库的横向对比" class="headerlink" title="1.三款开源日志库的横向对比"></a>1.三款开源日志库的横向对比</h2><ul>
<li>glog: <a href="https://github.com/golang/glog">https://github.com/golang/glog</a></li>
<li>logrus: <a href="https://github.com/sirupsen/logrus">https://github.com/sirupsen/logrus</a></li>
<li>zap: <a href="https://github.com/uber-go/zap">https://github.com/uber-go/zap</a></li>
</ul>
<p>如果用一次词语分别进行概括三者的特性，我分别会用：<strong>glog - 代码极简，logrus - 功能全面， zap - 高性能</strong>。经过反复思考，这个框架会选择zap库作为日志引擎的基本组件，主要考量如下：</p>
<ol>
<li><strong>高性能</strong> - 性能是一个日志库很重要的属性，它往往由前期的设计决定，很难通过后面的优化大幅度提高，所以zap的高性能很难被替代；</li>
<li><strong>方便封装</strong> - zap设计简单，容易进行二次封装（glog更简洁，相应地就需要更多的封装代码）</li>
<li><strong>大厂背书</strong> - zap库被很多大公司引用，作为内部的日志库的底层，再二次开发</li>
<li><strong>源码学习</strong> - zap库对性能追求极高，可以作为高性能Go语言代码的分析样例</li>
</ol>
<h2 id="2-zap日志库的关键实现"><a href="#2-zap日志库的关键实现" class="headerlink" title="2.zap日志库的关键实现"></a>2.zap日志库的关键实现</h2><h3 id="最简化的调用"><a href="#最简化的调用" class="headerlink" title="最简化的调用"></a>最简化的调用</h3><p>zap日志库的调用很简单，只需要两行代码就能实现初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">logger, _ := zap.NewProduction()</span><br><span class="line"><span class="keyword">defer</span> logger.Sync()</span><br></pre></td></tr></table></figure>

<p>但这样的zap代码存在两个明显弊端：</p>
<ul>
<li>默认输出到控制台上</li>
<li>无法保存到指定目录的文件</li>
</ul>
<h3 id="核心的日志文件实现"><a href="#核心的日志文件实现" class="headerlink" title="核心的日志文件实现"></a>核心的日志文件实现</h3><p>我们增加了一定的特性，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// Logger为zap提供的原始日志，但使用起来比较烦，有强类型约束</span></span><br><span class="line">	logger *zap.Logger</span><br><span class="line">	<span class="comment">// SugaredLogger为zap提供的一个通用性更好的日志组件，作为本项目的核心日志组件</span></span><br><span class="line">	Sugar *zap.SugaredLogger</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(logPath <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 日志暂时只开放一个配置 - 配置文件路径，有需要可以后续开放</span></span><br><span class="line">	hook := lumberjack.Logger&#123;</span><br><span class="line">		Filename: logPath,</span><br><span class="line">	&#125;</span><br><span class="line">	w := zapcore.AddSync(&amp;hook)</span><br><span class="line"></span><br><span class="line">	encoderConfig := zap.NewProductionEncoderConfig()</span><br><span class="line">	encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder</span><br><span class="line"></span><br><span class="line">	core := zapcore.NewCore(</span><br><span class="line">		zapcore.NewConsoleEncoder(encoderConfig),</span><br><span class="line">		w,</span><br><span class="line">		zap.InfoLevel,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	logger = zap.New(core, zap.AddCaller())</span><br><span class="line">	Sugar = logger.Sugar()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名和原生的Zap Log尽量一致，方便理解</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sync</span><span class="params">()</span></span> &#123;</span><br><span class="line">	logger.Sync()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们是如何解决上面两个问题的呢？</p>
<ol>
<li>利用<code>go.uber.org/zap/zapcore</code>中的开放配置</li>
<li>借用了<code>github.com/natefinch/lumberjack</code>这个常用的日志切分库，也顺带实现了日志路径的支持</li>
</ol>
<h3 id="main函数的调用"><a href="#main函数的调用" class="headerlink" title="main函数的调用"></a>main函数的调用</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> logFilePath = flag.String(<span class="string">&quot;l&quot;</span>, <span class="string">&quot;log/service.log&quot;</span>, <span class="string">&quot;log file path&quot;</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">zlog.Init(*logFilePath)</span><br><span class="line"><span class="keyword">defer</span> zlog.Sync()</span><br></pre></td></tr></table></figure>

<p>至此，我们的日志功能已经基本打通。</p>
<h2 id="3-关于日志参数的解析"><a href="#3-关于日志参数的解析" class="headerlink" title="3.关于日志参数的解析"></a>3.关于日志参数的解析</h2><p>日志参数常见的方式分2种，一个是来自<code>flag</code>的解析，另一个是来自配置文件。</p>
<p>随着我们功能的拓展，日志库肯定会支持越来越复杂的场景。那这个时候用<code>flag</code>解析的扩展性就会很差，所以，我更推荐在微服务的框架中，<strong>用配置文件的方式去加载日志的相关配置</strong>。但这种方式会带来一个常见的现象：</p>
<p>程序代码的实现为：先加载配置文件，后加载日志，导致配置文件出错时，无法通过日志来排查，需要用控制台或者进程管理工具协助定位问题。</p>
<p>后续，随着框架的迭代，我会开放出更多的日志参数，目前只放出了一个日志路径的参数作为示例。</p>
<h2 id="后续的两点核心需求"><a href="#后续的两点核心需求" class="headerlink" title="后续的两点核心需求"></a>后续的两点核心需求</h2><p>至此，我们添加的代码量并不多，也算成功地实现了一个日志打印的功能。但在实际的工程中，日志模块还需要实现两个比较大的功能：</p>
<ol>
<li>支持Go程序Panic/Error Wrapping风格的<strong>多行打印与采集</strong></li>
<li>支持分布式TraceId的打印，用来排查<strong>微服务调用链路</strong></li>
</ol>
<p>这两块的内容会结合具体的相关相关技术，会在后续专题中专门分享，请大家重点关注。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>zap</code>库的代码是一个很棒的实现，我会在接下来的<strong>Go语言技巧系列</strong>中详细分析，欢迎大家进行关注。</p>
<p>至此，我们的框架逐渐成型，接下来我将对<code>GORM</code>做一个简单的讲解，引入到框架中。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>技术框架</category>
      </categories>
      <tags>
        <tag>Go-Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言微服务框架 - 4.初识GORM库</title>
    <url>/2021/08/29/go-framework/go-framework-4/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p>
<p>数据持久化是服务的必要特性，最常见的组件就是关系型数据库<code>MySQL</code>。而在<code>Go</code>语言里，<code>GORM</code>已经成了对接<code>MySQL</code>事实上的标准，那么也就不去横向对比其它库了。</p>
<p><code>GORM</code>库是一个很强大、但同时也是一个非常复杂的工具。为了支持复杂的<code>SQL</code>语言，它比之前的配置文件加载工具<code>github.com/spf13/viper</code>要复杂不少。今天，我们不会全量地引入<code>GORM</code>里的所有特性，而是从一个最简单的场景入手，对它的基本特性有所了解。而后续随着框架的完善，我们会逐渐细化功能。</p>
<span id="more"></span>

<h2 id="v0-4-0：引入GORM库"><a href="#v0-4-0：引入GORM库" class="headerlink" title="v0.4.0：引入GORM库"></a>v0.4.0：引入GORM库</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.4.0">https://github.com/Junedayday/micro_web_service/tree/v0.4.0</a></p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>利用GORM实现简单的增删改查功能。</p>
<h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol>
<li>MySQL工具库的必要功能</li>
<li>GORM官方示例分析</li>
<li>使用GORM的思考</li>
</ol>
<h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">	|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">	   |-- idl                             对应idl文件夹</span><br><span class="line">	      |-- demo                             对应idl/demo服务</span><br><span class="line">	         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">	         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">	         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">	|-- idl                            原始的idl定义</span><br><span class="line">	   |-- demo                            业务package定义</span><br><span class="line">	      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">	|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">	   |-- config                          配置相关的文件夹</span><br><span class="line">	      |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">	   |-- dao                             新增：Data Access Object层</span><br><span class="line">	      |-- order.go                         新增：示例的一个Order对象，订单表</span><br><span class="line">	   |-- mysql                           新增：MySQL连接</span><br><span class="line">	      |-- init.go                          新增：初始化连接到MySQL的工作</span><br><span class="line">	   |-- server                          服务器的实现</span><br><span class="line">	      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">	      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">     |-- zlog                            封装日志的文件夹</span><br><span class="line">        |-- zap.go                           zap封装的代码实现</span><br><span class="line">	|-- buf.gen.yaml                   buf生成代码的定义</span><br><span class="line">	|-- buf.yaml                       buf工具安装所需的工具</span><br><span class="line">	|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">	|-- go.mod                         Go Module文件</span><br><span class="line">	|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure>

<h2 id="1-MySQL工具库的必要功能"><a href="#1-MySQL工具库的必要功能" class="headerlink" title="1.MySQL工具库的必要功能"></a>1.MySQL工具库的必要功能</h2><p>对于<code>MySQL</code>数据库来说，我们对它的日常操作其实就关注在CRUD上（也就是增删改查）。</p>
<p>除此以外，还有一些是我们需要关注的点：</p>
<ul>
<li><strong>便捷性</strong>：能快速、方便地实现实现功能，而不用写大量重复性的<code>SQL</code></li>
<li><strong>透明性</strong>：ORM经过层层封装，最终与MySQL交互的<code>SQL</code>语句可供排查问题</li>
<li><strong>扩展性</strong>：支持原生的<code>SQL</code>，在复杂场景下的ORM框架不如原始的<code>SQL</code>好用</li>
</ul>
<p>这里，我们先聚焦于第一点，后面两块<code>GORM</code>框架是支持的。</p>
<h2 id="2-GORM官方示例分析"><a href="#2-GORM官方示例分析" class="headerlink" title="2.GORM官方示例分析"></a>2.GORM官方示例分析</h2><p>接下来，我们对照着官方文档，来看看有什么样的注意点。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>中文文档链接 - <a href="https://gorm.io/zh_CN/docs/create.html">https://gorm.io/zh_CN/docs/create.html</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推荐使用方式：定义一个结构体，填充字段</span></span><br><span class="line">user := User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;</span><br><span class="line">result := db.Create(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：指定要创建的字段名，也就是user中部分生效，很容易产生迷惑</span></span><br><span class="line"><span class="comment">// 更建议新建一个user结构体进行创建</span></span><br><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量创建同推荐</span></span><br><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu3&quot;</span>&#125;&#125;</span><br><span class="line">db.Create(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：钩子相关的特性，类似于数据库里的trigger，隐蔽而迷惑，不易维护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">BeforeCreate</span><span class="params">(tx *gorm.DB)</span> <span class="params">(err error)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：用Map硬编码创建记录，改动成本大</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Create(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 争议点：gorm.Model中预定了数据库中的四个字段，是否应该把它引入到模型的定义中</span></span><br><span class="line"><span class="comment">// 我个人不太喜欢将这四个字段强定义为数据库表中的字段名</span></span><br><span class="line"><span class="keyword">type</span> Model <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID        <span class="keyword">uint</span> <span class="string">`gorm:&quot;primarykey&quot;`</span></span><br><span class="line">	CreatedAt time.Time</span><br><span class="line">	UpdatedAt time.Time</span><br><span class="line">	DeletedAt DeletedAt <span class="string">`gorm:&quot;index&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的一些操作可以看到，我推荐的使用方式有2个特点：</p>
<ol>
<li>尽可能简单，不要出现<strong>魔法变量</strong>，比如常量字符串</li>
<li><strong>不要让框架强约束表结构的设计</strong>，也是为了后续迁移框架、甚至语言时成本更低</li>
</ol>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>中文文档链接 - <a href="https://gorm.io/zh_CN/docs/query.html">https://gorm.io/zh_CN/docs/query.html</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不推荐： 我个人不太建议使用First/Last这种和原生SQL定义不一致的语法，扩展性也不好</span></span><br><span class="line"><span class="comment">// 在这种情况下，我更建议采用Find+Order+Limit这样的组合方式，通用性也更强</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：Find支持返回多个记录，是最常用的方法，但需要结合一定的限制</span></span><br><span class="line">result := db.Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：条件查询的字段名采用hard code，体验不好</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line">db.Where(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：结合结构体的方式定义，体验会好很多</span></span><br><span class="line"><span class="comment">// 但是，上面这种方法不支持结构体中Field为默认值的情况，如0，&#x27;&#x27;，false等</span></span><br><span class="line"><span class="comment">// 所以，更推荐采用下面这种方式，虽然会带来一定的hard code，但能指定要查询的结构体名称。</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">20</span>&#125;).First(&amp;user)</span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：指定排序</span></span><br><span class="line">db.Order(<span class="string">&quot;age desc, name&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：限制查询范围，结合Find</span></span><br><span class="line">db.Limit(<span class="number">10</span>).Offset(<span class="number">5</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure>

<p>查询还有很多的特性，今天我们暂不细讲。其中，希望大家能重点看一下默认值问题：</p>
<p>我们固然可以通过在定义字段时，排除这些默认值的情况，如定义<code>int</code>类型字段时跳过0、从1开始。但在实际的项目中，定义往往很难控制，我们不得不做一定的妥协，这部分hard code的成本也是可以接受的。</p>
<p><strong>我们不能因为框架里的一些特性，过度地限制其余组件的使用</strong>。</p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>中文文档链接 - <a href="https://gorm.io/zh_CN/docs/update.html">https://gorm.io/zh_CN/docs/update.html</a></p>
<p>更新其实是最麻烦的事情，它包括<strong>更新的字段与条件</strong>。我们来看看几个重点的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不推荐：单字段的更新，不常用</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：指定主键的多字段更新，但不支持默认类型</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>, Active: <span class="literal">false</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：指定主键的多字段的更新，但字段多了硬编码很麻烦</span></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：指定主键的多字段的更新，指定要更新的字段，*为全字段</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;new_name&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;*&quot;</span>).Update(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Role: <span class="string">&quot;admin&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：指定更新方式的多字段的更新</span></span><br><span class="line">db.Model(User&#123;&#125;).Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>中文文档链接 - <a href="https://gorm.io/zh_CN/docs/delete.html">https://gorm.io/zh_CN/docs/delete.html</a></p>
<p>删除我不太建议使用，更推荐用软删除的方式，也就是<strong>更新一个标识是否已经删除字段</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Delete(&amp;email)</span><br></pre></td></tr></table></figure>

<h2 id="3-使用GORM的思考"><a href="#3-使用GORM的思考" class="headerlink" title="3.使用GORM的思考"></a>3.使用GORM的思考</h2><p><code>GORM</code>是一个非常重量级的工具，尤其是<code>*gorm.DB</code>提供了大量的类似于Builder模式的方法，用来拼接<code>SQL</code>。</p>
<p>整个使用过程，对于一个不熟悉<code>SQL</code>语言的同学来说是很痛苦的，需要大量调试问题的时间；而对于熟悉<code>SQL</code>的朋友也会很疑惑，例如<code>First</code>等这种自定义命名的底层实现。所以，基于<code>GORM</code>库做一个简单封装是非常必要的，能大幅度地降低用户的使用和理解的门槛，也是这个微服务框架后续的改善方向之一。</p>
<h2 id="对微服务框架的延伸思考"><a href="#对微服务框架的延伸思考" class="headerlink" title="对微服务框架的延伸思考"></a>对微服务框架的延伸思考</h2><p>从之前的分析可以看到，我对微服务的框架有一个很重要的要求 - <strong>透明</strong>，比如不要引入大量和原始SQL无关的特性、不要过度依赖ORM而忘记了原生SQL才是我们最重要的技能。</p>
<p><strong>透明</strong>也是一个框架能实现简单性的重要特质，减少使用方的理解成本，也就能提高研发效能。</p>
<p>从更高的层面来看整个微服务框架，我们会有更深的体会：</p>
<ol>
<li><strong>为什么Spring Boot那么成功？</strong>主要是Spring Boot的设计理念是比较符合工程化的，而JVM也提供了一套很好的运行时的机制；与此同时，社区提供了大量的Spring Boot组件供开发者调用，自然比较受欢迎。</li>
<li><strong>Go的微服务框架为什么没有统一？</strong>Go的运行时非常轻量级，很难巧妙地像Spring Boot完成框架层面对组件的大一统。Go语言提供的各类组件，很多都是开源社区对传统服务或云原生理念的自我实践，没有绝对的正确与错误。</li>
<li><strong>那如今社区上的那些微服务框架都不值一提吗？</strong>并不是。如果你仔细看这些框架，其实都是对各类Go优秀组件的拼装，只是各有各的想法。我觉得，所谓的Go微服务框架短期内很难统一，但这些组件都会趋于一致。</li>
<li><strong>那你做这个框架的意义是什么呢？</strong>其实我个人并不觉得本框架比现有框架好，我更关注两点：一是分享引入并迭代各个开源组件的过程，让大家更好地理解框架是怎么完善的；第二个是从工程化的角度去思考微服务框架的问题，从会用框架变得理解框架、并改造框架。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们简单地引入了<code>GORM</code>并实现了一套简单的增删改查的代码，更多地是讨论一些技术选型的思考，希望能给大家带来启发。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>技术框架</category>
      </categories>
      <tags>
        <tag>Go-Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言微服务框架 - 5.GORM库的适配sqlmock的单元测试</title>
    <url>/2021/09/05/go-framework/go-framework-5/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p>
<p>随着<code>GORM</code>库的引入，我们在数据库持久化上已经有了解决方案。但上一篇我们使用的<code>GORM</code>过于简单，应用到实际的项目中局限性很大。</p>
<p>与此同时，我们也缺乏一个有效的手段来验证自己编写的相关代码。如果依靠连接到真实的<code>MySQL</code>去验证功能，那成本实在太高。那么，这里我们就引入一个经典的<code>sqlmock</code>框架，并配合对数据库相关代码的修改，来实现相关代码的可测试性。</p>
<span id="more"></span>

<h2 id="v0-4-1：GORM库的适配sqlmock的单元测试"><a href="#v0-4-1：GORM库的适配sqlmock的单元测试" class="headerlink" title="v0.4.1：GORM库的适配sqlmock的单元测试"></a>v0.4.1：GORM库的适配sqlmock的单元测试</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.4.1">https://github.com/Junedayday/micro_web_service/tree/v0.4.1</a></p>
<blockquote>
<p>由于主要是针对GORM的小改动，所以增加了一个小版本号</p>
</blockquote>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>利用sqlmock工具，并对数据库相关代码进行修改，实现单元测试。</p>
<h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol>
<li>Order相关代码的改造</li>
<li>引入sqlmock到测试代码</li>
<li>注意点讲解</li>
</ol>
<h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">	|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">	   |-- idl                             对应idl文件夹</span><br><span class="line">	      |-- demo                             对应idl/demo服务</span><br><span class="line">	         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">	         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">	         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">	|-- idl                            原始的idl定义</span><br><span class="line">	   |-- demo                            业务package定义</span><br><span class="line">	      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">	|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">	   |-- config                          配置相关的文件夹</span><br><span class="line">	      |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">	   |-- dao                             Data Access Object层</span><br><span class="line">	      |-- order.go                         更新：OrderO对象，订单表</span><br><span class="line">	      |-- order_test.go                    新增：Order的单元测试</span><br><span class="line">	   |-- mysql                           MySQL连接</span><br><span class="line">	      |-- init.go                          初始化连接到MySQL的工作</span><br><span class="line">	   |-- server                          服务器的实现</span><br><span class="line">	      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">	      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">     |-- zlog                            封装日志的文件夹</span><br><span class="line">        |-- zap.go                           zap封装的代码实现</span><br><span class="line">	|-- buf.gen.yaml                   buf生成代码的定义</span><br><span class="line">	|-- buf.yaml                       buf工具安装所需的工具</span><br><span class="line">	|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">	|-- go.mod                         Go Module文件</span><br><span class="line">	|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure>

<h2 id="1-Order相关代码的改造"><a href="#1-Order相关代码的改造" class="headerlink" title="1.Order相关代码的改造"></a>1.Order相关代码的改造</h2><p>我们要对Order相关的代码进行改造，来满足以下两个点：</p>
<ol>
<li>可测试性，可以脱离对真实数据库连接的依赖</li>
<li>灵活的更新方法，可以支持对指定条件、指定字段的更新</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  gorm.io/gorm 指的是gorm V2版本，详细可参考 https://gorm.io/zh_CN/docs/v2_release_note.html</span></span><br><span class="line"><span class="comment">  github.com/jinzhu/gorm 一般指V1版本</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderRepo <span class="keyword">struct</span> &#123;</span><br><span class="line">	db *gorm.DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将gorm.DB作为一个参数，在初始化时赋值：方便测试时，放一个mock的db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderRepo</span><span class="params">(db *gorm.DB)</span> *<span class="title">OrderRepo</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;OrderRepo&#123;db: db&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order针对的是 orders 表中的一行数据</span></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id    <span class="keyword">int64</span></span><br><span class="line">	Name  <span class="keyword">string</span></span><br><span class="line">	Price <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderFields 作为一个 数据库Order对象+fields字段的组合</span></span><br><span class="line"><span class="comment">// fields用来指定Order中的哪些字段生效</span></span><br><span class="line"><span class="keyword">type</span> OrderFields <span class="keyword">struct</span> &#123;</span><br><span class="line">	order  *Order</span><br><span class="line">	fields []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderFields</span><span class="params">(order *Order, fields []<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">OrderFields</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;OrderFields&#123;</span><br><span class="line">		order:  order,</span><br><span class="line">		fields: fields,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">AddOrder</span><span class="params">(order *Order)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	err = repo.db.Create(order).Error</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">QueryOrders</span><span class="params">(pageNumber, pageSize <span class="keyword">int</span>, condition *OrderFields)</span> <span class="params">(orders []Order, err error)</span></span> &#123;</span><br><span class="line">	db := repo.db</span><br><span class="line">	<span class="comment">// condition非nil的话，追加条件</span></span><br><span class="line">	<span class="keyword">if</span> condition != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 这里的field指定了order中生效的字段，这些字段会被放在SQL的where条件中</span></span><br><span class="line">		db = db.Where(condition.order, condition.fields...)</span><br><span class="line">	&#125;</span><br><span class="line">	err = db.</span><br><span class="line">		Limit(pageSize).</span><br><span class="line">		Offset((pageNumber - <span class="number">1</span>) * pageSize).</span><br><span class="line">		Find(&amp;orders).Error</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">UpdateOrder</span><span class="params">(updated, condition *OrderFields)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> updated == <span class="literal">nil</span> || <span class="built_in">len</span>(updated.fields) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;update must choose certain fields&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;update must include where condition&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = repo.db.</span><br><span class="line">		Model(&amp;Order&#123;&#125;).</span><br><span class="line">		<span class="comment">// 这里的field指定了order中被更新的字段</span></span><br><span class="line">		Select(updated.fields[<span class="number">0</span>], updated.fields[<span class="number">1</span>:]...).</span><br><span class="line">		<span class="comment">// 这里的field指定了被更新的where条件中的字段</span></span><br><span class="line">		Where(condition.order, condition.fields...).</span><br><span class="line">		Updates(updated.order).</span><br><span class="line">		Error</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-引入sqlmock到测试代码"><a href="#2-引入sqlmock到测试代码" class="headerlink" title="2.引入sqlmock到测试代码"></a>2.引入sqlmock到测试代码</h2><p>sqlmock是检查数据库最常用的工具，我们先不管它使用起来的复杂性，先来看看怎么实现对应的测试代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意，我们使用的是gorm 2.0，网上很多例子其实是针对1.0的</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	DB   *gorm.DB</span><br><span class="line">	mock sqlmock.Sqlmock</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestMain是在当前package下，最先运行的一个函数，常用于初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		db  *sql.DB</span><br><span class="line">		err error</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	db, mock, err = sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DB, err = gorm.Open(mysql.New(mysql.Config&#123;</span><br><span class="line">		Conn:                      db,</span><br><span class="line">		SkipInitializeWithVersion: <span class="literal">true</span>,</span><br><span class="line">	&#125;), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// m.Run 是真正调用下面各个Test函数的入口</span></span><br><span class="line">	os.Exit(m.Run())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  sqlmock 对语法限制比较大，下面的sql语句必须精确匹配（包括符号和空格）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOrderRepo_AddOrder</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> order = &amp;Order&#123;Name: <span class="string">&quot;order1&quot;</span>, Price: <span class="number">1.1</span>&#125;</span><br><span class="line">	orderRepo := NewOrderRepo(DB)</span><br><span class="line"></span><br><span class="line">	mock.ExpectBegin()</span><br><span class="line">	mock.ExpectExec(<span class="string">&quot;INSERT INTO `orders` (`name`,`price`) VALUES (?,?)&quot;</span>).</span><br><span class="line">		WithArgs(order.Name, order.Price).</span><br><span class="line">		WillReturnResult(sqlmock.NewResult(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">	mock.ExpectCommit()</span><br><span class="line">	err := orderRepo.AddOrder(order)</span><br><span class="line">	assert.Nil(t, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOrderRepo_QueryOrders</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> orders = []Order&#123;</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="string">&quot;name1&quot;</span>, <span class="number">1.0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">2</span>, <span class="string">&quot;name2&quot;</span>, <span class="number">1.0</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	page, size := <span class="number">2</span>, <span class="number">10</span></span><br><span class="line">	orderRepo := NewOrderRepo(DB)</span><br><span class="line">	condition := NewOrderFields(&amp;Order&#123;Price: <span class="number">1.0</span>&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;price&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">	mock.ExpectQuery(</span><br><span class="line">		<span class="string">&quot;SELECT * FROM `orders` WHERE `orders`.`price` = ? LIMIT 10 OFFSET 10&quot;</span>).</span><br><span class="line">		WithArgs(condition.order.Price).</span><br><span class="line">		WillReturnRows(</span><br><span class="line">			sqlmock.NewRows([]<span class="keyword">string</span>&#123;<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;price&quot;</span>&#125;).</span><br><span class="line">				AddRow(orders[<span class="number">0</span>].Id, orders[<span class="number">0</span>].Name, orders[<span class="number">0</span>].Price).</span><br><span class="line">				AddRow(orders[<span class="number">1</span>].Id, orders[<span class="number">1</span>].Name, orders[<span class="number">1</span>].Price))</span><br><span class="line"></span><br><span class="line">	ret, err := orderRepo.QueryOrders(page, size, condition)</span><br><span class="line">	assert.Nil(t, err)</span><br><span class="line">	assert.Equal(t, orders, ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOrderRepo_UpdateOrder</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	orderRepo := NewOrderRepo(DB)</span><br><span class="line">	<span class="comment">// 表示要更新的字段为Order对象中的id,name两个字段</span></span><br><span class="line">	updated := NewOrderFields(&amp;Order&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;test_name&quot;</span>&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>&#125;)</span><br><span class="line">	<span class="comment">// 表示更新的条件为Order对象中的price字段</span></span><br><span class="line">	condition := NewOrderFields(&amp;Order&#123;Price: <span class="number">1.0</span>&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;price&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">	mock.ExpectBegin()</span><br><span class="line">	mock.ExpectExec(</span><br><span class="line">		<span class="string">&quot;UPDATE `orders` SET `id`=?,`name`=? WHERE `orders`.`price` = ?&quot;</span>).</span><br><span class="line">		WithArgs(updated.order.Id, updated.order.Name, condition.order.Price).</span><br><span class="line">		WillReturnResult(sqlmock.NewResult(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">	mock.ExpectCommit()</span><br><span class="line"></span><br><span class="line">	err := orderRepo.UpdateOrder(updated, condition)</span><br><span class="line">	assert.Nil(t, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-注意点讲解"><a href="#3-注意点讲解" class="headerlink" title="3.注意点讲解"></a>3.注意点讲解</h2><p>虽然添加了注释，我这边依旧讲一下修改的重点：</p>
<ol>
<li><code>gorm.DB</code>作为一个初始化的参数，将其转变成一个依赖注入，使这块代码更具可测试性</li>
<li>查询和更新采用了一个新的结构体<code>OrderFields</code>，是用里面的<code>fields</code>声明了<code>order</code>中哪个字段生效</li>
</ol>
<h2 id="GORM框架的进一步扩展"><a href="#GORM框架的进一步扩展" class="headerlink" title="GORM框架的进一步扩展"></a>GORM框架的进一步扩展</h2><p>通过这一次对GORM数据库相关代码的迭代，还是可以发现有些不足：</p>
<ol>
<li>对复杂SQL的支持不足：如group by、子查询等语句</li>
<li>对field这块限制不好，<code>id</code>, <code>name</code>， <code>price</code>，容易发生误填字段的问题</li>
<li>没有串联日志模块</li>
</ol>
<p>接下来的模块，我会逐渐对2、3两点进行补充，而第1点需要有选择性地实现，我也会结合具体的场景进行分享。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这一个小版本，我们让<code>DAO</code>这个与数据库交互模块的代码更具可读性（从调用侧可以清楚地了解到要做什么）、健壮性（单元测试）和可扩展性（对后续字段的扩展也很容易支持）。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>技术框架</category>
      </categories>
      <tags>
        <tag>Go-Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言微服务框架 - 6.用Google风格的API接口打通MySQL操作</title>
    <url>/2021/09/19/go-framework/go-framework-6/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p>
<p>随着RPC与MySQL的打通，整个框架已经开始打通了数据的出入口。</p>
<p>接下来，我们就尝试着实现通过RPC请求操作MySQL数据库，打通整个链路，真正地让这个平台实现可用。</p>
<span id="more"></span>

<h2 id="v0-5-0：用Google风格的API接口打通MySQL操作"><a href="#v0-5-0：用Google风格的API接口打通MySQL操作" class="headerlink" title="v0.5.0：用Google风格的API接口打通MySQL操作"></a>v0.5.0：用Google风格的API接口打通MySQL操作</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.5.0">https://github.com/Junedayday/micro_web_service/tree/v0.5.0</a></p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>从API出发，实现一个数据库表的增删改查。</p>
<h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol>
<li>Google风格的API定义</li>
<li>model与dao的定义</li>
<li>service层的实现</li>
</ol>
<blockquote>
<p>注意，最近buf工具进行了一次不兼容的升级，从v1beta升级到了v1，可通过如下链接下载 <a href="https://github.com/bufbuild/buf/releases">https://github.com/bufbuild/buf/releases</a></p>
</blockquote>
<h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">	|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">	   |-- idl                             对应idl文件夹</span><br><span class="line">	      |-- demo                             对应idl/demo服务</span><br><span class="line">	         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">	         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">	         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">	    	|-- order                            新增：对应idl/order服务</span><br><span class="line">	         |-- order.pb.go                       新增：order.proto的基础结构</span><br><span class="line">	         |-- order.pb.gw.go                    新增：order.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">	         |-- order_grpc.pb.go                  新增：order.proto的gRPC接口代码</span><br><span class="line">	|-- idl                            原始的idl定义</span><br><span class="line">	   |-- demo                            业务package定义</span><br><span class="line">	      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">	   |-- order                           新增：业务order定义</span><br><span class="line">	      |-- order.proto                      新增：protobuffer的原始定义</span><br><span class="line">	|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">	   |-- config                          配置相关的文件夹</span><br><span class="line">	      |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">	   |-- dao                             Data Access Object层</span><br><span class="line">	      |-- order.go                         更新：Order对象，订单表，实现model层的OrderRepository</span><br><span class="line">	      |-- order_test.go                    Order的单元测试</span><br><span class="line">	   |-- model                           新增：model层，定义对象的接口方法</span><br><span class="line">	      |-- order.go                         新增：OrderRepository接口，具体实现在dao层</span><br><span class="line">	   |-- mysql                           MySQL连接</span><br><span class="line">	      |-- init.go                          初始化连接到MySQL的工作</span><br><span class="line">	   |-- server                          服务器的实现</span><br><span class="line">	      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">	      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">	   |-- service                         新增：service层，作为领域实现的核心部分</span><br><span class="line">	      |-- order.go                         新增：Order相关的服务，目前仅简单的CRUD</span><br><span class="line">     |-- zlog                            封装日志的文件夹</span><br><span class="line">        |-- zap.go                           zap封装的代码实现</span><br><span class="line">	|-- buf.gen.yaml                   更新：buf生成代码的定义，从v1beta升到v1</span><br><span class="line">	|-- buf.yaml                       更新：buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">	|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">	|-- go.mod                         Go Module文件</span><br><span class="line">	|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure>

<h2 id="1-Google风格的API定义"><a href="#1-Google风格的API定义" class="headerlink" title="1.Google风格的API定义"></a>1.Google风格的API定义</h2><p>由于整体的定义比较多，这里就以</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">CreateOrderRequest</span> </span>&#123;</span><br><span class="line">  Order order = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UpdateOrderRequest</span> </span>&#123;</span><br><span class="line">  Order order = <span class="number">1</span>;</span><br><span class="line">  google.protobuf.FieldMask update_mask = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">GetOrderRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order服务</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ListOrders(ListOrdersRequest) <span class="keyword">returns</span> (ListOrdersResponse) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      get: <span class="string">&quot;/v1/orders&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里body中的order表示HTTP的body里的数据填充到CreateOrderRequest结构中的order对象</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> CreateOrder(CreateOrderRequest) <span class="keyword">returns</span> (Order) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      post: <span class="string">&quot;/v1/orders&quot;</span></span><br><span class="line">      body: <span class="string">&quot;order&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> UpdateOrder(UpdateOrderRequest) <span class="keyword">returns</span> (google.protobuf.Empty) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      patch: <span class="string">&quot;/v1/orders&quot;</span></span><br><span class="line">      body: <span class="string">&quot;*&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里&#123;name=*&#125;表示这个字段填充到GetOrderRequest里的name字段</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetOrder(GetOrderRequest) <span class="keyword">returns</span> (Order) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      get: <span class="string">&quot;/v1/orders/&#123;name=*&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> DeleteBook(DeleteBookRequest) <span class="keyword">returns</span> (google.protobuf.Empty) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      delete: <span class="string">&quot;/v1/books&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们重点关注以下几个方法：</p>
<ol>
<li>List - 查询列表，对应HTTP的GET方法</li>
<li>Get - 查询单个对象，对应HTTP的GET方法</li>
<li>Create - 创建对象，对应HTTP的POST方法</li>
<li>Update - 更新对象，对应HTTP的PATCH方法</li>
<li>Delete - 删除对象，对应HTTP的DELETE方法（本次暂未实现，后续添加软删除时加上）</li>
</ol>
<blockquote>
<p>关于Google定义的标准方法细节，可以参考<a href="https://cloud.google.com/apis/design/standard_methods">Google Cloud API链接</a>，了解对资源、字段等命名的逻辑。</p>
<p>而对于gRPC-Gateway中对于proto3的语法，可以参考<a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/mapping/patch_feature/">gRPC-Gateway链接</a>。</p>
<p>以上两块内容比较多，建议边实践边学习，不要一开始就钻细节。</p>
</blockquote>
<h2 id="2-model与dao的定义"><a href="#2-model与dao的定义" class="headerlink" title="2.model与dao的定义"></a>2.model与dao的定义</h2><p>为了将模型的定义与数据库的实现分离，我将两者进行了拆分，分别放置在model与dao目录下，定位的简单介绍如下：</p>
<ul>
<li>model，数据模型的定义，更关注对业务层的数据格式统一，底层可以对应各种存储形式，如mysql、redis</li>
<li>dao，真实数据存储的操作，也就是model层的实现，目前实现了一种mysql的操作</li>
</ul>
<h3 id="Model层"><a href="#Model层" class="headerlink" title="Model层"></a>Model层</h3><p>重点是统一的数据结构定义<code>Order</code>，以及关键接口<code>OrderRepository</code>的定义。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Order针对的是 orders 表中的一行数据</span></span><br><span class="line"><span class="comment">// 在这里定义，是为了分离Model与Dao</span></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id    <span class="keyword">int64</span></span><br><span class="line">	Name  <span class="keyword">string</span></span><br><span class="line">	Price <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderFields 作为一个 数据库Order对象+fields字段的组合</span></span><br><span class="line"><span class="comment">// fields用来指定Order中的哪些字段生效</span></span><br><span class="line"><span class="keyword">type</span> OrderFields <span class="keyword">struct</span> &#123;</span><br><span class="line">	Order  *Order</span><br><span class="line">	Fields []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderRepository <span class="keyword">interface</span> &#123;</span><br><span class="line">	AddOrder(order *Order) (err error)</span><br><span class="line">	QueryOrders(pageNumber, pageSize <span class="keyword">int</span>, condition *OrderFields) (orders []Order, err error)</span><br><span class="line">	UpdateOrder(updated, condition *OrderFields) (err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h3><p>Dao层代码基本与之前一致，重点关注结构体<code>OrderRepo</code>，它是Model层<code>OrderRepository</code>的一种MySQL实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OrderRepo <span class="keyword">struct</span> &#123;</span><br><span class="line">	db *gorm.DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将gorm.DB作为一个参数，在初始化时赋值：方便测试时，放一个mock的db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderRepo</span><span class="params">(db *gorm.DB)</span> *<span class="title">OrderRepo</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;OrderRepo&#123;db: db&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-service层的实现"><a href="#3-service层的实现" class="headerlink" title="3.service层的实现"></a>3.service层的实现</h2><p>service是核心业务实现，但目前的示例代码比较简单，基本就是透传CRUD。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Service的实现，注意orderRepo的定义是model层的interface</span></span><br><span class="line"><span class="keyword">type</span> OrderService <span class="keyword">struct</span> &#123;</span><br><span class="line">	orderRepo model.OrderRepository</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象，注意orderRepo的实现为dao层代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderService</span><span class="params">()</span> *<span class="title">OrderService</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;OrderService&#123;</span><br><span class="line">		orderRepo: dao.NewOrderRepo(mysql.GormDB),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以List为例，透传查询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(orderSvc *OrderService)</span> <span class="title">List</span><span class="params">(ctx context.Context, pageNumber, pageSize <span class="keyword">int</span>, condition *model.OrderFields)</span> <span class="params">([]model.Order, error)</span></span> &#123;</span><br><span class="line">	orders, err := orderSvc.orderRepo.QueryOrders(pageNumber, pageSize, condition)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;OrderService List pageNumber %d pageSize %d&quot;</span>, pageNumber, pageSize)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> orders, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-模拟HTTP接口访问"><a href="#4-模拟HTTP接口访问" class="headerlink" title="4.模拟HTTP接口访问"></a>4.模拟HTTP接口访问</h2><p>本服务支持gRPC和HTTP访问，但由于gRPC不方便用工具模拟，我们这里就以HTTP对本服务进行访问</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// List</span></span><br><span class="line">curl --request GET <span class="string">&#x27;http://127.0.0.1:8081/v1/orders&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create</span></span><br><span class="line">curl --request POST <span class="string">&#x27;http://127.0.0.1:8081/v1/orders&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">--data-raw <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;order1&quot;,</span></span><br><span class="line"><span class="string">    &quot;price&quot;: 100.3</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update 这里 order 表示数据，update_mask表示更新的字段是price</span></span><br><span class="line">curl --request PATCH <span class="string">&#x27;http://127.0.0.1:8081/v1/orders&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">--data-raw <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;order&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;id&quot;: &quot;1&quot;,</span></span><br><span class="line"><span class="string">        &quot;name&quot;: &quot;order1&quot;,</span></span><br><span class="line"><span class="string">        &quot;price&quot;: 110.9</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;update_mask&quot;: &quot;price&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 查询name=order1的对象</span></span><br><span class="line">curl --request GET <span class="string">&#x27;http://127.0.0.1:8081/v1/orders/order1&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="关于Google风格的API总结"><a href="#关于Google风格的API总结" class="headerlink" title="关于Google风格的API总结"></a>关于Google风格的API总结</h2><p>Google风格的API和目前的主流RESTful标准的API有很多相似点、也存在一定的区别。</p>
<p>我们没有必要去抠API风格的细节实现、一定要与Google风格完全一致。API接口是一个通用协议，不同团队有自己的理解，就像RESTful标准的细节实现都有差异。</p>
<p>作为对外协议，最重要的是可读性，每个人都可以根据实际项目情况，对接口风格做一些适配性调整。这里介绍Google风格，主要是为了扩展大家的视野、拥有更多的技术实现方式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这个版本，我们打通了API接口到MySQL数据库操作的全流程，是对整个框架的一次初步整合。接下来，我们会对这一流程进行精雕细琢，使其更具通用性和易用性。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>技术框架</category>
      </categories>
      <tags>
        <tag>Go-Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言微服务框架 - 7.Gormer-自动生成代码的初体验</title>
    <url>/2021/09/27/go-framework/go-framework-7/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p>
<p>CRUD是贯穿整个程序员日常开发的基本工作，占据了我们绝大多数的coding时间。</p>
<p>作为一名程序员，我们总是希望能有更简单的开发方式来解决重复性的工作问题。在这个小版本中，我将结合自己的工作，来给出一套自动生成代码的完整方案，供大家借鉴。</p>
<span id="more"></span>

<h2 id="v0-5-1：Gormer-自动生成代码的初体验"><a href="#v0-5-1：Gormer-自动生成代码的初体验" class="headerlink" title="v0.5.1：Gormer-自动生成代码的初体验"></a>v0.5.1：Gormer-自动生成代码的初体验</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.5.1">https://github.com/Junedayday/micro_web_service/tree/v0.5.1</a></p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>自动生成一套可用的Dao层代码，兼容原始版本。</p>
<h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol>
<li>Go Template技术概览</li>
<li>gormer工具核心思路</li>
<li>gormer的模板填充</li>
</ol>
<h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">	|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">	   |-- idl                             对应idl文件夹</span><br><span class="line">	      |-- demo                             对应idl/demo服务</span><br><span class="line">	         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">	         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">	         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">	    	|-- order                            对应idl/order服务</span><br><span class="line">	         |-- order.pb.go                       order.proto的基础结构</span><br><span class="line">	         |-- order.pb.gw.go                    order.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">	         |-- order_grpc.pb.go                  order.proto的gRPC接口代码</span><br><span class="line">	|-- idl                            原始的idl定义</span><br><span class="line">	   |-- demo                            业务package定义</span><br><span class="line">	      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">	   |-- order                           业务order定义</span><br><span class="line">	      |-- order.proto                      protobuffer的原始定义</span><br><span class="line">	|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">	   |-- config                          配置相关的文件夹</span><br><span class="line">	      |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">	   |-- dao                             Data Access Object层</span><br><span class="line">	      |-- order.go                         Order对象，订单表，实现model层的OrderRepository</span><br><span class="line">	      |-- order_test.go                    Order的单元测试</span><br><span class="line">	   |-- gormer                          新增：从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">	      |-- order.go                         新增：gormer从orders表中获取的真实Gorm结构体</span><br><span class="line">	   |-- model                           model层，定义对象的接口方法</span><br><span class="line">	      |-- order.go                         OrderRepository接口，具体实现在dao层</span><br><span class="line">	   |-- mysql                           MySQL连接</span><br><span class="line">	      |-- init.go                          初始化连接到MySQL的工作</span><br><span class="line">	   |-- server                          服务器的实现</span><br><span class="line">	      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">	      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">	   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">	      |-- order.go                         Order相关的服务，目前仅简单的CRUD</span><br><span class="line">     |-- zlog                            封装日志的文件夹</span><br><span class="line">        |-- zap.go                           zap封装的代码实现</span><br><span class="line">  |-- pkg                            新增：开放给第三方的工具库</span><br><span class="line">     |-- gormer                          新增：gormer工具，用于生成Gorm相关Dao层代码</span><br><span class="line">	|-- buf.gen.yaml                   buf生成代码的定义，从v1beta升到v1</span><br><span class="line">	|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">	|-- gen.sh                         更新：生成代码的脚本：buf+gormer</span><br><span class="line">	|-- go.mod                         Go Module文件</span><br><span class="line">	|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure>

<h2 id="1-Go-Template技术概览"><a href="#1-Go-Template技术概览" class="headerlink" title="1.Go Template技术概览"></a>1.Go Template技术概览</h2><p>Go的标准库提供了Template功能，但网上的介绍很零散，我建议大家可以阅读以下两篇资料：</p>
<ul>
<li>原理性：官方文档 - <a href="https://pkg.go.dev/text/template">https://pkg.go.dev/text/template</a> </li>
<li>实践性：Blog - <a href="https://blog.gopheracademy.com/advent-2017/using-go-templates/">https://blog.gopheracademy.com/advent-2017/using-go-templates/</a> </li>
</ul>
<p>这里，为了方便大家阅读下面的内容，我简要概括下：</p>
<ol>
<li>结构体中字段填充 <code>&#123;&#123; .FieldName &#125;&#125;</code></li>
<li>条件语句 <code>&#123;&#123;if .FieldName&#125;&#125; // action &#123;&#123; else &#125;&#125; // action 2 &#123;&#123; end &#125;&#125;</code></li>
<li>循环 <code>&#123;&#123;range .Member&#125;&#125; ... &#123;&#123;end&#125;&#125;</code></li>
<li>流水线 <code>&#123;&#123; with $x := <^>result-of-some-action<^> &#125;&#125; &#123;&#123; $x &#125;&#125; &#123;&#123; end &#125;&#125;</code></li>
</ol>
<blockquote>
<p>很多资料会很自然地将Go Template和HTML结合起来，但这只是模板的其中一个用法。</p>
<p>HTML的结构用模板化的方式可以减少大量重复性的代码，但这种思路是前后单不分离的，个人不太推荐。</p>
</blockquote>
<h2 id="2-gormer工具核心思路"><a href="#2-gormer工具核心思路" class="headerlink" title="2.gormer工具核心思路"></a>2.gormer工具核心思路</h2><p>在pkg/gormer目录下提供了一个gormer工具，用于自动生成代码，我对主流程进行简单地讲解：</p>
<ol>
<li>解析各种关键性的参数</li>
<li>连接测试数据库，获取表信息</li>
<li>逐个处理每个表<ol>
<li>读取数据库中的表结构</li>
<li>根据表结构生成对应的Go语言结构体，放在internal/gormer下</li>
<li>生成相关的Dao层代码，放在internal/dao下</li>
</ol>
</li>
<li>执行go fmt格式化代码</li>
</ol>
<p>其中最关键的是3-b与3-c，它们是生成代码的最关键步骤。我们来看一个关键性的结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体名称，对应MySQL表级别的信息</span></span><br><span class="line"><span class="keyword">type</span> StructLevel <span class="keyword">struct</span> &#123;</span><br><span class="line">	TableName      <span class="keyword">string</span></span><br><span class="line">	Name           <span class="keyword">string</span></span><br><span class="line">	SmallCamelName <span class="keyword">string</span></span><br><span class="line">	Columns        []FieldLevel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Field字段名称，对应MySQL表里Column</span></span><br><span class="line"><span class="keyword">type</span> FieldLevel <span class="keyword">struct</span> &#123;</span><br><span class="line">	FieldName <span class="keyword">string</span></span><br><span class="line">	FieldType <span class="keyword">string</span></span><br><span class="line">	GormName  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-gormer的模板填充"><a href="#3-gormer的模板填充" class="headerlink" title="3.gormer的模板填充"></a>3.gormer的模板填充</h2><p>结合1、2，我们可以开始生成模板的部分，具体的Template代码如下，它会将StructLevel这个结构体中的字段填充到下面内容中，生成go文件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gormerTmpl = <span class="string">`</span></span><br><span class="line"><span class="string">// Table Level Info</span></span><br><span class="line"><span class="string">const &#123;&#123;.Name&#125;&#125;TableName = &quot;&#123;&#123;.TableName&#125;&#125;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Field Level Info</span></span><br><span class="line"><span class="string">type &#123;&#123;.Name&#125;&#125;Field string</span></span><br><span class="line"><span class="string">const (</span></span><br><span class="line"><span class="string">&#123;&#123;range $item := .Columns&#125;&#125;</span></span><br><span class="line"><span class="string">    &#123;&#123;$.Name&#125;&#125;Field&#123;&#123;$item.FieldName&#125;&#125; &#123;&#123;$.Name&#125;&#125;Field = &quot;&#123;&#123;$item.GormName&#125;&#125;&quot; &#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var &#123;&#123;$.Name&#125;&#125;FieldAll = []&#123;&#123;$.Name&#125;&#125;Field&#123; &#123;&#123;range $k,$item := .Columns&#125;&#125;&quot;&#123;&#123;$item.GormName&#125;&#125;&quot;, &#123;&#123;end&#125;&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Kernel struct for table for one row</span></span><br><span class="line"><span class="string">type &#123;&#123;.Name&#125;&#125; struct &#123; &#123;&#123;range $item := .Columns&#125;&#125;</span></span><br><span class="line"><span class="string">	&#123;&#123;$item.FieldName&#125;&#125;	&#123;&#123;$item.FieldType&#125;&#125;	`</span> + <span class="string">&quot;`&quot;</span> + <span class="string">`gorm:&quot;column:&#123;&#123;$item.GormName&#125;&#125;&quot;`</span> + <span class="string">&quot;`&quot;</span> + <span class="string">` &#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Kernel struct for table operation</span></span><br><span class="line"><span class="string">type &#123;&#123;.Name&#125;&#125;Options struct &#123;</span></span><br><span class="line"><span class="string">    &#123;&#123;.Name&#125;&#125; *&#123;&#123;.Name&#125;&#125;</span></span><br><span class="line"><span class="string">    Fields []string</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Match: case insensitive</span></span><br><span class="line"><span class="string">var &#123;&#123;$.Name&#125;&#125;FieldMap = map[string]string&#123;</span></span><br><span class="line"><span class="string">&#123;&#123;range $item := .Columns&#125;&#125;&quot;&#123;&#123;$item.FieldName&#125;&#125;&quot;:&quot;&#123;&#123;$item.GormName&#125;&#125;&quot;,&quot;&#123;&#123;$item.GormName&#125;&#125;&quot;:&quot;&#123;&#123;$item.GormName&#125;&#125;&quot;,</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func New&#123;&#123;.Name&#125;&#125;Options(target *&#123;&#123;.Name&#125;&#125;, fields ...&#123;&#123;$.Name&#125;&#125;Field) *&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">    options := &amp;&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">        &#123;&#123;.Name&#125;&#125;: target,</span></span><br><span class="line"><span class="string">        Fields: make([]string, len(fields)),</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    for index, field := range fields &#123;</span></span><br><span class="line"><span class="string">        options.Fields[index] = string(field)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return options</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func New&#123;&#123;.Name&#125;&#125;OptionsAll(target *&#123;&#123;.Name&#125;&#125;) *&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">    return New&#123;&#123;.Name&#125;&#125;Options(target, &#123;&#123;$.Name&#125;&#125;FieldAll...)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func New&#123;&#123;.Name&#125;&#125;OptionsRawString(target *&#123;&#123;.Name&#125;&#125;, fields ...string) *&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">    options := &amp;&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">        &#123;&#123;.Name&#125;&#125;: target,</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    for _, field := range fields &#123;</span></span><br><span class="line"><span class="string">        if f,ok := &#123;&#123;$.Name&#125;&#125;FieldMap[field];ok &#123;</span></span><br><span class="line"><span class="string">             options.Fields = append(options.Fields, f)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return options</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>生成的代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code generated by gormer. DO NOT EDIT.</span></span><br><span class="line"><span class="keyword">package</span> gormer</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Table Level Info</span></span><br><span class="line"><span class="keyword">const</span> OrderTableName = <span class="string">&quot;orders&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field Level Info</span></span><br><span class="line"><span class="keyword">type</span> OrderField <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	OrderFieldId         OrderField = <span class="string">&quot;id&quot;</span></span><br><span class="line">	OrderFieldName       OrderField = <span class="string">&quot;name&quot;</span></span><br><span class="line">	OrderFieldPrice      OrderField = <span class="string">&quot;price&quot;</span></span><br><span class="line">	OrderFieldCreateTime OrderField = <span class="string">&quot;create_time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> OrderFieldAll = []OrderField&#123;<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;price&quot;</span>, <span class="string">&quot;create_time&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kernel struct for table for one row</span></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id         <span class="keyword">int64</span>     <span class="string">`gorm:&quot;column:id&quot;`</span></span><br><span class="line">	Name       <span class="keyword">string</span>    <span class="string">`gorm:&quot;column:name&quot;`</span></span><br><span class="line">	Price      <span class="keyword">float64</span>   <span class="string">`gorm:&quot;column:price&quot;`</span></span><br><span class="line">	CreateTime time.Time <span class="string">`gorm:&quot;column:create_time&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kernel struct for table operation</span></span><br><span class="line"><span class="keyword">type</span> OrderOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">	Order  *Order</span><br><span class="line">	Fields []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Match: case insensitive</span></span><br><span class="line"><span class="keyword">var</span> OrderFieldMap = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">	<span class="string">&quot;Id&quot;</span>: <span class="string">&quot;id&quot;</span>, <span class="string">&quot;id&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;name&quot;</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Price&quot;</span>: <span class="string">&quot;price&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="string">&quot;price&quot;</span>,</span><br><span class="line">	<span class="string">&quot;CreateTime&quot;</span>: <span class="string">&quot;create_time&quot;</span>, <span class="string">&quot;create_time&quot;</span>: <span class="string">&quot;create_time&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderOptions</span><span class="params">(target *Order, fields ...OrderField)</span> *<span class="title">OrderOptions</span></span> &#123;</span><br><span class="line">	options := &amp;OrderOptions&#123;</span><br><span class="line">		Order:  target,</span><br><span class="line">		Fields: <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(fields)),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> index, field := <span class="keyword">range</span> fields &#123;</span><br><span class="line">		options.Fields[index] = <span class="keyword">string</span>(field)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderOptionsAll</span><span class="params">(target *Order)</span> *<span class="title">OrderOptions</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewOrderOptions(target, OrderFieldAll...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderOptionsRawString</span><span class="params">(target *Order, fields ...<span class="keyword">string</span>)</span> *<span class="title">OrderOptions</span></span> &#123;</span><br><span class="line">	options := &amp;OrderOptions&#123;</span><br><span class="line">		Order: target,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, field := <span class="keyword">range</span> fields &#123;</span><br><span class="line">		<span class="keyword">if</span> f, ok := OrderFieldMap[field]; ok &#123;</span><br><span class="line">			options.Fields = <span class="built_in">append</span>(options.Fields, f)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dao层的代码逻辑类似，我就不重复填写了。</p>
<p>这里，我将代码拆分成了gormer与dao两层，主要是：</p>
<ul>
<li>internal/gormer整个目录是不可变的、只能自动生成，对应基础的数据库表结构</li>
<li>internal/dao层会添加其余的文件，如定制化的sql。</li>
</ul>
<p>至此，再将引用的相关代码简单修改，就实现了这一整块功能.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章重点介绍了Go Template在高度重复的代码模块中的应用，结合数据库实现了一个高度自动化的工具gormer。</p>
<p>gormer目前实现的功能比较单一，但只要有了初步自动化的思路，我们可以在后续迭代中慢慢优化，让它适应更多的场景。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>技术框架</category>
      </categories>
      <tags>
        <tag>Go-Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言微服务框架 - 8.Gormer迭代-定制专属的ORM代码生成工具</title>
    <url>/2021/10/10/go-framework/go-framework-8/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p>
<p>在上一篇，我们写一个<code>gormer</code>工具库，支持了简单的CRUD。但是，在实际的开发场景中，这部分的功能仍显得非常单薄。</p>
<p>例如，我们对比一下GORM库提供的<code>gorm.Model</code>，它在新增、修改时，会自动修改对应的时间，这个可以帮我们减少很多重复性的代码编写。这里，我就针对现有的gormer工具做一个示例性的迭代。</p>
<span id="more"></span>

<h2 id="v0-5-2：Gormer迭代-定制更智能的代码生成工具"><a href="#v0-5-2：Gormer迭代-定制更智能的代码生成工具" class="headerlink" title="v0.5.2：Gormer迭代-定制更智能的代码生成工具"></a>v0.5.2：Gormer迭代-定制更智能的代码生成工具</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.5.2">https://github.com/Junedayday/micro_web_service/tree/v0.5.2</a></p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>生成一套智能化的Dao层代码，兼容软删除和硬删除。</p>
<blockquote>
<p>这里提一下软删除的概念，就是指在数据库中用某个字段标记为删除，但这行数据仍存在；而硬删除就是直接删除整条数据。</p>
<p>软删除虽然增加了一定的复杂度，但带来的收益很大。最直接的好处就是能保留记录，方便查原始记录。</p>
</blockquote>
<h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol>
<li>gormer.yaml的文件</li>
<li>模板文件的修改</li>
<li>核心结构体梳理</li>
<li>API调用示例</li>
</ol>
<h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><p>为了方便理解，我简化对应的目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">	|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">	   |-- idl                             对应idl文件夹</span><br><span class="line">	      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">	    	|-- order                            对应idl/order服务，同上</span><br><span class="line">	|-- idl                            原始的idl定义</span><br><span class="line">	   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">	   |-- order                           业务order定义，同时干</span><br><span class="line">	|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">	   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">	   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">	   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">	   |-- model                           model层，定义对象的接口方法，具体实现在dao层</span><br><span class="line">	   |-- mysql                           MySQL连接</span><br><span class="line">	   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">	   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          修改：gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">	|-- buf.gen.yaml                   buf生成代码的定义，从v1beta升到v1</span><br><span class="line">	|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">	|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">	|-- go.mod                         Go Module文件</span><br><span class="line">	|-- gormer.yaml                    新增：将gormer中的参数移动到这里</span><br><span class="line">	|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure>

<h2 id="1-gormer-yaml的文件"><a href="#1-gormer-yaml的文件" class="headerlink" title="1.gormer.yaml的文件"></a>1.gormer.yaml的文件</h2><p>这里先给出具体的建表语句，可以清晰地看到orders表6个字段的具体含义：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders</span><br><span class="line">(</span><br><span class="line">id <span class="type">bigint</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">255</span>) COMMENT <span class="string">&#x27;名称，建议唯一&#x27;</span>,</span><br><span class="line">price <span class="type">decimal</span>(<span class="number">15</span>,<span class="number">3</span>) COMMENT <span class="string">&#x27;订单价格&#x27;</span>,</span><br><span class="line">create_time <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">update_time <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">delete_status tinyint(<span class="number">3</span>) COMMENT <span class="string">&#x27;删除状态，1表示软删除&#x27;</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;订单信息表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>我们回顾一下之前的gormer程序，它采用了<code>flag</code>参数解析的方式。但随着复杂度提升，命令行参数包含了大量的内容，很难维护。这时，就建议采用<strong>配置文件</strong>的方式，保证可读性、可维护性。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据库相关的信息</span></span><br><span class="line"><span class="attr">database:</span></span><br><span class="line">  <span class="comment"># 数据库连接</span></span><br><span class="line">  <span class="attr">dsn:</span> <span class="string">&quot;root:123456@tcp(127.0.0.1:3306)/demo&quot;</span></span><br><span class="line">  <span class="comment"># 所有要生成到Go结构体中的表</span></span><br><span class="line">  <span class="attr">tables:</span></span><br><span class="line">    <span class="comment"># name-表名</span></span><br><span class="line">    <span class="comment"># goStruct-Go中结构体名</span></span><br><span class="line">    <span class="comment"># createTime-创建时间的数据库字段，必须为时间格式</span></span><br><span class="line">    <span class="comment"># updateTime-更新时间的数据库字段，必须为时间格式</span></span><br><span class="line">    <span class="comment"># softDeleteKey-软删除的数据库字段，必须为整数型，不填则为硬删除</span></span><br><span class="line">    <span class="comment"># softDeleteValue-表示为软删除的对应值</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;orders&quot;</span></span><br><span class="line">      <span class="attr">goStruct:</span> <span class="string">&quot;Order&quot;</span></span><br><span class="line">      <span class="attr">createTime:</span> <span class="string">&quot;create_time&quot;</span></span><br><span class="line">      <span class="attr">updateTime:</span> <span class="string">&quot;update_time&quot;</span></span><br><span class="line">      <span class="attr">softDeleteKey:</span> <span class="string">&quot;delete_status&quot;</span></span><br><span class="line">      <span class="attr">softDeleteValue:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目相关的信息</span></span><br><span class="line"><span class="attr">project:</span></span><br><span class="line">  <span class="comment"># 项目的路径</span></span><br><span class="line">  <span class="attr">base:</span> <span class="string">&quot;./&quot;</span></span><br><span class="line">  <span class="comment"># gorm相关核心结构的代码路径</span></span><br><span class="line">  <span class="attr">gorm:</span> <span class="string">&quot;internal/gormer/&quot;</span></span><br><span class="line">  <span class="comment"># dao层CRUD核心结构的代码路径</span></span><br><span class="line">  <span class="attr">dao:</span> <span class="string">&quot;internal/dao/&quot;</span></span><br><span class="line">  <span class="comment"># 项目的go module信息</span></span><br><span class="line">  <span class="attr">go_mod:</span> <span class="string">&quot;github.com/Junedayday/micro_web_service&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-模板文件的修改"><a href="#2-模板文件的修改" class="headerlink" title="2.模板文件的修改"></a>2.模板文件的修改</h2><p>这里以两个具有代表性的操作为例，一起来看看具体代码。</p>
<h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><p>利用了go template的特性，填充了create_time和update_time字段。这里包含两层if语句：</p>
<ul>
<li>第一层：在<code>gormer.yaml</code>里必须指定了createTime代码，否则不要生成这段代码</li>
<li>第二层：如果外部传进来的字段里没有指定时间，才填充最新的时间；否则以外部传入为准</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">daoTmplAdd = <span class="string">`func (repo *&#123;&#123;.StructName&#125;&#125;Repo) Add&#123;&#123;.StructName&#125;&#125;(&#123;&#123;.StructSmallCamelName&#125;&#125; *gormer.&#123;&#123;.StructName&#125;&#125;) (err error) &#123;</span></span><br><span class="line"><span class="string">&#123;&#123;if ne .FieldCreateTime &quot;&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">    if &#123;&#123;.StructSmallCamelName&#125;&#125;.&#123;&#123;.FieldCreateTime&#125;&#125;.IsZero() &#123;</span></span><br><span class="line"><span class="string">		&#123;&#123;.StructSmallCamelName&#125;&#125;.&#123;&#123;.FieldCreateTime&#125;&#125; = time.Now()</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;if ne .FieldUpdateTime &quot;&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">    if &#123;&#123;.StructSmallCamelName&#125;&#125;.&#123;&#123;.FieldUpdateTime&#125;&#125;.IsZero() &#123;</span></span><br><span class="line"><span class="string">		&#123;&#123;.StructSmallCamelName&#125;&#125;.&#123;&#123;.FieldUpdateTime&#125;&#125; = time.Now()</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">	err = repo.db.</span></span><br><span class="line"><span class="string">		Table(gormer.&#123;&#123;.StructName&#125;&#125;TableName).</span></span><br><span class="line"><span class="string">		Create(&#123;&#123;.StructSmallCamelName&#125;&#125;).</span></span><br><span class="line"><span class="string">		Error</span></span><br><span class="line"><span class="string">	return</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">AddOrder</span><span class="params">(order *gormer.Order)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> order.CreateTime.IsZero() &#123;</span><br><span class="line">		order.CreateTime = time.Now()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> order.UpdateTime.IsZero() &#123;</span><br><span class="line">		order.UpdateTime = time.Now()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = repo.db.</span><br><span class="line">		Table(gormer.OrderTableName).</span><br><span class="line">		Create(order).</span><br><span class="line">		Error</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除的逻辑主要区分了一个字段，即是否在<code>gormer.yaml</code>里指定了软删除的字段。</p>
<ul>
<li>指定了软删除的字段，则将这个字段更新为设定的值、并且更新updateTime字段；</li>
<li>未指定软删除的字段，则直接硬删除对应的记录；</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">daoTmplDelete = <span class="string">`func (repo *&#123;&#123;.StructName&#125;&#125;Repo) Delete&#123;&#123;.StructName&#125;&#125;(condition *gormer.&#123;&#123;.StructName&#125;&#125;Options) (err error) &#123;</span></span><br><span class="line"><span class="string">	if condition == nil &#123;</span></span><br><span class="line"><span class="string">		return errors.New(&quot;delete must include where condition&quot;)</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	err = repo.db.</span></span><br><span class="line"><span class="string">        Table(gormer.&#123;&#123;.StructName&#125;&#125;TableName).</span></span><br><span class="line"><span class="string">		Where(condition.&#123;&#123;.StructName&#125;&#125;, condition.Fields).</span></span><br><span class="line"><span class="string">&#123;&#123;if eq .FieldSoftDeleteKey &quot;&quot; &#125;&#125; Delete(&amp;gormer.&#123;&#123;.StructName&#125;&#125;&#123;&#125;).</span></span><br><span class="line"><span class="string">&#123;&#123; else &#125;&#125;  &#123;&#123;if eq .FieldUpdateTime &quot;&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">				Select(&quot;&#123;&#123;.TableSoftDeleteKey&#125;&#125;&quot;).</span></span><br><span class="line"><span class="string">				Updates(&amp;gormer.&#123;&#123;.StructName&#125;&#125;&#123;</span></span><br><span class="line"><span class="string">					&#123;&#123;.FieldSoftDeleteKey&#125;&#125;:&#123;&#123;.TableSoftDeleteValue&#125;&#125;,</span></span><br><span class="line"><span class="string">				&#125;).</span></span><br><span class="line"><span class="string">            &#123;&#123; else &#125;&#125;</span></span><br><span class="line"><span class="string">                Select(&quot;&#123;&#123;.TableSoftDeleteKey&#125;&#125;&quot;,&quot;&#123;&#123;.TableUpdateTime&#125;&#125;&quot;).</span></span><br><span class="line"><span class="string">				Updates(&amp;gormer.&#123;&#123;.StructName&#125;&#125;&#123;</span></span><br><span class="line"><span class="string">					&#123;&#123;.FieldSoftDeleteKey&#125;&#125;:&#123;&#123;.TableSoftDeleteValue&#125;&#125;,</span></span><br><span class="line"><span class="string">					&#123;&#123;.FieldUpdateTime&#125;&#125; : time.Now(),</span></span><br><span class="line"><span class="string">				&#125;).</span></span><br><span class="line"><span class="string">            &#123;&#123; end &#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123; end &#125;&#125;</span></span><br><span class="line"><span class="string">		Error</span></span><br><span class="line"><span class="string">	return</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">DeleteOrder</span><span class="params">(condition *gormer.OrderOptions)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> condition == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;delete must include where condition&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = repo.db.</span><br><span class="line">		Table(gormer.OrderTableName).</span><br><span class="line">		Where(condition.Order, condition.Fields).</span><br><span class="line">		Select(<span class="string">&quot;delete_status&quot;</span>, <span class="string">&quot;update_time&quot;</span>).</span><br><span class="line">		Updates(&amp;gormer.Order&#123;</span><br><span class="line">			DeleteStatus: <span class="number">1</span>,</span><br><span class="line">			UpdateTime:   time.Now(),</span><br><span class="line">		&#125;).</span><br><span class="line">		Error</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-核心结构体梳理"><a href="#3-核心结构体梳理" class="headerlink" title="3.核心结构体梳理"></a>3.核心结构体梳理</h2><p>我们再一起看看表结构对应到Go结构体的一个关键结构体，这里分成了4个重要的部分：</p>
<ol>
<li>表名、结构体名</li>
<li>表中的列信息、结构体中的Field字段信息</li>
<li>创建时间、更新时间</li>
<li>软删除的字段</li>
</ol>
<p>这个数据结构体，其实是将两个数据源进行了关联映射：</p>
<ul>
<li>原始信息：从MySQL表中查询</li>
<li>自定义字段信息：从gormer.yaml查询</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StructLevel <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// table -&gt; struct</span></span><br><span class="line">	TableName            <span class="keyword">string</span></span><br><span class="line">	StructName           <span class="keyword">string</span></span><br><span class="line">	StructSmallCamelName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// table column -&gt; struct field</span></span><br><span class="line">	Columns []FieldLevel</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create time</span></span><br><span class="line">	TableCreateTime <span class="keyword">string</span></span><br><span class="line">	FieldCreateTime <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// update time</span></span><br><span class="line">	TableUpdateTime <span class="keyword">string</span></span><br><span class="line">	FieldUpdateTime <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// soft delete</span></span><br><span class="line">	TableSoftDeleteKey   <span class="keyword">string</span></span><br><span class="line">	TableSoftDeleteValue <span class="keyword">int</span></span><br><span class="line">	FieldSoftDeleteKey   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FieldLevel <span class="keyword">struct</span> &#123;</span><br><span class="line">	FieldName <span class="keyword">string</span></span><br><span class="line">	FieldType <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// gorm tag for field</span></span><br><span class="line">	GormName <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// comment from create table sql</span></span><br><span class="line">	Comment <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-API调用示例"><a href="#4-API调用示例" class="headerlink" title="4.API调用示例"></a>4.API调用示例</h2><p>从API调用的角度来看，程序对外接口如下。有兴趣的可以体验下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// List</span><br><span class="line">curl --location --request GET &#x27;http://127.0.0.1:8081/v1/orders&#x27;</span><br><span class="line"></span><br><span class="line">// Create</span><br><span class="line">curl --location --request POST &#x27;http://127.0.0.1:8081/v1/orders&#x27; \</span><br><span class="line">--header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">--data-raw &#x27;&#123;</span><br><span class="line">    &quot;name&quot;: &quot;order4&quot;,</span><br><span class="line">    &quot;price&quot;: 100.3</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br><span class="line">// Update</span><br><span class="line">curl --location --request PATCH &#x27;http://127.0.0.1:8081/v1/orders&#x27; \</span><br><span class="line">--header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">--data-raw &#x27;&#123;</span><br><span class="line">    &quot;order&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;order1&quot;,</span><br><span class="line">        &quot;price&quot;: 110.8</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;update_mask&quot;: &quot;price&quot;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br><span class="line">// Get</span><br><span class="line">curl --location --request GET &#x27;http://127.0.0.1:8081/v1/orders/order1&#x27;</span><br><span class="line"></span><br><span class="line">// Delete</span><br><span class="line">curl --location --request DELETE &#x27;http://127.0.0.1:8081/v1/orders/order1&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="延伸思考"><a href="#延伸思考" class="headerlink" title="延伸思考"></a>延伸思考</h2><p>修改到这个版本，gormer工具已经达到了基本可用的阶段。我们回顾一下重点功能：<strong>根据数据库表结构，自动化生成dao层的CRUD代码</strong>，并扩展了两特性：</p>
<ol>
<li>支持创建时间、修改时间的字段，自动填充</li>
<li>支持软删除与硬删除</li>
</ol>
<p>从更远的角度来看，还有许多MySQL的特性可以添加，尤其是对事务的支持，有兴趣的可以自行探索。限于篇幅与复杂度，目前就迭代到这个版本。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Gormer是一个我们根据日常CRUD需求自行实现的工具，是框架实现高度自动化的重要环节。它的核心思想是 - <strong>在重复的日常开发过程中找到可自动化的环节，实现Generate Code</strong>。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>技术框架</category>
      </categories>
      <tags>
        <tag>Go-Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言微服务框架 - 9.分布式链路追踪-OpenTracing的初步引入</title>
    <url>/2021/10/26/go-framework/go-framework-9/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p>
<p>我们从API层到数据库层的链路已经打通，简单的CRUD功能已经可以快速实现。</p>
<p>随着模块的增加，我们会越发感受到系统的复杂性，开始关注系统的可维护性。这时，有个名词会进入我们的视野：<strong>分布式链路追踪</strong>。相关的内容可以参考这我的两篇文章：</p>
<ul>
<li>OpenTelemetry <a href="https://junedayday.github.io/2021/10/14/readings/go-digest-2/">https://junedayday.github.io/2021/10/14/readings/go-digest-2/</a></li>
<li>Jaeger <a href="https://junedayday.github.io/2021/10/20/readings/go-digest-3/">https://junedayday.github.io/2021/10/20/readings/go-digest-3/</a></li>
</ul>
<p>我们接下来直接进入实战。</p>
<span id="more"></span>

<h2 id="v0-6-0：分布式链路追踪-OpenTracing的初步引入"><a href="#v0-6-0：分布式链路追踪-OpenTracing的初步引入" class="headerlink" title="v0.6.0：分布式链路追踪-OpenTracing的初步引入"></a>v0.6.0：分布式链路追踪-OpenTracing的初步引入</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.6.0">https://github.com/Junedayday/micro_web_service/tree/v0.6.0</a></p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>在项目中引入Jaeger为代表的OpenTracing，用一个traceid串联整个请求的链路。</p>
<h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol>
<li>trace的初始化</li>
<li>将opentracing的设置到grpc和grpc-gateway中</li>
<li>将traceid引入到log组件中</li>
<li>HTTP请求返回traceid</li>
</ol>
<blockquote>
<p>前两点我将一笔带过，在 <a href="https://junedayday.github.io/2021/10/20/readings/go-digest-3/">https://junedayday.github.io/2021/10/20/readings/go-digest-3/</a> 这篇中已有详细的讲解</p>
</blockquote>
<h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">	|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">	   |-- idl                             对应idl文件夹</span><br><span class="line">	      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">	    	|-- order                            对应idl/order服务，同上</span><br><span class="line">	|-- idl                            原始的idl定义</span><br><span class="line">	   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">	   |-- order                           业务order定义，同时干</span><br><span class="line">	|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">	   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">	   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">	   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">	   |-- model                           model层，定义对象的接口方法，具体实现在dao层</span><br><span class="line">	   |-- mysql                           MySQL连接</span><br><span class="line">	   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">	   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">	|-- buf.gen.yaml                   buf生成代码的定义，从v1beta升到v1</span><br><span class="line">	|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">	|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">	|-- go.mod                         Go Module文件</span><br><span class="line">	|-- gormer.yaml                    将gormer中的参数移动到这里</span><br><span class="line">	|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure>

<h2 id="1-trace的初始化"><a href="#1-trace的初始化" class="headerlink" title="1.trace的初始化"></a>1.trace的初始化</h2><p>创建了一个jaeger的trace并设置到opentracing包里的全局变量中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">traceCfg := &amp;jaegerconfig.Configuration&#123;</span><br><span class="line">  ServiceName: <span class="string">&quot;MyService&quot;</span>,</span><br><span class="line">  Sampler: &amp;jaegerconfig.SamplerConfig&#123;</span><br><span class="line">    Type:  jaeger.SamplerTypeConst,</span><br><span class="line">    Param: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  Reporter: &amp;jaegerconfig.ReporterConfig&#123;</span><br><span class="line">    LocalAgentHostPort: <span class="string">&quot;127.0.0.1:6831&quot;</span>,</span><br><span class="line">    LogSpans:           <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">tracer, closer, err := traceCfg.NewTracer(jaegerconfig.Logger(jaeger.StdLogger))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> closer.Close()</span><br><span class="line">opentracing.SetGlobalTracer(tracer)</span><br></pre></td></tr></table></figure>

<h2 id="2-将opentracing的设置到grpc和grpc-gateway中"><a href="#2-将opentracing的设置到grpc和grpc-gateway中" class="headerlink" title="2.将opentracing的设置到grpc和grpc-gateway中"></a>2.将opentracing的设置到grpc和grpc-gateway中</h2><p>利用了拦截器的特性，类似于middleware。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// grpc-gateway</span></span><br><span class="line">opts := []grpc.DialOption&#123;</span><br><span class="line">  grpc.WithInsecure(),</span><br><span class="line">  grpc.WithUnaryInterceptor(</span><br><span class="line">    grpc_opentracing.UnaryClientInterceptor(</span><br><span class="line">      grpc_opentracing.WithTracer(opentracing.GlobalTracer()),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := demo.RegisterDemoServiceHandlerFromEndpoint(ctx, mux, fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, config.Viper.GetInt(<span class="string">&quot;server.grpc.port&quot;</span>)), opts); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;RegisterDemoServiceHandlerFromEndpoint error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grpc</span></span><br><span class="line">s := grpc.NewServer(grpc.UnaryInterceptor(grpc_opentracing.UnaryServerInterceptor(grpc_opentracing.WithTracer(opentracing.GlobalTracer()))))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-将traceid引入到log组件中"><a href="#3-将traceid引入到log组件中" class="headerlink" title="3.将traceid引入到log组件中"></a>3.将traceid引入到log组件中</h2><p>从Opentracing对Go语言的相关介绍可以得知，trace信息被放在go语言的context里。于是，就有了下面这一段提取traceid的代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了使用方便，不修改zap源码，这里利用With函数返回一个SugaredLogger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTrace</span><span class="params">(ctx context.Context)</span> *<span class="title">zap</span>.<span class="title">SugaredLogger</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> jTraceId jaeger.TraceID</span><br><span class="line">	<span class="keyword">if</span> parent := opentracing.SpanFromContext(ctx); parent != <span class="literal">nil</span> &#123;</span><br><span class="line">		parentCtx := parent.Context()</span><br><span class="line">		<span class="keyword">if</span> tracer := opentracing.GlobalTracer(); tracer != <span class="literal">nil</span> &#123;</span><br><span class="line">			mySpan := tracer.StartSpan(<span class="string">&quot;my info&quot;</span>, opentracing.ChildOf(parentCtx))</span><br><span class="line">      <span class="comment">// 提取出一个jaeger的traceid</span></span><br><span class="line">			<span class="keyword">if</span> sc, ok := mySpan.Context().(jaeger.SpanContext); ok &#123;</span><br><span class="line">				jTraceId = sc.TraceID()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">defer</span> mySpan.Finish()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Sugar.With(zap.String(jaeger.TraceContextHeaderName, fmt.Sprint(jTraceId)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-HTTP请求返回traceid"><a href="#4-HTTP请求返回traceid" class="headerlink" title="4.HTTP请求返回traceid"></a>4.HTTP请求返回traceid</h2><p>在拦截器里，解析出trace信息，设置到http的头里。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">trace, ok := serverSpan.Context().(jaeger.SpanContext)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">  w.Header().Set(jaeger.TraceContextHeaderName, fmt.Sprint(trace.TraceID()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们模拟一个简单的请求</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --request GET &#x27;http://127.0.0.1:8081/v1/orders&#x27;</span><br></pre></td></tr></table></figure>

<p>从返回的结果来看，可以看到<code>Uber-Trace-Id</code>头里有个具体的trace-id，例如5fd1fc3ba1715909。</p>
<p>而在应用代码中，我们添加了一行日志：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(orderSvc *OrderService)</span> <span class="title">List</span><span class="params">(ctx context.Context, pageNumber, pageSize <span class="keyword">int</span>, condition *gormer.OrderOptions)</span> <span class="params">([]gormer.Order, <span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">	zlog.WithTrace(ctx).Infof(<span class="string">&quot;page number is %d&quot;</span>, pageNumber)</span><br><span class="line">	<span class="comment">// zlog信息</span></span><br><span class="line">	<span class="keyword">return</span> orders, count, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的打印如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-10-22T17:25:05.591+0800	info	service/order.go:26	page number is 0	&#123;&quot;uber-trace-id&quot;: &quot;5fd1fc3ba1715909&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>虽然格式还不是那么优美，但traceid信息已经填入到了日志中。</p>
<p>至此，调用方只要提供返回的trace-id，我们就可以在程序日志中查找到相应的日志信息，方便针对性地排查问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OpenTracing是服务治理非常关键的一环。利用traceid串联一个请求的整个生命周期，能帮助我们快速地排查问题，在实际生产环境上能更快地定位问题。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>技术框架</category>
      </categories>
      <tags>
        <tag>Go-Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言学习路线 - 0.总览</title>
    <url>/2021/02/21/go-study/go-study-0/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p>
<p>大家好，我是六月天天。从今天开始，我将开启一个新的系列 - <strong>Go语言学习路线</strong>。</p>
<blockquote>
<p>大家可以从 <a href="https://space.bilibili.com/293775192">bilibili</a> 的视频分享中看到观点的延伸思考</p>
</blockquote>
<h2 id="以成长为核心"><a href="#以成长为核心" class="headerlink" title="以成长为核心"></a>以成长为核心</h2><p>目前网上已有很多Go相关的教程，包括基础讲解、源码解析、面试技巧等，但我依然下决心来做一个具有强烈个人主观观点色彩的<strong>Go语言学习路线</strong>：这个系列的目标只有一个 - <strong>成长</strong> 。我不求这个系列超越其它的教程，而是能做到<strong>去芜存菁</strong> ，引发一批朋友的共鸣。</p>
<p>整个系列中，我会输出大量的主观观点，大家不一定能全盘接受，我也不希望大家全盘接受。我坚信，<strong>没有碰撞的技术观点无法引起大家的深度思考</strong> ，犹如上课时老师对你进行单方面的内容输出；同时，<strong>主观观点会更具现实色彩与实践意义</strong> ，我经历的公司和方向都很丰富，或多或少会和大家的实际工作产生共鸣。</p>
<span id="more"></span>

<h2 id="学习路线概览"><a href="#学习路线概览" class="headerlink" title="学习路线概览"></a>学习路线概览</h2><ol>
<li>方向篇 - 明确学习的 <strong>短期目标</strong> 和 <strong>长期目标</strong> ，以及我的一些主观建议</li>
<li>准备篇 - <strong>工欲善其事，必先利其器</strong> ，一套好的工具和方法，不仅能让你更高效地学习，更能让你 <strong>坚持下来</strong></li>
<li>入门篇 - <strong>基础语法</strong> 的学习思路，提纲挈领，但不会细化到语法的讲解</li>
<li>基础篇 - <strong>简单web项目</strong> 的实现思路，介绍 <strong>项目布局</strong>、<strong>模块职责</strong>、<strong>业务特点</strong></li>
<li>提效篇 - <strong>提升开发效率</strong> ，常见思路是采用一些优秀的 <strong>编程实践</strong>、<strong>开源库</strong>、<strong>研发工具</strong>等</li>
<li>进阶篇 - 抛开日常的CRUD，根据自己的目标，找到适合自己的 <strong>进阶路线</strong></li>
<li>高级篇 - 根据互联网上相关信息，结合我的个人经验，谈谈<strong>Go语言的后续发展</strong></li>
</ol>
<blockquote>
<p>可能部分朋友会看重 <strong>入门、基础这些偏实践的模块</strong> ，但我花了大量心血在 <strong>方向及进阶相关的内容</strong> 上：</p>
<ul>
<li>入门的方式各有不同，快的一个月，慢的半年，但最终达到的效果差不了多少</li>
<li>方向错误会严重影响到个人的长远发展，拘泥于自己的舒适圈，越到后期，沉没成本越高</li>
</ul>
</blockquote>
<h2 id="自我简介"><a href="#自我简介" class="headerlink" title="自我简介"></a>自我简介</h2><p>我简单地介绍一下自己重要的编程经历，让大家更好地了解我：</p>
<ul>
<li>4年<code>C++</code> / 4年<code>Go</code> 开发，<code>Python</code>/<code>Java</code>/<code>Js</code>等也都有中小平台的研发经验</li>
<li>曾在某中型公司（已上市，1000+人）的运维开发团队中作为技术负责人，搭建研发效能平台</li>
<li>目前在某一线大厂任职，参与商用业务平台的开发</li>
<li>用<code>Go</code>语言研发过公司内部的 <strong>私有云平台</strong> 和已商用的 <strong>业务平台</strong></li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>最后，我再谈一谈自己对 <strong>Go语言学习路线</strong> 这个系列的期许，也是我希望能区别于其它教程的点：</p>
<ul>
<li><strong>可落地</strong> - 不停留于泛泛而谈，实践的具体路线清晰</li>
<li><strong>正反馈</strong> - 持续激励自己，避免半途而废</li>
<li><strong>阶梯式</strong> - 层层递进，有明确的进步目标</li>
<li><strong>通用性</strong> - 可延伸至各种技术的学习，形成自己的学习方法</li>
<li><strong>及时性</strong> - 定期更新，保证学习路线的内容不过时</li>
</ul>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Study</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言学习路线 - 1.方向篇:明确Go语言的成长方向</title>
    <url>/2021/03/05/go-study/go-study-1/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p>
<h2 id="Go的就业方向"><a href="#Go的就业方向" class="headerlink" title="Go的就业方向"></a>Go的就业方向</h2><p>目前，后端开发语言的就业方向主要分为两块：<strong>业务系统开发</strong> 与 <strong>基础平台开发</strong> 。<code>Go</code>语言自然也不会例外。</p>
<p>也许有朋友不太了解这两块，那我简单地解释下：</p>
<p><strong>业务系统开发</strong> 主要指公司对外盈利的系统，包括 <code>toB</code> 与 <code>toC</code>。由于这个是公司安身立命的根本，所以开发者是必须跟着业务走的。</p>
<p><strong>基础平台开发</strong> 指的是公司为了提升工作效率（不仅仅是研发），搭建的一套内部体系，常常需要跨业务支持。</p>
<blockquote>
<p>目前主流的云平台，其实是包装成一套业务系统的基础平台，比如阿里云的ECS。</p>
<p>这类云平台是大型公司将自己的基础平台能力沉淀下来后，包装成一套业务系统对外销售，内部也是分成了两类开发人员：上层开发一些多语言接口、计费等业务系统；下层开发对应的基础平台。</p>
</blockquote>
<span id="more"></span>

<h2 id="Go语言的劣势"><a href="#Go语言的劣势" class="headerlink" title="Go语言的劣势"></a>Go语言的劣势</h2><p>很遗憾，我依然在这里不得不进行一些编程语言间的对比。毕竟，如果不清楚一些技术的优劣势，我们很难明确自己的定位和发展方向。</p>
<h3 id="并不是所有编程语言适合各个领域"><a href="#并不是所有编程语言适合各个领域" class="headerlink" title="并不是所有编程语言适合各个领域"></a>并不是所有编程语言适合各个领域</h3><p>我先简单地抛出几个例子：</p>
<ul>
<li>游戏、音视频领域主流是<code>C/C++</code></li>
<li>测试、人工智能的主流是<code>Python</code></li>
<li>大数据平台的主流是<code>Java</code></li>
<li>前端的主流是<code>JavaScript</code></li>
</ul>
<p>这里的说法并不是绝对的，但选对了语言，能大量地复用业界现有的资源，少走很多弯路。</p>
<h3 id="语言特点决定“轮子”不会太多"><a href="#语言特点决定“轮子”不会太多" class="headerlink" title="语言特点决定“轮子”不会太多"></a>语言特点决定“轮子”不会太多</h3><p><code>Go</code>的生命已有十年多，但新增的特性很少，主要是语言创建者的核心理念 - <strong>简洁</strong>。这个理念导致了现成可用的轮子少：以<code>map</code>容器来说，<code>Java</code>至少提供了数十种，可根据不同的场景选择不同的实现，达到性能极致化，而<code>Go</code>只提供了一种通用的基本数据结构。</p>
<blockquote>
<p>Go 的设计哲学可以类比为 Unix </p>
</blockquote>
<p>那么，我们是否可以采用开源社区中<code>Go</code>的现成库呢？当然可以！那我们来继续拿<code>Java</code>中的容器对比一下，看看改造的成本：</p>
<ul>
<li>在<code>Java</code>中，容器是一个对象类型，已定义对应的接口<code>interface</code><ul>
<li>新的容器类实现对应的接口</li>
<li>改造成本：在创建容器的地方(如<code>beans</code>)替换即可</li>
</ul>
</li>
<li>而<code>Go</code>里的容器是基本类型，它的操作是定义在基本语法中，并没有抽象出接口<code>interface</code><ul>
<li>改造成本：新的容器实现后，所有的增删改查代码都需要修改</li>
</ul>
</li>
<li>在复杂的嵌套数据结构中，<code>Go</code>的改造成本更大</li>
</ul>
<blockquote>
<p>我们自然可以在自己的项目中，对map/slice操作先封装成一个方法，这样后续改造成本也很低了，但这种思想就很偏向于Java体系了：</p>
<ol>
<li>Go 崇尚的是简洁，map/slice能满足99%以上的使用场景</li>
<li>无法在语言层面将 map/slice 封装成方法，就不能发展成一个语言层面的通用标准，很难推广</li>
</ol>
</blockquote>
<h3 id="没有一套成熟的复杂系统开发方法论"><a href="#没有一套成熟的复杂系统开发方法论" class="headerlink" title="没有一套成熟的复杂系统开发方法论"></a>没有一套成熟的复杂系统开发方法论</h3><p>细心的读者可以注意到我这边用到的两个关键词：<strong>成熟</strong> 和 <strong>复杂系统</strong> 。用 <code>Go</code> 语言开发的系统自然有不少，但我认为至今为止，业界还没有一套非常适配 <code>Go</code> 语言的系统开发方法论，包括大厂们也是在摸索的过程中（或者说没有公开）。</p>
<p>这里，我列举四个我比较关注的点：</p>
<ol>
<li>引入<code>DDD</code>设计思想拆分微服务后，如何保证实践与设计一致</li>
<li>如何借用 <strong>面向对象UML设计图</strong> 类似的实践，梳理复杂系统内的关系</li>
<li>如何组织代码的仓库、目录与分层，适配业务场景</li>
<li>一整套覆盖开发各模块的工具集和最佳实践：如监控埋点、日志链路追踪、测试套件</li>
</ol>
<blockquote>
<p>以上四点业界都有一定的实践，但没有如Spring那般形成一个生态圈，达到一致。</p>
<p>如果达不到一致认可，就无法用工具去强制约束，那么软件工程的复杂度就无法控制了。</p>
</blockquote>
<h2 id="明确Go语言的核心成长方向"><a href="#明确Go语言的核心成长方向" class="headerlink" title="明确Go语言的核心成长方向"></a>明确Go语言的核心成长方向</h2><ol>
<li><strong>掌握计算机基础</strong> <code>Go</code> 官方包覆盖了操作系统、网络、数据库等各类常用操作，我们不能停留在 <strong>使用</strong> 上，而是通过代码去了解它们的 <strong>底层实现</strong> ，为后续遇上相关瓶颈时做好基础的知识储备。由于 <code>Go</code> 的源码简洁，所以阅读起来相对其它语言轻松不少。</li>
<li><strong>常用工具库的储备</strong> <code>Go</code> 在开源上存在一些 <strong>优秀的轮子</strong>，常常能达到事半功倍的效果。我建议分三步走： <strong>会用</strong> 、 <strong>用好</strong> 、<strong>体系化</strong> 。其中体系化是指要将这些库串联起来，根据场景选择，形成一整套灵活的解决方案。</li>
<li><strong>项目/工程化</strong> 将<code>Go</code>的项目与公司的整个研发流程、甚至是产品周期结合起来：小到如何保证一个需求的准确实现，大到如何保证研发架构的合理落地，都是比较有挑战的内容。</li>
</ol>
<blockquote>
<p>也许不少人会认为第三点是一个远超编程语言的话题，在这里讲意义不大。确实，项目工程化更多地是看团队结构、工作流程等上层机制的约束，编程语言能做的不多。</p>
<p>然而，目前<code>Java</code>编程语言已经产生了一个成熟的生态圈，从单纯的代码实现功能，慢慢影响到了开发的各个流程，这样就或多或少地具备了 <strong>项目工程化</strong> 的一些特征。其它的编程语言如果希望能支持复杂的开发场景，必须得有一套初步的系统化方法论（成熟度暂且不论），才有可能分得一杯羹。当然，由于不同编程语言背后的编程范式、设计理念不同，方法论也各具特色，很有可能随着时间推移而变化。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天跟大家聊的话题挺广的，也结合了很多我的个人感受，希望能给大家带来启发。下一篇，我会继续 <strong>方向篇</strong> 的话题，细化到具体工作上，和大家谈谈具体工作上的内容。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Study</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言学习路线 - 2.方向篇:如何成为一名优秀的Go语言工程师</title>
    <url>/2021/03/28/go-study/go-study-2/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p>
<h2 id="核心成长方向"><a href="#核心成长方向" class="headerlink" title="核心成长方向"></a>核心成长方向</h2><p>如何成为一名优秀的Go语言工程师，这是很多人都长期疑惑的问题。</p>
<p>我这边抛出自己的观点，希望能引起大家的思考：</p>
<p><strong>掌握基础，熟悉生态，集百家长，深耕领域</strong></p>
<p>接下来，我将围绕这四个词展开今天的分享。</p>
<span id="more"></span>

<h2 id="1-掌握基础"><a href="#1-掌握基础" class="headerlink" title="1. 掌握基础"></a>1. 掌握基础</h2><p>首先，我们来聊聊这个老生常谈的话题 - <strong>掌握基础</strong>。关于基础的学习路线我会在后面细讲，今天我们先来谈点别的。</p>
<p><strong>所谓基础，会根据工作的不同阶段而不断变化。</strong> 也就是要用 <strong>发展</strong> 的眼光来看问题。</p>
<p>举个例子，就以 <strong>编程语言</strong> 的作为切入点：</p>
<ul>
<li>一名合格的业务开发者，会熟练地应用<strong>编程语言</strong>去实现功能需求，熟练掌握常见的<strong>开源工具库</strong>；</li>
<li>进一步，如果作为一名模块的负责人，那就需要考虑<strong>设计模式</strong>来抽象复杂业务，熟悉编程语言底层的<strong>运行原理</strong>；</li>
<li>再进一步，作为一名架构师，就得思考如何用 <strong>工程化</strong> 来控制复杂度和约束规范性；</li>
<li>而如果是更高一层的角色，如CTO，就需要从编程语言或框架的 <strong>成熟度、前瞻性</strong> 的角度来决定路线。</li>
</ul>
<h2 id="2-熟悉生态"><a href="#2-熟悉生态" class="headerlink" title="2. 熟悉生态"></a>2. 熟悉生态</h2><p><strong>生态</strong> 这个词很微妙，社区里有不同的见解，我也无法抛出一个准确的定义，这块需要大家自行摸索。不过，我倒是可以分享几个踩坑经历：</p>
<ol>
<li><strong>语言生态</strong> ：编程语言都是有对应的应用领域的，我在上一讲已经说过，这里不再细谈；</li>
<li><strong>框架生态</strong> ：编程语言往往提供多种框架，不同框架的设计理念和使用场景不同，甚至会有一定的矛盾。例如有的框架提供了重量级的解决方案，可以快速生成一套代码，但对应的灵活性就大大降低；对应的，另一个框架能提供轻量级的插件化解决方案，需要你自行挑选、组装、调试，以提升复杂度的代价换来了灵活性；</li>
<li><strong>社区生态</strong> ：除了极少的探索性的工作，绝大部分的开发工作都能在社区中找到同路人，经常能发现很有价值的建议。但社区里的声音很杂，筛选信息是最大障碍，这一点很容易反复踩坑。</li>
</ol>
<blockquote>
<p>比起一些告诉你 <strong>该怎么做</strong> 的建议，我更倾向于那些 <strong>不该怎么做</strong> 的建议。</p>
<p>一次成功往往有大量的偶然因素，而从失败中分析出原因更有长期价值。</p>
</blockquote>
<h2 id="3-集百家长"><a href="#3-集百家长" class="headerlink" title="3.集百家长"></a>3.集百家长</h2><p>接下来的这点，是本章的重点，希望大家看完之后能重点思考。</p>
<p><strong>Go</strong> 语言是一个以简单著称的编程语言，又被号称是 <strong>云时代的编程语言</strong>。这背后蕴含了两层含义。</p>
<h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><p>第一点，也就是 <strong>简单</strong> 带来的副作用。一种编程语言如果被冠以 <strong>简单</strong> 的头衔，那么它的设计核心就是 <strong>可读性</strong>。</p>
<p>但是，无论是模板、元编程、泛型这些语法上的高端特性，还是继承、多态、函数式等编程范式上的特性，虽然很复杂（或者说是学习曲线很陡峭），但不得不承认它们在特定的场景中，达到了很好的抽象效果，大幅度地提升了程序的效率。</p>
<p>所以，<strong>Go</strong> 语言决定了在单个程序中支持的复杂度有限，进一步则需要 <strong>JAVA、C++为代表的工业级编程语言</strong> 的一些特性。</p>
<h3 id="云时代的编程语言"><a href="#云时代的编程语言" class="headerlink" title="云时代的编程语言"></a>云时代的编程语言</h3><p>从上一点来看，<strong>Go</strong> 语言支持的单个程序复杂度有限，那就非常依赖 <strong>微服务</strong> 的核心理念 - 拆。通过拆解，可以将单个程序的复杂度转移到架构层面，也更好地契合了<strong>服务内聚</strong>的理念。</p>
<p>但是，即便进行了很好的设计与拆分，<strong>微服务</strong> 依然有两个比较重要的前置要求：<strong>服务间通信</strong> 和 <strong>微服务治理</strong>。前者相对容易解决，统一采用 <strong>RESTful</strong> 风格或 <strong>gRPC</strong> 等框架进行通信，就能满足基本要求；而微服务的治理问题就非常复杂了，很长一段时间都没有一套成熟的解决方案。近几年，随着 <strong>Docker容器化</strong> + <strong>Kubernetes调度平台</strong> 的出现与推广，已经成为了 <strong>微服务的Best Practice</strong> 。</p>
<p>以 <strong>K8s为核心的云原生生态</strong>，涵盖了<strong>监控、日志采集、链路追踪、Service Mesh</strong>等各类子领域的解决方案，均得到了快速迭代。其中，各种核心组件均是通过 <strong>Go</strong> 语言开发而成，像 <strong>Kubernetes、Prometheus、Etcd</strong> 等。</p>
<p>至此，我们开发的服务不再需要过分关注基础组件，而是更聚焦于业务领域。</p>
<h3 id="CNCF"><a href="#CNCF" class="headerlink" title="CNCF"></a>CNCF</h3><p>再回到这一个话题的核心 - <strong>集百家长</strong>。</p>
<p>云原生的社区<strong>CNCF</strong>提供了大量的组件，大家可以通过<a href="https://landscape.cncf.io/images/landscape.png">这个链接</a>看到对应的全景图。它提供了是一整套<strong>插件化</strong>的组合方案，需要开发人员按需组合（后面我也会给出一些建议）。</p>
<p>我非常不建议大家去自己从头开发一个模块，主要有两点（巨型互联网的基础团队除外）：</p>
<ol>
<li>自建轮子跟不上社区迭代，投入产出比价值低；</li>
<li>很多时候某些功能已经在某个组件中实现，或者正在实现，只是没正确使用。</li>
</ol>
<blockquote>
<p>如果真要新增某个重要功能，优先去找个现有CNCF项目的负责人聊聊，提交PR合入，或者自行fork开发。</p>
<p>相信我，在一个成熟产品中新增特性，比你重写一个轮子更有价值！无论是对技术的提升、还是投递简历时的效果，都更有意义。</p>
</blockquote>
<p>举一个场景，当我们发现需要在程序中用<code>map</code>保存大量结果时，用默认的数据结构效率很低：</p>
<ul>
<li>如果在<strong>JAVA</strong>生态里，那么内部就有丰富的容器库可供选择，放在一个服务中即可；</li>
<li>而在<strong>Go</strong>中，自然也可以借用<strong>github</strong>上面搜索的三方库来解决，但更建议根据场景选用开源的K-V组件，通过RPC调用来解决问题，也就是拆成了 <strong>业务功能</strong> 与 <strong>map数据存储</strong> 两个服务</li>
<li>专业的事交给专业的组件</li>
</ul>
<h2 id="4-深耕领域"><a href="#4-深耕领域" class="headerlink" title="4. 深耕领域"></a>4. 深耕领域</h2><p>在工作三年以上，我越来越感受到 <strong>领域</strong> 是一个很重要的概念，也是各公司考验高端人才的重要素质。</p>
<p>举几个例子：</p>
<ul>
<li><p>作为一名 <strong>电商支付领域</strong> 的开发专家，需要在编程语言的 <strong>如何保证数据一致性</strong> 的相关特性有深入研究；</p>
</li>
<li><p>如果是 <strong>物流订单领域</strong> 的专家，则要考虑 <strong>如何合理抽象各类物流类型</strong> 的问题，来支持复杂的场景；</p>
</li>
<li><p>当你负责的是一个 <strong>秒杀系统</strong>，那么需要对 <strong>高并发场景与异常兜底</strong> 有足够的经验。</p>
</li>
</ul>
<p>每一块 <strong>领域</strong> 都需要有大量的 <strong>专业技能</strong> 与 <strong>行业经验</strong> 沉淀，这是高端人才的核心竞争力。</p>
<p>虽说两者缺一不可，但还是具有一定的倾向性</p>
<ul>
<li>偏技术的领域更需要 <strong>专业技能</strong> ，瓶颈往往是某一个垂直领域的技术深度；</li>
<li>偏业务的领域更要求 <strong>行业经验</strong> ，要求负责人能 <strong>带领团队避开坑，走对路</strong> 。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾一下这四个点： <strong>掌握基础，熟悉生态，集百家长，深耕领域</strong> 。这一整个过程，也可以说是：<strong>修炼内功，学习并合理使用外部资源，沉淀于特定领域</strong> 。</p>
<p>纵观周围环境，我发现大部分的开发者都热衷于 <strong>修炼内功和领域沉淀</strong>，而过于轻视了 <strong>外部资源</strong> 的作用，就错失了一个快速提升个人能力的手段，技术视野也非常有限。这一块，将是我后续分享的重点，也是区别于其余教程的一大特点。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Study</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言学习路线 - 3.准备篇:打造个人专属的学习环境</title>
    <url>/2021/04/05/go-study/go-study-3/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p>
<h2 id="为何我们需要持续学习"><a href="#为何我们需要持续学习" class="headerlink" title="为何我们需要持续学习"></a>为何我们需要持续学习</h2><p><strong>终身成长</strong> 一词已被广泛认可，意味着我们将比前人花费更多的时间在 <strong>学习成长</strong> 中，才能将个人的认知跟上社会的步伐。且不论是否应该放慢脚步，但我们大部分人不得不跟随社会的节奏，<strong>持续学习并提高自己</strong>。</p>
<p>相信有不少朋友跟我一样，在学习的过程中经常会 <strong>半途而废</strong>。那么我在这里分享一些方法和技巧（包括但不仅限于Go语言），希望能给大家带来一些启发。</p>
<p>这部分内容依旧会带有一些强烈的个人主观色彩，大家按需选用~</p>
<span id="more"></span>

<h2 id="心理建设"><a href="#心理建设" class="headerlink" title="心理建设"></a>心理建设</h2><p>在正式开始聊工具和方法前，我先聊聊自己学习前的心理建设。这一点看过去 <strong>很“软”</strong> ，但我吃过很多次亏：</p>
<p><strong>与其在学习的过程中，给自己找100个理由放弃，还不如在一开始就否定这些理由。</strong> </p>
<p>以Go语言为例，常见的放弃理由如下：</p>
<ul>
<li>Go真的能长期“火”下去吗？</li>
<li>Go的就业面不广，是否另选其它编程语言</li>
<li>学了基础的Go语法后，没有实践的机会</li>
<li>一段时间提升很不明显，感觉什么都懂、但什么都不精通</li>
</ul>
<p>我就是抱着这样的想法，走走停停，错过了很多快速提升的时期；不过也是由于这段经历，让我对许多朋友的想法有切身体会。今天我不会对着上面的问题一一回复，只强调一个重点：</p>
<p><strong>学技术带着功利心（跳槽、升职）是正常且必要的，毕竟只有解决问题的技术才是有价值的。Go语言是非常依赖“云原生”这一体系的：它实现了云原生的基石-Kubernetes及其余组件，也依赖云原生、提供了非常优雅的微服务解决方案。如今公有云和私有云的建设如火如荼，注定是一个不可逆的过程，所以Go语言是一个需求很大的方向。</strong></p>
<h2 id="学习环境的准备"><a href="#学习环境的准备" class="headerlink" title="学习环境的准备"></a>学习环境的准备</h2><p>下面，正式进入准备的细节：</p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>尽管Go语言支持跨操作系统，但我还是强烈建议大家使用Mac OS，关键在于 <strong>提效</strong>。</p>
<blockquote>
<p> 既然可以花7分力气做一件事，为什么需要10分呢？</p>
</blockquote>
<p>不排除后期Windows系统越来越完善，但目前来看，所有的大厂提供给开发者都是Macbook，这点就不言而喻了吧。如果你有在windows/Linux环境上高效开发的经验，欢迎与大家分享~</p>
<h3 id="Go语言版本"><a href="#Go语言版本" class="headerlink" title="Go语言版本"></a>Go语言版本</h3><p>在<a href="https://golang.google.cn/dl/">官网</a>任意挑选。</p>
<p>如果公司没有要求，那就直接上最新的版本吧~</p>
<blockquote>
<p>如果公司还在用1.13之前的版本，可以尝试着跟领导沟通，升级到较新的版本。</p>
<p>使用低版本会不断发现不兼容某些开源库的情况，比如有些依赖库引入了context的特性</p>
</blockquote>
<h3 id="代码编辑器"><a href="#代码编辑器" class="headerlink" title="代码编辑器"></a>代码编辑器</h3><p>强烈建议准备 VSCode + Goland ！对，不用二选一，而是两个都要！</p>
<ul>
<li><p>VSCode对各类语言、组件兼容都很好，面对<strong>轻量级</strong>的开发时完全可以胜任</p>
</li>
<li><p>Goland在面对<strong>重量级</strong>项目时效果很棒，尤其是对重构项目时，效率能提升一大截</p>
</li>
</ul>
<p>这里提供两个官网： <a href="https://code.visualstudio.com/">VSCode</a> / <a href="https://www.jetbrains.com/go/">Goland</a></p>
<blockquote>
<p>这两款软件的配置，前期尽量用默认的即可。</p>
<p>而如果有大量私人化的配置，记得将整个配置方案导出并保存。</p>
</blockquote>
<h3 id="其余提效工具"><a href="#其余提效工具" class="headerlink" title="其余提效工具"></a>其余提效工具</h3><ul>
<li><a href="https://git-scm.com/">git</a> 不要把git单纯地当作公司的版本管理工具，它更是你私人代码的管理工具</li>
<li><a href="https://segmentfault.com/a/1190000014992947">iTerm2 + Oh My Zsh</a> 这是在Mac下我非常喜欢的一套终端配置方案，大家可以借鉴</li>
<li>笔记类：这块大家按自己的习惯选用，常见的如 印象笔记、Microsoft TODO、typora、幕布、系统自带的笔记本等</li>
<li>上网助手：技术渠道有不少是在国外的网站上，不清楚具体访问方法的话，可以多和周围的开发者交流</li>
</ul>
<blockquote>
<p>欢迎大家留言谈谈自己最喜爱的工具，分享给我~</p>
</blockquote>
<h2 id="Markdown技术写作"><a href="#Markdown技术写作" class="headerlink" title="Markdown技术写作"></a>Markdown技术写作</h2><p>作为一个技术工作者，文档是一个必备技能。我们不应把写文档当作一个负担，大部分的时候它是一种沟通与协作上的提效工具。</p>
<p>这里不得不提一下Markdown，它的语法简单，产出的文档样式也满足基本的场景。大家可以根据<a href="https://www.markdown.xyz/basic-syntax/">这个链接</a>或者自行搜索教程。</p>
<blockquote>
<p>学习Markdown就是一个很小且价值很高的技术点，可以拿这个作为练手，先使用起来。</p>
<p>补充一句：Markdown在社区中的支持度不同，但基本大同小异。为了兼容性，少用html的相关特性。</p>
</blockquote>
<p>Markdown尽管简单，也有很多语法点，建议大家分阶段使用：</p>
<ol>
<li>标题、粗体、代码、链接、列表</li>
<li>图片、引用、分隔线、表格</li>
<li>其它</li>
</ol>
<p>第一阶段的5种语法已经可以满足日常的文档协作，第二阶段的特性可以让文档更具专业性，而其余特性完全可以在使用到时再去查询。</p>
<p><strong>切忌一次性想掌握全部，分阶段使用才是最有效的学习路径。</strong></p>
<p>这里推荐一个我常用的本地Markdown文档写作工具 - <a href="https://typora.io/">typora</a> 。尽管有Web文档工具支持在线编辑，但我更喜欢本地编辑后再复制过去，这样也方便留档。</p>
<h2 id="个人博客系统"><a href="#个人博客系统" class="headerlink" title="个人博客系统"></a>个人博客系统</h2><h3 id="为什么要玩博客"><a href="#为什么要玩博客" class="headerlink" title="为什么要玩博客"></a>为什么要玩博客</h3><ol>
<li><strong>根本价值</strong> - 作为个人的知识输出，沉淀到文档</li>
<li><strong>附带价值</strong> - 面试前后，让心仪的公司更好地了解你</li>
<li><strong>持续价值</strong> - 形成 <strong>正反馈</strong>，持续激励自我</li>
</ol>
<blockquote>
<p>有些人玩博客会将价值颠倒，比如将面试筹码作为根本价值，那么这个技术博客就会明显变味。</p>
</blockquote>
<h3 id="搭建教程"><a href="#搭建教程" class="headerlink" title="搭建教程"></a>搭建教程</h3><p>搭建博客系统的方法有很多，我这边推荐一个 <a href="https://segmentfault.com/a/1190000017986794">hexo + github pages</a> 的。</p>
<p>这种博客的优点在于2点：</p>
<ol>
<li>发布非常方便、非常方便、非常方便！</li>
<li>原始文档为Markdown，可在本地编辑、存档</li>
</ol>
<h3 id="写博客的Tips"><a href="#写博客的Tips" class="headerlink" title="写博客的Tips"></a>写博客的Tips</h3><ol>
<li><strong>降低“成本”</strong> - 让一篇博客从创作到发布变得简单，这点比较依赖博客系统，例如上面的 hexo+github pages</li>
<li><strong>分享作品</strong> - 分享个人的文章，有利于形成“正反馈”；对于比较腼腆的朋友，可以在小规模的圈子中先进行尝试</li>
<li><strong>多元化</strong> - 博客不仅仅停留在技术上，工作上的心得或者生活上的感悟，都可以写进来</li>
<li><strong>适当拆分</strong> - 不要过分追求长篇大作或者系列形式的文章，<em>小步快走</em> 在这里也适用</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>打造个人专属的学习环境，我认为主要包括三块：</p>
<ol>
<li>个人心态 - 坚持</li>
<li>开发环境 - 快速便捷</li>
<li>正反馈路线 - 文档博客</li>
</ol>
<p>当然，你可以根据实际情况，添加一些个人专属的内容：</p>
<ul>
<li>如果你是windows用户，你需要搞一套虚拟机</li>
<li>如果你已有一套成熟的文档系统，那就继续使用</li>
<li>如果你想快速地了解Go而不计划深入，那么没必要过于完善学习环境</li>
</ul>
<p>希望大家在 <strong>心理</strong> 和 <strong>环境</strong> 都做好充分的准备后，再去走这条长期的技术学习路线，并能坚持下来。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Study</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言学习路线 - 4.入门篇:快速体系化地入门Go语言</title>
    <url>/2021/04/17/go-study/go-study-4/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p>
<h2 id="从一本书入门Go语言"><a href="#从一本书入门Go语言" class="headerlink" title="从一本书入门Go语言"></a>从一本书入门Go语言</h2><p>如今互联网资料泛滥，入门编程语言的途径有很多种选择，但如果要我推荐，只有一个建议 - <strong>研读一本该编程语言最优秀的基础书籍</strong>。 </p>
<p>对于Go语言，我推荐 《Go程序设计语言》(The Go Programming Language)，也被称为 <strong>Go语言圣经</strong>。参考链接:<a href="http://product.dangdang.com/25072202.html">当当链接</a> 和 <a href="https://docs.hacknode.org/gopl-zh/">网页版链接</a>。</p>
<blockquote>
<p>我认为，尽量避免只通过网上的博客或视频去学习基础。</p>
<p><strong>体系化</strong> 是建立知识体系最重要的一点。网上的资料最缺乏的就是 <strong>体系化</strong>，而经典书籍都经过了反复的精雕细琢。</p>
</blockquote>
<p>虽然这本书很经典，但在新手在学习的过程中还是会遇到三个经典的疑问：</p>
<ul>
<li>这本书出版已经有4年多，是否有些知识点已经 <strong>过时</strong>？</li>
<li>书籍中的知识点有深有浅，新手只想快速入门，该如何 <strong>权衡知识点</strong>？</li>
<li>书中的知识点虽然是体系化的，但新手很难 <strong>串联</strong> 起来。</li>
</ul>
<p>所以，本章的核心是为了解决上面三个问题的，也可以认为是我对于 <strong>Go语言圣经的导读</strong>。</p>
<blockquote>
<p>基础因人而异，根据自己的实际情况适当提高或降低预期。</p>
</blockquote>
<span id="more"></span>

<h2 id="1-了解背景"><a href="#1-了解背景" class="headerlink" title="1. 了解背景"></a>1. 了解背景</h2><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><ul>
<li><p>出版者的话、译者序、前言</p>
</li>
<li><p>第1章 入门 （不需要对着示例敲代码）</p>
</li>
</ul>
<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>每门编程语言都有自己的背景和思想，了解这块对新手来说很有必要。如果上来就直接看一些基础语法，就会感觉是在 <strong>拼凑知识点</strong>。</p>
<p>所以，好好读一读这部分内容，<strong>建立自己在整体上对Go语言的认识</strong> 。</p>
<h2 id="2-基础语法点"><a href="#2-基础语法点" class="headerlink" title="2. 基础语法点"></a>2. 基础语法点</h2><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><ul>
<li>第2章 程序结构 （难点：指针、引用）</li>
<li>第3章 基本数据 （难点：字符串的编码UTF-8相关知识）</li>
<li>第4章 复合数据类型</li>
<li>第5章 函数（跳过：函数变量、匿名函数）</li>
</ul>
<h3 id="导读-1"><a href="#导读-1" class="headerlink" title="导读"></a>导读</h3><p>这块内容是最基础的，需要对着具体例子敲代码、并跑通。</p>
<p>上面指出的难点，如果不能快速掌握就跳过，<strong>入门学习没必要扣每个细节</strong> 。</p>
<p>至此，你已经掌握了最常见的Go语言用法了。</p>
<h2 id="3-面向对象编程"><a href="#3-面向对象编程" class="headerlink" title="3.面向对象编程"></a>3.面向对象编程</h2><h3 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h3><ul>
<li>第6章 方法</li>
<li>第7章 接口</li>
</ul>
<h3 id="导读-2"><a href="#导读-2" class="headerlink" title="导读"></a>导读</h3><p>这部分的语法并不难，关键点在于慢慢接触 <strong>学习面向对象编程的理念</strong>。</p>
<p><strong>面向对象</strong> 是一个博大精深的话题，这点需要长期的实践与体验，不用急于一时。</p>
<blockquote>
<p>如果对 <strong>面向对象</strong> 这个名词不熟悉的，先去搜搜科普贴，再回头理解这2章的内容。</p>
<p>建议Go语言入门后，跳出具体编程语言的视角，好好地理解一下面向对象的思想。</p>
</blockquote>
<h2 id="4-并发编程"><a href="#4-并发编程" class="headerlink" title="4. 并发编程"></a>4. 并发编程</h2><h2 id="范围-3"><a href="#范围-3" class="headerlink" title="范围"></a>范围</h2><ul>
<li>第8章 goroutine和通道</li>
<li>第9章 使用共享变量实现并发</li>
</ul>
<h3 id="导读-3"><a href="#导读-3" class="headerlink" title="导读"></a>导读</h3><p>并发编程一直都是各编程语言的一大难点，而Go语言将其语法设计得非常简洁，相对更容易学习。</p>
<p>学习并发这块，不仅仅需要大家去 <strong>扣每行代码的逻辑</strong> ，更要了解 <strong>这些并发语法是为了解决什么问题</strong>。</p>
<blockquote>
<p>纯编程新手对并发编程的理解需要一个过程，如果不能快速掌握也不用心浮气躁。</p>
<p>要真正地了解并发，那就得学习操作系统的相关知识。</p>
</blockquote>
<h2 id="5-函数式编程"><a href="#5-函数式编程" class="headerlink" title="5. 函数式编程"></a>5. 函数式编程</h2><h3 id="范围-4"><a href="#范围-4" class="headerlink" title="范围"></a>范围</h3><ul>
<li>第5章 函数（函数变量、匿名函数）</li>
</ul>
<h3 id="导读-4"><a href="#导读-4" class="headerlink" title="导读"></a>导读</h3><p>Go语言支持一定的函数式编程能力。函数式编程是对<strong>传统过程性编码思维的一种突破</strong>，新手了解基本使用方法即可。</p>
<p>匿名函数这块的玩法很有意思，也是面试的高频考点。</p>
<h2 id="6-Go语言的工程化"><a href="#6-Go语言的工程化" class="headerlink" title="6. Go语言的工程化"></a>6. Go语言的工程化</h2><h3 id="范围-5"><a href="#范围-5" class="headerlink" title="范围"></a>范围</h3><ul>
<li>第10章 包和go工具（简单通读里面的一些思想即可，最新的包管理已经完全采用<code>go mod</code>）</li>
<li>第11章 测试</li>
</ul>
<h3 id="导读-5"><a href="#导读-5" class="headerlink" title="导读"></a>导读</h3><p>Go的包管理工具几经波折，目前已经由<code>go mod</code>一统江湖了。<code>go mod</code>的资料可以参考 <a href="https://blog.golang.org/using-go-modules">官方博客</a>。但由于国内下载部分库有限制，可以参考搜索引擎进行配置。</p>
<p>而对于测试部分，我个人觉得 <em>官方提供的原始功能并不好用</em>，初学者写几个示例了解即可，后续在大型项目中还是需要一定的工具辅助。</p>
<h2 id="7-底层知识"><a href="#7-底层知识" class="headerlink" title="7. 底层知识"></a>7. 底层知识</h2><h3 id="范围-6"><a href="#范围-6" class="headerlink" title="范围"></a>范围</h3><ul>
<li>第12章 反射</li>
<li>第13章 低级编程（cgo直接忽略）</li>
</ul>
<h3 id="导读-6"><a href="#导读-6" class="headerlink" title="导读"></a>导读</h3><p>入门的新手<strong>浏览一遍即可，无需深入思考</strong>。大家需要了解的就是2点：</p>
<ol>
<li><strong>反射reflect</strong> 是将 <strong>数据和程序结构</strong> 互相转换的工具</li>
<li><strong>unsafe</strong> 是直接操作 <strong>计算机地址</strong> 的工具</li>
</ol>
<p>在实践中遇到具体问题时，再去针对性地学习。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>总体来看，入门Go语言的关键放在 2、3、4 三点即可，也就是 第2~9章，多敲代码、反复品读。</p>
<p>为了让大家更好地阅读书籍，我再补充三个建议：</p>
<ol>
<li><strong>结合上下文理解难点</strong> - 每个知识点都不是独立的，一定要了解上下文，切忌上来就敲代码；</li>
<li><strong>用文字背后的思想组织成体系化</strong> - 串联知识点的，并不是具体代码，而是相关的文字说明，多多琢磨背后的思想；</li>
<li><strong>对复杂知识点，暂时降低预期，做长期建设</strong> - 像面向对象、并发编程、函数式编程等 高阶内容，不可能只通过学习Go语言就能掌握；</li>
</ol>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Study</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言学习路线 - 5.基础篇:从一个web项目来谈Go语言的技能点</title>
    <url>/2021/05/13/go-study/go-study-5/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p>
<h2 id="从一个Web项目开始"><a href="#从一个Web项目开始" class="headerlink" title="从一个Web项目开始"></a>从一个Web项目开始</h2><p>经过了 <strong>入门篇</strong> 的学习，大家已经初步了解Go语言的语法，也能写常见的代码了。接下来，我们就从一个Web项目入手，看看一些常见的技能与知识吧。</p>
<p>我们先简单地聊一下这个Web项目的背景：我们要做的是一个简单的web系统 ，有前端同学负责界面的开发，后端不会考虑高并发等复杂情况。</p>
<p>我们先从一个Web请求出发，看看会涉及到哪些模块。</p>
<span id="more"></span>

<h2 id="前端的请求生命周期"><a href="#前端的请求生命周期" class="headerlink" title="前端的请求生命周期"></a>前端的请求生命周期</h2><p>用户在web界面上点击了一个按钮，就由前端发起了一个请求。那这个请求的生命周期是怎么样的呢？</p>
<p>通常情况下，后端的工作是<strong>解析前端的数据，处理对应的业务逻辑，返回操作结果</strong>。</p>
<p>这里，离不开三层概念：</p>
<ul>
<li>API层：解析来自前端的数据，转化成go的数据结构</li>
<li>Service层：包含业务逻辑，是这个请求具体要做的事情</li>
<li>Dao层：数据持久化，也就是更新到数据库等，保证不丢失</li>
</ul>
<blockquote>
<p>不同框架有不同的命名方式，但我个人建议只关注这三层即可。</p>
</blockquote>
<p>当然，这三层逻辑并不绝对，会因为项目特点有所调整，但整体的<strong>分层思路</strong>是不会变化的。我认为，如果你能真正地理解web的分层，对项目的框架就能掌握得很棒了。</p>
<p>接下来，我们自顶向下逐层聊聊。</p>
<h2 id="第一层：API层"><a href="#第一层：API层" class="headerlink" title="第一层：API层"></a>第一层：API层</h2><p>通常来说，API层只做三件事：</p>
<ol>
<li><strong>根据路由规则，调用具体的处理函数</strong> ，常见的RESTful就是由<code>URL</code>+<code>Method</code>的作为路由规则；</li>
<li><strong>解析文本或二进制数据到Go结构体</strong>，常见的是用<code>json</code>反序列化；</li>
<li><strong>调用下一层Service的函数</strong></li>
</ol>
<p>抛开第三点暂且不谈，前两者比较容易理解，大家可以使用标准库里的<code>net/http</code>和<code>encoding/json</code>来完成。具体的代码我就不写了，网上示例非常多。</p>
<p>那么，API层这么简单，有什么学问嘛？这里，我建议大家看看两个开源库：</p>
<ul>
<li><a href="https://github.com/gin-gonic/gin">Gin</a></li>
<li><a href="https://github.com/gorilla/mux">Mux</a></li>
</ul>
<p>看看上面的示例，对比一下原生的<code>net/http</code>库写出来的代码，是否感觉可读性大大提高？没错，API层关键点之一的就是<strong>可读性</strong>。</p>
<p>不过Gin相对于Mux非常重量级，学习起来成本很大；而Mux虽然可读性提高，但在解析<code>http body</code>数据这块效果不佳，还是需要逐个手写结构体。</p>
<blockquote>
<p>所以，在我看来，这两个都并不是最佳方案，我非常建议有条件的项目能够直接引入 <strong>RPC级别的解决方案</strong>，例如gRPC。这块我会拿具体项目、花好几讲来好好说说。</p>
</blockquote>
<p>在开发的过程中，我对API层的开发会重点关注这几点：</p>
<ul>
<li>可读性：可以快速地根据命名了解功能，如<strong>RESTful</strong></li>
<li>高度复用：如引入<code>mux</code> 中的各种 middleware，比如 <strong>防止panic</strong> 、<strong>用户认证</strong> 、日志打印等</li>
<li>尽量薄：不做或少做业务逻辑处理，复杂处理都丢到service层</li>
<li>文档化：将接口的相关参数通过文档给到前端或第三方，尽量做到自动化或半自动化</li>
</ul>
<p>我再强调一下API层的重要性：<strong>API层是程序最关键的入口和出口，能很好地追踪到数据的前后变化情况。</strong> 一个优秀的API层实现，不仅能让我们少写很多重复性代码，也能大幅度地降低我们排查问题的效率。</p>
<h2 id="第二层：Service层"><a href="#第二层：Service层" class="headerlink" title="第二层：Service层"></a>第二层：Service层</h2><p>Service层可以理解为服务层，是整个项目中最复杂、也是代码比重往往是最多的。它是一个项目最核心的业务价值所在。</p>
<p>Service是最灵活、也是最考验设计能力的，虽说<strong>没有一套固定的模式</strong>，但还是会有一定的<strong>套路</strong>。</p>
<p>我分享一下个人的三个见解：</p>
<ol>
<li>单元测试覆盖率要尽量高，这是一个<strong>高频迭代与重构</strong>的模块，也是最容易出现问题的部分；</li>
<li>深入实践 <strong>面向对象与DDD</strong> ，最锻炼工程师抽象、解耦等能力的模块；</li>
<li>选择合适的 <strong>设计模式</strong> 可大幅度地提升研发效率；</li>
</ol>
<p>再提一句，请跃跃欲试的各位冷静一下，<strong>Service层是和业务一起成长的</strong>，前期没必要过度设计。我们把重点放在<strong>单元测试</strong>的编写上即可，适当地选用一些库来提高效率，如开源的<code>stretchr/testify</code>，内部的<code>reflect</code>等。</p>
<h2 id="第三层：Dao层"><a href="#第三层：Dao层" class="headerlink" title="第三层：Dao层"></a>第三层：Dao层</h2><p>Dao层常被理解为数据持久化层，但我们可以将它进行一定的延伸：<strong>将RPC调用也当做Dao层</strong>（不妨认为将数据持久化到了另一个服务），来适配微服务架构的场景。</p>
<blockquote>
<p>严格意义上，RPC调用和普通的Dao差异有不少，但为了收敛话题，我们暂且不细分。</p>
</blockquote>
<p>今天，我们不关注分布式场景下的各种数据问题，也不考虑各种存储中间件的特点，而是聚焦于一个问题：<strong>如何将内存中的对象持久化到数据库中</strong>。在编程领域，这部分的工具被称为<strong>ORM</strong>。</p>
<p>以Go语言对接MySQL为例，最常见的为<a href="https://github.com/go-gorm/gorm">gorm</a>，它能很便捷地将一个Go语言中的结构体，映射到MySQL数据库某个表中的一行数据。</p>
<blockquote>
<p>请自行对比一下，用go官方的sql库写增删改查，与用gorm写增删改查的工作量差异。</p>
</blockquote>
<p>关于Dao层，我认为有部分的实践是比较通用的：</p>
<ol>
<li><strong>选用官方或社区高频使用的库</strong>，避免后期出现功能缺失或性能瓶颈的问题；</li>
<li><strong>灵活性比易用性更重要</strong>，通过一层浅封装，往往能更适配项目，达到更棒的易用性；</li>
<li><strong>关注数据库的原理、而不是ORM工具的实现方式</strong>，数据库的原理是长期的积累，对技术选型和排查故障很有帮助。</li>
</ol>
<blockquote>
<p>至于不同的数据库ORM有不同的最佳实践，一一列举的工作量太大，我会在工程化的过程中选择性地讲解。</p>
</blockquote>
<h2 id="串联三层"><a href="#串联三层" class="headerlink" title="串联三层"></a>串联三层</h2><p>到这里，我们对这三层有了初步的了解，可以总结为**两边薄（API、Dao），中间厚（Service)**。</p>
<p>这里的实践需要大家不断打磨，比如说：</p>
<ul>
<li>API与Dao会随着个人编程能力的提升，不断地总结出更好的编程实践；</li>
<li>做性能优化时，优先考虑Dao，其次考虑API，这两部分的提效是最明显的；</li>
<li>排查问题时，先分析API的出入口，再分析Dao的出入口，实在解决不了再去看Service（此时已经是严重的业务逻辑问题了）；</li>
</ul>
<p>到最后，相信大家对这三层认知会进一步提升：</p>
<ul>
<li>API：服务对外的门面，通过一个接口定义就能了解大致实现原理；</li>
<li>Service：复杂的业务逻辑，非该服务的核心成员无需关注，而核心成员须重点维护；</li>
<li>Dao：无论是调用<strong>ORM</strong>还是<strong>SDK</strong>，都视为一种<strong>工具集</strong>，是一个技术人员沉淀通用能力的重点。</li>
</ul>
<h2 id="CRUD程序员"><a href="#CRUD程序员" class="headerlink" title="CRUD程序员"></a>CRUD程序员</h2><p>很多程序员都戏称自己是一个只会<strong>CRUD</strong>的码农。让我们换个视角，看看CRUD背后有没有一些的技术点。</p>
<ul>
<li>API层：遵循<strong>RESTful</strong>的原则，提高可读性（最好能在一行代码中看到，如<code>mux</code>）<ul>
<li>将操作（CRUD）对应到HTTP的Method</li>
<li>将资源对象对应到HTTP的URL</li>
</ul>
</li>
<li>Service层：<ul>
<li>对于只是简单的修改，Service不用做复杂处理，透传到Dao层即可</li>
<li>如果涉及到多个表的修改，进行事务处理（如mysql的transaction）</li>
<li>在Dao层出现错误时，适当封装错误信息，提高可读性</li>
</ul>
</li>
<li>Dao层：<ul>
<li>选择并熟练运用ORM，快速实现基本的CRUD</li>
<li>对复杂的ORM进行一层浅封装，方便Service层的调用</li>
</ul>
</li>
</ul>
<p>经过一段时间的磨练，CRUD的工作能大大提效，我们就能抽出更多的时间去学习其余技能了。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Web项目是我们日常开发最常见的项目类型，也是很多面试考察点的基点。</p>
<p>我建议大家从<strong>分层</strong>着手，明确各层职责，<strong>关注API与Dao层的提效工作，做好Service层的质量保障</strong>，更好地掌控全局。而在具体的开源库的使用过程中，<strong>选对比会用更重要</strong>，集中在<strong>API与Dao层</strong>。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Study</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言学习路线 - 6.提效篇:不懈地追求提升研发效率</title>
    <url>/2021/07/21/go-study/go-study-6/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p>
<h2 id="为什么要追求研发效能"><a href="#为什么要追求研发效能" class="headerlink" title="为什么要追求研发效能"></a>为什么要追求研发效能</h2><p>在<strong>入门篇</strong>与<strong>基础篇</strong>之后，我选择做了这一讲<strong>提效篇</strong>。而在提效篇的推出之前，我也开启<a href="https://junedayday.github.io/tags/Go-Tip/">Go语言技巧系列</a>的更新，着重分享一些具体的工程化实例，包括错误处理、Go Module等。</p>
<p>也许有读者会好奇为什么会把提效篇放在这里，在我看来，<strong>如果工程师已经度过了入门阶段，就应该重点关注研发效能</strong>。</p>
<blockquote>
<p>严格意义来说，基础篇的<strong>分层思想</strong>，就是一个很有效的提升研发效能的手段。</p>
</blockquote>
<p><strong>研发效能</strong>涉及的面很广，但这里我们聚焦于讨论<strong>软件编码阶段</strong>的工作，专注于提升工程师在开发阶段的效率。</p>
<p>提升了研发效能后，我不太建议大家去<strong>主动接手更多的开发工作</strong>，而是<strong>投入到不断地学习和提升自己，持续提高效率，实现正反馈循环</strong>。至于投入到哪些方面更有价值，则是我今天分享的重点。</p>
<span id="more"></span>

<h2 id="培养意识是核心"><a href="#培养意识是核心" class="headerlink" title="培养意识是核心"></a>培养意识是核心</h2><p>我并不想直接聊提效的各种手段与方法，因为这些都是停留在 <strong>术</strong> 的阶段，大概率会随着时间变化而变化。那什么是 <strong>道</strong> 呢？我相信是工程师的思想意识。</p>
<p>举四个比较关键的点：</p>
<h3 id="保持一颗追求“偷懒”的心"><a href="#保持一颗追求“偷懒”的心" class="headerlink" title="保持一颗追求“偷懒”的心"></a>保持一颗追求“偷懒”的心</h3><p>提高效率的最大原动力是为了“偷懒”，这一点很容易理解。但难的是在重复性的日常工作下，我们如何能够抵抗住“混一天是一天”的躺平心态，想方设法地缩短现有的工作时间。</p>
<h3 id="对知识的开闭原则"><a href="#对知识的开闭原则" class="headerlink" title="对知识的开闭原则"></a>对知识的开闭原则</h3><p>软件工程里有开闭原则OCP，我们对待知识也要有一定的“开闭心态”：</p>
<ul>
<li><strong>开放 - 对待知识的初始心态要开放，海纳百川。</strong>要做到这一点很难，我们要抛开原有的观念，才能对有一个客观的认知。</li>
<li><strong>封闭 - 使用知识时前反复斟酌，考虑周全。</strong>要推广、实践一个技术点，不仅仅是技术本身的问题，还要考虑人员因素、团队现状、公司发展、投入产出比等现实性的问题。</li>
</ul>
<h3 id="原理决定选择，选择重于实现"><a href="#原理决定选择，选择重于实现" class="headerlink" title="原理决定选择，选择重于实现"></a>原理决定选择，选择重于实现</h3><p>如今，开源社区已经提供了各种现成工具，日常功能的实现已经基本没有技术瓶颈，这时更考验人的是如何适应后续的<strong>可扩展性</strong>。选择<code>MySQL</code>还是<code>ES</code>，选择 <code>官方sql库</code> 还是比较重量级的<code>GORM</code>库，都是很值得考量的点。</p>
<p><strong>不同选择代表着不同的发展方向</strong>，这个与我们的职业发展一样，一旦开了头，很难改变路线。所以，在做选择之前，我们要尽可能地了解背后的原理，根据自己的应用场景进行选择。</p>
<h3 id="脚踏实地，追求技术最优解"><a href="#脚踏实地，追求技术最优解" class="headerlink" title="脚踏实地，追求技术最优解"></a>脚踏实地，追求技术最优解</h3><p>技术人在<strong>面向业务编程时，常常会做技术上的妥协</strong>。固然，我们应脚踏实地从业务出发去做技术，但如果你对业务有了自己的理解，有了更优解，哪怕需要多几天的开发周期，你也应该尝试说服周围人，这样更能体现你的<strong>技术和业务的领导力</strong>。</p>
<h2 id="提效1-编程语言"><a href="#提效1-编程语言" class="headerlink" title="提效1 - 编程语言"></a>提效1 - 编程语言</h2><p>虽然这是一篇关于<code>Go</code>语言的学习路线，但我希望大家不要把目光局限于这一门语言。</p>
<p>比如，在日常开发、部署、故障排查的过程中，<code>Shell</code>是一个高频的工具；面对大数据处理场景时，用<code>Go</code>语言开发需要造大量轮子，远不如<code>Java</code>体系高度的成熟度；<code>Python</code>在做测试脚本的开发时颇具效率，也有大量的成熟的软件平台。</p>
<p><strong>对普通开发人员来说，逆主流是个大忌！</strong></p>
<h2 id="提效2-RPC框架"><a href="#提效2-RPC框架" class="headerlink" title="提效2 - RPC框架"></a>提效2 - RPC框架</h2><p>目前在开源社区中，最主流的RPC框架是<code>Gin</code>，可以通过<a href="https://github.com/gin-gonic/gin">链接</a>进行访问。如果你是一个初学者、公司也没有一个成熟的框架，那就毫不犹豫地选择这个吧！</p>
<p>同时，以<code>gRPC</code>为核心的<code>gRPC-Gateway</code>方案，是我比较推荐的进阶方案，相对<code>Gin</code>而言学习难度会高一些，大家可以通过这个<a href="https://github.com/grpc-ecosystem/grpc-gateway">链接</a>进行访问。它的优点是支持<code>http1.x</code>和<code>http2.0</code>，跨语言的解决方案<code>protobuffer</code>，以及大量的插件化工具（尤其是自动生成接口文档）。</p>
<p>最后，如果你所在的公司已有一个成熟的RPC框架，那就毫不犹豫地使用它吧！同时，你也可以学习<code>Gin</code>和<code>gRPC-Gateway</code>中优点，尝试往公司框架中贡献一些特性，提升自己的技术影响力。</p>
<blockquote>
<p>关于第二个gRPC-Gateway方案，后续我会在<strong>Go语言技巧系列</strong>中花几章进行介绍。</p>
</blockquote>
<h2 id="提效3-工具库"><a href="#提效3-工具库" class="headerlink" title="提效3 - 工具库"></a>提效3 - 工具库</h2><p><code>Go</code>语言在开源社区有广泛的现成工具库，但没有如<code>Spring</code>全家桶那般形成标准，往往需要我们自行挑选。</p>
<p>我们固然可以从百度中搜索出一个解决方案直接使用，也可以直接搜索一个使用率最高的库，但<strong>知其所以然</strong>更加重要。我非常建议大家在使用对应的工具库前，多花点时间学习底层原理，如使用<code>GORM</code>前先掌握<code>MySQL</code>的基础。</p>
<p>工具库这部分的学习是长期的工作，也是我后续分享的碎片知识点。</p>
<h2 id="提效4-IDE"><a href="#提效4-IDE" class="headerlink" title="提效4 - IDE"></a>提效4 - IDE</h2><p>我非常建议新手朋友使用<code>IDE</code>，也就是<code>Goland</code>。</p>
<p>虽然重度依赖IDE会带来限制，但往往利大于弊，例如：</p>
<ul>
<li>在内存中缓存数据，实现快速跳转</li>
<li><code>go fmt/goimports</code>等格式化代码的工具</li>
<li>引入<code>Golint</code>进行静态代码扫描</li>
<li><code>Refactor</code>重构等特性，在大型项目中很有价值</li>
<li>快速生成单元测试、接口、实现等</li>
<li>利用<code>Live Template</code>特性，给常用代码生成模板</li>
<li>断点调试</li>
</ul>
<p>如果你一上手就直接用<code>VSCode</code>、甚至<code>Vim</code>，你可能根本不清楚有这么多工具可以帮助你提升工程质量。当你熟练掌握后，就可以将这些特性作为插件引入到<code>VSCode</code>与<code>Vim</code>中。</p>
<h2 id="提效5-辅助工具"><a href="#提效5-辅助工具" class="headerlink" title="提效5 - 辅助工具"></a>提效5 - 辅助工具</h2><p>在日常研发时，有许多辅助性的工具，在特定场景带来意想不到的帮助，需要大家结合自己的场景选择：</p>
<ul>
<li>开发环境</li>
<li><code>git</code>命令与工作流</li>
<li><code>markdown</code>文档写作</li>
<li>个人任务管理</li>
<li><code>chrome/wireshark/postman</code>等网络相关工具</li>
<li><code>shell</code>排查性能问题</li>
</ul>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>提效是一个长期的工作，需要我们长期摸索前进。</p>
<p><strong>提效篇</strong>只是一个开始，更多的相关内容，我会放到 <a href="https://junedayday.github.io/tags/Go-Tip/">Go语言技巧系列</a> 里，欢迎大家持续关注。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Study</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言学习路线 - 7.进阶篇:一名软件工程师的价值沉淀</title>
    <url>/2021/07/25/go-study/go-study-7/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p>
<h2 id="阶段性的思考"><a href="#阶段性的思考" class="headerlink" title="阶段性的思考"></a>阶段性的思考</h2><p>通过前面几讲的分享，相信大家已经能清楚地看到一名普通软件工程师的发展路线：<strong>不断学习技能，提高研发效能，实现业务功能</strong>。</p>
<p>如果我们尝试回头看，可能会对自己的定位存在疑问：这些日常CRUD的开发工作，很多不具备太高的技术难度，可以靠人力堆积来实现。那么，如何在研发团队里打造自己的<strong>技术壁垒</strong>、体现个人价值呢？</p>
<p>下面，我将分多个层面和大家聊聊，大家可以根据自己的发展目标和工作环境，选择性地发展几项。今天的内容会抛开编程语言之争，从更高的维度来看问题。</p>
<span id="more"></span>

<h2 id="1-专项业务领域"><a href="#1-专项业务领域" class="headerlink" title="1. 专项业务领域"></a>1. 专项业务领域</h2><p><strong>业务往往与公司的赢利点挂钩</strong>，决定了公司的生死存亡，所以业务驱动了公司里的很多事情，包括晋升、组织架构等。</p>
<p>大多数的开发者往往长期投入在公司的业务相关开发，或是满足产品的迭代，或是满足甲方的需求。从结果来看，业务开发是最容易看到成果的，可以与具体的增长和营收挂钩。那么，业务领域的开发者需要关注什么呢？我也列举三点</p>
<ul>
<li>产品设计 - 具备<strong>产品的规划与设计</strong>能力，将业务开发的经验沉淀为对产品的理解</li>
<li>业务架构 - 能将<strong>软件架构适配业务</strong>，也能根据公司的基础能力灵活调整</li>
<li>权衡能力 - <strong>权衡技术与业务的冲突</strong>，能保证业务快速实现的同时，尽可能地减少技术债</li>
</ul>
<h2 id="2-专项技术领域"><a href="#2-专项技术领域" class="headerlink" title="2. 专项技术领域"></a>2. 专项技术领域</h2><p>技术人常常期望能<strong>抛开烦杂的业务需求，长期在一个技术领域深耕</strong>，例如专职研究存储系统、网络架构、云原生架构、大数据引擎等。这里，我希望有此类想法的同学先想清楚一个问题：你究竟是厌倦了做需求迭代，还是真正喜欢某项技术？</p>
<p>深耕专项的技术领域，遇到的挑战很多，我列举三个比较重要的：</p>
<ul>
<li>评价产出 - 思考如何将<strong>技术变现</strong>，在公司中体现自己的<strong>能力价值</strong></li>
<li>承载业务 - <strong>对接并服务</strong>各个业务团队，根据具体场景做优化、适配等工作</li>
<li>探索前景 - <strong>紧跟并探索</strong>技术发展前景，方向准确，并长期坚持</li>
</ul>
<h2 id="3-团队领导力"><a href="#3-团队领导力" class="headerlink" title="3. 团队领导力"></a>3. 团队领导力</h2><p>合作与分工是所有团队都面临的问题。随着一名工程师的经验与资历的提升，都会直接或间接地带领团队去实现目标。</p>
<p>那怎么考验一个人的<strong>团队领导力</strong>呢？一般会更关注以下三点：</p>
<ul>
<li>能力提升 - 保证资深员工能有效地将<strong>经验与技能</strong>传递给新人，自身也有足够的发展空间</li>
<li>合理用人 - <strong>如何管理性格、能力各异的成员，尽可能实现产出最大化</strong></li>
<li>落地文化 - 一个团队如果要长久发展，必须得形成<strong>文化价值观</strong>，并聚拢一批认同这个价值观的成员</li>
</ul>
<h2 id="4-研发效能管理"><a href="#4-研发效能管理" class="headerlink" title="4. 研发效能管理"></a>4. 研发效能管理</h2><p>如今，<strong>软件工程日益精细化</strong>，公司越来越重视研发效能的管理，而非当初那种野蛮地堆人力、抢占市场。</p>
<p>研发效能的管理分为多个方向，例如：</p>
<ul>
<li>项目/需求/故障管理 - 用平台跟进项目进度、投入人力</li>
<li>CICD/devops - 各类自动化的工具平台，促进研发与运维一体化，让研发对整个生命周期负责</li>
<li>基础框架/库 - 加速研发对接日志、监控、部署等平台</li>
<li>流程平台化 - 将公司内的各种日常流程落地为平台</li>
</ul>
<h2 id="5-安全"><a href="#5-安全" class="headerlink" title="5. 安全"></a>5. 安全</h2><p>安全是一个很有意思的话题，大部分人的认知是：<strong>在没有问题时，安全一文不值；在出现问题后，安全又是至关重要的</strong>。</p>
<p>安全领域门槛很高，会有专属于自己的一个小圈子。绝大多数的开发者并不需要过多掌握安全相关的技能，只需了解一些常规的安全技能，在日常研发中有意识地加以重视：</p>
<ul>
<li>网络安全 - 常见的<code>HTTPS</code>、证书、<code>Sync Flooding</code>等</li>
<li>数据安全 - 加解密、备份</li>
<li>编程相关 - SQL注入、核心参数校验、审计功能</li>
</ul>
<h2 id="6-稳定性"><a href="#6-稳定性" class="headerlink" title="6. 稳定性"></a>6. 稳定性</h2><p>在项目投入生产使用后，<strong>稳定性</strong>逐渐成为一项重要指标，它与公司的营收直接相关。</p>
<p>在某个程度上，稳定性与安全非常类似，<strong>不出问题时，大家都不care稳定性，都想着快速迭代；出现问题后，又想法设法维持稳定</strong>。那如何体现一个人在稳定性上的能力呢？</p>
<ul>
<li>代码研发 - 从实际代码出发，保证核心功能的<strong>健壮性和可扩展性</strong></li>
<li>软件架构 - 软件架构稳定，既能保证<strong>功能迭代</strong>，也能随着规模扩大保证<strong>性能稳定</strong></li>
<li>工作流程 - 从功能迭代、需求上线、故障处理等流程出发，控制风险</li>
</ul>
<h2 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h2><p>以上六点，是作为开发者的价值点沉淀。我比较赞同一个观点：<strong>对公司的价值输出，决定了你的绩效；而对自己能力的沉淀，决定了你的市场价值</strong>。所以，绝大多数的人更应该把关注点放在自身的能力沉淀。</p>
<p>不过，我这边也针对一个极端的观点做一下修正：<strong>不要花太多心思在公司工作上，而是多提升自身能力。</strong></p>
<p>公司评定一个人包括两块：工作产出与自身能力。光有能力而没有足够产出，是可以让我们在当前岗位上表现达到中上，却很难让自己获得晋升、进而到一个更高的位置去锻炼自己。</p>
<p>个人能力毕竟有限，必须借助公司的力量，才能产出更大的价值；反之，如果你的产出全部依赖公司平台，也就是说脱离了平台你的价值大打折扣，那也是一个非常严重的问题。</p>
<p>我比较建议，在 <strong>保证自己能在当前岗位成为TOP10%的前提下，多多提升自己</strong>。</p>
<p>如果在工作中投入了100%的时间与精力，却依旧达不到TOP10%的业绩产出，这也是很多人遇到的问题。此时，我建议<strong>减少纯工作上的投入，多花时间提升个人能力</strong>。哪怕会在短期内会导致绩效的不如意，但能换来长期良好的职业发展。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本篇和大家聊了很多关于个人长期发展的话题，也探讨了个人与公司上的冲突问题。</p>
<p>如果用一句话总结，我会选择：<strong>软件工程师的价值沉淀是一个长期过程，核心是锻炼自身能力，也要借助公司的平台来帮助自己更快地成长</strong>。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Study</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言学习路线 - 8.高级篇:从五个问题来畅想Go工程师的未来发展</title>
    <url>/2021/07/26/go-study/go-study-8/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p>
<h2 id="编程语言对软件工程师的意义"><a href="#编程语言对软件工程师的意义" class="headerlink" title="编程语言对软件工程师的意义"></a>编程语言对软件工程师的意义</h2><p>有人常说，编程语言对软件工程师来说并不重要，更重要的是<strong>软件工程思想</strong>、<strong>架构设计能力</strong>等更高层面的内容。</p>
<p>这个观点本身没有问题，但它更多的是针对有相当工作经验的程序员。对于绝大多数的人，<strong>编程语言依然是最重要、最核心的技能，也是通往更高层面的敲门砖</strong>。所以，<strong>精通一门编程语言，不仅仅要熟悉其语法与原理，更要了解其周边的生态，包括框架、开源库、中间件等，以及掌握它适用的业务场景</strong>。</p>
<p>所以，作为一名将Go语言作为主要开发语言的工程师，如果你能合理地利用好这个敲门砖，你的职业发展必将更加通畅。下面，我会从几个常见问题谈起，分享我的经验与见解，希望能给各位带来启发。</p>
<span id="more"></span>

<h2 id="问题1：需要关注编程语言之争吗？"><a href="#问题1：需要关注编程语言之争吗？" class="headerlink" title="问题1：需要关注编程语言之争吗？"></a>问题1：需要关注编程语言之争吗？</h2><p>需要，而且非常有意义。但是，我们的精力毕竟有限，更应该关注哪些内容呢？我推荐三点：</p>
<ol>
<li><strong>编程语言常见特性的设计理念，能解决什么样的问题</strong>，如<code>try-catch</code></li>
<li><strong>编程范式所包含的思想</strong>，如<code>面向对象编程</code>、<code>函数式编程</code>、<code>依赖注入</code></li>
<li><strong>特定领域中语言的现状</strong>，如<code>Julia</code>在大数据体系中对<code>Java</code>的冲击</li>
</ol>
<p>上面这些例子是一些很发散的内容，但能证明你的<strong>视野足够广阔</strong>。不过，在关注编程语言之争的同时，我们仍应把主要精力聚焦于一门语言的深入学习，这才是我们的核心竞争力。</p>
<h2 id="问题2：Go语言工程师有什么其余语言无法替代的呢？"><a href="#问题2：Go语言工程师有什么其余语言无法替代的呢？" class="headerlink" title="问题2：Go语言工程师有什么其余语言无法替代的呢？"></a>问题2：Go语言工程师有什么其余语言无法替代的呢？</h2><p>说到一门语言的<strong>不可替代性</strong>，核心关注两点：</p>
<ol>
<li>现状：即<strong>一门语言在特定的领域中已沉淀的积累</strong>，包括开源软件、SDK库、文档、社区、用户等</li>
<li>未来：<strong>各公司或组织对这门语言的投入</strong>，如建立基金会、形成规范、招聘人才趋势等</li>
</ol>
<p>上面这两点，也间接地回答了一个很常见的问题：<code>Go</code>能替代<code>Java</code>成为主流业务开发语言吗？我个人短期内并不看好。</p>
<p>回到问题，那么Go最擅长的领域是什么呢？答案也是大家耳熟能详的<strong>云原生技术</strong>。</p>
<ol>
<li>现状：云原生的核心技术<code>Kubernetes</code>与大量相关套件都是用Go语言开发的，短期内无法被替换</li>
<li>未来：云原生在<code>CNCF</code>的推动下，已经在各类云厂商中形成事实标准</li>
</ol>
<h2 id="问题3：Go语法简洁，做业务开发很方便，可以用吗？"><a href="#问题3：Go语法简洁，做业务开发很方便，可以用吗？" class="headerlink" title="问题3：Go语法简洁，做业务开发很方便，可以用吗？"></a>问题3：Go语法简洁，做业务开发很方便，可以用吗？</h2><p>当然可以使用！Go语法简洁的特性能让代码更容易阅读，但我们要清楚地认识到其弊端，才能长期地坚持走这条路：</p>
<ol>
<li>由于不存在类似<code>Spring</code>的编程框架做强限制，不同人的代码风格差异还是很大，最好前期有个资深专家 <strong>做好前期框架规划</strong>，才能更好地体现Go的优势</li>
<li><strong>对接部分技术体系的开源库缺失或不够成熟</strong>，尤其是对接<code>Hive</code>、<code>Flink</code>等大数据体系时，<code>Java</code>仍是第一选择</li>
<li>Go的标准库中往往<strong>为了通用性而牺牲了定制化</strong>，例如排序函数采用的是一个工业级混合多种排序的方法，而无法灵活地按需选择冒泡、快排等，这就需要一定的二次开发</li>
</ol>
<p>也许你看完这三个问题，会觉得自己学Go语言的热情被劝退了，但其实换个角度来看问题，其实答案也很有意思：</p>
<ol>
<li>Go语言官方只做最基础的底层，而上层的业务框架由各家在实践中探索，发展空间很大</li>
<li>Google推出Go之后又推出的gRPC、云原生理念，就是希望编程语言百家齐鸣，各自有各自擅长的领域</li>
<li>一方面，通用性能降低编程语言学习的复杂度；另一方面，我们也是希望把一部分的复杂度从编程语言转移到各类中间件中，可以减少很多重复建设</li>
</ol>
<h2 id="问题4：从目前来看，Go业务开发工程师的前途不行吗？"><a href="#问题4：从目前来看，Go业务开发工程师的前途不行吗？" class="headerlink" title="问题4：从目前来看，Go业务开发工程师的前途不行吗？"></a>问题4：从目前来看，Go业务开发工程师的前途不行吗？</h2><p>综合上面讨论的问题来看，现有阶段用Go语言做业务开发并不是最快的。</p>
<p>但是，从目前<strong>云原生</strong>理念被越来越多的人接受，我相信Go语言做业务开发也是一个很棒的选择。这里，我强调一个点：<strong>借势</strong>。怎么理解这个词呢？</p>
<ol>
<li><strong>承认短板</strong>：既然需要”借”，那就先得承认自己有不足。如果幻想毕其功于一役，那这条路很容易走到尽头。</li>
<li><strong>善假于物</strong>：对于Go语言来说，借势的关键对象是两个：<strong>云原生</strong> 与 <strong>其余编程语言的生态</strong><ol>
<li>云原生：有大量优秀的基础组件与中间件，尽可能地复用这部分的能力（基本上覆盖了所有的基础设施）</li>
<li>其余编程语言：根据业务需要自行使用，建议在非熟悉的领域尽可能地做到简单，把复杂的业务逻辑放到最熟悉的编程语言中</li>
</ol>
</li>
</ol>
<p>上面聊的比较抽象，我再举两个具体的例子：</p>
<ol>
<li>对某个服务做网络的限流，更推荐放在<code>Istio</code>上，而不需要在应用程序中加上一堆计算流量的代码</li>
<li>某个Go服务想对接<code>Flink</code>计算业务数据，那就用利用JAVA的SDK开发一个对接的小服务，通过HTTP或MQ对外输出结果，而复杂的业务逻辑放在Go服务中</li>
</ol>
<h2 id="问题5：Go开发工程师的长期发展目标怎么定，才更有竞争力？"><a href="#问题5：Go开发工程师的长期发展目标怎么定，才更有竞争力？" class="headerlink" title="问题5：Go开发工程师的长期发展目标怎么定，才更有竞争力？"></a>问题5：Go开发工程师的长期发展目标怎么定，才更有竞争力？</h2><p>从能力层面来说，我认为Go语言工程师的核心技能点分为四层：</p>
<ol>
<li>基础层：计算机基础、网络、操作系统、算法</li>
<li>语言层：<strong>Go语言原理与实践</strong>，其它语言的优秀特性</li>
<li>应用层：中间件、软件工程、架构设计</li>
<li>业务层：业务逻辑、<strong>云原生生态与解决方案</strong></li>
</ol>
<blockquote>
<p>加粗的为Go语言特别关注</p>
</blockquote>
<p>这四层的内容极多，我建议围绕着两个重点进行学习：</p>
<ol>
<li><strong>系统性的学习Go语言原理与实践</strong>，向下即阅读源码，掌握操作系统、网络等基础原理；向上则结合项目，对接各类中间件，学习软件架构设计</li>
<li><strong>利用碎片时间了解云原生</strong>，云原生是一个日新月异的研发生态，对于非资深的开发者没必要前期就投入大量精力、导致基础不扎实，关注发展趋势、了解大致原理即可（技术的底层往往互通）</li>
</ol>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>整个Go语言学习路线到此已经更新完毕，很高兴有朋友陪我走到最后。后续我也会持续更新这个系列的文章，保证内容的实时性。</p>
<p>学习技术是一个长期的过程，敝帚自珍很容易中途失去信心而放弃，大家一起鼓励、探讨，就能走得更远。</p>
<p>欢迎大家私聊我探讨问题，也可以通过公众号加入到Go学习小组中交流更多日常问题。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Study</tag>
      </tags>
  </entry>
  <entry>
    <title>Go算法实战 - 1.【两数相加LeetCode-2】递归解法</title>
    <url>/2021/07/10/go-leetcode/go-leetcode-1/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="Leetcode-2-两数相加"><a href="#Leetcode-2-两数相加" class="headerlink" title="Leetcode-2 两数相加"></a>Leetcode-2 两数相加</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="keyword">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了能保证代码都能执行，我会贴出所有代码，<strong>重点会用注释着重说明</strong>。</p>
<span id="more"></span>

<h2 id="递归实现的思路"><a href="#递归实现的思路" class="headerlink" title="递归实现的思路"></a>递归实现的思路</h2><h3 id="简化问题"><a href="#简化问题" class="headerlink" title="简化问题"></a>简化问题</h3><p>这道题的难点在于处理<strong>进位</strong>。那我们就先<strong>简化问题、把框架搭起来</strong>，看看先不考虑进位的大致代码怎么写的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// 先判断边界情况</span></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val</span><br><span class="line">        node.Next = addTwoNumbers(l1.Next, l2.Next)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val </span><br><span class="line">        node.Next = addTwoNumbers(l1.Next, l2)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val </span><br><span class="line">        node.Next = addTwoNumbers(l1, l2.Next)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这块代码有个问题- 当<code>l1</code>和<code>l2</code>都为空时，还会进入一次<code>addTwoNumbers</code>，导致最高位必定是0。</p>
<p>所以，我们需要保证<strong>最高位不要产生一个冗余，也就是l1和l2都为nil时，不要再进入addTwoNumbers函数</strong>。</p>
<h3 id="修复最高位的问题"><a href="#修复最高位的问题" class="headerlink" title="修复最高位的问题"></a>修复最高位的问题</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="comment">// 这里l1和l2作为指针传递下去</span></span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val </span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果都为空，无需继续处理</span></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续处理下一个节点</span></span><br><span class="line">    node.Next = addTwoNumbers(l1, l2)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="递归函数增加进位参数carry"><a href="#递归函数增加进位参数carry" class="headerlink" title="递归函数增加进位参数carry"></a>递归函数增加进位参数carry</h3><p>进位carry是一个在不同位中传递的参数，所以必须要加到函数签名中，所以我们得对递归函数进行改造。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的函数参数 carry</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val + carry</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + carry</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val + carry</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newCarry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> node.Val &gt; <span class="number">9</span> &#123;</span><br><span class="line">        node.Val = node.Val - <span class="number">10</span></span><br><span class="line">        newCarry = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; newCarry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, newCarry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="边界条件修复"><a href="#边界条件修复" class="headerlink" title="边界条件修复"></a>边界条件修复</h3><p>到了这里，我们看似完成了功能，但还有个边界条件没有修复：引入进位后，当<code>l1/l2</code>为nil，carry为1时，我们很容易就修复了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val + carry</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + carry</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val + carry</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        node.Val = carry <span class="comment">// 修复进位的边界问题</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newCarry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> node.Val &gt; <span class="number">9</span> &#123;</span><br><span class="line">        node.Val = node.Val - <span class="number">10</span></span><br><span class="line">        newCarry = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; newCarry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, newCarry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="持续优化"><a href="#持续优化" class="headerlink" title="持续优化"></a>持续优化</h2><p>首先，先明确一下优化的原则：</p>
<p><strong>我并不是单纯地为了提升性能而去优化，而是更应该从全局入手，考虑代码的可读性和扩展性！</strong></p>
<p>所以，下面的优化并不一定是性能最优的，但或多或少可能让你感受到代码的迭代升级。</p>
<h3 id="A-复用变量"><a href="#A-复用变量" class="headerlink" title="A - 复用变量"></a>A - 复用变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val + carry</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + carry</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val + carry</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.Val = carry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node.Val &gt; <span class="number">9</span> &#123;</span><br><span class="line">        node.Val = node.Val - <span class="number">10</span></span><br><span class="line">        carry = <span class="number">1</span> <span class="comment">// 复用carry变量</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; carry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, carry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除<code>newCarry</code>变量，节省了内存。</p>
<p>虽然这点改进很小，但我想表达的重点是：<strong>大家不要小看变量的复用，尤其是在一些递归调用的场景下，能节省大量的空间。</strong>上面的<code>l1</code>与<code>l2</code>这两个指针也进行了变量的复用。</p>
<h3 id="B-增加位操作，去除if-else分支"><a href="#B-增加位操作，去除if-else分支" class="headerlink" title="B - 增加位操作，去除if-else分支"></a>B - 增加位操作，去除if-else分支</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val + carry</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + carry</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val + carry</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.Val = carry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> <span class="comment">// 引入位操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; carry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, carry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="C-增加代码的扩展性（推荐）"><a href="#C-增加代码的扩展性（推荐）" class="headerlink" title="C - 增加代码的扩展性（推荐）"></a>C - 增加代码的扩展性（推荐）</h3><p>在这个代码里，我们只支持2个<code>ListNode</code>的相加，就引入了4个<code>if-else</code>的分支，这就很难支持大量<code>ListNode</code>的扩展。</p>
<p><strong>总体来说，我个人推荐这个解法，它的思路很清晰，也不会出现边界问题。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val += l1.Val</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val += l2.Val</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Val += carry</span><br><span class="line">    carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> <span class="comment">// 引入位操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; carry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, carry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实战化特性"><a href="#实战化特性" class="headerlink" title="实战化特性"></a>实战化特性</h2><p>在实际的项目中，我们会希望这个函数的扩展性能更好，例如支持多个输入参数。</p>
<h3 id="引入不定参数的特性"><a href="#引入不定参数的特性" class="headerlink" title="引入不定参数的特性"></a>引入不定参数的特性</h3><p>我们进一步改造成<strong>不定参数</strong>形式的函数签名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(<span class="number">0</span>, l1, l2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不定参数必须是最后一个函数签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(carry <span class="keyword">int</span>, nodes ...*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">        <span class="keyword">if</span> nodes[k] != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += nodes[k].Val</span><br><span class="line">            nodes[k] = nodes[k].Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Val += carry</span><br><span class="line">    carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> <span class="comment">// 引入位操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断所有node是否为空</span></span><br><span class="line">    <span class="keyword">var</span> isEnd = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">        <span class="keyword">if</span> nodes[k] != <span class="literal">nil</span> &#123;</span><br><span class="line">            isEnd = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> isEnd &amp;&amp; carry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(carry, nodes...)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Go算法实战 - 2.【两数相加LeetCode-2】非递归解法</title>
    <url>/2021/07/10/go-leetcode/go-leetcode-2/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="Leetcode-2-两数相加"><a href="#Leetcode-2-两数相加" class="headerlink" title="Leetcode-2 两数相加"></a>Leetcode-2 两数相加</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></p>
<p>我们继续看上一个题目，这次我们尝试写一个非递归的解法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="keyword">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了能保证代码都能执行，我会贴出所有代码，<strong>重点会用注释着重说明</strong>。</p>
<blockquote>
<p>我个人认为，非递归比递归写法更加麻烦，所以放到了第二讲。一开始直接上手用非递归的解法，很容易迷失在 边界条件 和 循环条件 中，排查问题也比较麻烦。</p>
</blockquote>
<span id="more"></span>

<h2 id="非递归实现的思路"><a href="#非递归实现的思路" class="headerlink" title="非递归实现的思路"></a>非递归实现的思路</h2><h3 id="简化问题"><a href="#简化问题" class="headerlink" title="简化问题"></a>简化问题</h3><p>我们不考虑进位问题，看看大致的代码架构：</p>
<h3 id="不考虑进位的解法"><a href="#不考虑进位的解法" class="headerlink" title="不考虑进位的解法"></a>不考虑进位的解法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// 哨兵节点，也就是作为初始化的节点</span></span><br><span class="line">    <span class="comment">// 在单向链表时引入这个哨兵，有利于我们找到起始的点</span></span><br><span class="line">    <span class="keyword">var</span> sentinel = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="comment">// walker节点，也就是用于遍历的节点</span></span><br><span class="line">    <span class="keyword">var</span> walker = sentinel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l1.Val</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l2.Val</span><br><span class="line">            l2l1 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把node追加到后面，walker继续往后走</span></span><br><span class="line">        walker.Next = node</span><br><span class="line">        walker = walker.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentinel.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="增加进位参数carry"><a href="#增加进位参数carry" class="headerlink" title="增加进位参数carry"></a>增加进位参数carry</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sentinel = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> walker = sentinel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l1.Val</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        node.Val += carry</span><br><span class="line">        carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> <span class="comment">// 利用位操作</span></span><br><span class="line"></span><br><span class="line">        walker.Next = node</span><br><span class="line">        walker = walker.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentinel.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般情况下，<strong>非递归的实现会比递归的性能更高，但可读性较差</strong>。</p>
<ol>
<li>非递归减少了函数的堆栈，所以性能更高；</li>
<li>递归通过递归函数简化了复杂度，而非递归则需要循环；</li>
</ol>
<h2 id="持续优化"><a href="#持续优化" class="headerlink" title="持续优化"></a>持续优化</h2><h3 id="A-简单优化代码结构（推荐）"><a href="#A-简单优化代码结构（推荐）" class="headerlink" title="A - 简单优化代码结构（推荐）"></a>A - 简单优化代码结构（推荐）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sentinel = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> walker = sentinel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">        node.Val = carry <span class="comment">// 将carry直接放到初始化位置</span></span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l1.Val</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将两个指针赋值放在一起，含义比较清晰</span></span><br><span class="line">        <span class="comment">// 建议此类表达式尽量用于 多个强相关的变量 赋值，而不要贪图方便</span></span><br><span class="line">        walker.Next, walker = node, node </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentinel.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>内存消耗：4.7 MB, 在所有 Go 提交中击败了29.47%的用户</li>
</ul>
<h3 id="B-进一步节省空间"><a href="#B-进一步节省空间" class="headerlink" title="B - 进一步节省空间"></a>B - 进一步节省空间</h3><p>至此，其实我们的代码已经相当简洁了，但有同学追求更好的数据。</p>
<p>这里，我们可以看一下，因为<code>l1</code>和<code>l2</code>这两个链表相加后，新的链表长度肯定是大于这两者的。所以，我们可以尝试复用一下其中一个链表，节省一下内存空间。这里，我们尝试复用一下链表<code>l1</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> walker = l1</span><br><span class="line"></span><br><span class="line">    <span class="comment">// walker用于遍历l1，而l1指针自身不动，用于返回</span></span><br><span class="line">    <span class="keyword">for</span> walker != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Val += l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        walker.Val += carry </span><br><span class="line"></span><br><span class="line">        carry, walker.Val = walker.Val/<span class="number">10</span>, walker.Val%<span class="number">10</span> </span><br><span class="line">        walker = walker.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的整体逻辑是正确的，但存在边界问题：如果<code>l1</code>比<code>l2</code>短时，后续的元素怎么生成？</p>
<p>于是，我们就有了改进：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> walker = l1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> walker != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Val += l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        walker.Val += carry </span><br><span class="line"></span><br><span class="line">        carry, walker.Val = walker.Val/<span class="number">10</span>, walker.Val%<span class="number">10</span> </span><br><span class="line">        <span class="comment">// 当walker下个节点为nil时，但后续节点还需要继续遍历，就新建一个Node</span></span><br><span class="line">        <span class="keyword">if</span> walker.Next == <span class="literal">nil</span> &amp;&amp; (l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            walker.Next = <span class="built_in">new</span>(ListNode)</span><br><span class="line">        &#125;</span><br><span class="line">        walker = walker.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>内存消耗：4.4 MB, 在所有 Go 提交中击败了96.97%的用户</li>
</ul>
<h3 id="C-再次节省空间"><a href="#C-再次节省空间" class="headerlink" title="C - 再次节省空间"></a>C - 再次节省空间</h3><p>从上一个例子不难想到，我们还有继续优化的空间：如果<code>l2</code>比<code>l1</code>长时，我们想办法把walker节点指向<code>l2</code>，于是就有了下面的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 由于两个链表均为非空，所以初始化会简单一点</span></span><br><span class="line">    <span class="keyword">var</span> sentinel = l1</span><br><span class="line">    <span class="keyword">var</span> walker = l1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// walker与l1为统一节点时，Val已经有值了</span></span><br><span class="line">            <span class="keyword">if</span> walker != l1 &#123;</span><br><span class="line">                walker.Val += l1.Val</span><br><span class="line">            &#125;</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> walker != l2 &#123;</span><br><span class="line">                walker.Val += l2.Val</span><br><span class="line">            &#125;</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        walker.Val += carry </span><br><span class="line"></span><br><span class="line">        carry, walker.Val = walker.Val/<span class="number">10</span>, walker.Val%<span class="number">10</span> </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里就是去找下一个walker节点，先看l1，再看l2，最后看carry位有没有</span></span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Next = l1</span><br><span class="line">            walker = walker.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Next = l2</span><br><span class="line">            walker = walker.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> carry &gt; <span class="number">0</span> &#123;</span><br><span class="line">            walker.Next = <span class="built_in">new</span>(ListNode)</span><br><span class="line">            walker = walker.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentinel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再次做一个简单的优化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> sentinel, walker = l1, l1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> walker != l1 &#123;</span><br><span class="line">                walker.Val += l1.Val</span><br><span class="line">            &#125;</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> walker != l2 &#123;</span><br><span class="line">                walker.Val += l2.Val</span><br><span class="line">            &#125;</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        walker.Val += carry </span><br><span class="line">        carry, walker.Val = walker.Val/<span class="number">10</span>, walker.Val%<span class="number">10</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Next = l1</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Next = l2</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> carry &gt; <span class="number">0</span> &#123;</span><br><span class="line">            walker.Next = <span class="built_in">new</span>(ListNode)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从循环中跳出，也就是l1/l2为nil,carry=0</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将上面三个判断分支中的共性提取出</span></span><br><span class="line">        walker = walker.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentinel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在解单向链表的问题时，<code>Sentinel哨兵</code> + <code>Walker遍历</code>是一个很好的组合。</p>
<ul>
<li><code>Sentinel</code>放在单向链表的起始，指向我们的链表，能解决很多初始情况问题，例如链表本身为<code>nil</code></li>
<li><code>Walker</code>是一个遍历指针，聚焦于<code>walker = walker.Next</code>这个关键的移动操作</li>
</ul>
<p>总体来说，非递归的代码可读性会比递归的差一点，比较考验程序员的解题思路。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Go算法实战 - 3.【无重复字符的最长子串LeetCode-3】</title>
    <url>/2021/07/14/go-leetcode/go-leetcode-3/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="Leetcode-3-无重复字符的最长子串"><a href="#Leetcode-3-无重复字符的最长子串" class="headerlink" title="Leetcode-3 无重复字符的最长子串"></a>Leetcode-3 无重复字符的最长子串</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="递归解题思路"><a href="#递归解题思路" class="headerlink" title="递归解题思路"></a>递归解题思路</h2><p>从函数签名<code>func lengthOfLongestSubstring(s string) int </code>来看，我们可以将问题拆分成子问题</p>
<ol>
<li>首字符<ol>
<li>包含s[0]的最长无重复子串</li>
<li>lengthOfLongestSubstring(s[1:n])</li>
</ol>
</li>
<li>尾字符<ol>
<li>lengthOfLongestSubstring(s[0:n-1])</li>
<li>包含s[n]的最长无重复子串</li>
</ol>
</li>
</ol>
<h3 id="利用首字符的递归问题"><a href="#利用首字符的递归问题" class="headerlink" title="利用首字符的递归问题"></a>利用首字符的递归问题</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// guard clauses，也就是卫语句，在递归中非常重要</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局的字符串，用于保存</span></span><br><span class="line">    <span class="keyword">var</span> mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := mp[s[i]]; ok &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// 找到重复的，直接退出</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mp[s[i]] = i <span class="comment">// 没找到重复的，加上这个子串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    length := lengthOfLongestSubstring(s[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">if</span> i &gt; length &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归的解法可读性较佳，但实际的时间复杂度会比较高，因为它的每一次 <strong>递归操作都要维护一个新的数据栈</strong>。</p>
<h2 id="非递归实现思路"><a href="#非递归实现思路" class="headerlink" title="非递归实现思路"></a>非递归实现思路</h2><h3 id="先用“笨办法”实现"><a href="#先用“笨办法”实现" class="headerlink" title="先用“笨办法”实现"></a>先用“笨办法”实现</h3><p>我们先不追求<strong>复杂度</strong>，先写一个简单的解法，搭建出解题框架：</p>
<p>从左往右看字符串s，如果我们限制了起始字符，然后逐个往右查找、找到第一个重复字符串，就是最长子串。</p>
<p>所以，如果s为<code>b1b2b3...bn</code>，它就能被拆解为 <strong>起始字符为<code>b1</code>，<code>b2</code>,<code>b3</code> …. <code>bn</code>这样n个子问题中的最大值</strong>。</p>
<p>于是，我们尝试写一下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 遍历s，以i作为起始点，找到最长的子串</span></span><br><span class="line">    <span class="comment">// 注意：在string中如果用range的方法遍历，类型不是byte，而是rune</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">        mp[s[i]] = i</span><br><span class="line">        <span class="comment">// j 作为一个从i往后移动的游标，找到第一个重复的词或者达到len(s)，也就是末尾</span></span><br><span class="line">        <span class="keyword">var</span> j <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(s); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> _, ok := mp[s[j]]; ok &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="comment">// 找到重复的，直接退出</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mp[s[j]] = j <span class="comment">// 没找到重复的，加上这个子串</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 算出以i为起点的最长子串</span></span><br><span class="line">        length := j - i</span><br><span class="line">        <span class="keyword">if</span> length &gt; max &#123;</span><br><span class="line">            max = length</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面存在一些边界条件的判定，需要大家认证思考。</p>
<h3 id="从核心map切入"><a href="#从核心map切入" class="headerlink" title="从核心map切入"></a>从核心map切入</h3><p>在上面的解法中，我们用到了一个<code>map[byte]int</code>，用来保存 <strong>字符与位置的映射关系</strong>。但在整个循环的过程中，我们反复地<code>var mp = make(map[byte]int)</code>创建了空间。</p>
<p>由于s是一个固定的字符串，我们可以换一个思路尝试，先写出一个纯过程式的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 全局的字符串，用于保存</span></span><br><span class="line">    <span class="keyword">var</span> mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="comment">// Case1: 这是一个暂时未出现过的字符</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := mp[s[i]]; !ok &#123;</span><br><span class="line">            length := i - left + <span class="number">1</span> <span class="comment">// 到最左边的距离</span></span><br><span class="line">            <span class="keyword">if</span> length &gt; max &#123;</span><br><span class="line">                max = length</span><br><span class="line">            &#125;</span><br><span class="line">            mp[s[i]] = i <span class="comment">// 不存在的新元素，直接添加进来</span></span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// 打断逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Case2: 这是一个出现过的重复字符</span></span><br><span class="line">        length := i - left + <span class="number">1</span> <span class="comment">// 到最左边的距离</span></span><br><span class="line">        length2 := i - mp[s[i]] <span class="comment">// 到上一个重复字符串的距离</span></span><br><span class="line">        <span class="keyword">if</span> length &gt; length2 &#123;</span><br><span class="line">            length = length2 <span class="comment">// 取较短值</span></span><br><span class="line">            left = mp[s[i]] + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> length &gt; max &#123;</span><br><span class="line">            max = length</span><br><span class="line">        &#125;</span><br><span class="line">        mp[s[i]] = i <span class="comment">// 更新索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理一下最后一个字符串</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) - left &gt; max &#123;</span><br><span class="line">        max = <span class="built_in">len</span>(s) - left </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码的关键实现在于<strong>两个索引index</strong>：</p>
<ol>
<li><code>i</code>，用于遍历s</li>
<li><code>left</code>，0 &lt;= left &lt;= i，s[left:i]是<strong>不存在重复字符的字符串</strong>，其中left尽量取最小。换一个说法，s[left:i]是<strong>以s[i]为右节点的、无重复的、最长的子字符串</strong>。</li>
</ol>
<p>我们再回头看一下上面的代码，可读性有不少改进空间，我们尝试做一下优化，让可读性更好：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        length := i - left + <span class="number">1</span> <span class="comment">// 到最左边的距离</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := mp[s[i]]; ok &#123;</span><br><span class="line">            length2 := i - mp[s[i]] <span class="comment">// 到上一个重复字符串的距离</span></span><br><span class="line">            <span class="keyword">if</span> length &gt; length2 &#123;</span><br><span class="line">                length = length2</span><br><span class="line">                left = mp[s[i]] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> length &gt; max &#123;</span><br><span class="line">            max = length</span><br><span class="line">        &#125;</span><br><span class="line">        mp[s[i]] = i </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) - left &gt; max &#123;</span><br><span class="line">        max = <span class="built_in">len</span>(s) - left </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改动点并不大，但抽离了不少共性的代码，整体的性能有所提升。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面对<strong>明显可用递归方案解决</strong>的题目时，个人比较推荐的解题思路是：</p>
<ul>
<li><strong>用递归的解决方案理清思路，写出一个可用的方案，此时不要关注性能</strong></li>
<li><strong>从复杂度的角度思考，哪部分的工作是重复性的，提取出一个非递归的方案</strong></li>
</ul>
<p>如果一开始就去抠所谓的最佳方案，很容易陷入细节问题，而丢失了全局视野。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Go算法实战 - 4.【寻找两个正序数组的中位数LeetCode-4】</title>
    <url>/2021/07/19/go-leetcode/go-leetcode-4/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="Leetcode-4-寻找两个正序数组的中位数"><a href="#Leetcode-4-寻找两个正序数组的中位数" class="headerlink" title="Leetcode-4 寻找两个正序数组的中位数"></a>Leetcode-4 寻找两个正序数组的中位数</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在解这个题之前，我们要注意<strong>奇数和偶数</strong>的边界情况。</p>
<ul>
<li>奇数2n+1个，我们要取第n+1小的数</li>
<li>偶数2n个，我们要取第n和n+1小的数</li>
</ul>
<p>在Go语言中，因为是强类型的，切片<code>nums1</code>与<code>nums2</code>是整数，返回值则是浮点数</p>
<blockquote>
<p>这是我们遇到的第一道hard级别的题目，让我们一起尝试攻克它！</p>
</blockquote>
<span id="more"></span>

<h2 id="基本解法"><a href="#基本解法" class="headerlink" title="基本解法"></a>基本解法</h2><h3 id="常规思路1-逐个寻找"><a href="#常规思路1-逐个寻找" class="headerlink" title="常规思路1 - 逐个寻找"></a>常规思路1 - 逐个寻找</h3><p>常规思路来看，我们就是找第X小的数，那我们就一个一个找：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    length1, length2 := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="comment">// 注意，这里是向下取整</span></span><br><span class="line">    mid := (length1 + length2) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区分一下奇数与偶数，奇数为mid+1，偶数为mid/mid+1</span></span><br><span class="line">    <span class="comment">// 奇数为2n+1个，mid=n,这样下一个就是中位数</span></span><br><span class="line">    <span class="comment">// 偶数为2n个，mid=n，所以处理一下，让mid=n-1，这样接下来两个就是中位数</span></span><br><span class="line">    <span class="keyword">var</span> isOdd <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">if</span> (length1 + length2) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        isOdd = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mid =  mid - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> i1, i2 <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 移动两个索引i1与i2，找到最小的mid个</span></span><br><span class="line">    <span class="comment">// 关键是注意两个边界情况的判定</span></span><br><span class="line">    <span class="keyword">for</span> mid &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i1 &gt;= <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">            i2++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> i2 &gt;= <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">            i1++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i1] &gt; nums2[i2] &#123;</span><br><span class="line">            i2++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i1++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mid--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到mid后下一个</span></span><br><span class="line">    <span class="keyword">var</span> n1 <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> i1 &gt;= <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">        n1 = nums2[i2]</span><br><span class="line">        i2++</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> i2 &gt;= <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">        n1 = nums1[i1]</span><br><span class="line">        i1++</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i1] &gt; nums2[i2] &#123;</span><br><span class="line">        n1 = nums2[i2]</span><br><span class="line">        i2++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n1 = nums1[i1]</span><br><span class="line">        i1++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 奇数直接返回结果</span></span><br><span class="line">    <span class="keyword">if</span> isOdd &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(n1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偶数找到再下一个，再返回</span></span><br><span class="line">    <span class="keyword">var</span> n2 <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> i1 &gt;= <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">        n2 = nums2[i2]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> i2 &gt;= <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">        n2 = nums1[i1]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i1] &gt; nums2[i2] &#123;</span><br><span class="line">        n2 = nums2[i2]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n2 = nums1[i1]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(n1 + n2) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码很长，但性能不差，因为都是顺序的逻辑。</p>
<p>分析一下复杂度，空间复杂度是O(1)，时间复杂度为O(m+n)，其中m=len(nums1)，n=len(nums2)。</p>
<h3 id="常规思路2-排序后直接根据索引查找"><a href="#常规思路2-排序后直接根据索引查找" class="headerlink" title="常规思路2 - 排序后直接根据索引查找"></a>常规思路2 - 排序后直接根据索引查找</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="comment">// Go里面不支持对 []int 直接进行排序，必须通过 sort.IntSlice 做一次转化</span></span><br><span class="line">    <span class="keyword">var</span> intSlice sort.IntSlice</span><br><span class="line">    intSlice = <span class="built_in">append</span>(intSlice, nums1...)</span><br><span class="line">    intSlice = <span class="built_in">append</span>(intSlice, nums2...)</span><br><span class="line"></span><br><span class="line">    sort.Sort(intSlice)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(intSlice) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 注意这里的索引，切勿再+1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(intSlice[<span class="built_in">len</span>(intSlice) / <span class="number">2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(intSlice[<span class="built_in">len</span>(intSlice) / <span class="number">2</span> - <span class="number">1</span>] + intSlice[<span class="built_in">len</span>(intSlice) / <span class="number">2</span> ]) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我个人觉得Go语言里的排序函数<code>sort.Sort</code>对使用者的体验不是很好，尤其是对一些基础类型的支持。</p>
<p>这个解法的问题是对nums1和nums2进行了重新排序，没有充分利用nums1与nums2为<strong>有序数组</strong>这个条件。</p>
<h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><h3 id="递归的基本思路"><a href="#递归的基本思路" class="headerlink" title="递归的基本思路"></a>递归的基本思路</h3><p>我们注意到，这道题中给出的两个数组都是 <strong>已排序</strong> 的，所以可以利用<strong>数组的随机访问</strong>特性，做一定的加速。</p>
<p>这道题的问题是取中位数，但由于<strong>数组长度的奇偶性</strong>问题，这个中位数很难递归。所以，我们需要将问题做一个转化，实现<strong>找到第K小的数字</strong>，也就是下面的<code>findKthSortedArrays</code>函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    length1, length2 := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="comment">// 奇数可以一步计算得出</span></span><br><span class="line">    <span class="keyword">if</span> (length1 + length2) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthSortedArrays(nums1, nums2, (length1 + length2) / <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 偶数的拆分为两个子问题</span></span><br><span class="line">    <span class="keyword">return</span> (findKthSortedArrays(nums1, nums2, (length1 + length2) / <span class="number">2</span>) +</span><br><span class="line">        findKthSortedArrays(nums1, nums2, (length1 + length2) / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    length1, length2 := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="comment">// 技巧1：保证nums1比nums2长，能减少下面很多条件的判断</span></span><br><span class="line">    <span class="keyword">if</span> length1 &lt; length2 &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthSortedArrays(nums2, nums1, k)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> length2 == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(nums1[k - <span class="number">1</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> k == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nums1[<span class="number">0</span>] &gt; nums2[<span class="number">0</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">float64</span>(nums2[<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(nums1[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们要保证i1和i2都要小于k，否则下面很难递归</span></span><br><span class="line">    i2 := k / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> i2 &gt; length2 &#123;</span><br><span class="line">      i2 = length2</span><br><span class="line">    &#125;</span><br><span class="line">    i1 := k - i2</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归的核心思路</span></span><br><span class="line">    <span class="keyword">if</span> nums1[i1 - <span class="number">1</span>] &lt; nums2[i2 - <span class="number">1</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthSortedArrays(nums1[i1:], nums2, k - i1)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i1 - <span class="number">1</span>] &gt; nums2[i2 - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthSortedArrays(nums1, nums2[i2:], k - i2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(nums1[i1 - <span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决这道题的难点在于3点：</p>
<ul>
<li>大量<strong>边界条件</strong>的编写，很容易发生遗漏导致运行失败</li>
<li>第n个数字转化为数组索引时，自带一个<code>-1</code>操作，在递归时容易混淆</li>
<li>递归的核心思路：<strong>将第k个元素转化为2个数组的索引之和，并保证不小于各自数组的长度</strong></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解决本题的难点在于大量的条件判断，存在大量<code>if-else</code>的代码，很容易让我们在编写代码时产生混乱，常常需要大量的调试。</p>
<p>我个人比较推荐用<strong>常规解法1</strong>这种笨办法来思路梳理，完整地处理好各种边界条件。接下来，再通过<strong>进阶解法</strong>来提升自己的抽象水平。</p>
<p>恭喜我们，正式解决了第一道困难的Leetcode！</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Go算法实战 - 5.【最长回文子串LeetCode-5】</title>
    <url>/2021/07/19/go-leetcode/go-leetcode-5/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="Leetcode-5-最长回文子串"><a href="#Leetcode-5-最长回文子串" class="headerlink" title="Leetcode-5 最长回文子串"></a>Leetcode-5 最长回文子串</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题中，我们也要注意<strong>奇数和偶数</strong>的边界情况。</p>
<span id="more"></span>

<h2 id="基本解法"><a href="#基本解法" class="headerlink" title="基本解法"></a>基本解法</h2><h3 id="枚举所有情况"><a href="#枚举所有情况" class="headerlink" title="枚举所有情况"></a>枚举所有情况</h3><p>刚拿到这道题时，我们很容易想到一个解法：</p>
<ul>
<li>枚举出s所有的子字符串</li>
<li>找到最长的回文串</li>
</ul>
<p>这个解法代码我就不专门写了，复杂度很高，但如果你想不到解决方案时，可以先写出这个解法，再逐步优化。</p>
<h3 id="利用递归拆分成子问题"><a href="#利用递归拆分成子问题" class="headerlink" title="利用递归拆分成子问题"></a>利用递归拆分成子问题</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找以s[0]为开头的最长回文子串</span></span><br><span class="line">    right := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> ; right &gt;= <span class="number">0</span>; right-- &#123;</span><br><span class="line">        <span class="comment">// 找到最长的回文子串就退出</span></span><br><span class="line">        <span class="keyword">if</span> isPalindrome(s[:right]) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用递归的方式获取s[1:]的长度，与上面的结果对比</span></span><br><span class="line">    subS := longestPalindrome(s[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(subS) &gt; right &#123;</span><br><span class="line">        <span class="keyword">return</span> subS</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[:right]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头尾两个指针不断往中间缩进</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果s长度为奇数，退出时刚好left=right，偶数则为 left &gt; right</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        <span class="keyword">if</span> s[left] != s[right] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        left++</span><br><span class="line">        right--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个解法的代码思路相对清晰，核心思路是将 <strong>以s[0]开头的回文字符串</strong> 与 <strong>s[1:]中最长回文子串</strong> 进行对比，其中后者是递归的子问题。</p>
<p>在有一定的算法基础后，我个人比较喜欢先用 <strong>递归思路去简化问题</strong>，将代码拆分成子问题，能大量地简化代码。</p>
<h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><h3 id="利用对称点"><a href="#利用对称点" class="headerlink" title="利用对称点"></a>利用对称点</h3><p>从回文串的特点来看，它存在一个对称点：</p>
<ul>
<li>长度为奇数2n+1的字符串，对称点为第n+1个字符</li>
<li>长度为偶数2n的字符串，对称点为第n与n+1个字符之间，我们不妨命名为空白blank</li>
</ul>
<p>所以，我们就对字符串s进行遍历，查找它的<strong>每个对称点上最长的回文串</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> longest <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// 是否为空白</span></span><br><span class="line">	<span class="comment">// 我们把字符串s看作为： s[0]-blank-s[1]-...-s[n-1]</span></span><br><span class="line">	<span class="keyword">var</span> isBlank <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">var</span> mid <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> mid &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">		<span class="keyword">var</span> sub <span class="keyword">string</span></span><br><span class="line">		<span class="keyword">if</span> isBlank &#123;</span><br><span class="line">			<span class="comment">// 空白的话，我们认为这个空白是在mid-1和mid之间的，从两边开始对比</span></span><br><span class="line">			sub = findLongestPalindromeByMid(s, mid<span class="number">-1</span>, mid)</span><br><span class="line">			isBlank = <span class="literal">false</span></span><br><span class="line">			mid++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 非空白的话，从索引mid的两边开始对比</span></span><br><span class="line">			sub = findLongestPalindromeByMid(s, mid<span class="number">-1</span>, mid+<span class="number">1</span>)</span><br><span class="line">			isBlank = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(sub) &gt; <span class="built_in">len</span>(longest) &#123;</span><br><span class="line">			longest = sub</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> longest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLongestPalindromeByMid</span><span class="params">(s <span class="keyword">string</span>, left, right <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// left和right就是两个指针，不断往两边移动，直到找到不相同的两个字符</span></span><br><span class="line">	<span class="keyword">for</span> left &gt;= <span class="number">0</span> &amp;&amp; right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">		<span class="keyword">if</span> s[left] != s[right] &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		left--</span><br><span class="line">		right++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意这里的索引，很容易搞混，我们要取的是left+1到right-1，这里切片后面的索引为right</span></span><br><span class="line">	<span class="keyword">return</span> s[left+<span class="number">1</span> : right]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="简化空白的处理"><a href="#简化空白的处理" class="headerlink" title="简化空白的处理"></a>简化空白的处理</h3><p>从上面的代码来看，空白的处理挺麻烦，我们可以直接从代码结构去优化。</p>
<p>大家可以仔细的阅读<code>isBlank</code>相关的代码，可以直接消除这个变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> longest <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> mid <span class="keyword">int</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> mid &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="comment">// 对称点为某个字符，长度为奇数</span></span><br><span class="line">        sub := findLongestPalindromeByMid(s, mid<span class="number">-1</span>, mid)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(sub) &gt; <span class="built_in">len</span>(longest) &#123;</span><br><span class="line">            longest = sub</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对称点为空白，长度为偶数</span></span><br><span class="line">        sub = findLongestPalindromeByMid(s, mid<span class="number">-1</span>, mid+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(sub) &gt; <span class="built_in">len</span>(longest) &#123;</span><br><span class="line">            longest = sub</span><br><span class="line">        &#125;</span><br><span class="line">        mid++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLongestPalindromeByMid</span><span class="params">(s <span class="keyword">string</span>, left, right <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> left &gt;= <span class="number">0</span> &amp;&amp; right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">if</span> s[left] != s[right] &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        left--</span><br><span class="line">        right++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s[left+<span class="number">1</span>:right]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划是算法中大量出现的一个解法，我们以这道题为例，进行探索。</p>
<blockquote>
<p>动态规划的细节请自行搜索，如 <a href="https://www.zhihu.com/question/39948290">https://www.zhihu.com/question/39948290</a> </p>
</blockquote>
<h3 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// 边界条件判断</span></span><br><span class="line">	length := <span class="built_in">len</span>(s)</span><br><span class="line">	<span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 回文子串至少为1，即单个字符</span></span><br><span class="line">	begin, maxLen := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="comment">// 动态规划的关键数组dp</span></span><br><span class="line">	<span class="keyword">var</span> dp = <span class="built_in">make</span>([][]<span class="keyword">bool</span>, length)</span><br><span class="line">	<span class="keyword">for</span> k1 := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[k1] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, length)</span><br><span class="line">		<span class="keyword">for</span> k2 := <span class="keyword">range</span> dp[k1] &#123;</span><br><span class="line">			<span class="comment">// 初始化均为false</span></span><br><span class="line">			dp[k1][k2] = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 单个字符默认为回文串</span></span><br><span class="line">		dp[k1][k1] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> size := <span class="number">2</span>; size &lt;= length; size++ &#123;</span><br><span class="line">		<span class="keyword">for</span> start := <span class="number">0</span>; start &lt;= length-size; start++ &#123;</span><br><span class="line">			end := start + size - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果首位字符串相同</span></span><br><span class="line">			<span class="keyword">if</span> s[start] == s[end] &#123;</span><br><span class="line">				<span class="keyword">if</span> size == <span class="number">2</span> &#123;</span><br><span class="line">					<span class="comment">// 边界情况，即只有2个字符且相等</span></span><br><span class="line">					dp[start][end] = <span class="literal">true</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 核心：动态规划的核心推导函数</span></span><br><span class="line">					dp[start][end] = dp[start+<span class="number">1</span>][end<span class="number">-1</span>]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 更新最长回文子串</span></span><br><span class="line">			<span class="keyword">if</span> dp[start][end] &amp;&amp; size &gt; maxLen &#123;</span><br><span class="line">				maxLen = size</span><br><span class="line">				begin = start</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s[begin : begin+maxLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最核心的公式为<code>dp[start][end] = dp[start+1][end-1]</code>，其余都是对边界条件的处理。</p>
<p>但运行结果的效率偏低</p>
<ul>
<li>执行用时：104 ms, 在所有 Go 提交中击败了42.53%的用户</li>
<li>内存消耗：7 MB, 在所有 Go 提交中击败了24.68%的用户</li>
</ul>
<h3 id="优化1-优化条件分支"><a href="#优化1-优化条件分支" class="headerlink" title="优化1 优化条件分支"></a>优化1 优化条件分支</h3><p>我们分析一下上面的代码：从空间复杂度来看，动态规划的数组<code>dp</code>是不可或缺的，所以减少内存消耗比较困难了。</p>
<p>因此，我们把目光放在执行时间上，那么重点就是<code>for</code>循环里的代码复杂度。</p>
<p>我们注意到一个关键的变量<code>dp[start][end]</code>，对它进行改造</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(s)</span><br><span class="line">	<span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	begin, maxLen := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> dp = <span class="built_in">make</span>([][]<span class="keyword">bool</span>, length)</span><br><span class="line">	<span class="keyword">for</span> k1 := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[k1] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, length)</span><br><span class="line">		<span class="keyword">for</span> k2 := <span class="keyword">range</span> dp[k1] &#123;</span><br><span class="line">			dp[k1][k2] = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		dp[k1][k1] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> size := <span class="number">2</span>; size &lt;= length; size++ &#123;</span><br><span class="line">		<span class="keyword">for</span> start := <span class="number">0</span>; start &lt;= length-size; start++ &#123;</span><br><span class="line">			end := start + size - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> s[start] == s[end] &#123;</span><br><span class="line">				<span class="keyword">if</span> size == <span class="number">2</span> || dp[start+<span class="number">1</span>][end<span class="number">-1</span>] &#123;</span><br><span class="line">					dp[start][end] = <span class="literal">true</span></span><br><span class="line">					<span class="comment">// 减少if-else的分支判断次数</span></span><br><span class="line">					<span class="keyword">if</span> size &gt; maxLen &#123;</span><br><span class="line">						maxLen = size</span><br><span class="line">						begin = start</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s[begin : begin+maxLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果很明显，代码执行时间减少</p>
<ul>
<li>执行用时：72 ms, 在所有 Go 提交中击败了50.93%的用户</li>
<li>内存消耗：7 MB, 在所有 Go 提交中击败了28.37%的用户</li>
</ul>
<h3 id="优化2-分析循环内代码执行逻辑"><a href="#优化2-分析循环内代码执行逻辑" class="headerlink" title="优化2 分析循环内代码执行逻辑"></a>优化2 分析循环内代码执行逻辑</h3><p>我们继续看代码里的<code>size &gt; maxLen</code>条件，发现会出现如下情况：</p>
<ul>
<li>如果一个字符有多个相同<code>size</code>的回文子串，这个<code>if</code>内的语句会被执行多次</li>
<li>但我们只需要获得最长的回文子串之一，所以只需要记录第一次即可</li>
</ul>
<p>于是我们尝试改造：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(s)</span><br><span class="line">	<span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	begin, maxLen := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> dp = <span class="built_in">make</span>([][]<span class="keyword">bool</span>, length)</span><br><span class="line">	<span class="keyword">for</span> k1 := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[k1] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, length)</span><br><span class="line">		<span class="keyword">for</span> k2 := <span class="keyword">range</span> dp[k1] &#123;</span><br><span class="line">			dp[k1][k2] = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		dp[k1][k1] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> size := <span class="number">2</span>; size &lt;= length; size++ &#123;</span><br><span class="line">		<span class="comment">// 用来表示对应size的字符串已经找到</span></span><br><span class="line">		founded := <span class="literal">false</span></span><br><span class="line">		<span class="keyword">for</span> start := <span class="number">0</span>; start &lt;= length-size; start++ &#123;</span><br><span class="line">			end := start + size - <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> s[start] == s[end] &#123;</span><br><span class="line">				<span class="keyword">if</span> size == <span class="number">2</span> || dp[start+<span class="number">1</span>][end<span class="number">-1</span>] &#123;</span><br><span class="line">					dp[start][end] = <span class="literal">true</span></span><br><span class="line">					<span class="comment">// 只记录第一个即可</span></span><br><span class="line">					<span class="keyword">if</span> !founded &amp;&amp; size &gt; maxLen &#123;</span><br><span class="line">						maxLen, begin = size, start</span><br><span class="line">						founded = <span class="literal">true</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s[begin : begin+maxLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：80 ms, 在所有 Go 提交中击败了49.30%的用户</li>
<li>内存消耗：7 MB, 在所有 Go 提交中击败了31.54%的用户</li>
</ul>
<p>然而，执行结果告诉我们这部分的优化无明显效果，甚至还降低了评分。但我们无需沮丧，<strong>因为这道题针对的是小规模场景的算法题，这个思路可能在大规模的计算场景下带来很明显的提升</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Leetcode第五题的难度不高，也让我们初次接触了 <strong>动态规划</strong> 这个思路。</p>
<p>同时，我们也遇到了一个<strong>“失败的优化案例”</strong>。这也从侧面告诉了我们，<strong>抛开具体场景的优化都是不可靠的</strong>。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Go算法实战 - 6.【正则表达式匹配LeetCode-10】</title>
    <url>/2021/07/28/go-leetcode/go-leetcode-6/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="Leetcode-10-正则表达式匹配"><a href="#Leetcode-10-正则表达式匹配" class="headerlink" title="Leetcode-10 正则表达式匹配"></a>Leetcode-10 正则表达式匹配</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/regular-expression-matching/">https://leetcode-cn.com/problems/regular-expression-matching/</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="基础解法"><a href="#基础解法" class="headerlink" title="基础解法"></a>基础解法</h2><p>我们先理一下正则匹配的大致思路：<strong>逐个对比s和p两个字符串，匹配则继续往后，发现不匹配直接退出</strong>。</p>
<p>那么，我们先简化一下问题，看看代码的大致结构：</p>
<h3 id="普通字符串匹配"><a href="#普通字符串匹配" class="headerlink" title="普通字符串匹配"></a>普通字符串匹配</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> || <span class="built_in">len</span>(p) == <span class="number">0</span> || s[<span class="number">0</span>] != p[<span class="number">0</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的代码思路很清晰，我们重点要解决的是两个通配符<code>.</code>和<code>*</code>：</p>
<h3 id="单个字符匹配"><a href="#单个字符匹配" class="headerlink" title="单个字符匹配"></a>单个字符匹配</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> || <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果p[0]为. ，则必定匹配</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] != p[<span class="number">0</span>] &amp;&amp; p[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匹配"><a href="#匹配" class="headerlink" title="*匹配"></a>*匹配</h2><p>接下来，我们就要解决最复杂的*匹配，也就是star符号。具体的解法我在下面给出，大家可以参考注释阅读：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 边界情况，即s为空，p前两个为 x*</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(p) &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> isMatch(s, p[<span class="number">2</span>:])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// p是否为 x* 形式</span></span><br><span class="line">	<span class="keyword">var</span> hasStar <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(p) &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">		hasStar = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// isMatch表示s与p的第一个字符是否匹配</span></span><br><span class="line">	<span class="keyword">var</span> isMatched = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">if</span> s[<span class="number">0</span>] != p[<span class="number">0</span>] &amp;&amp; p[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">		isMatched = <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> hasStar &#123;</span><br><span class="line">		<span class="keyword">if</span> isMatched &#123;</span><br><span class="line">			<span class="comment">// 情况1： 有星且第一个字符匹配，则递归包括2个情况：s去掉第一个字符，p去掉star这两个字符</span></span><br><span class="line">			<span class="keyword">return</span> isMatch(s[<span class="number">1</span>:], p) || isMatch(s, p[<span class="number">2</span>:])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 情况2：有星且不匹配，则去掉p的前两个字符继续匹配</span></span><br><span class="line">		<span class="keyword">return</span> isMatch(s, p[<span class="number">2</span>:])</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> !isMatched &#123;</span><br><span class="line">		<span class="comment">// 情况3：没星且不匹配，则直接返回不匹配</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 情况4：没有星但是匹配，s和p删掉匹配的第一个字符，继续匹配</span></span><br><span class="line">	<span class="keyword">return</span> isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个解法虽然看过去复杂，但是比较直观，核心在于两个变量<code>hasStar</code>和<code>isMatch</code>，以及它们组合起来的四个情况。</p>
<h2 id="动态规划解"><a href="#动态规划解" class="headerlink" title="动态规划解"></a>动态规划解</h2><p>动态规划是一个面试高频的题，其核心是<strong>状态转移方程</strong>。这道题很符合动态规划的特征，我们通过了上面的递归解法，其实已经有了基本的思路：<strong>递归中的四种情况，其实就是状态转移方程的大致思路</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	row, col := <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dp 就是核心的状态转移方程，这里注意要+1，是为了空字符串这个边界条件</span></span><br><span class="line">	<span class="comment">// 所以后面的i/j默认都要-1</span></span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, row+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, col+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 填充dp[0]数组，也就是s为空字符串</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; col+<span class="number">1</span>; j++ &#123;</span><br><span class="line">		<span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// p为空字符串的情况</span></span><br><span class="line">			dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">			<span class="comment">// 如果p[j-1]为*，则可以认为匹配p和p[0:j-2]一样，类似于情况2</span></span><br><span class="line">			dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-2</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 填充整个dp数组，注意i和j在dp中不变，但对应到字符串s/p中都要-1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; row+<span class="number">1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; col+<span class="number">1</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">					<span class="comment">// 对应情况1，有星且第一个字符匹配</span></span><br><span class="line">					dp[i][j] = dp[i][j<span class="number">-2</span>] || dp[i<span class="number">-1</span>][j]</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 对应情况2，有星且不匹配</span></span><br><span class="line">					dp[i][j] = dp[i][j<span class="number">-2</span>]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">				<span class="comment">// 对应情况4，没有星但是匹配</span></span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 其余的对应情况3，没星且不匹配，即默认false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[row][col]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要有了递归解法的思路，动态规划的难度并不高。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们又完成了一道hard级别的题目！</p>
<p>这道题，让我们看到了递归与动态规划存在共性。其中，递归解法的核心思路是<strong>将问题拆解为复杂度更低的子问题，直到边界情况</strong>，而动态规划解法的核心思路是<strong>从边界情况开始推导，从复杂度低的问题推导出复杂度更高的问题</strong>。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Go算法实战 - 7.【盛最多水的容器LeetCode-11】</title>
    <url>/2021/08/02/go-leetcode/go-leetcode-7/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="Leetcode-11-盛最多水的容器"><a href="#Leetcode-11-盛最多水的容器" class="headerlink" title="Leetcode-11 盛最多水的容器"></a>Leetcode-11 盛最多水的容器</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/container-with-most-water/">https://leetcode-cn.com/problems/container-with-most-water/</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="基础解法"><a href="#基础解法" class="headerlink" title="基础解法"></a>基础解法</h2><h3 id="基本的递归"><a href="#基本的递归" class="headerlink" title="基本的递归"></a>基本的递归</h3><p>我们先通过递归来解一下这个问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(height) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(height) == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> height[<span class="number">0</span>] &gt; height[<span class="number">1</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> height[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> height[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右边固定为height[len(height) - 1]，左边不断移动，寻找最大的区域</span></span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(height) - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        right := height[<span class="built_in">len</span>(height) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> height[i] &lt; right &#123;</span><br><span class="line">            right = height[i]</span><br><span class="line">        &#125;</span><br><span class="line">        area := (<span class="built_in">len</span>(height) - <span class="number">1</span> - i) * right</span><br><span class="line">        <span class="keyword">if</span> area &gt; max &#123;</span><br><span class="line">            max = area</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// height去掉最右边的一个点，拆解为子问题</span></span><br><span class="line">    subArea := maxArea(height[:<span class="built_in">len</span>(height) - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> subArea &gt; max&#123;</span><br><span class="line">        <span class="keyword">return</span> subArea</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个代码的逻辑没有问题，但在线上执行的结果是<strong>超出了时间限制</strong>，也就是递归太深。</p>
<p>我们能否想个办法，做到<strong>减枝</strong>？我们尝试下将已经算出来的区域传递下去。</p>
<h3 id="利用减枝"><a href="#利用减枝" class="headerlink" title="利用减枝"></a>利用减枝</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 处理初始边界条件</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(height) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(height) == <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> height[<span class="number">0</span>] &gt; height[<span class="number">1</span>] &#123;</span><br><span class="line">			<span class="keyword">return</span> height[<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> height[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxAreaWithAera(height, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxAreaWithAera</span><span class="params">(height []<span class="keyword">int</span>, area <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(height) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> area</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	right := height[<span class="built_in">len</span>(height)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">if</span> right != <span class="number">0</span> &#123;</span><br><span class="line">		leftIndex := <span class="built_in">len</span>(height) - <span class="number">2</span></span><br><span class="line">		<span class="comment">// 关键在于理解 len(height)-1-area/right，也就是左边至少从右边的边偏移area/right，才有可能大于area</span></span><br><span class="line">		<span class="keyword">if</span> area != <span class="number">0</span> &amp;&amp; leftIndex &gt; <span class="built_in">len</span>(height)<span class="number">-1</span>-area/right &#123;</span><br><span class="line">			leftIndex = <span class="built_in">len</span>(height) - <span class="number">1</span> - area/right</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// leftIndex往左偏移</span></span><br><span class="line">		<span class="keyword">for</span> ; leftIndex &gt;= <span class="number">0</span>; leftIndex-- &#123;</span><br><span class="line">			right := height[<span class="built_in">len</span>(height)<span class="number">-1</span>]</span><br><span class="line">			<span class="keyword">if</span> height[leftIndex] &lt; right &#123;</span><br><span class="line">				right = height[leftIndex]</span><br><span class="line">			&#125;</span><br><span class="line">			a := (<span class="built_in">len</span>(height) - <span class="number">1</span> - leftIndex) * right</span><br><span class="line">			<span class="keyword">if</span> a &gt; area &#123;</span><br><span class="line">				area = a</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxAreaWithAera(height[:<span class="built_in">len</span>(height)<span class="number">-1</span>], area)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点就是<code>len(height)-1-area/right</code>这个值，这里利用了传递的<code>area</code>进行<strong>减枝</strong>。</p>
<h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><h3 id="梳理思路"><a href="#梳理思路" class="headerlink" title="梳理思路"></a>梳理思路</h3><p>我们跳出代码，来思考一下整个问题解决的宏观思路</p>
<ol>
<li>当左边与右边确定时，假设索引为<code>l1</code>和<code>r1</code>，区域大小是固定的<ol>
<li><code>area = min(height[l1], height[r1]) * (r1 - l1)</code></li>
</ol>
</li>
<li>接下来，我们要简化问题，也就是要将**[]height的左边界往右移或者右边界往左移**<ol>
<li>无论如何移动，<strong>x轴是不断缩小的</strong>，所以问题在于<code>左边界height[l2]</code>和右边界的高度<code>height[r2]</code></li>
<li><code>area2 = min(height[l2], height[r2]) * (r2 - l2)</code></li>
</ol>
</li>
<li><code>l2</code>和<code>r2</code>同时改变的话，整个计算方式就会很复杂，那我们就尝试固定其中一个不变，例如<ol>
<li><code>l1 = l2</code> 并且 <code>r1 &gt; r2</code>，即<strong>右边界往左移动</strong>，此时</li>
<li><code>area = min(height[l1], height[r1]) * (r1 - l1)</code></li>
<li><code>area2 = min(height[l1], height[r2]) * (r2 - l1)</code></li>
</ol>
</li>
<li>有什么办法可以对比<code>area</code>与<code>area2</code> 呢？<ol>
<li><code>r1 - l1 &gt; r2 - l1</code>可根据条件快速判断</li>
<li>核心在于对比 <code>min(height[l1], height[r1])</code> 和 <code>min(height[l1], height[r2])</code><ol>
<li>如果 <code>height[r1])</code> &gt;= <code>min(height[l1]</code>，也就是**[]height高度最右边最高于左边**，那么 <code>min(height[l1], height[r1])</code> &gt;=  <code>min(height[l1], height[r2])</code>成立，此时 area &gt;= area2 也必定成立</li>
<li>如果 <code>height[r1])</code> &lt; <code>min(height[l1]</code>，那么 area 与 area2 的关系没法判断</li>
</ol>
</li>
<li>归纳一下上面这个情况：就是<strong>当[]height高度最右边高于最左边时，移动右边面积肯定变小，移动左边面积变化未知</strong>。</li>
</ol>
</li>
<li>用更通用的说法就是，如果要找到[]height子集中更大的面积，<strong>固定较高边，移动较低边</strong>。在编程中，这种接法往往称为<strong>双指针</strong>。</li>
</ol>
<h3 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        <span class="keyword">var</span> area <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">if</span> height[left] &gt; height[right] &#123;</span><br><span class="line">            area = height[right] * (right - left)</span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            area = height[left] * (right - left)</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> area &gt; max &#123;</span><br><span class="line">            max = area</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双指针解法很简洁</strong>，但最重要的是推导过程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在编写代码的过程中，我们很难一步到位就写出最佳实现的解法，而前面的<strong>递归+减枝</strong>方法，虽然代码比较复杂，但是更符合我们直观逻辑的。<strong>双指针解法</strong>并不直观，这也就是体现出了刷题的价值。</p>
<p>值得一提的是，如果你上手就写出双指针解法，面试官会认为你是靠刷题记忆的，所以在面试算法的过程中，我们更应该关注<strong>解决问题的递进式思路</strong>，答案只是评价算法能力的其中一个重要项。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Go算法实战 - 8.【三数之和LeetCode-15】</title>
    <url>/2021/08/08/go-leetcode/go-leetcode-8/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="Leetcode-15-三数之和"><a href="#Leetcode-15-三数之和" class="headerlink" title="Leetcode-15 三数之和"></a>Leetcode-15 三数之和</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="基础解法"><a href="#基础解法" class="headerlink" title="基础解法"></a>基础解法</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>在看到这道题的后，我们很自然地可以想到简单的解法，例如穷举出所有的值。这个代码我就不专门写了。</p>
<h3 id="利用排序进行优化"><a href="#利用排序进行优化" class="headerlink" title="利用排序进行优化"></a>利用排序进行优化</h3><p>由于这道题返回的<code>[][]int</code>要求是对应的值，而不是索引，所以我们可以利用排序做一定的加速，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 先排序，为了方便处理</span></span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	<span class="comment">// 用于去重</span></span><br><span class="line">	<span class="keyword">var</span> solutionMap = <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">3</span>]<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">for</span> k := j + <span class="number">1</span>; k &lt;= <span class="built_in">len</span>(nums)<span class="number">-1</span>; k++ &#123;</span><br><span class="line">				<span class="keyword">if</span> nums[i]+nums[j]+nums[k] == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="comment">// 取到一个解即可</span></span><br><span class="line">					solutionMap[[<span class="number">3</span>]<span class="keyword">int</span>&#123;nums[i], nums[j], nums[k]&#125;] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[j]+nums[k] &gt; <span class="number">0</span> &#123;</span><br><span class="line">					<span class="comment">// 如果已经大于0了，由于nums是递增的，无需继续循环下去了</span></span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 取一下去重后的解</span></span><br><span class="line">	<span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> solutionMap &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, k[<span class="number">0</span>], k[<span class="number">1</span>], k[<span class="number">2</span>]))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但运行下来，在数据量大的情况下还是会超出时间限制</p>
<h3 id="利用二分查找加速"><a href="#利用二分查找加速" class="headerlink" title="利用二分查找加速"></a>利用二分查找加速</h3><p>我们把目光聚焦到<code>k</code>，在一个有序的数组中，可以利用二分查找加速</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	<span class="keyword">var</span> solutionMap = <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">3</span>]<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; j++ &#123;</span><br><span class="line">			<span class="comment">// 用二分查找加速</span></span><br><span class="line">			<span class="comment">// 但需要注意的是，go里的sort并不是精确匹配，所以需要二次判断</span></span><br><span class="line">			k := sort.SearchInts(nums[j+<span class="number">1</span>:], -nums[i]-nums[j])</span><br><span class="line">			<span class="keyword">if</span> k &lt; <span class="built_in">len</span>(nums[j+<span class="number">1</span>:]) &amp;&amp; nums[i]+nums[j]+nums[j+k+<span class="number">1</span>] == <span class="number">0</span> &#123;</span><br><span class="line">				solutionMap[[<span class="number">3</span>]<span class="keyword">int</span>&#123;nums[i], nums[j], nums[j+k+<span class="number">1</span>]&#125;] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> solutionMap &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, k[<span class="number">0</span>], k[<span class="number">1</span>], k[<span class="number">2</span>]))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，代码已经可以通过验证，我们再看看有什么进一步的优化空间。</p>
<h3 id="优化1：减少元素的存储"><a href="#优化1：减少元素的存储" class="headerlink" title="优化1：减少元素的存储"></a>优化1：减少元素的存储</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	<span class="comment">// 缩小元素的存储</span></span><br><span class="line">	<span class="keyword">var</span> solutionMap = <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">2</span>]<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; j++ &#123;</span><br><span class="line">			k := sort.SearchInts(nums[j+<span class="number">1</span>:], -nums[i]-nums[j])</span><br><span class="line">			<span class="keyword">if</span> k &lt; <span class="built_in">len</span>(nums[j+<span class="number">1</span>:]) &amp;&amp; nums[i]+nums[j]+nums[j+k+<span class="number">1</span>] == <span class="number">0</span> &#123;</span><br><span class="line">				solutionMap[[<span class="number">2</span>]<span class="keyword">int</span>&#123;nums[i], nums[j]&#125;] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> solutionMap &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, k[<span class="number">0</span>], k[<span class="number">1</span>], -k[<span class="number">0</span>]-k[<span class="number">1</span>]))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化2：初始化切片大小，防止扩容效率"><a href="#优化2：初始化切片大小，防止扩容效率" class="headerlink" title="优化2：初始化切片大小，防止扩容效率"></a>优化2：初始化切片大小，防止扩容效率</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	<span class="keyword">var</span> solutionMap = <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">2</span>]<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; j++ &#123;</span><br><span class="line">			k := sort.SearchInts(nums[j+<span class="number">1</span>:], -nums[i]-nums[j])</span><br><span class="line">			<span class="keyword">if</span> k &lt; <span class="built_in">len</span>(nums[j+<span class="number">1</span>:]) &amp;&amp; nums[i]+nums[j]+nums[j+k+<span class="number">1</span>] == <span class="number">0</span> &#123;</span><br><span class="line">				solutionMap[[<span class="number">2</span>]<span class="keyword">int</span>&#123;nums[i], nums[j]&#125;] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化切片空间</span></span><br><span class="line">	<span class="keyword">var</span> result = <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(solutionMap))</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> solutionMap &#123;</span><br><span class="line">		result[i] = []<span class="keyword">int</span>&#123;k[<span class="number">0</span>], k[<span class="number">1</span>], -k[<span class="number">0</span>] - k[<span class="number">1</span>]&#125;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优化3：利用map加速查询"><a href="#优化3：利用map加速查询" class="headerlink" title="优化3：利用map加速查询"></a>优化3：利用map加速查询</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	<span class="keyword">var</span> dataCountMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := dataCountMap[v]; !ok &#123;</span><br><span class="line">			dataCountMap[v] = <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dataCountMap[v]++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> solutionMap = <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">2</span>]<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; j++ &#123;</span><br><span class="line">			expected := -nums[i] - nums[j]</span><br><span class="line">			<span class="keyword">if</span> num, ok := dataCountMap[expected]; ok &amp;&amp; expected &gt;= nums[j] &#123;</span><br><span class="line">				<span class="keyword">if</span> expected == nums[j] &#123;</span><br><span class="line">					num--</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> expected == nums[i] &#123;</span><br><span class="line">					num--</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">					solutionMap[[<span class="number">2</span>]<span class="keyword">int</span>&#123;nums[i], nums[j]&#125;] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result = <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(solutionMap))</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> solutionMap &#123;</span><br><span class="line">		result[i] = []<span class="keyword">int</span>&#123;k[<span class="number">0</span>], k[<span class="number">1</span>], -k[<span class="number">0</span>] - k[<span class="number">1</span>]&#125;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="进阶思路-双指针"><a href="#进阶思路-双指针" class="headerlink" title="进阶思路 -  双指针"></a>进阶思路 -  双指针</h2><p>我们把眼光放回到这个问题。通过排序，其实我们已经将问题变得比较清晰了。</p>
<p>在这个题目中，有三个关键的变量，我们可以将其中一个固定，例如<code>i</code>，将问题简化为<code>nums[j]+nums[k]=-nums[i]</code>。</p>
<p>于是，问题就在于<code>j</code>和<code>k</code>这两个坐标的移动。整体的代码思路并不难，但性能的提升集中在<strong>对剪枝情况的处理</strong>，尤其是值相同的元素。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	<span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 剪枝：最小值大于0时无需再遍历</span></span><br><span class="line">		<span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 剪枝：最小值和前一个值一样时，上一个循环已经判断过，无需再判断</span></span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// j,k 为两个指针，分别从最左边和最右边开始移动</span></span><br><span class="line">		j, k := i+<span class="number">1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">		<span class="keyword">for</span> j &lt; k &#123;</span><br><span class="line">			left, right := nums[j], nums[k]</span><br><span class="line">			<span class="keyword">if</span> nums[i]+nums[j]+nums[k] == <span class="number">0</span> &#123;</span><br><span class="line">				result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;nums[i], nums[j], nums[k]&#125;)</span><br><span class="line">				<span class="comment">// 减枝：跳过 nums[j] == nums[j+1] 的情况</span></span><br><span class="line">				<span class="keyword">for</span> j &lt; k &amp;&amp; nums[j] == left &#123;</span><br><span class="line">					j++</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 减枝：跳过 nums[k] == nums[k-1] 的情况</span></span><br><span class="line">				<span class="keyword">for</span> j &lt; k &amp;&amp; nums[k] == right &#123;</span><br><span class="line">					k--</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[j]+nums[k] &lt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 和小于0，则增大最左边的j</span></span><br><span class="line">				j++</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 和大于0，则减少最右边的k</span></span><br><span class="line">				k--</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题的难度并不高，我们可以快速地实现这块代码。</p>
<p>与此同时，我们将更多的注意力放在了<strong>剪枝</strong>的情况，也就成为了最终算法是否高效的关键因素。在实际的工程中，<strong>剪枝</strong>是一个很重要的思想，我们经常要<strong>根据具体的数据特征进行策略调整</strong>。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Go算法实战 - 9.【电话号码的字母组合LeetCode-17】</title>
    <url>/2021/08/18/go-leetcode/go-leetcode-9/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="Leetcode-17-电话号码的字母组合"><a href="#Leetcode-17-电话号码的字母组合" class="headerlink" title="Leetcode-17 电话号码的字母组合"></a>Leetcode-17 电话号码的字母组合</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="基础解法"><a href="#基础解法" class="headerlink" title="基础解法"></a>基础解法</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>这道题的思路并不复杂，我们逐个处理<code>digits</code>里的字符，追加到结果上</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numToLetter = <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>&#123;</span><br><span class="line">	<span class="string">&quot;2&quot;</span>: &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;,</span><br><span class="line">	<span class="string">&quot;3&quot;</span>: &#123;<span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>&#125;,</span><br><span class="line">	<span class="string">&quot;4&quot;</span>: &#123;<span class="string">&quot;g&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;i&quot;</span>&#125;,</span><br><span class="line">	<span class="string">&quot;5&quot;</span>: &#123;<span class="string">&quot;j&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;l&quot;</span>&#125;,</span><br><span class="line">	<span class="string">&quot;6&quot;</span>: &#123;<span class="string">&quot;m&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;o&quot;</span>&#125;,</span><br><span class="line">	<span class="string">&quot;7&quot;</span>: &#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;s&quot;</span>&#125;,</span><br><span class="line">	<span class="string">&quot;8&quot;</span>: &#123;<span class="string">&quot;t&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;v&quot;</span>&#125;,</span><br><span class="line">	<span class="string">&quot;9&quot;</span>: &#123;<span class="string">&quot;w&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> digits == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> matchNext([]<span class="keyword">string</span>&#123;&#125;, digits)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心递归，逐个处理剩余的字符串left</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">matchNext</span><span class="params">(current []<span class="keyword">string</span>, left <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> current</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从题目来看肯定是matched的</span></span><br><span class="line">	matched, ok := numToLetter[<span class="keyword">string</span>(left[<span class="number">0</span>])]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> current</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(current) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> matchNext(matched, left[<span class="number">1</span>:])</span><br><span class="line">	&#125;</span><br><span class="line">	next := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(current)*<span class="built_in">len</span>(matched))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> next &#123;</span><br><span class="line">	  <span class="comment">// 利用位操作加速</span></span><br><span class="line">		next[i] = current[i/<span class="built_in">len</span>(matched)] + matched[i%<span class="built_in">len</span>(matched)]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> matchNext(next, left[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="减少内存空间"><a href="#减少内存空间" class="headerlink" title="减少内存空间"></a>减少内存空间</h3><p>从运行结果来看：</p>
<ul>
<li>执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</li>
</ul>
<p>运行速度已经很难优化了，我们就想办法减少一下内存空间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 减少空间，把切片转变成字符串</span></span><br><span class="line"><span class="keyword">var</span> numToLetter = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">	<span class="string">&quot;2&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">	<span class="string">&quot;3&quot;</span>: <span class="string">&quot;def&quot;</span>,</span><br><span class="line">	<span class="string">&quot;4&quot;</span>: <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">	<span class="string">&quot;5&quot;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">	<span class="string">&quot;6&quot;</span>: <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">	<span class="string">&quot;7&quot;</span>: <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">	<span class="string">&quot;8&quot;</span>: <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">	<span class="string">&quot;9&quot;</span>: <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> digits == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> matchNext([]<span class="keyword">string</span>&#123;&#125;, digits)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">matchNext</span><span class="params">(current []<span class="keyword">string</span>, left <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> current</span><br><span class="line">	&#125;</span><br><span class="line">	matched, ok := numToLetter[<span class="keyword">string</span>(left[<span class="number">0</span>])]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> current</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(current) == <span class="number">0</span> &#123;</span><br><span class="line">		next := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(matched))</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> matched &#123;</span><br><span class="line">			next[i] = <span class="keyword">string</span>(matched[i])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> matchNext(next, left[<span class="number">1</span>:])</span><br><span class="line">	&#125;</span><br><span class="line">	next := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(current)*<span class="built_in">len</span>(matched))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> next &#123;</span><br><span class="line">		<span class="comment">// 利用位操作加速</span></span><br><span class="line">		next[i] = current[i/<span class="built_in">len</span>(matched)] + <span class="keyword">string</span>(matched[i%<span class="built_in">len</span>(matched)])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> matchNext(next, left[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进阶：引入函数式编程"><a href="#进阶：引入函数式编程" class="headerlink" title="进阶：引入函数式编程"></a>进阶：引入函数式编程</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(digits) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> result []<span class="keyword">string</span></span><br><span class="line">	numToLetter := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;2&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">		<span class="string">&quot;3&quot;</span>: <span class="string">&quot;def&quot;</span>,</span><br><span class="line">		<span class="string">&quot;4&quot;</span>: <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">		<span class="string">&quot;5&quot;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">		<span class="string">&quot;6&quot;</span>: <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">		<span class="string">&quot;7&quot;</span>: <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">		<span class="string">&quot;8&quot;</span>: <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">		<span class="string">&quot;9&quot;</span>: <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> matchNext <span class="function"><span class="keyword">func</span><span class="params">(current <span class="keyword">string</span>, left <span class="keyword">string</span>)</span></span></span><br><span class="line">	matchNext = <span class="function"><span class="keyword">func</span><span class="params">(current <span class="keyword">string</span>, left <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(left) == <span class="number">0</span> &#123;</span><br><span class="line">			result = <span class="built_in">append</span>(result, current)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> numToLetter[<span class="keyword">string</span>(left[<span class="number">0</span>])] &#123;</span><br><span class="line">			current = current + <span class="keyword">string</span>(v)</span><br><span class="line">			matchNext(current, left[<span class="number">1</span>:])</span><br><span class="line">			current = current[:<span class="built_in">len</span>(current)<span class="number">-1</span>] <span class="comment">//回溯</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	matchNext(<span class="string">&quot;&quot;</span>, digits)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个思路比较简单，最主要的优点在于将<code>numToLetter</code>和<code>matchNext</code>收敛到了函数中，对外暴露的细节就减少了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题的解法比较通俗易懂，最主要的切入点是引入<strong>递归的思想</strong>，来不断地缩减传入的字符串<code>digits</code>的长度，直到为0。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Go编程模式 - 1.基础编码上</title>
    <url>/2021/02/20/go-patterns/go-patterns-1/</url>
    <content><![CDATA[<blockquote>
<p> 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的<a href="https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save">链接</a>可能并不方便获取，所以我下载了一份<a href="https://github.com/Junedayday/code_reading/tree/master/doc/Go_Programming_Patterns.pdf">PDF</a>到git仓，方便大家阅读。我将结合自己的实际项目经历，与大家一起细品这份文档。</p>
</blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#Slice-Internal">Slice的底层实现</a></li>
<li><a href="#Deep-Comparison">深度对比</a></li>
<li><a href="#Function-vs-Receiver">函数传参VS对象方法</a></li>
<li><a href="#Interface-Patterns">面向接口编程</a></li>
</ul>
<h3 id="Slice-Internal"><a href="#Slice-Internal" class="headerlink" title="Slice Internal"></a>Slice Internal</h3><p>关于Slice的实现，我之前有<a href="https://github.com/Junedayday/code_reading/blob/master/basic/data_struct.md#slice">一讲</a>专门分析过底层实现。考虑到很多朋友没有细看，那我就再简单地讲一下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer <span class="comment">// Slice底层保存数据的指针</span></span><br><span class="line">	<span class="built_in">len</span> <span class="keyword">int</span> <span class="comment">// 当前使用的长度</span></span><br><span class="line">	<span class="built_in">cap</span> <span class="keyword">int</span> <span class="comment">// 分配的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>掌握Slice的底层实现，能让你真正理解一些看似“奇怪的”现象：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    foo := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    foo[<span class="number">3</span>] = <span class="number">42</span></span><br><span class="line">    foo[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line">    </span><br><span class="line">    bar := foo[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">    bar[<span class="number">1</span>] = <span class="number">99</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(foo)</span><br><span class="line">    <span class="comment">// [0 0 99 42 100]</span></span><br><span class="line">    fmt.Println(bar)</span><br><span class="line">    <span class="comment">// [0 99 42]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tip: bar和foo是共享slice结构体底层的array的，所以修改了bar数组，foo也会变化</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">32</span>)</span><br><span class="line">    b := a[<span class="number">1</span>:<span class="number">16</span>]</span><br><span class="line">    </span><br><span class="line">    a = <span class="built_in">append</span>(a, <span class="number">1</span>)</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">42</span></span><br><span class="line">  </span><br><span class="line">    fmt.Println(b)</span><br><span class="line">    <span class="comment">// [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tip: a和b原来是共享array的，但在a = append(a, 1)后发生了扩容，a和b指向的array发生了变化</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    path := []<span class="keyword">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">    sepIndex := bytes.IndexByte(path,<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    dir1 := path[:sepIndex]</span><br><span class="line">    dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">    fmt.Println(<span class="built_in">cap</span>(dir1),<span class="built_in">cap</span>(dir2))</span><br><span class="line">    <span class="comment">// 14 9</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;dir1 =&gt;&quot;</span>,<span class="keyword">string</span>(dir1))</span><br><span class="line">    <span class="comment">// dir1 =&gt; AAAA</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;dir2 =&gt;&quot;</span>,<span class="keyword">string</span>(dir2))</span><br><span class="line">    <span class="comment">// dir2 =&gt; BBBBBBBBB</span></span><br><span class="line">    </span><br><span class="line">    dir1 = <span class="built_in">append</span>(dir1,<span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line">    fmt.Println(<span class="string">&quot;dir1 =&gt;&quot;</span>,<span class="keyword">string</span>(dir1))</span><br><span class="line">    <span class="comment">// dir1 =&gt; AAAAsuffix</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;dir2 =&gt;&quot;</span>,<span class="keyword">string</span>(dir2))</span><br><span class="line">    <span class="comment">// dir2 =&gt; uffixBBBB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tip: 核心点在于理解dir1和dir2的cap分别是14和9。由于dir1的当前len=4，append的长度=6，4+6&lt;14，所以不会发生扩容</p>
</blockquote>
<h3 id="Deep-Comparison"><a href="#Deep-Comparison" class="headerlink" title="Deep Comparison"></a>Deep Comparison</h3><p>我们先看一下示例，<code>data</code>结构体中四个注释为<code>not comparable</code>表示无法直接用 == 符号对比</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	num    <span class="keyword">int</span>               <span class="comment">// ok</span></span><br><span class="line">	checks [<span class="number">10</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span>   // <span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line">	doit   <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span>       // <span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line">	m      <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// not comparable</span></span><br><span class="line">	bytes  []<span class="keyword">byte</span>            <span class="comment">// not comparable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v1 := data&#123;&#125;</span><br><span class="line">	v2 := data&#123;&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;v1 == v2:&quot;</span>, reflect.DeepEqual(v1, v2))</span><br><span class="line">	<span class="comment">// prints: v1 == v2: true</span></span><br><span class="line"></span><br><span class="line">	m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">	m2 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;m1 == m2:&quot;</span>, reflect.DeepEqual(m1, m2))</span><br><span class="line">	<span class="comment">// prints: m1 == m2: true</span></span><br><span class="line"></span><br><span class="line">	s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	s2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;s1 == s2:&quot;</span>, reflect.DeepEqual(s1, s2))</span><br><span class="line">	<span class="comment">// prints: s1 == s2: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tip： 示例比较复杂，其实要表达的内容比较简单：</p>
<p>函数、map、切片（不包括数组）以及它们的复合结构（如函数的数组），无法直接对比，只能用 reflect.DeepEqual</p>
</blockquote>
<h3 id="Function-vs-Receiver"><a href="#Function-vs-Receiver" class="headerlink" title="Function vs Receiver"></a>Function vs Receiver</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Sexual <span class="keyword">string</span></span><br><span class="line">	Age    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintPerson</span><span class="params">(p *Person)</span></span> &#123; fmt.Printf(<span class="string">&quot;Name=%s, Sexual=%s, Age=%d\n&quot;</span>, p.Name, p.Sexual, p.Age) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">Print</span><span class="params">()</span></span>    &#123; fmt.Printf(<span class="string">&quot;Name=%s, Sexual=%s, Age=%d\n&quot;</span>, p.Name, p.Sexual, p.Age) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p = Person&#123;</span><br><span class="line">		Name: <span class="string">&quot;Hao Chen&quot;</span>, Sexual: <span class="string">&quot;Male&quot;</span>, Age: <span class="number">44</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PrintPerson(&amp;p)</span><br><span class="line">	<span class="comment">// Name=Hao Chen, Sexual=Male, Age=44</span></span><br><span class="line">	p.Print()</span><br><span class="line">	<span class="comment">// Name=Hao Chen, Sexual=Male, Age=44</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tip: 示例比较简单，但其中蕴含的意义非常大，如对Person这个对象的抽象、简化代码等。</p>
<p>另外值得一提的是，Go编译器会根据方法 <code>func (p *Person) Print()</code> 的定义，将 <code>p.Print()</code>中的p从<code>Person</code>转换为<code>*Person</code>。</p>
</blockquote>
<h3 id="Interface-Patterns"><a href="#Interface-Patterns" class="headerlink" title="Interface Patterns"></a>Interface Patterns</h3><p>这个模块非常重要，希望大家倒一杯水，细细品尝。</p>
<p>示例是一个很简单的interface实现，用来打印接口，我们看看代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Country <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> City <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Printable <span class="keyword">interface</span> &#123;</span><br><span class="line">	PrintStr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Country)</span> <span class="title">PrintStr</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(c.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c City)</span> <span class="title">PrintStr</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(c.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c1 := Country&#123;<span class="string">&quot;China&quot;</span>&#125;</span><br><span class="line">	c2 := City&#123;<span class="string">&quot;Beijing&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> cList = []Printable&#123;c1, c2&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> cList &#123;</span><br><span class="line">		v.PrintStr()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，这时问题来了，如果我要实现N个<code>Printable</code>，就要定义N个strcut+N个<code>PrintStr()</code>方法。</p>
<p>前者的工作不能避免，而后者能否简化？那么示例来了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WithName <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Country <span class="keyword">struct</span> &#123;</span><br><span class="line">	WithName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> City <span class="keyword">struct</span> &#123;</span><br><span class="line">	WithName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Printable <span class="keyword">interface</span> &#123;</span><br><span class="line">	PrintStr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c WithName)</span> <span class="title">PrintStr</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(c.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c1 := Country&#123;WithName&#123;<span class="string">&quot;China&quot;</span>&#125;&#125;</span><br><span class="line">	c2 := City&#123;WithName&#123;<span class="string">&quot;Beijing&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> cList = []Printable&#123;c1, c2&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> cList &#123;</span><br><span class="line">		v.PrintStr()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tip: 核心就是用 embedded 的特性来删除冗余的代码。当然，代价是初始化会稍微麻烦点。</p>
</blockquote>
<hr>
<p>这时候，陈皓又给出了一个例子，即打印的内容会根据具体的实现不同时，无法直接用<code>WithName</code>来实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Country <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> City <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Printable <span class="keyword">interface</span> &#123;</span><br><span class="line">	PrintStr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Country)</span> <span class="title">PrintStr</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Country:&quot;</span>, c.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c City)</span> <span class="title">PrintStr</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;City:&quot;</span>, c.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c1 := Country&#123;<span class="string">&quot;China&quot;</span>&#125;</span><br><span class="line">	c2 := City&#123;<span class="string">&quot;Beijing&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> cList = []Printable&#123;c1, c2&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> cList &#123;</span><br><span class="line">		v.PrintStr()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们要明确是否有必要优化。如果只有示例中这么几行代码，我们完全没必要改写。那如果系统真复杂到一定程度，我们该怎么办呢？</p>
<p>这是一个很发散性的问题，我这里给出一个个人比较常用的解决方案，作为参考。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WithTypeName <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type <span class="keyword">string</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Country <span class="keyword">struct</span> &#123;</span><br><span class="line">	WithTypeName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCountry</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Printable</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Country&#123;WithTypeName&#123;<span class="string">&quot;Country&quot;</span>, name&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> City <span class="keyword">struct</span> &#123;</span><br><span class="line">	WithTypeName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCity</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Printable</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> City&#123;WithTypeName&#123;<span class="string">&quot;City&quot;</span>, name&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Printable <span class="keyword">interface</span> &#123;</span><br><span class="line">	PrintStr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c WithTypeName)</span> <span class="title">PrintStr</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s:%s\n&quot;</span>, c.Type, c.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c1 := NewCountry(<span class="string">&quot;China&quot;</span>)</span><br><span class="line">	c2 := NewCity(<span class="string">&quot;Beijing&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> cList = []Printable&#123;c1, c2&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> cList &#123;</span><br><span class="line">		v.PrintStr()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tip： 这种方法的好处有很多（先不谈弊端），比如可以将具体的实现<code>Country</code>和<code>City</code>私有化，不对外暴露实现细节。今天不做细谈。</p>
</blockquote>
<p>最后，送上一句经典：</p>
<p><strong>Program to an interface, not an implementation</strong></p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>经典品读</category>
      </categories>
      <tags>
        <tag>Go-Programming-Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>Go编程模式 - 2.基础编码下</title>
    <url>/2021/02/20/go-patterns/go-patterns-2/</url>
    <content><![CDATA[<blockquote>
<p> 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的<a href="https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save">链接</a>可能并不方便获取，所以我下载了一份<a href="https://github.com/Junedayday/code_reading/tree/master/doc/Go_Programming_Patterns.pdf">PDF</a>到git仓，方便大家阅读。我将结合自己的实际项目经历，与大家一起细品这份文档。</p>
</blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#Time">时间格式</a></li>
<li><a href="#Performance1">性能1</a></li>
<li><a href="#Performance2">性能2</a></li>
<li><a href="#Further">扩展阅读</a></li>
</ul>
<p>注：切勿过早优化！</p>
<h2 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h2><p>这部分的内容实战项目中用得不多，大家记住耗子叔总结出来的一个原则即可：</p>
<blockquote>
<p>尽量用<code>time.Time</code>和<code>time.Duration</code>，如果必须用string，尽量用<code>time.RFC3339</code></p>
</blockquote>
<p>然而现实情况并没有那么理想，实际项目中用得最频繁，还是自定义的<code>2006-01-02 15:04:05</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="Performance1"><a href="#Performance1" class="headerlink" title="Performance1"></a>Performance1</h2><h3 id="Itoa性能高于Sprint"><a href="#Itoa性能高于Sprint" class="headerlink" title="Itoa性能高于Sprint"></a>Itoa性能高于Sprint</h3><p>主要性能差异是由于<code>Sprint</code>针对的是复杂的字符串拼接，底层有个buffer，会在它的基础上进行一些字符串的拼接；</p>
<p>而<code>Itoa</code>直接通过一些位操作组合出字符串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 170 ns/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_Sprint</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = fmt.Sprint(rand.Int())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 81.9 ns/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_Itoa</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = strconv.Itoa(rand.Int())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="减少string到byte的转换"><a href="#减少string到byte的转换" class="headerlink" title="减少string到byte的转换"></a>减少string到byte的转换</h3><p>主要了解go的<code>string</code>到<code>[]byte</code>的转换还是比较耗性能的，但大部分情况下无法避免这种转换。</p>
<p>我们注意一种场景即可：从<code>[]byte</code>转换为<code>string</code>，再转换为<code>[]byte</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 43.9 ns/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_String2Bytes</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	data := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">	w := ioutil.Discard</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		w.Write([]<span class="keyword">byte</span>(data))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.06 ns/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_Bytes</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	data := []<span class="keyword">byte</span>(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">	w := ioutil.Discard</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		w.Write(data)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="切片能声明cap的，尽量初始化时声明"><a href="#切片能声明cap的，尽量初始化时声明" class="headerlink" title="切片能声明cap的，尽量初始化时声明"></a>切片能声明cap的，尽量初始化时声明</h3><p>了解slice的扩容机制就能很容易地理解。切片越长，影响越大。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> size = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4494 ns/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_NoCap</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++ &#123;</span><br><span class="line">			data = <span class="built_in">append</span>(data, k)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2086 ns/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_Cap</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, size)</span><br><span class="line">		<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++ &#123;</span><br><span class="line">			data = <span class="built_in">append</span>(data, k)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="避免用string做大量字符串的拼接"><a href="#避免用string做大量字符串的拼接" class="headerlink" title="避免用string做大量字符串的拼接"></a>避免用string做大量字符串的拼接</h3><p>频繁拼接字符串的场景并不多，了解即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strLen = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0.0107 ns/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_StringAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; strLen; n++ &#123;</span><br><span class="line">		str += <span class="string">&quot;x&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0.000154 ns/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_StringBuilder</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> builder strings.Builder</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; strLen; n++ &#123;</span><br><span class="line">		builder.WriteString(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0.000118 ns/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_BytesBuffer</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; strLen; n++ &#123;</span><br><span class="line">		buffer.WriteString(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Performance2"><a href="#Performance2" class="headerlink" title="Performance2"></a>Performance2</h2><h3 id="并行操作用sync-WaitGroup控制"><a href="#并行操作用sync-WaitGroup控制" class="headerlink" title="并行操作用sync.WaitGroup控制"></a>并行操作用sync.WaitGroup控制</h3><h3 id="热点内存分配用sync-Pool"><a href="#热点内存分配用sync-Pool" class="headerlink" title="热点内存分配用sync.Pool"></a>热点内存分配用sync.Pool</h3><p>注意一下，一定要是<code>热点</code>，千万不要 <strong>过早优化</strong></p>
<h3 id="倾向于使用lock-free的atomic包"><a href="#倾向于使用lock-free的atomic包" class="headerlink" title="倾向于使用lock-free的atomic包"></a>倾向于使用lock-free的atomic包</h3><p>除了常用的<code>CAS</code>操作，还有<code>atomic.Value</code>的<code>Store</code>和<code>Load</code>操作，这里简单地放个实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := atomic.Value&#123;&#125;</span><br><span class="line">	<span class="keyword">type</span> demo <span class="keyword">struct</span> &#123;</span><br><span class="line">		a <span class="keyword">int</span></span><br><span class="line">		b <span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v.Store(&amp;demo&#123;</span><br><span class="line">		a: <span class="number">1</span>,</span><br><span class="line">		b: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	data, ok := v.Load().(*demo)</span><br><span class="line">	fmt.Println(data, ok)</span><br><span class="line">	<span class="comment">// &amp;&#123;1 hello&#125; true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂场景下，还是建议用<code>mutex</code>。</p>
<h3 id="对磁盘的大量读写用bufio包"><a href="#对磁盘的大量读写用bufio包" class="headerlink" title="对磁盘的大量读写用bufio包"></a>对磁盘的大量读写用bufio包</h3><p><code>bufio.NewReader()</code>和<code>bufio.NewWriter()</code></p>
<h3 id="对正则表达式不要重复compile"><a href="#对正则表达式不要重复compile" class="headerlink" title="对正则表达式不要重复compile"></a>对正则表达式不要重复compile</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果匹配的格式不会变化，全局只初始化一次即可</span></span><br><span class="line"><span class="keyword">var</span> compiled = regexp.MustCompile(<span class="string">`^[a-z]+[0-9]+$`</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(compiled.MatchString(<span class="string">&quot;test123&quot;</span>))</span><br><span class="line">	fmt.Println(compiled.MatchString(<span class="string">&quot;test1234&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="用protobuf替换json"><a href="#用protobuf替换json" class="headerlink" title="用protobuf替换json"></a>用protobuf替换json</h3><p>go项目内部通信尽量用<code>protobuf</code>，但如果是对外提供api，比如web前端，<code>json</code>格式更方便。</p>
<h3 id="map的key尽量用int来代替string"><a href="#map的key尽量用int来代替string" class="headerlink" title="map的key尽量用int来代替string"></a>map的key尽量用int来代替string</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> size = <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0.0442 ns/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_MapInt</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">		m[i] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; size; n++ &#123;</span><br><span class="line">		_, _ = m[n]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0.180 ns/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_MapString</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">		m[strconv.Itoa(i)] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; size; n++ &#123;</span><br><span class="line">		_, _ = m[strconv.Itoa(n)]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例中<code>strconv.Itoa</code>函数对性能多少有点影响，但可以看到<code>string</code>和<code>int</code>的差距是在数量级的。</p>
<h2 id="Further"><a href="#Further" class="headerlink" title="Further"></a>Further</h2><p>PPT中给出了8个扩展阅读，大家根据情况自行阅读。</p>
<p>如果说你的时间只够读一个材料的话，我推荐大家反复品读一下<a href="https://golang.org/doc/effective_go.html">Effective Go</a></p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>经典品读</category>
      </categories>
      <tags>
        <tag>Go-Programming-Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>Go编程模式 - 3.继承与嵌入</title>
    <url>/2021/02/20/go-patterns/go-patterns-3/</url>
    <content><![CDATA[<blockquote>
<p> 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的<a href="https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save">链接</a>可能并不方便获取，所以我下载了一份<a href="https://github.com/Junedayday/code_reading/tree/master/doc/Go_Programming_Patterns.pdf">PDF</a>到git仓，方便大家阅读。我将结合自己的实际项目经历，与大家一起细品这份文档。</p>
</blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#Embedded">嵌入和委托</a></li>
<li><a href="#IoC">反转控制</a></li>
</ul>
<h2 id="Embedded"><a href="#Embedded" class="headerlink" title="Embedded"></a>Embedded</h2><p>接口定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义了两种interface</span></span><br><span class="line"><span class="keyword">type</span> Painter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Paint()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Clicker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Click()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Label 实现了 Painter</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标准组件，用于嵌入</span></span><br><span class="line"><span class="keyword">type</span> Widget <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Label 实现了 Painter</span></span><br><span class="line"><span class="keyword">type</span> Label <span class="keyword">struct</span> &#123;</span><br><span class="line">	Widget        <span class="comment">// Embedding (delegation)</span></span><br><span class="line">	Text   <span class="keyword">string</span> <span class="comment">// Aggregation</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(label Label)</span> <span class="title">Paint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p:Label.Paint(%q)\n&quot;</span>, &amp;label, label.Text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ListBox实现了Painter和Clicker</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListBox声明了Paint和Click，所以实现了Painter和Clicker</span></span><br><span class="line"><span class="keyword">type</span> ListBox <span class="keyword">struct</span> &#123;</span><br><span class="line">	Widget          <span class="comment">// Embedding (delegation)</span></span><br><span class="line">	Texts  []<span class="keyword">string</span> <span class="comment">// Aggregation</span></span><br><span class="line">	Index  <span class="keyword">int</span>      <span class="comment">// Aggregation</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(listBox ListBox)</span> <span class="title">Paint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;ListBox.Paint(%q)\n&quot;</span>, listBox.Texts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(listBox ListBox)</span> <span class="title">Click</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;ListBox.Click(%q)\n&quot;</span>, listBox.Texts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Button也实现了Painter和Clicker</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Button 继承了Label，所以直接实现了Painter</span></span><br><span class="line"><span class="comment">// 接下来，Button又声明了Paint和Click，所以实现了Painter和Clicker，其中Paint方法被覆</span></span><br><span class="line"><span class="keyword">type</span> Button <span class="keyword">struct</span> &#123;</span><br><span class="line">	Label <span class="comment">// Embedding (delegation)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(button Button)</span> <span class="title">Paint</span><span class="params">()</span></span> &#123; <span class="comment">// Override</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Button.Paint(%s)\n&quot;</span>, button.Text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(button Button)</span> <span class="title">Click</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Button.Click(%s)\n&quot;</span>, button.Text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	label := Label&#123;Widget&#123;<span class="number">10</span>, <span class="number">70</span>&#125;, <span class="string">&quot;Label&quot;</span>&#125;</span><br><span class="line">	button1 := Button&#123;Label&#123;Widget&#123;<span class="number">10</span>, <span class="number">70</span>&#125;, <span class="string">&quot;OK&quot;</span>&#125;&#125;</span><br><span class="line">	button2 := Button&#123;Label&#123;Widget&#123;<span class="number">50</span>, <span class="number">70</span>&#125;, <span class="string">&quot;Cancel&quot;</span>&#125;&#125;</span><br><span class="line">	listBox := ListBox&#123;Widget&#123;<span class="number">10</span>, <span class="number">40</span>&#125;,</span><br><span class="line">		[]<span class="keyword">string</span>&#123;<span class="string">&quot;AL&quot;</span>, <span class="string">&quot;AK&quot;</span>, <span class="string">&quot;AZ&quot;</span>, <span class="string">&quot;AR&quot;</span>&#125;, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, painter := <span class="keyword">range</span> []Painter&#123;label, listBox, button1, button2&#125; &#123;</span><br><span class="line">		painter.Paint()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, widget := <span class="keyword">range</span> []<span class="keyword">interface</span>&#123;&#125;&#123;label, listBox, button1, button2&#125; &#123;</span><br><span class="line">		<span class="comment">// 默认都实现了Painter接口，可以直接调用</span></span><br><span class="line">		widget.(Painter).Paint()</span><br><span class="line">		<span class="keyword">if</span> clicker, ok := widget.(Clicker); ok &#123;</span><br><span class="line">			clicker.Click()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子代码很多，我个人认为重点可以归纳为一句话：</p>
<p><strong>用嵌入实现方法的继承，减少代码的冗余度</strong></p>
<p>耗子叔的例子很精彩，不过我个人不太喜欢<code>interface</code>这个数据类型（main函数中），有没有什么优化的空间呢？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义两种方法的组合</span></span><br><span class="line"><span class="keyword">type</span> PaintClicker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Painter</span><br><span class="line">	Clicker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在上面的例子中，interface传参其实不太优雅，有没有更优雅的实现呢？那就用组合的interface</span></span><br><span class="line">	<span class="keyword">for</span> _, widget := <span class="keyword">range</span> []PaintClicker&#123;listBox, button1, button2&#125; &#123;</span><br><span class="line">		widget.Paint()</span><br><span class="line">		widget.Click()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p>先看一个Int集合的最基本实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Int集合，用于最基础的增删查</span></span><br><span class="line"><span class="keyword">type</span> IntSet <span class="keyword">struct</span> &#123;</span><br><span class="line">	data <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIntSet</span><span class="params">()</span> <span class="title">IntSet</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> IntSet&#123;<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *IntSet)</span> <span class="title">Add</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123; set.data[x] = <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *IntSet)</span> <span class="title">Delete</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123; <span class="built_in">delete</span>(set.data, x) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *IntSet)</span> <span class="title">Contains</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> set.data[x] &#125;</span><br></pre></td></tr></table></figure>

<p>现在，需求来了，我们希望对这个Int集合的操作是可撤销的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可撤销的Int集合，依赖于IntSet，我们看看基本实现</span></span><br><span class="line"><span class="keyword">type</span> UndoableIntSet <span class="keyword">struct</span> &#123; <span class="comment">// Poor style</span></span><br><span class="line">	IntSet    <span class="comment">// Embedding (delegation)</span></span><br><span class="line">	functions []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUndoableIntSet</span><span class="params">()</span> <span class="title">UndoableIntSet</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> UndoableIntSet&#123;NewIntSet(), <span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增</span></span><br><span class="line"><span class="comment">// 不存在元素时：添加元素，并新增撤销函数：删除</span></span><br><span class="line"><span class="comment">// 存在元素时：不做任何操作，并新增撤销函数：空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *UndoableIntSet)</span> <span class="title">Add</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// Override</span></span><br><span class="line">	<span class="keyword">if</span> !set.Contains(x) &#123;</span><br><span class="line">		set.data[x] = <span class="literal">true</span></span><br><span class="line">		set.functions = <span class="built_in">append</span>(set.functions, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; set.Delete(x) &#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		set.functions = <span class="built_in">append</span>(set.functions, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除，与新增相反</span></span><br><span class="line"><span class="comment">// 存在元素时：删除元素，并新增撤销函数：新增</span></span><br><span class="line"><span class="comment">// 不存在元素时：不做任何操作，并新增撤销函数：空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *UndoableIntSet)</span> <span class="title">Delete</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// Override</span></span><br><span class="line">	<span class="keyword">if</span> set.Contains(x) &#123;</span><br><span class="line">		<span class="built_in">delete</span>(set.data, x)</span><br><span class="line">		set.functions = <span class="built_in">append</span>(set.functions, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; set.Add(x) &#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		set.functions = <span class="built_in">append</span>(set.functions, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 撤销：执行最后一个撤销函数function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *UndoableIntSet)</span> <span class="title">Undo</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(set.functions) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;No functions to undo&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	index := <span class="built_in">len</span>(set.functions) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> function := set.functions[index]; function != <span class="literal">nil</span> &#123;</span><br><span class="line">		function()</span><br><span class="line">		set.functions[index] = <span class="literal">nil</span> <span class="comment">// For garbage collection</span></span><br><span class="line">	&#125;</span><br><span class="line">	set.functions = set.functions[:index]</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实现是一种顺序逻辑的思路，整体还是挺麻烦的。有没有优化思路呢？</p>
<p>定义一下Undo这个结构。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Undo []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(undo *Undo)</span> <span class="title">Add</span><span class="params">(function <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	*undo = <span class="built_in">append</span>(*undo, function)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(undo *Undo)</span> <span class="title">Undo</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	functions := *undo</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(functions) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;No functions to undo&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	index := <span class="built_in">len</span>(functions) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> function := functions[index]; function != <span class="literal">nil</span> &#123;</span><br><span class="line">		function()</span><br><span class="line">		functions[index] = <span class="literal">nil</span> <span class="comment">// For garbage collection</span></span><br><span class="line">	&#125;</span><br><span class="line">	*undo = functions[:index]</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细品一下这里的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSet2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	data <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span></span><br><span class="line">	undo Undo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIntSet2</span><span class="params">()</span> <span class="title">IntSet2</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> IntSet2&#123;data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *IntSet2)</span> <span class="title">Undo</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> set.undo.Undo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *IntSet2)</span> <span class="title">Contains</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> set.data[x]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *IntSet2)</span> <span class="title">Add</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !set.Contains(x) &#123;</span><br><span class="line">		set.data[x] = <span class="literal">true</span></span><br><span class="line">		set.undo.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; set.Delete(x) &#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		set.undo.Add(<span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *IntSet2)</span> <span class="title">Delete</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> set.Contains(x) &#123;</span><br><span class="line">		<span class="built_in">delete</span>(set.data, x)</span><br><span class="line">		set.undo.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; set.Add(x) &#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		set.undo.Add(<span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看一下，这块代码的前后逻辑有了啥变化：</p>
<ol>
<li>之前，撤销函数是在Add/Delete时添加的，函数中包含了IntSet的操作，也就是 <strong>Undo依赖IntSet</strong></li>
<li>而修改之后，撤销函数被抽象为Undo，撤销相关的工作直接调用Undo相关的工作即可，也就是 <strong>IntSet依赖Undo</strong></li>
</ol>
<p>我们再来分析一下</p>
<ul>
<li>Undo是控制逻辑 - 撤销动作</li>
<li>IntSet是业务逻辑 - 保存数据的功能。</li>
</ul>
<p><strong>业务逻辑依赖控制逻辑，才能保证在复杂业务逻辑变化场景下，代码更健壮！</strong></p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>经典品读</category>
      </categories>
      <tags>
        <tag>Go-Programming-Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>Go编程模式 - 4.错误处理</title>
    <url>/2021/02/20/go-patterns/go-patterns-4/</url>
    <content><![CDATA[<blockquote>
<p> 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的<a href="https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save">链接</a>可能并不方便获取，所以我下载了一份<a href="https://github.com/Junedayday/code_reading/tree/master/doc/Go_Programming_Patterns.pdf">PDF</a>到git仓，方便大家阅读。我将结合自己的实际项目经历，与大家一起细品这份文档。</p>
</blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#Functional">函数式处理</a></li>
<li><a href="#ErrorObject">对象嵌入错误</a></li>
<li><a href="#Wrap">错误包装</a></li>
</ul>
<h2 id="Functional"><a href="#Functional" class="headerlink" title="Functional"></a>Functional</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Number <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="keyword">int</span></span><br><span class="line">	b <span class="keyword">string</span></span><br><span class="line">	c <span class="keyword">bool</span></span><br><span class="line">	d []<span class="keyword">int32</span></span><br><span class="line">	e error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Number)</span> <span class="title">parse</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := binary.Read(r, binary.BigEndian, &amp;n.a); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := binary.Read(r, binary.BigEndian, &amp;n.b); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := binary.Read(r, binary.BigEndian, &amp;n.c); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := binary.Read(r, binary.BigEndian, &amp;n.d); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := binary.Read(r, binary.BigEndian, &amp;n.e); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>引入了函数式编程的方式，我们看看有什么改变</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Number)</span> <span class="title">parse</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 先定义一个error</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义函数，注意这里的err的作用域是来自上面定义的</span></span><br><span class="line">	read := <span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 先检查error，如果已经有错误则不检查</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		err = binary.Read(r, binary.BigEndian, data)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意，这个函数的调用逻辑和之前的差别在于一点：</span></span><br><span class="line">	<span class="comment">// 即使前面的发生了error，下面的函数也会被调用</span></span><br><span class="line">	read(&amp;n.a)</span><br><span class="line">	read(&amp;n.b)</span><br><span class="line">	read(&amp;n.c)</span><br><span class="line">	read(&amp;n.d)</span><br><span class="line">	read(&amp;n.e)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ErrorObject"><a href="#ErrorObject" class="headerlink" title="ErrorObject"></a>ErrorObject</h2><p>先看一个标准库中的实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	input := bytes.NewReader([]<span class="keyword">byte</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 扫描数据，这里不会直接返回错误</span></span><br><span class="line">	scanner := bufio.NewScanner(input)</span><br><span class="line">	<span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">		token := scanner.Text()</span><br><span class="line">		fmt.Println(token)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 从Err()方法中获取错误</span></span><br><span class="line">	<span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的根本思想，是将<code>error</code>嵌入到了对象中。那我们借鉴一下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">	r   io.Reader</span><br><span class="line">	err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">read</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.err == <span class="literal">nil</span> &#123;</span><br><span class="line">		r.err = binary.Read(r.r, binary.BigEndian, data)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Number)</span> <span class="title">parse</span><span class="params">(reader io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	r := Reader&#123;r: reader&#125;</span><br><span class="line"></span><br><span class="line">	r.read(&amp;n.a)</span><br><span class="line">	r.read(&amp;n.b)</span><br><span class="line">	r.read(&amp;n.c)</span><br><span class="line">	r.read(&amp;n.d)</span><br><span class="line">	r.read(&amp;n.e)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>捎带提一句：个人不太喜欢上面<code>scanner</code>的错误处理方式，这个要求使用方对这个包很熟悉，否则很容易忘掉后面的错误处理逻辑。但后面处理错误的逻辑，就很直接地将错误返回，可读性很强。</p>
<h2 id="Wrap"><a href="#Wrap" class="headerlink" title="Wrap"></a>Wrap</h2><p>耗子叔给的例子是调用了<code>github.com/pkg/errors</code>下的wrap包，不过我更倾向于直接用原生的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 原始 error</span></span><br><span class="line">	err := errors.New(<span class="string">&quot;level 1&quot;</span>)</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">	<span class="comment">// level 1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// wrap一下error，注意error的占位符是%w</span></span><br><span class="line">	wraped := fmt.Errorf(<span class="string">&quot;%v: %w&quot;</span>, <span class="string">&quot;level 2&quot;</span>, err)</span><br><span class="line">	fmt.Println(wraped)</span><br><span class="line">	<span class="comment">// level 2: level 1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// unwrap 后获得原来的错误</span></span><br><span class="line">	unwraped := errors.Unwrap(wraped)</span><br><span class="line">	fmt.Println(unwraped)</span><br><span class="line">	<span class="comment">// level 1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 过度unwrap会导致错误变成nil</span></span><br><span class="line">	unwraped2 := errors.Unwrap(unwraped)</span><br><span class="line">	fmt.Println(unwraped2)</span><br><span class="line">	<span class="comment">// nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但在实际项目实践中，<code>Wrap</code>的这个特性并不好用：</p>
<p>如何Wrap Error，在多人协同开发、多模块开发过程中，很难统一。而一旦不统一，容易出现示例中的过度Unwrap的情况。</p>
<p>所以，我认为与其花大精力在制定错误的标准上，还不如利用<code>fmt.Errorf</code>将错误信息直观地表述出来。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>经典品读</category>
      </categories>
      <tags>
        <tag>Go-Programming-Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>Go编程模式 - 5.函数式选项</title>
    <url>/2021/02/20/go-patterns/go-patterns-5/</url>
    <content><![CDATA[<blockquote>
<p> 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的<a href="https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save">链接</a>可能并不方便获取，所以我下载了一份<a href="https://github.com/Junedayday/code_reading/tree/master/doc/Go_Programming_Patterns.pdf">PDF</a>到git仓，方便大家阅读。我将结合自己的实际项目经历，与大家一起细品这份文档。</p>
</blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#ServerConfig">一个常见的HTTP服务器</a></li>
<li><a href="#SplitConfig">拆分可选配置</a></li>
<li><a href="#Functional-Option">函数式选项</a></li>
<li><a href="#Further">更进一步</a></li>
</ul>
<h2 id="ServerConfig"><a href="#ServerConfig" class="headerlink" title="ServerConfig"></a>ServerConfig</h2><p>我们先来看看一个常见的HTTP服务器的配置，它区分了2个必填参数与4个非必填参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ServerCfg <span class="keyword">struct</span> &#123;</span><br><span class="line">	Addr     <span class="keyword">string</span>        <span class="comment">// 必填</span></span><br><span class="line">	Port     <span class="keyword">int</span>           <span class="comment">// 必填</span></span><br><span class="line">	Protocol <span class="keyword">string</span>        <span class="comment">// 非必填</span></span><br><span class="line">	Timeout  time.Duration <span class="comment">// 非必填</span></span><br><span class="line">	MaxConns <span class="keyword">int</span>           <span class="comment">// 非必填</span></span><br><span class="line">	TLS      *tls.Config   <span class="comment">// 非必填</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们要实现非常多种方法，来支持各种非必填的情况，示例如下</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>)</span> <span class="params">(*Server, error)</span></span>                                   &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTLSServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, tls *tls.Config)</span> <span class="params">(*Server, error)</span></span>               &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServerWithTimeout</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, timeout time.Duration)</span> <span class="params">(*Server, error)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTLSServerWithMaxConnAndTimeout</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, maxconns <span class="keyword">int</span>, timeout time.Duration, tls *tls.Config)</span> <span class="params">(*Server, error)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SplitConfig"><a href="#SplitConfig" class="headerlink" title="SplitConfig"></a>SplitConfig</h2><p>编程的一大重点，就是要 <code>分离变化点和不变点</code>。这里，我们可以将必填项认为是不变点，而非必填则是变化点。</p>
<p>我们将非必填的选项拆分出来。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	Protocol <span class="keyword">string</span></span><br><span class="line">	Timeout  time.Duration</span><br><span class="line">	MaxConns <span class="keyword">int</span></span><br><span class="line">	TLS      *tls.Config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	Addr <span class="keyword">string</span></span><br><span class="line">	Port <span class="keyword">int</span></span><br><span class="line">	Conf *Config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, conf *Config)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Server&#123;</span><br><span class="line">		Addr: addr,</span><br><span class="line">		Port: port,</span><br><span class="line">		Conf: conf,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	srv1, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">9000</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	conf := Config&#123;Protocol: <span class="string">&quot;tcp&quot;</span>, Timeout: <span class="number">60</span> * time.Second&#125;</span><br><span class="line">	srv2, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">9000</span>, &amp;conf)</span><br><span class="line"></span><br><span class="line">	fmt.Println(srv1, srv2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，其实已经满足大部分的开发需求了。那么，我们将进入今天的重点。</p>
<h2 id="Functional-Option"><a href="#Functional-Option" class="headerlink" title="Functional Option"></a>Functional Option</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	Addr     <span class="keyword">string</span></span><br><span class="line">	Port     <span class="keyword">int</span></span><br><span class="line">	Protocol <span class="keyword">string</span></span><br><span class="line">	Timeout  time.Duration</span><br><span class="line">	MaxConns <span class="keyword">int</span></span><br><span class="line">	TLS      *tls.Config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个Option类型的函数，它操作了Server这个对象</span></span><br><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*Server)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是对四个可选参数的配置函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Protocol</span><span class="params">(p <span class="keyword">string</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">		s.Protocol = p</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Timeout</span><span class="params">(timeout time.Duration)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">		s.Timeout = timeout</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxConns</span><span class="params">(maxconns <span class="keyword">int</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">		s.MaxConns = maxconns</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TLS</span><span class="params">(tls *tls.Config)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">		s.TLS = tls</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用到了不定参数的特性，将任意个option应用到Server上</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, options ...Option)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 先填写默认值</span></span><br><span class="line">	srv := Server&#123;</span><br><span class="line">		Addr:     addr,</span><br><span class="line">		Port:     port,</span><br><span class="line">		Protocol: <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">		Timeout:  <span class="number">30</span> * time.Second,</span><br><span class="line">		MaxConns: <span class="number">1000</span>,</span><br><span class="line">		TLS:      <span class="literal">nil</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 应用任意个option</span></span><br><span class="line">	<span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">		option(&amp;srv)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;srv, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">1024</span>)</span><br><span class="line">	s2, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">2048</span>, Protocol(<span class="string">&quot;udp&quot;</span>))</span><br><span class="line">	s3, _ := NewServer(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8080</span>, Timeout(<span class="number">300</span>*time.Second), MaxConns(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">	fmt.Println(s1, s2, s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>耗子哥给出了6个点，但我感受最深的是以下两点：</p>
<ol>
<li>可读性强，将配置都转化成了对应的函数项option</li>
<li>扩展性好，新增参数只需要增加一个对应的方法</li>
</ol>
<p>那么对应的代价呢？就是需要编写多个Option函数，代码量会有所增加。</p>
<p>如果大家对这个感兴趣，可以去看一下Rob Pike的<a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html">这篇blog</a> 。</p>
<h2 id="Further"><a href="#Further" class="headerlink" title="Further"></a>Further</h2><p>顺着耗子叔的例子，我们再思考一下，如果配置的过程中有参数限制，那么我们该怎么办呢？</p>
<p>首先，我们改造一下函数Option</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回错误</span></span><br><span class="line"><span class="keyword">type</span> OptionWithError <span class="function"><span class="keyword">func</span><span class="params">(*Server)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>然后，我们改造一下其中两个函数作为示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Protocol</span><span class="params">(p <span class="keyword">string</span>)</span> <span class="title">OptionWithError</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;empty protocol&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		s.Protocol = p</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Timeout</span><span class="params">(timeout time.Duration)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> timeout.Seconds() &lt; <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;time out should not less than 1s&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		s.Timeout = timeout</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再做一次改造</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, options ...OptionWithError)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line">	srv := Server&#123;</span><br><span class="line">		Addr:     addr,</span><br><span class="line">		Port:     port,</span><br><span class="line">		Protocol: <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">		Timeout:  <span class="number">30</span> * time.Second,</span><br><span class="line">		MaxConns: <span class="number">1000</span>,</span><br><span class="line">		TLS:      <span class="literal">nil</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 增加了一个参数验证的步骤</span></span><br><span class="line">	<span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">		<span class="keyword">if</span> err := option(&amp;srv); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;srv, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改造基本到此完成，希望能给大家带来一定的帮助。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>经典品读</category>
      </categories>
      <tags>
        <tag>Go-Programming-Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>Go编程模式 - 6-映射、归约与过滤</title>
    <url>/2021/02/20/go-patterns/go-patterns-6/</url>
    <content><![CDATA[<blockquote>
<p> 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的<a href="https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save">链接</a>可能并不方便获取，所以我下载了一份<a href="https://github.com/Junedayday/code_reading/tree/master/doc/Go_Programming_Patterns.pdf">PDF</a>到git仓，方便大家阅读。我将结合自己的实际项目经历，与大家一起细品这份文档。</p>
</blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#Map/Reduce/Filter">映射、规约与过滤</a></li>
<li><a href="#Scenarios">应用场景探索</a></li>
<li><a href="#Generic">泛型</a></li>
</ul>
<h2 id="Map-Reduce-Filter"><a href="#Map-Reduce-Filter" class="headerlink" title="Map/Reduce/Filter"></a>Map/Reduce/Filter</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapUpCase</span><span class="params">(arr []<span class="keyword">string</span>, fn <span class="keyword">func</span>(s <span class="keyword">string</span>)</span> <span class="title">string</span>) []<span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> newArray = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, it := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		newArray = <span class="built_in">append</span>(newArray, fn(it))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapLen</span><span class="params">(arr []<span class="keyword">string</span>, fn <span class="keyword">func</span>(s <span class="keyword">string</span>)</span> <span class="title">int</span>) []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> newArray = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, it := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		newArray = <span class="built_in">append</span>(newArray, fn(it))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reduce</span><span class="params">(arr []<span class="keyword">string</span>, fn <span class="keyword">func</span>(s <span class="keyword">string</span>)</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, it := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		sum += fn(it)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Filter</span><span class="params">(arr []<span class="keyword">string</span>, fn <span class="keyword">func</span>(n <span class="keyword">string</span>)</span> <span class="title">bool</span>) []<span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> newArray = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, it := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		<span class="keyword">if</span> fn(it) &#123;</span><br><span class="line">			newArray = <span class="built_in">append</span>(newArray, it)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> list = []<span class="keyword">string</span>&#123;<span class="string">&quot;Hao&quot;</span>, <span class="string">&quot;Chen&quot;</span>, <span class="string">&quot;MegaEase&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 元素一对一映射 string-&gt;string</span></span><br><span class="line">	x := MapUpCase(list, <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> strings.ToUpper(s)</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, x)</span><br><span class="line">	<span class="comment">// [HAO CHEN MEGAEASE]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 元素一对一映射 string-&gt;int</span></span><br><span class="line">	y := MapLen(list, <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, y)</span><br><span class="line">	<span class="comment">// [3 4 8]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 归约：多个元素-&gt;一个元素</span></span><br><span class="line">	z := Reduce(list, <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, z)</span><br><span class="line">	<span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 过滤：过滤不满足条件的元素</span></span><br><span class="line">	f := Filter(list, <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(s) &gt; <span class="number">3</span></span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, f)</span><br><span class="line">	<span class="comment">// [Chen MegaEase]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Scenarios"><a href="#Scenarios" class="headerlink" title="Scenarios"></a>Scenarios</h2><ul>
<li><code>Map</code> 是一对一的场景，是 <strong>循环中对数据加工处理</strong> </li>
<li><code>Reduce</code> 是多对一，是 <strong>数据聚合处理</strong></li>
<li><code>Filter</code>是过滤的处理，是 <strong>数据有效性</strong></li>
</ul>
<p>我们以常见的账单统计相关的功能，我们会遇上大量的此类情况：</p>
<ol>
<li>统计消费总额 - Reduce</li>
<li>统计用户A - Filter</li>
<li>统计本月 - Filter</li>
<li>费用转化为美金 - Map</li>
</ol>
<p>在综合各个因素后，就是大量复杂的、管道式的Map/Reduce/Filter操作。</p>
<blockquote>
<p>延伸思考一下，这块和SQL语句非常类似</p>
</blockquote>
<h2 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h2><p>耗子叔在接下来的部分，展示了用<code>reflect</code>处理泛型情况。我这边简单地截取Map部分解析一下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TransformInPlace</span><span class="params">(slice, function <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> transform(slice, function, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map的转换函数，slice为切片，function为对应的函数，inPlace表示是否原地处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transform</span><span class="params">(slice, function <span class="keyword">interface</span>&#123;&#125;, inPlace <span class="keyword">bool</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="comment">// 类型判断，必须为切片</span></span><br><span class="line">	sliceInType := reflect.ValueOf(slice)</span><br><span class="line">	<span class="keyword">if</span> sliceInType.Kind() != reflect.Slice &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;transform: not slice&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 函数的签名判断，即函数的入参必须和slice里的元素一致</span></span><br><span class="line">	fn := reflect.ValueOf(function)</span><br><span class="line">	elemType := sliceInType.Type().Elem()</span><br><span class="line">	<span class="keyword">if</span> !verifyFuncSignature(fn, elemType, <span class="literal">nil</span>) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;trasform: function must be of type func(&quot;</span> + sliceInType.Type().Elem().String() + <span class="string">&quot;) outputElemType&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果是原地，则直接处理函数，结果会保存到入参中（这时入参一般为指针）</span></span><br><span class="line">	<span class="comment">// 如果非原地，那就需要新建一个切片，用来保存结果</span></span><br><span class="line">	sliceOutType := sliceInType</span><br><span class="line">	<span class="keyword">if</span> !inPlace &#123;</span><br><span class="line">		sliceOutType = reflect.MakeSlice(reflect.SliceOf(fn.Type().Out(<span class="number">0</span>)), sliceInType.Len(), sliceInType.Len())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; sliceInType.Len(); i++ &#123;</span><br><span class="line">		sliceOutType.Index(i).Set(fn.Call([]reflect.Value&#123;sliceInType.Index(i)&#125;)[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sliceOutType.Interface()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">verifyFuncSignature</span><span class="params">(fn reflect.Value, types ...reflect.Type)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 类型判断</span></span><br><span class="line">	<span class="keyword">if</span> fn.Kind() != reflect.Func &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 入参数量和函数签名一致，出参必须只有一个</span></span><br><span class="line">	<span class="keyword">if</span> (fn.Type().NumIn() != <span class="built_in">len</span>(types)<span class="number">-1</span>) || (fn.Type().NumOut() != <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每个函数入参的类型校验</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(types)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> fn.Type().In(i) != types[i] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 出参类型的校验</span></span><br><span class="line">	outType := types[<span class="built_in">len</span>(types)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">if</span> outType != <span class="literal">nil</span> &amp;&amp; fn.Type().Out(<span class="number">0</span>) != outType &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细阅读这一块代码，我们能学到很多反射方面的知识，尤其是并不常用的函数相关的。</p>
<p>但是，我不建议大家在实际项目中直接使用这一块代码，毕竟其中大量的反射操作是比较耗时的，尤其是在延迟非常敏感的web服务器中。</p>
<p>如果我们多花点时间、直接编写指定类型的代码，那么就能在编译期发现错误，运行时也可以跳过反射的耗时。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>经典品读</category>
      </categories>
      <tags>
        <tag>Go-Programming-Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>Go编程模式 - 7-代码生成</title>
    <url>/2021/02/20/go-patterns/go-patterns-7/</url>
    <content><![CDATA[<blockquote>
<p> 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的<a href="https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save">链接</a>可能并不方便获取，所以我下载了一份<a href="https://github.com/Junedayday/code_reading/tree/master/doc/Go_Programming_Patterns.pdf">PDF</a>到git仓，方便大家阅读。我将结合自己的实际项目经历，与大家一起细品这份文档。</p>
</blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#Simple-Script">简单脚本准备</a><ul>
<li><a href="#Template">模板文件</a></li>
<li><a href="#Shell">运行脚本</a></li>
<li><a href="#Generate-File">入口文件</a></li>
<li><a href="#Generation">运行原理</a></li>
</ul>
</li>
<li><a href="#genny">类型替换工具genny</a></li>
<li><a href="#go-bindata">任意文件转Go</a></li>
<li><a href="#stringer">字符串生成工具stringer</a></li>
</ul>
<h2 id="Simple-Script"><a href="#Simple-Script" class="headerlink" title="Simple Script"></a>Simple Script</h2><p>为了让大家快速了解这块，我们从一个最简单的例子入手。</p>
<h3 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h3><p>首先创建一个模板Go文件，即容器模板：container.tmp.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> PACKAGE_NAME</span><br><span class="line"><span class="keyword">type</span> GENERIC_NAMEContainer <span class="keyword">struct</span> &#123;</span><br><span class="line">    s []GENERIC_TYPE</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGENERIC_NAMEContainer</span><span class="params">()</span> *<span class="title">GENERIC_NAMEContainer</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;GENERIC_NAMEContainer&#123;s: []GENERIC_TYPE&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *GENERIC_NAMEContainer)</span> <span class="title">Put</span><span class="params">(val GENERIC_TYPE)</span></span> &#123;</span><br><span class="line">    c.s = <span class="built_in">append</span>(c.s, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *GENERIC_NAMEContainer)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">GENERIC_TYPE</span></span> &#123;</span><br><span class="line">    r := c.s[<span class="number">0</span>]</span><br><span class="line">    c.s = c.s[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>生成的shell脚本，gen.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">SRC_FILE=$&#123;1&#125;</span><br><span class="line">PACKAGE=$&#123;2&#125;</span><br><span class="line">TYPE=$&#123;3&#125;</span><br><span class="line">DES=$&#123;4&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">uppcase the first char</span></span><br><span class="line">PREFIX=&quot;$(tr &#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27; &lt;&lt;&lt; $&#123;TYPE:0:1&#125;)$&#123;TYPE:1&#125;&quot;</span><br><span class="line"></span><br><span class="line">DES_FILE=$(echo $&#123;TYPE&#125;| tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)_$&#123;DES&#125;.go</span><br><span class="line"></span><br><span class="line">sed &#x27;s/PACKAGE_NAME/&#x27;&quot;$&#123;PACKAGE&#125;&quot;&#x27;/g&#x27; $&#123;SRC_FILE&#125; | \</span><br><span class="line">    sed &#x27;s/GENERIC_TYPE/&#x27;&quot;$&#123;TYPE&#125;&quot;&#x27;/g&#x27; | \</span><br><span class="line">    sed &#x27;s/GENERIC_NAME/&#x27;&quot;$&#123;PREFIX&#125;&quot;&#x27;/g&#x27; &gt; $&#123;DES_FILE&#125;</span><br></pre></td></tr></table></figure>

<p>四个参数分别为</p>
<ul>
<li>源文件名</li>
<li>包名</li>
<li>类型</li>
<li>文件后缀名</li>
</ul>
<h3 id="Generate-File"><a href="#Generate-File" class="headerlink" title="Generate File"></a>Generate File</h3><p>最后，增加一个创建代码的go文件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:generate ./gen.sh ./template/container.tmp.go gen uint32 container</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateUint32Example</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> u <span class="keyword">uint32</span> = <span class="number">42</span></span><br><span class="line">    c := NewUint32Container()</span><br><span class="line">    c.Put(u)</span><br><span class="line">    v := c.Get()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;generateExample: %d (%T)\n&quot;</span>, v, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate ./gen.sh ./template/container.tmp.go gen string container</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateStringExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    c := NewStringContainer()</span><br><span class="line">    c.Put(s)</span><br><span class="line">    v := c.Get()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;generateExample: %s (%T)\n&quot;</span>, v, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h3><p>我们运行一下 <code>go generate</code>，就能产生对应的文件。</p>
<ol>
<li>运行go generate，工具会扫描所有的文件</li>
<li>如果发现注释有带 go:generate的，会自动运行后面的命令</li>
<li>通过命令生成的代码，会在源文件添加提示，告诉他人这是自动生成的代码，不要编辑</li>
</ol>
<p>因此，我们不仅仅可以用<code>shell</code>脚本，也可以用各种二进制工具来生成代码。值得一提的是，像Kubernetes这种重量级的项目，大量地应用了这种特性。后面我也会和大家分享在开发web项目中的应用。</p>
<p>下面，我也来介绍几个个人认为比较有用的工具。</p>
<h2 id="genny"><a href="#genny" class="headerlink" title="genny"></a>genny</h2><p>源项目链接：<a href="https://github.com/cheekybits/genny">https://github.com/cheekybits/genny</a></p>
<h3 id="Go文件示例"><a href="#Go文件示例" class="headerlink" title="Go文件示例"></a>Go文件示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/cheekybits/genny/generic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> this is how easy it is to define a generic type</span></span><br><span class="line"><span class="keyword">type</span> Something generic.Type</span><br><span class="line"></span><br><span class="line"><span class="comment">// SomethingQueue is a queue of Somethings.</span></span><br><span class="line"><span class="keyword">type</span> SomethingQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">  items []Something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSomethingQueue</span><span class="params">()</span> *<span class="title">SomethingQueue</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;SomethingQueue&#123;items: <span class="built_in">make</span>([]Something, <span class="number">0</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *SomethingQueue)</span> <span class="title">Push</span><span class="params">(item Something)</span></span> &#123;</span><br><span class="line">  q.items = <span class="built_in">append</span>(q.items, item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *SomethingQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">Something</span></span> &#123;</span><br><span class="line">  item := q.items[<span class="number">0</span>]</span><br><span class="line">  q.items = q.items[<span class="number">1</span>:]</span><br><span class="line">  <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat source.go | genny gen &quot;Something=string&quot;</span><br></pre></td></tr></table></figure>

<p>官方示例还是采用的是shell脚本，建议替换到 go:generate 中，这样的代码更统一</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>可以简单地理解成一个类型替换的工具（PS：擅长用sed脚本的朋友也可直接通过shell脚本实现）</p>
<h2 id="go-bindata"><a href="#go-bindata" class="headerlink" title="go-bindata"></a>go-bindata</h2><p>源网站链接：<a href="https://github.com/go-bindata/go-bindata">https://github.com/go-bindata/go-bindata</a></p>
<p>go-bindata的功能是将任意格式的源文件，转化为Go代码，使我们无需再去打开文件读取了。</p>
<p>这个工具多用在静态网页转化为Go代码（不符合前后端分离的实践），所以具体的使用方式我就不细讲了，大家有兴趣的可以自行阅读教程。</p>
<p>但它有两个优点值得我们关注：无需再进行文件读取操作、压缩。</p>
<h2 id="stringer"><a href="#stringer" class="headerlink" title="stringer"></a>stringer</h2><p>stringer是官方提供一个字符串工具，我个人非常推荐大家使用</p>
<p>文档链接：<a href="https://pkg.go.dev/golang.org/x/tools/cmd/stringer">https://pkg.go.dev/golang.org/x/tools/cmd/stringer</a> </p>
<h3 id="Go文件"><a href="#Go文件" class="headerlink" title="Go文件"></a>Go文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> painkiller</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pill <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Placebo Pill = <span class="literal">iota</span></span><br><span class="line">	Aspirin</span><br><span class="line">	Ibuprofen</span><br><span class="line">	Paracetamol</span><br><span class="line">	Acetaminophen = Paracetamol</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:generate stringer -type=Pill</span></span><br></pre></td></tr></table></figure>

<p>于是，就会生成对应的方法<code>func (Pill) String() string</code>，也就是直接转化成了其命名。</p>
<h3 id="价值"><a href="#价值" class="headerlink" title="价值"></a>价值</h3><p>Go语言在调用 <code>fmt</code> 等相关包时，如果要将某个变量转化为字符串，默认会寻找它的<code>String()</code>方法。</p>
<p>这时，<strong>良好的命名</strong> 能体现出其价值。尤其是在错误码的处理上，无需再去查询错误码对应的错误内容，直接可以通过命名了解。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>经典品读</category>
      </categories>
      <tags>
        <tag>Go-Programming-Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>Go编程模式 - 8-装饰、管道和访问者模式</title>
    <url>/2021/02/20/go-patterns/go-patterns-8/</url>
    <content><![CDATA[<blockquote>
<p> 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的<a href="https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save">链接</a>可能并不方便获取，所以我下载了一份<a href="https://github.com/Junedayday/code_reading/tree/master/doc/Go_Programming_Patterns.pdf">PDF</a>到git仓，方便大家阅读。我将结合自己的实际项目经历，与大家一起细品这份文档。</p>
</blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#Decoration">装饰模式</a></li>
<li><a href="#Pipeline">管道模式</a></li>
<li><a href="#Visitorl">访问者模式</a></li>
</ul>
<p>今天，我会抛开官方的定义，简单介绍一下三种设计模式。</p>
<blockquote>
<p> 后续会有介绍Go语言设计模式Design Patterns的系列，会更具理论性。</p>
</blockquote>
<h2 id="Decoration"><a href="#Decoration" class="headerlink" title="Decoration"></a>Decoration</h2><p>代码实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decorator</span><span class="params">(f <span class="keyword">func</span>(s <span class="keyword">string</span>)</span>) <span class="title">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Started&quot;</span>)</span><br><span class="line">		f(s)</span><br><span class="line">		fmt.Println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一句话解释：<strong>在函数f前后，添加装饰性的功能函数，但不改变函数本身的行为</strong>。</p>
<p>这种设计模式，对一些被高频率调用的代码非常有用：</p>
<ol>
<li>HTTP Server被调用的handler</li>
<li>HTTP Client发送请求</li>
<li>对MySQL的操作</li>
</ol>
<p>而装饰性的功能，常见的有：</p>
<ol>
<li>打印相关的日志信息（Debug中非常有用！）</li>
<li>耗时相关的计算</li>
<li>监控埋点</li>
</ol>
<h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>代码示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HttpHandlerDecorator <span class="function"><span class="keyword">func</span><span class="params">(http.HandlerFunc)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handler</span><span class="params">(h http.HandlerFunc, decors ...HttpHandlerDecorator)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> decors &#123;</span><br><span class="line">        d := decors[<span class="built_in">len</span>(decors)<span class="number">-1</span>-i] <span class="comment">// iterate in reverse</span></span><br><span class="line">        h = d(h)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一句话解释：<strong>用不定参数的特性，将入参中的函数，逐个应用到对象上</strong></p>
<blockquote>
<p>看到这里，如果你能想起之前 <code>Functional Option</code> 那篇，会发现有这块的影子。</p>
</blockquote>
<p>主要应用于： 有多种可选择的配置（对应Field）或处理（对应方法）的复杂对象。</p>
<p>耗子叔在后面又增加了一些用Goroutine+Channel的方式，其实就是讲Channel作为一个管道的承载体。</p>
<h2 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor"></a>Visitor</h2><p>关于访问者设计者模式，我之前在Kubernetes源码分析中专门分析了源码。今天，我们也简单地过一下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义访问的函数类型</span></span><br><span class="line"><span class="keyword">type</span> VisitorFunc <span class="function"><span class="keyword">func</span><span class="params">(*Info, error)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Visitor接口设计</span></span><br><span class="line"><span class="keyword">type</span> Visitor <span class="keyword">interface</span> &#123;</span><br><span class="line">	Visit(VisitorFunc) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源对象</span></span><br><span class="line"><span class="keyword">type</span> Info <span class="keyword">struct</span> &#123;</span><br><span class="line">	Namespace   <span class="keyword">string</span></span><br><span class="line">	Name        <span class="keyword">string</span></span><br><span class="line">	OtherThings <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Visitor函数应用到资源对象上</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(info *Info)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fn(info, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看其中一个实现：NameVisitor，其余的也类似，这样就能注入对应的Visitor</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NameVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">	visitor Visitor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v NameVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v.visitor.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="comment">// 这里是运行入参中的VisitorFunc，这一块的逻辑有点像pipeline</span></span><br><span class="line">		err = fn(info, err)</span><br><span class="line">		<span class="comment">// NameVisitor自己实现的Visit逻辑</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，Kubernetes中的Visitor还有进一步的封装，包括遇到错误时的处理，这里不细讲，有兴趣的朋友可以看看我对那一篇的分析。</p>
<p>Visitor模式最大的优点就是 <code>解耦了数据和程序</code>。回头看Kubernetes的Visitor应用场景，主要是从各种输入源中解析出资源<code>Info</code>。这个过程中Info是数据，各类解析方法是资源。</p>
<p>所以，我认为Visitor模式比较适合的是：<strong>目标数据明确，但获取数据的方法多样且复杂</strong>。但由于多层Visitor调用复杂，建议大家可以在外面再简单地封一层，提供常用的几种Visitor组合后的接口，供使用方调用。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>经典品读</category>
      </categories>
      <tags>
        <tag>Go-Programming-Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言技巧 - 1.【惊艳亮相】如何写出一个优雅的main函数</title>
    <url>/2021/03/07/go-tip/go-tip-1/</url>
    <content><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="一个简单的main函数"><a href="#一个简单的main函数" class="headerlink" title="一个简单的main函数"></a>一个简单的main函数</h2><p>我们先来看看一个最简单的<code>http服务端</code>的实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的功能很简单：提供一个监听在<code>8080</code>端口的服务器，处理<code>URL</code>为<code>/hello</code>的请求，并打印出hello。</p>
<p>可以用一个简单的curl请求来打印结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://localhost:8080/hello</span><br></pre></td></tr></table></figure>

<p>也可以用对应的<code>kill</code>杀死了对应的进程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -9 &#123;pid&#125;</span><br></pre></td></tr></table></figure>

<p>但有一个问题：</p>
<p><strong>如果程序因为代码问题而意外退出（例如panic），无法和kill这种人为强制杀死的情况进行区分</strong></p>
<span id="more"></span>

<h2 id="引入signal"><a href="#引入signal" class="headerlink" title="引入signal"></a>引入signal</h2><p><code>kill</code>工具是<code>Linux</code>系统中，往进程发送一个信号。所以，我们的关键是去实现 <strong>捕获信号</strong> 的功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个 sig 的 channel，捕获系统的信号，传递到sig中</span></span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line"></span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello)</span><br><span class="line">	<span class="comment">// http服务改造成异步</span></span><br><span class="line">	<span class="keyword">go</span> http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, mux)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 程序阻塞在这里，除非收到了interrupt或者kill信号</span></span><br><span class="line">	fmt.Println(&lt;-sig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们的主函数已经能区分正常的信号退出了。</p>
<h2 id="优雅退出的需求"><a href="#优雅退出的需求" class="headerlink" title="优雅退出的需求"></a>优雅退出的需求</h2><p>服务端程序经常会处理各种各样的逻辑，如操作数据库、读写文件、RPC调用等。根据其对 <strong>原子性</strong> 的要求，我将处理逻辑区分为两种：</p>
<ul>
<li>一种是<strong>无严格数据质量</strong>要求的，即程序直接崩溃也没有问题，比如一个普通查询；</li>
<li>另一种是有 <strong>原子性</strong> 要求的，即不希望运行到一半就退出，例如写文件、修改数据等，<strong>最好是程序提供一定的缓冲时间</strong>，等待这部分的逻辑处理完，优雅地退出。</li>
</ul>
<p>在复杂系统中，为了保证数据质量，<strong>优雅退出</strong> 是一个必要特性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟并发进行的处理业务逻辑</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="comment">// 我们希望程序能等当前这个周期休眠完，再优雅退出</span></span><br><span class="line">				time.Sleep(time.Duration(i) * time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(&lt;-sig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是一个简单的示例，开启了10个<code>goroutine</code>并发处理，那么这时捕获信号后，这10个协程就立刻停止。而<strong>优雅退出</strong>，则是希望能执行完当前的<code>Sleep</code>再退出。</p>
<h2 id="一对一的解决方案"><a href="#一对一的解决方案" class="headerlink" title="一对一的解决方案"></a>一对一的解决方案</h2><p>我们先简化问题：主函数对应的是一个需要优雅关闭的协程。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	fmt.Println(&lt;-sig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体操作如下：</p>
<ul>
<li>父<code>goroutine</code>通知子<code>goroutine</code>准备优雅地关闭</li>
<li>子<code>goroutine</code>通知父<code>goroutine</code>已经关闭完成</li>
</ul>
<p>我们回忆下在<code>goroutine</code>传递消息的几个方案（排除共享的全局变量这种方式）。</p>
<h3 id="最直观的解决方案-2个channel"><a href="#最直观的解决方案-2个channel" class="headerlink" title="最直观的解决方案 - 2个channel"></a>最直观的解决方案 - 2个channel</h3><p>既然我们要在父子goroutine中传递消息，最直接的想法是启用2个 <code>channel</code> 用来通信，对应到代码：</p>
<ul>
<li><p>父<code>goroutine</code>通知子<code>goroutine</code>准备优雅地关闭，也就是<code>stopCh</code></p>
</li>
<li><p>子<code>goroutine</code>通知父<code>goroutine</code>已经关闭完成，也就是<code>finishedCh</code></p>
<p>具体代码实现如下</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	finishedCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(stopCh, finishedCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">				fmt.Println(<span class="string">&quot;stopped&quot;</span>)</span><br><span class="line">				finishedCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(stopCh, finishedCh)</span><br><span class="line"></span><br><span class="line">	&lt;-sig</span><br><span class="line">	stopCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&lt;-finishedCh</span><br><span class="line">	fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="华丽的解决方案-channel嵌套channel"><a href="#华丽的解决方案-channel嵌套channel" class="headerlink" title="华丽的解决方案 - channel嵌套channel"></a>华丽的解决方案 - channel嵌套channel</h3><p>这个解决方案不太容易想到（看过Rob Pike的演讲视频除外，可在go官网看到）。</p>
<p>这个方案的核心结构为<code>chan chan</code>。</p>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(stopChh <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> ch := &lt;-stopCh:</span><br><span class="line">				<span class="comment">// 结束后，通过ch通知主goroutine</span></span><br><span class="line">				fmt.Println(<span class="string">&quot;stopped&quot;</span>)</span><br><span class="line">				ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(stopCh)</span><br><span class="line"></span><br><span class="line">	&lt;-sig</span><br><span class="line">	<span class="comment">// ch作为一个channel，传递给子goroutine，待其结束后从中返回</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	stopCh &lt;- ch</span><br><span class="line">	&lt;-ch</span><br><span class="line">	fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个方案很酷，建议大家多思考思考，尤其是channel中传递的数据为error时，就能有更多信息了</p>
</blockquote>
<h3 id="标准解决方案-引入上下文context"><a href="#标准解决方案-引入上下文context" class="headerlink" title="标准解决方案 - 引入上下文context"></a>标准解决方案 - 引入上下文context</h3><p><code>go</code>语言里的上下文<code>context</code>不仅仅可以传递数值，也可以控制子<code>goroutine</code>的生命周期，很自然地有了如下解决方案。</p>
<p>实例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	finishedCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, finishedCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				<span class="comment">// 结束后，通过ch通知主goroutine</span></span><br><span class="line">				fmt.Println(<span class="string">&quot;stopped&quot;</span>)</span><br><span class="line">				finishedCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(ctx, finishedCh)</span><br><span class="line"></span><br><span class="line">	&lt;-sig</span><br><span class="line">	cancel()</span><br><span class="line">	&lt;-finishedCh</span><br><span class="line">	fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>有兴趣的朋友可以空闲时想一个问题：社区里有人认为context是一个很不好的实现：</p>
<p>context意思为上下文，最初的设计意为传递数值，也就是一个 <strong>数据流</strong> ；</p>
<p>而go中的context又延伸出了 控制goroutine生命周期的功能，也就成了 <strong>控制流</strong> 。</p>
<p>这么看下来，其实context就有 角色不清晰 的味道了。</p>
<p>但不可否认，context已经在go语言中大量被采用，这个问题可以作为大家自己设计模块时的参考。</p>
</blockquote>
<h2 id="一对多的解决方案"><a href="#一对多的解决方案" class="headerlink" title="一对多的解决方案"></a>一对多的解决方案</h2><p>一对多的解决方案可以复用 <strong>一对一解决方案</strong> 中的思想。我这边也给出另外一个 <code>context</code> + <code>sync.WaitGroup</code> 的解决方案。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	num := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用wg来控制多个子goroutine的生命周期</span></span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(num)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">					fmt.Println(<span class="string">&quot;stopped&quot;</span>)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					time.Sleep(time.Duration(i) * time.Second)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(ctx)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;-sig</span><br><span class="line">	cancel()</span><br><span class="line">	<span class="comment">// 等待所有的子goroutine都优雅退出</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家要注意一下，在追求 <strong>优雅退出</strong> 时要注意 <strong>控制细粒度</strong> 。</p>
<blockquote>
<p>比如一个<code>http</code>服务器，我们要控制整个<code>http server</code>的优雅退出。</p>
<p>千万不要去想着在主函数层面去控制每个<code>http handler</code>，也就是每个<code>http</code>请求的优雅退出，这样很难控制代码的复杂度。对于每个<code>http</code>请求的控制，应该交给<code>http server</code>这个框架去实现。</p>
<p>所以，在主函数中，其实需要优雅退出的选项其实很有限。</p>
</blockquote>
<h2 id="延伸思考"><a href="#延伸思考" class="headerlink" title="延伸思考"></a>延伸思考</h2><p>本次我们讲的是<code>main</code>函数控制其<code>goroutine</code>的优雅退出，其实我们延伸开来，就是 <strong>父Goroutine怎么保证子Goroutine优雅退出</strong> 这个问题。</p>
<p>虽然有解决方案，但我这是想泼一盆冷水，希望大家想想一个问题：<strong>既然这个子Goroutine是有价值的，不想轻易丢失，那么为什么不放到主Goroutine中呢？</strong> 其实，很多时候，我们都在 <strong>滥用Goroutine</strong> 。我希望大家更多地抛开语言特性，从整体思考以下三个问题：</p>
<ol>
<li><strong>明确调用链路</strong> - 梳理整个调用流程，区分关键和非关键的步骤，以及在对应步骤上发生错误时的处理方法</li>
<li><strong>用MQ解耦服务</strong> - 跨服务的调用如果比较费时，大部分时候更建议采用消息队列解耦</li>
<li><strong>面向错误编程</strong> - 关键业务的<code>Goroutine</code> 里代码要考虑所有可能发生错误的点，保证程序退出或<code>panic/recover</code>也不要出现 <strong>脏数据</strong>。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>main</code>函数是<code>go</code>程序的入口，如果在这里写出一段优雅的代码，很容易给阅读自己源码的朋友留下良好的印象。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言技巧 - 10.【初始化代码生成】Wire工具基础讲解</title>
    <url>/2021/12/25/go-tip/go-tip-10/</url>
    <content><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="Wire概览"><a href="#Wire概览" class="headerlink" title="Wire概览"></a>Wire概览</h2><p>在讲解Kratos的过程中，我们引入了google推出的wire这个工具。我们先阅读一下官方的定义：</p>
<p><strong>Wire is a code generation tool that automates connecting components using dependency injection.</strong></p>
<p>从关键词入手：</p>
<ul>
<li><strong>code generation 代码生成</strong>，一方面说明了有学习成本，需要了解这个工具的原理；另一方面，也说明了它的目标是消除重复性的coding</li>
<li><strong>automates connecting components 自动连接组件</strong>，明确了wire工具的目标是将多个对象组合起来</li>
<li><strong>dependency injection 依赖注入</strong>，指明了wire实现自动连接组件的思想。依赖注入是一个很强大的功能，我会在下面结合具体的case聊一聊</li>
</ul>
<p>我们从具体的case着手，学习wire这个工具。</p>
<span id="more"></span>

<h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><h3 id="常规实现"><a href="#常规实现" class="headerlink" title="常规实现"></a>常规实现</h3><p>我简化了官方的示例，给出一个注释后的代码，方便大家阅读：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// Part-1 Message对象</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMessage</span><span class="params">()</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Message(<span class="string">&quot;Hi there!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Part-2 Greeter对象,依赖Message</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeter</span><span class="params">(m Message)</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Greeter&#123;Message: m&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Greeter <span class="keyword">struct</span> &#123;</span><br><span class="line">	Message Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Greeter)</span> <span class="title">Greet</span><span class="params">()</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> g.Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	message := NewMessage()</span><br><span class="line">	greeter := NewGreeter(message)</span><br><span class="line"></span><br><span class="line">	greeter.Greet()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的调用很直观，分为3步：</p>
<ol>
<li>用<code>NewMessage</code>创建<code>Message</code>对象</li>
<li>通过<code>NewGreeter</code>方法，将<code>Message</code>对象注入到<code>Greeter</code>对象里</li>
<li>调用<code>Greeter</code>的方法，其实内部用到了前面注入的<code>Message</code>对象</li>
</ol>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入的详细定义可以参考链接 - <a href="https://en.wikipedia.org/wiki/Dependency_injection%EF%BC%8C%E6%88%91%E5%B0%B1%E4%B8%8D%E8%B5%98%E8%BF%B0%E4%BA%86%E3%80%82%E8%BF%99%E9%87%8C%E6%88%91%E7%94%A8%E5%85%B7%E4%BD%93%E7%9A%84case%E8%BF%9B%E8%A1%8C%E5%AF%B9%E6%AF%94%EF%BC%8C%E6%96%B9%E4%BE%BF%E5%A4%A7%E5%AE%B6%E7%90%86%E8%A7%A3%EF%BC%9A">https://en.wikipedia.org/wiki/Dependency_injection，我就不赘述了。这里我用具体的case进行对比，方便大家理解：</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Greeter <span class="keyword">struct</span> &#123;</span><br><span class="line">	Message Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeter</span><span class="params">(m Message)</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Greeter&#123;Message: m&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Greeter)</span> <span class="title">Greet</span><span class="params">()</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> g.Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Greeter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Greeter)</span> <span class="title">Greet</span><span class="params">()</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">	g.Message = NewMessage()</span><br><span class="line">	<span class="keyword">return</span> g.Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完例子，可能大家对DI已经有个初步的概念了，我这边再重复一下关键点：</p>
<ol>
<li><code>Greeter</code>的方法<code>Greet()</code>会依赖内部的<code>Message</code>对象，所以我们说 - <strong>Greeter的实现依赖Message</strong></li>
<li><code>Message</code>的初始化分为两种：创建Greeter对象前和调用Greet方法时，前者被称为<strong>依赖注入</strong>，相当于<strong>在初始化时把依赖项注入进去，而不是使用时再创建</strong>。</li>
<li>DI，最直接的好处就是可以很方便地调整这个注入项，比如Greet升级成GreetV2，或者单测的MockGreet。</li>
</ol>
<h3 id="使用wire生成代码"><a href="#使用wire生成代码" class="headerlink" title="使用wire生成代码"></a>使用wire生成代码</h3><p>我们先安装wire工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get github.com/google/wire/cmd/wire</span><br></pre></td></tr></table></figure>

<p>再编写一个<code>wire.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//+build wireinject</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/google/wire&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">	wire.Build(NewGreeter, NewMessage)</span><br><span class="line">	<span class="keyword">return</span> Greeter&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行命令<code>wire gen</code>生成wire_gen.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code generated by Wire. DO NOT EDIT.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate go run github.com/google/wire/cmd/wire</span></span><br><span class="line"><span class="comment">//+build !wireinject</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// Injectors from wire.go:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">	message := NewMessage()</span><br><span class="line">	greeter := NewGreeter(message)</span><br><span class="line">	<span class="keyword">return</span> greeter</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，可以在<code>main</code>函数里使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	greeter := InitializeGreeter()</span><br><span class="line"></span><br><span class="line">	greeter.Greet()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="wire的大致实现"><a href="#wire的大致实现" class="headerlink" title="wire的大致实现"></a>wire的大致实现</h3><p>可以看到，wire这个工具基本能力就体现在<code>wire.Build(NewGreeter, NewMessage)</code>里，把这里面的两个初始化函数串联了起来，形成了一个整体的InitializeGreeter。</p>
<h2 id="基本扩展"><a href="#基本扩展" class="headerlink" title="基本扩展"></a>基本扩展</h2><h3 id="带error的处理"><a href="#带error的处理" class="headerlink" title="带error的处理"></a>带error的处理</h3><p>我们新增一个方法，初始化结果里增加一个error返回值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Part-3 Greeter对象,依赖Message,并且返回error方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeterV2</span><span class="params">(m Message)</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> m == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Greeter&#123;&#125;, errors.New(<span class="string">&quot;empty message&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Greeter&#123;Message: m&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>wire.go</code>里调整函数返回值增加一个error</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line">	wire.Build(NewGreeterV2, NewMessage)</span><br><span class="line">	<span class="keyword">return</span> Greeter&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在<code>wire_gen.go</code>里生成了带error的新方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeterV2</span><span class="params">()</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line">	message := NewMessage()</span><br><span class="line">	greeter, err := NewGreeterV2(message)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Greeter&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> greeter, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增加一个入参"><a href="#增加一个入参" class="headerlink" title="增加一个入参"></a>增加一个入参</h3><p>我们新增一个方法，增加一个name的入参</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Part-3 Greeter对象,依赖Message和参数name,并且返回error方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeterV3</span><span class="params">(m Message, name <span class="keyword">string</span>)</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Greeter&#123;&#125;, errors.New(<span class="string">&quot;empty name&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Greeter&#123;Message: m&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>wire.go</code>里也增加一个<code>string</code>类型的入参（变量名可以任意）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeterV3</span><span class="params">(greetName <span class="keyword">string</span>)</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line">	wire.Build(NewGreeterV3, NewMessage)</span><br><span class="line">	<span class="keyword">return</span> Greeter&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后生成对应的方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeterV3</span><span class="params">(greetName <span class="keyword">string</span>)</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line">	message := NewMessage()</span><br><span class="line">	greeter, err := NewGreeterV3(message, greetName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Greeter&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> greeter, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Provider和Injector"><a href="#Provider和Injector" class="headerlink" title="Provider和Injector"></a>Provider和Injector</h2><p>Wire里面提了两个关键性的概念，为了方便大家阅读文档时能快速理解，我这里再专门说明下：</p>
<ul>
<li><strong>Provider</strong> - 即各个初始化函数，如<code>NewXXX</code></li>
<li><strong>Injector</strong> - 即Initial的函数，将各个Provider注入到wire中，生成一个新的初始化函数</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Github - <a href="https://github.com/google/wire">https://github.com/google/wire</a></p>
<p>DI - <a href="https://en.wikipedia.org/wiki/Dependency_injection">https://en.wikipedia.org/wiki/Dependency_injection</a></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><code>wire</code>工具的实现逻辑很清晰 - <strong>按一定规则组装多个Provider到Injector中</strong>。</p>
<p>生成的代码 <strong>结构简单而具有规律</strong>，所以用代码生成技术很有价值，既减少了重复性工作，又能引入DI的思想方便程序的扩展。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，我们对wire的基础用法已经了然于胸，但更多的价值需要深入理解DI这个概念，最好能结合到具体的工程实践上。如果你对这块还没有太深刻的理解，建议结合网上的相关资料了解DI在工程中的价值，会让你使用wire这个工具时更有感触。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言技巧 - 11.【初始化代码生成】Wire进阶使用</title>
    <url>/2021/12/28/go-tip/go-tip-11/</url>
    <content><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="Wire进阶"><a href="#Wire进阶" class="headerlink" title="Wire进阶"></a>Wire进阶</h2><p>通过上一篇的讲解，我们已经掌握<code>wire</code>工具的基本用法了。但应用在实际工程中，这些基本功能还是有很多局限性。</p>
<p>在这一篇，我们一起看看Google推出的<code>wire</code>的进阶使用方法，并总结出一套实践思路。</p>
<span id="more"></span>

<h2 id="进阶示例"><a href="#进阶示例" class="headerlink" title="进阶示例"></a>进阶示例</h2><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p><code>Set</code>特性比较直观：组合几个<code>Provider</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> BasicSet = wire.NewSet(NewGreeter, NewMessage)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">	wire.Build(BasicSet)</span><br><span class="line">	<span class="keyword">return</span> Greeter&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般应用在初始化对象比较多的情况下，减少<code>Injector</code>里的信息。</p>
<h3 id="绑定接口"><a href="#绑定接口" class="headerlink" title="绑定接口"></a>绑定接口</h3><p>接口这个特性在面向对象编程时非常有意义，我们来看一个具体的示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象出一个 Messager 的接口</span></span><br><span class="line"><span class="keyword">type</span> Messager <span class="keyword">interface</span> &#123;</span><br><span class="line">	Name() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Message 是Messager的一个具体实现</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Message)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;message&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMessage</span><span class="params">()</span> *<span class="title">Message</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Message&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Greeter的初始化依赖的是Messager接口，而不是Message这个实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeter</span><span class="params">(m Messager)</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Greeter&#123;Message: m&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Greeter <span class="keyword">struct</span> &#123;</span><br><span class="line">	Message Messager</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Greeter)</span> <span class="title">Greet</span><span class="params">()</span> <span class="title">Messager</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> g.Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出，我们要做的就是在<code>NewGreeter(m Messager)</code>初始化时，用<code>Message</code>这个具体实现来代替<code>Messager</code>接口。这里，我们就在<code>wire.go</code>里引入了 <strong>绑定</strong> 这个方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wire.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> BasicSet = wire.NewSet(</span><br><span class="line">	NewGreeter,</span><br><span class="line">	wire.Bind(<span class="built_in">new</span>(Messager), <span class="built_in">new</span>(*Message)),</span><br><span class="line">	NewMessage,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">	wire.Build(BasicSet)</span><br><span class="line">	<span class="keyword">return</span> Greeter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire_gen.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">	message := NewMessage()</span><br><span class="line">	greeter := NewGreeter(message)</span><br><span class="line">	<span class="keyword">return</span> greeter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造结构体"><a href="#构造结构体" class="headerlink" title="构造结构体"></a>构造结构体</h3><p>上面的例子里，我们都定义了具体的构造函数，也就是Provider。但实际开发过程中，我们经常会遇到只有一个具体的结构体，而没有定义具体的函数。这时我们可以采用 <strong>构造结构体的特性</strong>。例如，我们定义一个<code>MyGreeter</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyGreeter <span class="keyword">struct</span> &#123;</span><br><span class="line">	Msg Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeMyGreeter</span><span class="params">()</span> *<span class="title">MyGreeter</span></span> &#123;</span><br><span class="line">	wire.Build(</span><br><span class="line">		NewMessage,</span><br><span class="line">		wire.Struct(<span class="built_in">new</span>(MyGreeter), <span class="string">&quot;Msg&quot;</span>),</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">return</span> &amp;MyGreeter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire_gen.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeMyGreeter</span><span class="params">()</span> *<span class="title">MyGreeter</span></span> &#123;</span><br><span class="line">	message := NewMessage()</span><br><span class="line">	myGreeter := &amp;MyGreeter&#123;</span><br><span class="line">		Msg: message,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> myGreeter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绑定值"><a href="#绑定值" class="headerlink" title="绑定值"></a>绑定值</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyGreeter <span class="keyword">struct</span> &#123;</span><br><span class="line">	X   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeMyGreeter</span><span class="params">()</span> *<span class="title">MyGreeter</span></span> &#123;</span><br><span class="line">	wire.Build(</span><br><span class="line">		wire.Value(&amp;MyGreeter&#123;X: <span class="number">42</span>&#125;),</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">return</span> &amp;MyGreeter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire_gen.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeMyGreeter</span><span class="params">()</span> *<span class="title">MyGreeter</span></span> &#123;</span><br><span class="line">	myGreeter := _wireMyGreeterValue</span><br><span class="line">	<span class="keyword">return</span> myGreeter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	_wireMyGreeterValue = &amp;MyGreeter&#123;X: <span class="number">42</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="获取结构体中的字段"><a href="#获取结构体中的字段" class="headerlink" title="获取结构体中的字段"></a>获取结构体中的字段</h3><p>这块比较简单，就是从一个结构体里提取一个Public的field，作为一个<code>Provider</code>，这里给出一个简单的示例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    S <span class="keyword">string</span></span><br><span class="line">    N <span class="keyword">int</span></span><br><span class="line">    F <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire_gen.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">injectedMessage</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    wire.Build(</span><br><span class="line">        provideFoo,</span><br><span class="line">        wire.FieldsOf(<span class="built_in">new</span>(Foo), <span class="string">&quot;S&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清理函数"><a href="#清理函数" class="headerlink" title="清理函数"></a>清理函数</h3><p>清理函数利用了函数变量的特性，将资源释放函数抛出来。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">provideFile</span><span class="params">(log Logger, path Path)</span> <span class="params">(*os.File, <span class="keyword">func</span>()</span>, <span class="title">error</span>)</span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="keyword">string</span>(path))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    cleanup := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Log(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f, cleanup, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="1-区别类型"><a href="#1-区别类型" class="headerlink" title="1.区别类型"></a>1.区别类型</h3><p>采用类型别名，和标准类型区分开来，如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MySQLConnectionString <span class="keyword">string</span></span><br></pre></td></tr></table></figure>

<h3 id="2-可选结构体"><a href="#2-可选结构体" class="headerlink" title="2. 可选结构体"></a>2. 可选结构体</h3><p>当一个<code>Injector</code>需要多个<code>Provider</code>时，将这些<code>Provider</code>集中到一个<code>Option</code>的结构体，即组合多个参数，如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Messages is the set of recommended greetings.</span></span><br><span class="line">    Messages []Message</span><br><span class="line">    <span class="comment">// Writer is the location to send greetings. nil goes to stdout.</span></span><br><span class="line">    Writer io.Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-合理使用Provider-Sets"><a href="#3-合理使用Provider-Sets" class="headerlink" title="3.合理使用Provider Sets"></a>3.合理使用Provider Sets</h3><p>Set集合了多个Provider效率很高，具体实践过程中要根据实际情况出发，参考 <a href="https://github.com/google/wire/blob/main/docs/best-practices.md#provider-sets-in-libraries%E3%80%82">https://github.com/google/wire/blob/main/docs/best-practices.md#provider-sets-in-libraries。</a></p>
<p>总体来说把握一个原则：<code>In general, prefer small provider sets in a library. </code> 即Set尽量小，多多考虑复合。</p>
<h3 id="4-Mocking"><a href="#4-Mocking" class="headerlink" title="4.Mocking"></a>4.Mocking</h3><p>Mock这块主要是用于测试，官方给出了两个途径：</p>
<ul>
<li>Pass mocks to the injector</li>
<li>Return the mocks from the injector</li>
</ul>
<p>初看可能不容易理解，我们结合实际代码就能了解</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 途径1 - 即依赖项以参数注入，这样返回的app和正常的app完全一致</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMockedAppFromArgs</span><span class="params">(mt timer)</span> *<span class="title">app</span></span> &#123;</span><br><span class="line">	wire.Build(appSetWithoutMocks)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 途径2 - 内部增加mock的具体field，会与app中的对应变量绑定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMockedApp</span><span class="params">()</span> *<span class="title">appWithMocks</span></span> &#123;</span><br><span class="line">	wire.Build(mockAppSet)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> appWithMocks <span class="keyword">struct</span> &#123;</span><br><span class="line">	app app</span><br><span class="line">	mt  *mockTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体来说，我个人比较推荐使用方案1，它能保证mock对象的使用方式和真实对象完全一致，能屏蔽很多复杂度。在一个复杂系统中，底层的mock对象可以很容易应用到高层。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Github - <a href="https://github.com/google/wire">https://github.com/google/wire</a></p>
<p>Blog - <a href="https://go.dev/blog/wire">https://go.dev/blog/wire</a> </p>
<p>Package Doc - <a href="https://pkg.go.dev/github.com/google/wire">https://pkg.go.dev/github.com/google/wire</a></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>通过这一篇，我们能看到<code>wire</code>很多进阶的能力，其实还有一部分特性并未在文档中说明，可以参考package doc学习。</p>
<p>我更建议大家可以从单元测试的角度切入，去理解这个工具的实践：</p>
<ol>
<li><strong>自底向上地考虑wire的实践</strong>：尤其是db、redis这些基础工具，底层的mock会为上层的mock带来巨大便利；</li>
<li><strong>不断抽离和组合对象中的依赖</strong>：依赖小到某个关键变量、大到某个外部服务，也同时注意组合相似度高的依赖项到<code>Set</code>；</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>wire</code>的核心是依赖注入，对整个框架的可测试性来说是根基，对<code>Go</code>语言这类静态编译的语言尤为重要。</p>
<p><code>Java</code>语言有一整套强大的<code>JVM</code>引擎，可以在运行时做各种复杂操作；而静态语言在编写时就决定了程序的基本运行方式，从简单性来说很棒 - <strong>所见即所得</strong>，但也说明了不应有复杂的运行时。这时，一个良好的依赖注入机制对<code>Go</code>语言尤为重要。</p>
<p>那么，<code>Wire</code>引入的DI思想对<code>Go</code>语言来说可以称得上是<code>银弹</code>，但我们更应该重视基础库的<code>Mock</code>能力，毕竟没有底层能力、就没有高层建设。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言技巧 - 12.【Go实体框架】Facebook开源ent概览</title>
    <url>/2021/12/31/go-tip/go-tip-12/</url>
    <content><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="Ent概览"><a href="#Ent概览" class="headerlink" title="Ent概览"></a>Ent概览</h2><p><strong>Simple, yet powerful ORM for modeling and querying data.</strong></p>
<p><code>Ent</code>作为一款由<code>Facebook</code>开源的库，官方定义为<code>An entity framework for Go</code>。从整个微服务框架来看，它更准确的定位应是 <strong>数据模型层的工具库</strong>。了解<code>Ent</code>这款企业级工具的大致实现，不仅有助于我们在技术选型时拓宽视野，也能帮助我们能更好地认识数据模型层。</p>
<span id="more"></span>

<h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="Schema-As-Code"><a href="#Schema-As-Code" class="headerlink" title="Schema As Code"></a>Schema As Code</h3><blockquote>
<p>Simple API for modeling any database schema as Go objects. </p>
</blockquote>
<p>从定义来看这个特性非常棒 - <code>Ent</code> 可以将各种异构数据库映射到Go语言的结构体。</p>
<p>但在实际的开发中，如果你对各类数据库有深入的理解，就会清楚地知道这个特性在对数据库特性有一定要求时，框架层面就很难满足了。</p>
<h3 id="Easily-Traverse-Any-Graph"><a href="#Easily-Traverse-Any-Graph" class="headerlink" title="Easily Traverse Any Graph"></a>Easily Traverse Any Graph</h3><blockquote>
<p>Run queries, aggregations and traverse any graph structure easily.</p>
</blockquote>
<p>强调对图结构的 <strong>查询、聚合和遍历</strong>。这里的图数据库和传统的关系型数据库差别不小，有兴趣的朋友可搜索<strong>图数据库</strong>的相关概念。</p>
<h3 id="Statically-Typed-And-Explicit-API"><a href="#Statically-Typed-And-Explicit-API" class="headerlink" title="Statically Typed And Explicit API"></a>Statically Typed And Explicit API</h3><blockquote>
<p>100% statically typed and explicit API using code generation.</p>
</blockquote>
<p>利用代码生成的能力，保证静态类型和显示声明的API。</p>
<h3 id="特性总结"><a href="#特性总结" class="headerlink" title="特性总结"></a>特性总结</h3><p>三大特性，分别从 <strong>支持的数据库能力集</strong>、<strong>针对图形数据处理能力</strong> 和 <strong>代码生成的输出形式</strong>，描述了<code>Ent</code>框架的优点。</p>
<p>这里，我会更聚焦于第二点中的关键词：<strong>图形数据</strong>。让我们带着对三个特性的初印象，开始了解相关官方示例。</p>
<h2 id="Ent实践"><a href="#Ent实践" class="headerlink" title="Ent实践"></a>Ent实践</h2><blockquote>
<p>Ent工具的使用方式并不是本篇的重点，具体的操作方法我会放在链接里，文中只给出关键性的内容</p>
</blockquote>
<h3 id="1-创建实体"><a href="#1-创建实体" class="headerlink" title="1.创建实体"></a>1.创建实体</h3><p>链接 - <a href="https://entgo.io/docs/getting-started/#create-your-first-entity">https://entgo.io/docs/getting-started/#create-your-first-entity</a> </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">u, err := client.User.</span><br><span class="line">        Create().</span><br><span class="line">        SetAge(<span class="number">30</span>).</span><br><span class="line">        SetName(<span class="string">&quot;a8m&quot;</span>).</span><br><span class="line">        Save(ctx)</span><br></pre></td></tr></table></figure>

<p>代码和<code>GORM</code>非常类似，但不支持复杂结构体的传入，面对大量参数时比较麻烦。</p>
<h3 id="2-查询实体"><a href="#2-查询实体" class="headerlink" title="2.查询实体"></a>2.查询实体</h3><p>链接 - <a href="https://entgo.io/docs/getting-started/#query-your-entities">https://entgo.io/docs/getting-started/#query-your-entities</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">u, err := client.User.</span><br><span class="line">        Query().</span><br><span class="line">        Where(user.Name(<span class="string">&quot;a8m&quot;</span>)).</span><br><span class="line">        <span class="comment">// `Only` fails if no user found,</span></span><br><span class="line">        <span class="comment">// or more than 1 user returned.</span></span><br><span class="line">        Only(ctx)</span><br></pre></td></tr></table></figure>

<p>基本同上，表达方式还是很明确的。但对于<code>Only</code>这种新引入的关键词，对新人来说有学习成本。</p>
<h3 id="3-Edge相关"><a href="#3-Edge相关" class="headerlink" title="3.Edge相关"></a>3.Edge相关</h3><ul>
<li><a href="https://entgo.io/docs/getting-started/#add-your-first-edge-relation">https://entgo.io/docs/getting-started/#add-your-first-edge-relation</a></li>
<li><a href="https://entgo.io/docs/getting-started/#add-your-first-inverse-edge-backref">https://entgo.io/docs/getting-started/#add-your-first-inverse-edge-backref</a></li>
<li><a href="https://entgo.io/docs/getting-started/#create-your-second-edge">https://entgo.io/docs/getting-started/#create-your-second-edge</a></li>
</ul>
<p>我们以一个复杂Edge为例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cars, err := client.Group.</span><br><span class="line">        Query().</span><br><span class="line">        Where(group.Name(<span class="string">&quot;GitHub&quot;</span>)). <span class="comment">// (Group(Name=GitHub),)</span></span><br><span class="line">        QueryUsers().                <span class="comment">// (User(Name=Ariel, Age=30),)</span></span><br><span class="line">        QueryCars().                 <span class="comment">// (Car(Model=Tesla, RegisteredAt=&lt;Time&gt;), Car(Model=Mazda, RegisteredAt=&lt;Time&gt;),)</span></span><br><span class="line">        All(ctx)</span><br></pre></td></tr></table></figure>

<p>从表达式上来看，就是查询Group、然后关联查询User、最后再查到Car。</p>
<p>首先，我们要认识到 - <strong>抛开背后的实现，这种表达方式很简洁</strong>。</p>
<p>如果底层是<code>MySQL</code>，这里至少关联了三张实体表（JOIN），很容易引起性能问题。这个问题也就是上面所说的，<strong>框架屏蔽了异构数据库</strong>而导致的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Github - <a href="https://github.com/ent/ent">https://github.com/ent/ent</a></p>
<p>官网 - <a href="https://entgo.io/">https://entgo.io/</a></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>通过相关资料和简单实操，我对于<code>Ent</code>框架的定位是 - <strong>一个面向图数据库的ORM框架</strong>。相信随着图数据库的逐渐成熟，<code>Ent</code>会更具价值。但考虑到以下两点：</p>
<ol>
<li>图数据库的成熟周期还需要一段时间，当前的维护成本高；</li>
<li>在非图数据库上使用<code>Ent</code>，对开发者的要求很高，既要了解<code>Ent</code>对不同数据库的底层实现，又要懂数据库原理。</li>
</ol>
<blockquote>
<p>举个例子，ent的部分Edge特性需要依赖数据库的外键，但如今主流数据库的实践，倡导去外键，而是将相关逻辑转移到程序代码里。</p>
</blockquote>
<p>所以，我不建议将<code>Ent</code>引入到项目中。关于<code>Ent</code>更多的细节需要大家自行阅读和实践。</p>
<p>这里，我抛出一个自己的理解：<strong>从编程语言框架层面，不应过度基础设施的复杂度。从异构数据库来说，它们的特性、维护方式、设计模式都各不相同，应寻找每种数据库对应的工具库，而不应期望毕其功于一役。</strong></p>
<p>换一句话，如果期望一个工具库能适配十种数据库，那么换一种角度，这十种数据库更应该被封装成一种数据库。<strong>通用性如果能沉淀在基础设施上，价值远大于在工具库上做适配。</strong></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Ent</code>能在Facebook等公司与Kratos框架上沉淀，证明了它具备实际工程落地的能力，但对使用者的要求很高，很难具备普适性。</p>
<p>前文为了表达个人想法，我在论述观点时会相对态度鲜明，但并非对<code>Ent</code>持有否定态度。相反地，从具体的实现细节来看，<code>Ent</code>给了我不少启发，尤其是强调静态类型，能看出它对性能的追求。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言技巧 - 2.【错误处理】谈谈Go Error的前世今生</title>
    <url>/2021/05/05/go-tip/go-tip-2/</url>
    <content><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="从Go-2-Error-Proposal谈起"><a href="#从Go-2-Error-Proposal谈起" class="headerlink" title="从Go 2 Error Proposal谈起"></a>从Go 2 Error Proposal谈起</h2><p><code>Go</code>对<code>error</code>的处理一直都是很大的争议点，这点官方也已多次发文，并在2019年1月推出了一篇Proposal，有兴趣的可以点击链接细细品读。</p>
<p><a href="https://go.googlesource.com/proposal/+/master/design/29934-error-values.md">官方原文链接</a></p>
<p>下面，我会结合Proposal原文，发表一些自己的看法（会带上主观意见），欢迎讨论。</p>
<span id="more"></span>

<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>这篇Proposal有一句话很好地解释了对<code>error</code>的期许：</p>
<p><strong>making errors more informative for both programs and people</strong></p>
<p>错误不仅是告诉机器怎么做的，也是告诉人发生了什么问题。</p>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>先让我们一起简单地回顾一下<code>error</code>的现状，来更好地理解这个 <strong>more informative</strong> 指的是什么。</p>
<p>原始的error定义为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">  Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面的包含信息很少：一个Error() 的方法，即用字符串返回对应的错误信息。</p>
<p>最常用的<code>error</code>相关方法是2种：</p>
<ol>
<li>创建<code>error</code> - <code>fmt.Errorf</code>，它是针对<code>Error() </code>方法返回的字符串进行加工，如附带一些参数信息（暂不讨论%w这个wrap错误的实现）</li>
<li>使用<code>error</code> - 由于我们将<code>error</code>的输出结果定义为字符串，所以使用<code>error</code>时，一旦涉及到细节，就只能使用一些<code>string</code>的方法了</li>
</ol>
<p>举个具体的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 假设 readFile 存在于第三方或公用的库，我们没有权限修改、或者修改它的影响面很大</span></span><br><span class="line">	_, err := readFile(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 错误中包含业务逻辑:</span></span><br><span class="line">	<span class="comment">// 1. 文件不存在时，认为是 正常</span></span><br><span class="line">	<span class="comment">// 2. 其余报错时，认为是 异常</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> strings.Index(err.Error(), <span class="string">&quot;no such file or directory&quot;</span>) &gt;= <span class="number">0</span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;file not exist&quot;</span>)</span><br><span class="line">			os.Exit(<span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Println(<span class="string">&quot;open file error&quot;</span>)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(fileName <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	b, err := ioutil.ReadFile(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;read file %s error %v&quot;</span>, fileName, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里存在3个明显的问题：</p>
<ol>
<li><strong>破坏性</strong> - <code>fmt.Errorf</code> 破坏了原有的error，将它从一个 <strong>具体对象</strong> 转化为 <strong>扁平的</strong> <code>string</code>，再填充到了新的<code>error</code>中。所以，通过<code>fmt.Errorf</code>处理后的error，都只传递了一个<code>string</code>的信息</li>
<li><strong>实现僵化</strong> - <strong>“no such file or directory”</strong> 这个错误信息用的是<strong>硬编码</strong>，对第三方<code>readFile</code>的内容有强依赖，不灵活</li>
<li><strong>排查问题效率低</strong> - 可以通过日志组件了解到error在<code>main</code>函数哪行发生，但无法知道错误从<code>readFile</code>中的哪行返回过来的</li>
</ol>
<blockquote>
<p>其中第一个破坏性的问题，其实就是破坏了error这个interface背后的具体实现，违背了面向对象的继承原则。</p>
</blockquote>
<h2 id="Handle-Errors-Only-Once"><a href="#Handle-Errors-Only-Once" class="headerlink" title="Handle Errors Only Once"></a>Handle Errors Only Once</h2><p>在工程中，为了解决 <strong>排查问题效率低</strong> 这个问题，有一个很常见的做法（以上面的readFile为例）:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(fileName <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	b, err := ioutil.ReadFile(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;read file %s error %v&quot;</span>, fileName, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;read file %s error %v&quot;</span>, fileName, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没错，就是 <strong>打印错误并返回</strong>。有大量排查问题经验的同学，对此肯定是深恶痛绝： <strong>一个错误能找到N处打印，看得人眼花缭乱</strong>。</p>
<p>这里违背了一个关键性的原则：<strong>对错误只进行一次处理，处理完之后就不要再往上抛了，而打印错误也是一种处理。</strong></p>
<p>结合三种具体的场景，我们分析一下：</p>
<ol>
<li>一个程序模块内，<code>error</code>不断往上抛，最上层处理；</li>
<li>一个公共的工具包中，<code>error</code>不记录，传给调用方处理；</li>
<li>一个RPC模块的调用中，<code>error</code>可以记录，作为<code>debug</code>信息，而具体的处理仍应交给调用方。</li>
</ol>
<p>示例参考文章</p>
<ul>
<li><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a></li>
<li><a href="https://www.orsolabs.com/post/go-errors-and-logs/">https://www.orsolabs.com/post/go-errors-and-logs/</a></li>
</ul>
<h2 id="理论实现"><a href="#理论实现" class="headerlink" title="理论实现"></a>理论实现</h2><p>那么，怎么样的<code>error</code>才是合适的呢？我们分两个角度来看这个<code>error</code>：</p>
<ol>
<li>对程序来说，<code>error</code>要包含<strong>错误细节</strong>：如错误类型、错误码等，方便在模块间传递；</li>
<li>对人来说，<code>error</code>要包含<strong>代码信息</strong>：如相关的调用参数、运行信息，方便查问题；</li>
</ol>
<p>用原文一句话来归纳：<strong>hide implementation details from programs while displaying them for diagnosis</strong></p>
<ul>
<li>Wrap - 隐藏实现，针对代码调用时的堆栈信息</li>
<li>Is/As - 展示细节，针对底层真正实现的数据结构</li>
</ul>
<h2 id="当前实现"><a href="#当前实现" class="headerlink" title="当前实现"></a>当前实现</h2><p><code>Go</code>语言发展多年，已经有了很多关于<code>error</code>的处理方法，但大多为过渡方案，我就不一一分析了。</p>
<p>这里我以 github.com/pkg/errors 为例，也是这个<strong>官方Proposal</strong>的重点参考对象，简单地分享一下大致实现思路。</p>
<p>代码量并不多，大家可以自行阅读源码：</p>
<h3 id="New-产生错误的堆栈信息"><a href="#New-产生错误的堆栈信息" class="headerlink" title="New 产生错误的堆栈信息"></a>New 产生错误的堆栈信息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(message <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;fundamental&#123;</span><br><span class="line">		msg:   message,</span><br><span class="line">		stack: callers(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fundamental <span class="keyword">struct</span> &#123;</span><br><span class="line">	msg <span class="keyword">string</span></span><br><span class="line">	*stack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong> stack保存了错误产生的堆栈信息，如函数名、代码行</p>
<h3 id="Wrap-包装错误"><a href="#Wrap-包装错误" class="headerlink" title="Wrap 包装错误"></a>Wrap 包装错误</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Wrap</span><span class="params">(err error, message <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	err = &amp;withMessage&#123;</span><br><span class="line">		cause: err,</span><br><span class="line">		msg:   message,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;withStack&#123;</span><br><span class="line">		err,</span><br><span class="line">		callers(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong> 将错误包装出一个全新的堆栈。一般只用于对外接口产生错误时，包括标准库、RPC。</p>
<h3 id="WithMessage-添加普通信息"><a href="#WithMessage-添加普通信息" class="headerlink" title="WithMessage 添加普通信息"></a>WithMessage 添加普通信息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithMessage</span><span class="params">(err error, message <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;withMessage&#123;</span><br><span class="line">		cause: err,</span><br><span class="line">		msg:   message,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong> 添加错误信息，增加一个普通的堆栈打印</p>
<h3 id="Is-解析Sentinel错误、即全局错误变量"><a href="#Is-解析Sentinel错误、即全局错误变量" class="headerlink" title="Is 解析Sentinel错误、即全局错误变量"></a>Is 解析Sentinel错误、即全局错误变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target error)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> stderrors.Is(err, target) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err == target</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	isComparable := reflectlite.TypeOf(target).Comparable()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> isComparable &amp;&amp; err == target &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; Is(error) <span class="keyword">bool</span> &#125;); ok &amp;&amp; x.Is(target) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> consider supporing target.Is(err). This would allow</span></span><br><span class="line">		<span class="comment">// user-definable predicates, but also may allow for coping with sloppy</span></span><br><span class="line">		<span class="comment">// APIs, thereby making it easier to get away with them.</span></span><br><span class="line">		<span class="keyword">if</span> err = Unwrap(err); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong> 反复Unwrap、提取错误，解析并对比错误类型</p>
<h2 id="As-提取出具体的错误数据结构"><a href="#As-提取出具体的错误数据结构" class="headerlink" title="As - 提取出具体的错误数据结构"></a>As - 提取出具体的错误数据结构</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">As</span><span class="params">(err error, target <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> stderrors.As(err, target) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">As</span><span class="params">(err error, target <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;errors: target cannot be nil&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	val := reflectlite.ValueOf(target)</span><br><span class="line">	typ := val.Type()</span><br><span class="line">	<span class="keyword">if</span> typ.Kind() != reflectlite.Ptr || val.IsNil() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;errors: target must be a non-nil pointer&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> e := typ.Elem(); e.Kind() != reflectlite.Interface &amp;&amp; !e.Implements(errorType) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;errors: *target must be interface or implement error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	targetType := typ.Elem()</span><br><span class="line">	<span class="keyword">for</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> reflectlite.TypeOf(err).AssignableTo(targetType) &#123;</span><br><span class="line">			val.Elem().Set(reflectlite.ValueOf(err))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; As(<span class="keyword">interface</span>&#123;&#125;) <span class="keyword">bool</span> &#125;); ok &amp;&amp; x.As(target) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		err = Unwrap(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong> 反复Unwrap、提取错误，提取底层的实现类型</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Go</code>语言对<code>error</code>的定义很简单，虽然带来了灵活性，但也导致处理方式泛滥，一如当年的<strong>Go语言的版本管理</strong>。如今的<strong>go mod</strong>版本管理机制已经”一统江湖“，随着大家对<code>error</code>这块的不断深入，<code>Error Handling</code>也总会达成共识。</p>
<p>接下来，我会结合实际代码样例，写一个具体工程中 <strong>Error Handling</strong> 的操作方法，提供一定的参考。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言技巧 - 3.【Error工程化】Go Error的工程化探索</title>
    <url>/2021/05/07/go-tip/go-tip-3/</url>
    <content><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="Go-Error的工程化探索"><a href="#Go-Error的工程化探索" class="headerlink" title="Go Error的工程化探索"></a>Go Error的工程化探索</h2><p>在上一篇，我分享了对 <a href="https://go.googlesource.com/proposal/+/master/design/29934-error-values.md">官方Proposal</a> 的一些见解，偏向于理论层面。</p>
<p>本篇里，我会具体到代码层面，谈谈如何在一个工程化的项目中利用<code>github.com/pkg/errors</code>包，完整实现一套的错误处理机制。</p>
<span id="more"></span>

<h2 id="全局定义的error实现-MyError"><a href="#全局定义的error实现-MyError" class="headerlink" title="全局定义的error实现 - MyError"></a>全局定义的error实现 - MyError</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局的 错误号 类型，用于API调用之间传递</span></span><br><span class="line"><span class="keyword">type</span> MyErrorCode <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的 错误号 的具体定义</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	ErrorBookNotFoundCode MyErrorCode = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">	ErrorBookHasBeenBorrowedCode</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部的错误map，用来对应 错误号和错误信息</span></span><br><span class="line"><span class="keyword">var</span> errCodeMap = <span class="keyword">map</span>[MyErrorCode]<span class="keyword">string</span>&#123;</span><br><span class="line">	ErrorBookNotFoundCode:        <span class="string">&quot;Book was not found&quot;</span>,</span><br><span class="line">	ErrorBookHasBeenBorrowedCode: <span class="string">&quot;Book has been borrowed&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sentinel Error： 即全局定义的Static错误变量</span></span><br><span class="line"><span class="comment">// 注意，这里的全局error是没有保存堆栈信息的，所以需要在初始调用处使用 errors.Wrap</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ErrorBookNotFound        = NewMyError(ErrorBookNotFoundCode)</span><br><span class="line">	ErrorBookHasBeenBorrowed = NewMyError(ErrorBookHasBeenBorrowedCode)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyError</span><span class="params">(code MyErrorCode)</span> *<span class="title">MyError</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">		Code:    code,</span><br><span class="line">		Message: errCodeMap[code],</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error的具体实现</span></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 对外使用 - 错误码</span></span><br><span class="line">	Code MyErrorCode</span><br><span class="line">	<span class="comment">// 对外使用 - 错误信息</span></span><br><span class="line">	Message <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="具体示例-借书的三种场景"><a href="#具体示例-借书的三种场景" class="headerlink" title="具体示例 - 借书的三种场景"></a>具体示例 - 借书的三种场景</h2><p>我们来模拟一个场景：</p>
<p>我去图书馆借几本书，会存在三个场景，分别的处理逻辑如下</p>
<ol>
<li>找到书 - 不需要任何处理</li>
<li>发现书被借走了 - 打印一下即可，不认为是错误</li>
<li>发现图书馆不存在这本书 - 认为是错误，需要打印详细的错误信息</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	books := []<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;Hamlet&quot;</span>,</span><br><span class="line">		<span class="string">&quot;Jane Eyre&quot;</span>,</span><br><span class="line">		<span class="string">&quot;War and Peace&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, bookName := <span class="keyword">range</span> books &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s start\n===\n&quot;</span>, bookName)</span><br><span class="line"></span><br><span class="line">		err := borrowOne(bookName)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;===\n%s end\n\n&quot;</span>, bookName)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">borrowOne</span><span class="params">(bookName <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Step1: 找书</span></span><br><span class="line">	err := searchBook(bookName)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step2: 处理</span></span><br><span class="line">	<span class="comment">// 特殊业务场景：如果发现书被借走了，下次再来就行了，不需要作为错误处理</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 提取error这个interface底层的错误码，一般在API的返回前才提取</span></span><br><span class="line">		<span class="comment">// As - 获取错误的具体实现</span></span><br><span class="line">		<span class="keyword">var</span> myError = <span class="built_in">new</span>(MyError)</span><br><span class="line">		<span class="keyword">if</span> errors.As(err, &amp;myError) &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;error code is %d, message is %s\n&quot;</span>, myError.Code, myError.Message)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 特殊逻辑: 对应场景2，指定错误(ErrorBookHasBeenBorrowed)时，打印即可，不返回错误</span></span><br><span class="line">		<span class="comment">// Is - 判断错误是否为指定类型</span></span><br><span class="line">		<span class="keyword">if</span> errors.Is(err, ErrorBookHasBeenBorrowed) &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;book %s has been borrowed, I will come back later!\n&quot;</span>, bookName)</span><br><span class="line">			err = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBook</span><span class="params">(bookName <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 下面两个 error 都是不带堆栈信息的，所以初次调用得用Wrap方法</span></span><br><span class="line">	<span class="comment">// 如果已有堆栈信息，应调用WithMessage方法</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3 发现图书馆不存在这本书 - 认为是错误，需要打印详细的错误信息</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(bookName) &gt; <span class="number">10</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Wrapf(ErrorBookNotFound, <span class="string">&quot;bookName is %s&quot;</span>, bookName)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(bookName) &gt; <span class="number">8</span> &#123;</span><br><span class="line">		<span class="comment">// 2 发现书被借走了 - 打印一下被接走的提示即可，不认为是错误</span></span><br><span class="line">		<span class="keyword">return</span> errors.Wrapf(ErrorBookHasBeenBorrowed, <span class="string">&quot;bookName is %s&quot;</span>, bookName)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 1 找到书 - 不需要任何处理</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><h3 id="1-找到书-Helmet"><a href="#1-找到书-Helmet" class="headerlink" title="1. 找到书 - Helmet"></a>1. 找到书 - Helmet</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hamlet start</span><br><span class="line">===</span><br><span class="line">===</span><br><span class="line">Hamlet end</span><br></pre></td></tr></table></figure>

<p>没有任何错误信息</p>
<h3 id="2-发现书被借走了-Jane-Eyre"><a href="#2-发现书被借走了-Jane-Eyre" class="headerlink" title="2. 发现书被借走了 - Jane Eyre"></a>2. 发现书被借走了 - Jane Eyre</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Jane Eyre start</span><br><span class="line">===</span><br><span class="line">error code is 2, message is Book has been borrowed</span><br><span class="line">book Jane Eyre has been borrowed, I will come back later!</span><br><span class="line">===</span><br><span class="line">Jane Eyre end</span><br></pre></td></tr></table></figure>

<p><strong>打印被借走的提示</strong>，而错误被 <code>err = nil</code> 屏蔽。</p>
<h3 id="3-发现图书馆不存在这本书-War-and-Peace"><a href="#3-发现图书馆不存在这本书-War-and-Peace" class="headerlink" title="3. 发现图书馆不存在这本书 - War and Peace"></a>3. 发现图书馆不存在这本书 - War and Peace</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">War and Peace start</span><br><span class="line">===</span><br><span class="line">error code is 1, message is Book was not found</span><br><span class="line">Book was not found</span><br><span class="line">bookName is War and Peace</span><br><span class="line">main.searchBook</span><br><span class="line">        /GoProject/godemo/main.go:98</span><br><span class="line">main.borrowOne</span><br><span class="line">        /GoProject/godemo/main.go:71</span><br><span class="line">main.main</span><br><span class="line">        /GoProject/godemo/main.go:60</span><br><span class="line">runtime.main</span><br><span class="line">        /usr/local/go1.13.5/src/runtime/proc.go:203</span><br><span class="line">runtime.goexit</span><br><span class="line">        /usr/local/go1.13.5/src/runtime/asm_amd64.s:1357</span><br><span class="line">===</span><br><span class="line">War and Peace end</span><br></pre></td></tr></table></figure>

<p><strong>打印了错误的详细堆栈</strong>，在IDE中调试非常方便，可以直接跳转到对应代码位置。</p>
<h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ol>
<li><code>MyError</code> 作为全局 <code>error</code> 的底层实现，保存具体的错误码和错误信息；</li>
<li><code>MyError</code>向上返回错误时，第一次先用<code>Wrap</code>初始化堆栈，后续用<code>WithMessage</code>增加堆栈信息；</li>
<li>从<code>error</code>中解析具体错误时，用<code>errors.As</code>提取出<code>MyError</code>，其中的错误码和错误信息可以传入到具体的API接口中；</li>
<li>要判断<code>error</code>是否为指定的错误时，用<code>errors.Is</code> + <code>Sentinel Error</code>的方法，处理一些特定情况下的逻辑；</li>
</ol>
<blockquote>
<p>Tips：</p>
<ol>
<li>不要一直用errors.Wrap来反复包装错误，堆栈信息会爆炸，具体情况可自行测试了解</li>
<li>利用go generate可以大量简化初始化Sentinel Error这块重复的工作</li>
<li><code>github.com/pkg/errors</code>和标准库的<code>error</code>完全兼容，可以先替换、后续改造历史遗留的代码</li>
<li>一定要注意打印<code>error</code>的堆栈需要用<code>%+v</code>，而原来的<code>%v</code>依旧为普通字符串方法；同时也要注意日志采集工具是否支持多行匹配</li>
</ol>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从现状来看，<code>Go</code> 语言的 <code>Error Handling</code> 已趋于共识，。</p>
<p>后续差异点就在底层 <code>MyError</code> 这块的实现，我个人认为会有如下三个方向：</p>
<ul>
<li>增加一些其余业务或系统的字段</li>
<li>对<code>Is</code>，<code>As</code> 等函数再进行一定的封装，使用起来更方便</li>
<li>区分不同的错误类型，来告诉调用方该如何处理，如 <strong>普通错误</strong>、<strong>重试错误</strong> 、<strong>服务降级错误</strong> 等</li>
</ul>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言技巧 - 4.【错误的三种处理】探索不同代码风格背后的哲学</title>
    <url>/2021/06/27/go-tip/go-tip-4/</url>
    <content><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>通过前面两讲，我们对错误的认知已经超过很多人了。让我们继续去看看常见项目中对错误的处理方式，探索背后的深意。</p>
<p>在介绍具体的处理方式前，我们先来模拟一个场景：我们要去动物园进行一次游玩，主要行为有</p>
<ul>
<li>进入动物园</li>
<li>参观熊猫</li>
<li>参观老虎</li>
<li>离开动物园</li>
</ul>
<span id="more"></span>

<h2 id="第一种风格-经典Go语言的处理模式"><a href="#第一种风格-经典Go语言的处理模式" class="headerlink" title="第一种风格 - 经典Go语言的处理模式"></a>第一种风格 - 经典Go语言的处理模式</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次旅游</span></span><br><span class="line"><span class="keyword">type</span> ZooTour1 <span class="keyword">interface</span> &#123;</span><br><span class="line">	Enter() error <span class="comment">// 进入</span></span><br><span class="line">	VisitPanda(panda *Panda) error <span class="comment">// 看熊猫</span></span><br><span class="line">	VisitTiger(tiger *Tiger) error <span class="comment">// 看老虎</span></span><br><span class="line">	Leave() error <span class="comment">// 离开</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tour1</span><span class="params">(t ZooTour1, panda *Panda, tiger *Tiger)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := t.Enter(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;Enter failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := t.VisitPanda(panda); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessagef(err, <span class="string">&quot;VisitPanda failed, panda is %v&quot;</span>, panda)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := t.VisitTiger(tiger); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessagef(err, <span class="string">&quot;VisitTiger failed, tiger is %v&quot;</span>, tiger)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := t.Leave(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;Leave failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个处理风格非常经典。我们先不深入讨论，看完下一种后再做对比。</p>
<h2 id="第二种风格-类似Try-Catch的代码风格"><a href="#第二种风格-类似Try-Catch的代码风格" class="headerlink" title="第二种风格 - 类似Try-Catch的代码风格"></a>第二种风格 - 类似Try-Catch的代码风格</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ZooTour2 <span class="keyword">interface</span> &#123;</span><br><span class="line">	Enter()</span><br><span class="line">	VisitPanda(panda *Panda)</span><br><span class="line">	VisitTiger(tiger *Tiger)</span><br><span class="line">	Leave()</span><br><span class="line"></span><br><span class="line">	Err() error <span class="comment">// 统一处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tour2</span><span class="params">(t ZooTour2, panda *Panda, tiger *Tiger)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	t.Enter()</span><br><span class="line">	t.VisitPanda(panda)</span><br><span class="line">	t.VisitTiger(tiger)</span><br><span class="line">	t.Leave()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := t.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;ZooTour failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一整块的代码风格非常类似<strong>Try Catch</strong>，即先写业务逻辑，在最后对错误进行集中处理。</p>
<blockquote>
<p>标准库中的<code>bufio.Scanner</code>就是参考这种方式实现的。</p>
</blockquote>
<p>不过，由于Go语言对error的处理没有往外抛的机制，所以需要专门针对error做处理：</p>
<blockquote>
<p>新手千万不要把panic的机制和错误处理混为一谈。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ZooTour的具体实现，需要保存一个error</span></span><br><span class="line"><span class="keyword">type</span> myZooTour <span class="keyword">struct</span> &#123;</span><br><span class="line">	err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *myZooTour)</span> <span class="title">VisitPanda</span><span class="params">(panda *Panda)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 遇到错误就要直接返回，再处理其余逻辑</span></span><br><span class="line">	<span class="keyword">if</span> t.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="两种风格的对比"><a href="#两种风格的对比" class="headerlink" title="两种风格的对比"></a>两种风格的对比</h2><p>如果分别用一个词来形容前两种风格，我倾向于：</p>
<ol>
<li><strong>过程式的调用</strong></li>
<li><strong>集中处理错误</strong></li>
</ol>
<p>两种风格无法说清孰优孰劣，但有各自适宜的场景，我们来列举两种：</p>
<h3 id="不关注错误的发生，而关注错误发生后的统一处理"><a href="#不关注错误的发生，而关注错误发生后的统一处理" class="headerlink" title="不关注错误的发生，而关注错误发生后的统一处理"></a>不关注错误的发生，而关注错误发生后的统一处理</h3><p>内部存在大量的<code>VisitXXX</code>的函数，业务不关注发生错误的处理逻辑，而是关注整个流程完成后对error的处理。</p>
<p>例如，调用过程中如果出现了某个动物不在的问题，我们不关心，继续访问下一个，最后统一处理一下，看看有多少动物是不在的，打印一下即可。</p>
<p>这时，第二种处理方式明显会更简洁。</p>
<blockquote>
<p>一般推荐在工具类中采用这种方式，处理的内容比较直观，不会有太多异常case</p>
</blockquote>
<h3 id="错误有多种分类，会影响到程序的运行逻辑"><a href="#错误有多种分类，会影响到程序的运行逻辑" class="headerlink" title="错误有多种分类，会影响到程序的运行逻辑"></a>错误有多种分类，会影响到程序的运行逻辑</h3><p>例如<code>VisitPanda(panda *Panda)</code> 可能产生的错误分2类：</p>
<ul>
<li><p>不影响主流程：例如发现panda不见了，但还要接着继续参观其余动物</p>
</li>
<li><p>影响主流程：例如突然收到动物园闭园的通知，不能参观其余动物了</p>
</li>
</ul>
<p>这时，如果我们采用第二种风格，就得在每个函数内部加上很多特殊的业务逻辑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *myZooTour)</span> <span class="title">VisitTiger</span><span class="params">(tiger *Tiger)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 要针对特定error进行处理</span></span><br><span class="line">	<span class="keyword">if</span> t.err != <span class="literal">nil</span> &amp;&amp; t.err != ErrorPandaMissing &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很有可能出现一个问题：<strong>把Panda相关的error放到了Tiger里</strong>。</p>
<p>所以，<strong>当错误的类型会影响到代码的运行逻辑，更适合第一种方案</strong>。</p>
<blockquote>
<p>一般情况下，我们的业务代码都是复杂的，这时候更适合写过程性的代码。</p>
</blockquote>
<h2 id="第三种风格-函数式编程"><a href="#第三种风格-函数式编程" class="headerlink" title="第三种风格 - 函数式编程"></a>第三种风格 - 函数式编程</h2><p>借用1中的接口定义，我们将它改造成函数式的风格：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFunc <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEnterFunc</span><span class="params">()</span> <span class="title">MyFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.Enter()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewVisitPandaFunc</span><span class="params">(panda *Panda)</span> <span class="title">MyFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.VisitPanda(panda)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewVisitTigerFunc</span><span class="params">(tiger *Tiger)</span> <span class="title">MyFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.VisitTiger(tiger)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLeaveFunc</span><span class="params">()</span> <span class="title">MyFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.Leave()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用代码示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tour3</span><span class="params">(t ZooTour1, panda *Panda, tiger *Tiger)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> actions = []MyFunc&#123;</span><br><span class="line">		NewEnterFunc(),</span><br><span class="line">		NewVisitPandaFunc(panda),</span><br><span class="line">		NewVisitTigerFunc(tiger),</span><br><span class="line">		NewLeaveFunc(),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ContinueOnError(t, actions)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContinueOnError</span><span class="params">(t ZooTour1, funcs []MyFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">    <span class="keyword">if</span> err := f(t);err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// continue</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BreakOnError</span><span class="params">(t ZooTour1, funcs []MyFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">    <span class="keyword">if</span> err := f(t);err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提的是</p>
<ul>
<li><code>ContinueOnError</code>表示遇到了error只记录下来，但整个流程继续往下跑</li>
<li><code>BreakOnError</code>表示遇到了error就直接break，不再跑接下来的<code>MyFunc</code></li>
</ul>
<h2 id="方案三背后的思想与延伸"><a href="#方案三背后的思想与延伸" class="headerlink" title="方案三背后的思想与延伸"></a>方案三背后的思想与延伸</h2><p>函数式编程最直观的一个特点是 <strong>延迟执行</strong>，也就是在引用<code>MyFunc</code>处不运行，在<code>ContinueOnError</code>或<code>BreakOnError</code>里才是真正执行的地方。</p>
<p>这个延迟执行的特性，在这里还能达到一个很有意思的效果 - <strong>分离关注点</strong>。</p>
<h3 id="关注点1-数据结构"><a href="#关注点1-数据结构" class="headerlink" title="关注点1 - 数据结构"></a>关注点1 - 数据结构</h3><p>样例中的<code>[]MyFunc</code>是一个切片，可以简单地理解为<strong>串行执行</strong>，也就是<code>MyFunc</code>执行完一个，再执行下一个。</p>
<p>我们可以引入更多的数据结构，例如<code>[][]MyFunc</code>，那就可以理解为增加了一层：</p>
<p>每一层中的<code>[]MyFunc</code>，代表这里面的所有<code>MyFunc</code>是平级的，也就可以采用一定的并发模式来加速执行。</p>
<h3 id="关注点2-执行逻辑"><a href="#关注点2-执行逻辑" class="headerlink" title="关注点2 - 执行逻辑"></a>关注点2 - 执行逻辑</h3><p>以<code>ContinueOnError</code>或<code>BreakOnError</code>为例，它们都是对各种<code>MyFunc</code>的处理逻辑。我们还可以引入更多的执行逻辑，比如：</p>
<ul>
<li>容忍特定错误的情况</li>
<li>对错误发生的数量有容忍上限</li>
<li>保证一定的并发模式</li>
</ul>
<h3 id="流水线的模式"><a href="#流水线的模式" class="headerlink" title="流水线的模式"></a>流水线的模式</h3><p>以我们常见的开发流水线为例，常见的包括：代码检查、单元测试、编译、CodeReview、自动化部署等。</p>
<p>这时，数据结构可以用来表示<strong>流水线的结构</strong>，执行逻辑可以用来表示<strong>流水线对异常的处置</strong>。</p>
<p>比如说，我们可以编排为一种串行执行的逻辑：</p>
<ol>
<li>代码检查</li>
<li>单元测试</li>
<li>编译</li>
<li>CodeReview</li>
<li>自动化部署</li>
</ol>
<p>我们想要加速整个流程，可以考虑修改为：</p>
<ol>
<li>检查<ol>
<li>代码检查</li>
<li>单元测试</li>
<li>编译</li>
</ol>
</li>
<li>CodeReview</li>
<li>自动化部署</li>
</ol>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文介绍了三种对error的处理方式，代码实现相对简单，大家更需要关注背后的适用场景。</p>
<p>其中，第三种方式是一个很有意思的设计模式，可以帮助大家理解函数式编程的价值。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言技巧 - 5.【初探Go Module】Go语言的版本管理</title>
    <url>/2021/07/03/go-tip/go-tip-5/</url>
    <content><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="Go-Mod的官方说明"><a href="#Go-Mod的官方说明" class="headerlink" title="Go Mod的官方说明"></a>Go Mod的官方说明</h2><p>Go语言自从推出了<code>go mod</code>作为版本管理工具后，结束Go语言版本管理工具的纷争，实现了大一统。</p>
<p>相信有很多人都对这个版本管理的机制都有基础的概念、但并不深入。而官方把最核心的实现，都放在这一篇 <a href="https://golang.org/ref/mod">https://golang.org/ref/mod</a> 文档中。</p>
<p>今天，我们一起来读读这一篇文章。</p>
<span id="more"></span>

<h2 id="快速入门-5篇介绍Go-Mod系列的官方博客"><a href="#快速入门-5篇介绍Go-Mod系列的官方博客" class="headerlink" title="快速入门 - 5篇介绍Go Mod系列的官方博客"></a>快速入门 - 5篇介绍Go Mod系列的官方博客</h2><p>新手直接阅读这篇文章的门槛有点高，我建议可以先看看下面这五篇较为通俗的官方博客，能帮助我们了解一些背景知识。</p>
<h3 id="1-using-go-modules"><a href="#1-using-go-modules" class="headerlink" title="1. using-go-modules"></a>1. using-go-modules</h3><p><a href="https://blog.golang.org/using-go-modules">https://blog.golang.org/using-go-modules</a> </p>
<ol>
<li><code>go.mod</code>放在项目的根目录，抛弃原来的<code>GOPATH</code></li>
<li>用<code>MAJOR.MINOR.PATCH</code>格式管理版本，详细可参考<a href="https://semver.org/">Semantic Versioning 2.0.0</a></li>
<li>用<code>go.sum</code>保证依赖文件被完整下载（如果公司搭建私有库就会出现校验问题，需要关闭GOSUM）</li>
<li>项目内部的库，不再是相对路径，而用的是 <code>go mod模块名</code> + <code>相对路径</code> ，定义更加清晰</li>
</ol>
<blockquote>
<p>第四点的价值很大，可读性大大提高，我们可以将一整个path来辅助命名，如 market/order，前者market可以帮助后者order的含义做一定补充</p>
</blockquote>
<h3 id="2-migrating-to-go-modules"><a href="#2-migrating-to-go-modules" class="headerlink" title="2. migrating-to-go-modules"></a>2. migrating-to-go-modules</h3><p><a href="https://blog.golang.org/migrating-to-go-modules">https://blog.golang.org/migrating-to-go-modules</a></p>
<p>将项目迁移到go mod，主要讲的是对接老的版本管理系统，如<code>godeps</code>。</p>
<h3 id="3-publishing-go-modules"><a href="#3-publishing-go-modules" class="headerlink" title="3. publishing-go-modules"></a>3. publishing-go-modules</h3><p><a href="https://blog.golang.org/publishing-go-modules">https://blog.golang.org/publishing-go-modules</a></p>
<p>版本命名规则：推荐不稳定版本用<code>v0.x.x</code>开始，稳定后改成<code>v1.x.x</code>。</p>
<p><strong>pseudo-version</strong> 直译为假的版本，一般是直接依赖branch，而不是按规范依赖tag</p>
<h3 id="4-v2-go-modules"><a href="#4-v2-go-modules" class="headerlink" title="4. v2-go-modules"></a>4. v2-go-modules</h3><p><a href="https://blog.golang.org/v2-go-modules">https://blog.golang.org/v2-go-modules</a></p>
<p>注意主版本名为<code>v2</code>之后的，项目里对应的要新增一个<code>v2</code>或者更高版本号的目录。</p>
<blockquote>
<p>我个人感觉升级到v2这种方式不太友好，需要我们再维护一整个目录</p>
</blockquote>
<h3 id="5-module-compatibility"><a href="#5-module-compatibility" class="headerlink" title="5. module-compatibility"></a>5. module-compatibility</h3><p><a href="https://blog.golang.org/module-compatibility">https://blog.golang.org/module-compatibility</a></p>
<ol>
<li>用不定参数<code>...</code>的特性提高函数的入参扩展性</li>
<li>引入函数式的参数，也就是将具体的执行逻辑作为参数，传递进来</li>
<li>引入<code>Option types</code>模式，更详细地可以参考我的<a href="https://junedayday.github.io/2021/02/20/go-patterns/go-patterns-5/">文章</a></li>
<li>用接口<code>interface</code>分离调用和实现</li>
<li>如果结构体<code>struct</code>明确不能对比，就用一个<code>doNotCompare</code>的<code>field</code>来告诉调用者</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> doNotCompare [<span class="number">0</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">        doNotCompare</span><br><span class="line">        X <span class="keyword">int</span></span><br><span class="line">        Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第五点非常有意思，也就是要求我们在前期设计对象时，就要考虑清楚这个对象后续的特性，比如示例中的是否可以对比</p>
</blockquote>
<h2 id="从go-mod的文件格式讲起"><a href="#从go-mod的文件格式讲起" class="headerlink" title="从go.mod的文件格式讲起"></a>从go.mod的文件格式讲起</h2><p>进入正题，我们来一起看看<code>go.mod</code>，它的定义简单示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module example.com/my/thing</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require example.com/other/thing v1.0.2</span><br><span class="line">require example.com/new/thing/v2 v2.3.4</span><br><span class="line">exclude example.com/old/thing v1.2.3</span><br><span class="line">replace example.com/bad/thing v1.4.5 =&gt; example.com/good/thing v1.4.5</span><br><span class="line">retract [v1.9.0, v1.9.5]</span><br></pre></td></tr></table></figure>

<p>IDE会帮助你格式化，记住以下关键词即可（重点为前三个）</p>
<ol>
<li><strong>module</strong> - go mod init指令定义的<strong>库名</strong></li>
<li><strong>go</strong> - <strong>要求go语言的最低版本</strong>，会影响到后面依赖库的下载</li>
<li><strong>require</strong> - <strong>必备库</strong>，也就是代码中直接import的部分</li>
<li><strong>replace</strong> - <strong>替换库</strong>，在重构时挺好用（比如某个开源组件有问题，内部fork了一版，直接replace即可）</li>
<li><strong>retract</strong> <strong>撤回版本</strong>，告诉调用本库的项目，部分版本有严重问题、不要引用</li>
</ol>
<blockquote>
<p>go mod 底层实现依赖 - <strong>MVS</strong> 最小版本选择。</p>
<p>这个特性很有意思，后续单独来讲讲这块，一开始就不深入到细节了</p>
</blockquote>
<h2 id="加深理解-incompatible和indirect"><a href="#加深理解-incompatible和indirect" class="headerlink" title="加深理解 - incompatible和indirect"></a>加深理解 - incompatible和indirect</h2><p>在我们整理<code>go.mod</code>文件时，经常能看到两个奇怪的字符<code>indirect</code>和<code>incompatible</code>。我们来详细地分析一下。</p>
<h3 id="incompatible-兼容v2及以上的版本号"><a href="#incompatible-兼容v2及以上的版本号" class="headerlink" title="incompatible - 兼容v2及以上的版本号"></a>incompatible - 兼容v2及以上的版本号</h3><p>上面我们已经讲过，如果一个库的tag为v1以上，如v2，就必须得创建一个v2的目录。例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require example.com/new/thing/v2 v2.3.4</span><br></pre></td></tr></table></figure>

<p>这就要求我们在项目<code>example.com/new/thing</code>下新建v2目录，再存放代码。但是，很多库往往只是升级个主版本号，并不会去新建目录、还需要迁移代码。为了兼容这个情况，就会引入<code>+incompatible</code>。例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require example.com/new/thing v2.3.4+incompatible</span><br></pre></td></tr></table></figure>

<h3 id="indirect-未在go-mod里定义、但间接调用的库"><a href="#indirect-未在go-mod里定义、但间接调用的库" class="headerlink" title="indirect - 未在go.mod里定义、但间接调用的库"></a>indirect - 未在go.mod里定义、但间接调用的库</h3><p>我们先聊一个简单的场景：<strong>当前项目为A，调用了项目B，B又调用了C。对A进行编译，需要B和C的相关代码</strong>。</p>
<p>在完全规范的项目中：</p>
<ul>
<li><strong>条件1</strong> - A的go.mod里包含B</li>
<li><strong>条件2</strong> - B的go.mod里包含C</li>
</ul>
<p>在编译A时，会在go.mod找到B的信息，所以B是<code>require</code>字段；而C的信息已经被维护在B的go.mod里了，不需要在A的go.mod里维护。</p>
<p>而什么样的情况会发生indirect呢？它对应的是 <strong>条件2</strong> 缺失的场景</p>
<ol>
<li>B<strong>没有启用Go Module</strong>，采用的是老项目管理方式</li>
<li>B的<strong>go.mod部分缺失</strong>，未填写模块C</li>
</ol>
<blockquote>
<p>最常见的部分缺失场景是：项目虽然有go.mod，但实际编译不走Go Module，而是如vendor目录等方式</p>
</blockquote>
<p>用一句话总结，<strong>A库无法根据B库的<code>go.mod</code>找到C库</strong>。</p>
<h2 id="常见命令介绍"><a href="#常见命令介绍" class="headerlink" title="常见命令介绍"></a>常见命令介绍</h2><p>相关的指令有很多，我重点分两块来说：</p>
<p>先是<strong>高频使用</strong>的命令：</p>
<h3 id="用go-mod-init初始化项目"><a href="#用go-mod-init初始化项目" class="headerlink" title="用go mod init初始化项目"></a>用go mod init初始化项目</h3><p>初始化项目，保证module名称与git路径一致。</p>
<p>例如 <code>go mod init github.com/example/a</code></p>
<h3 id="用go-get下载指定依赖库与版本"><a href="#用go-get下载指定依赖库与版本" class="headerlink" title="用go get下载指定依赖库与版本"></a>用go get下载指定依赖库与版本</h3><p>常见的flags</p>
<ul>
<li><strong>-d</strong> 只更新<code>go.mod</code>中的依赖，轻量级</li>
<li><strong>-u</strong> 更新指定库与依赖它的库，全量</li>
</ul>
<p>例如<code>go get -d github.com/example/b</code></p>
<h3 id="根据go-mod下载依赖库go-mod-download-vendor"><a href="#根据go-mod下载依赖库go-mod-download-vendor" class="headerlink" title="根据go.mod下载依赖库go mod download/vendor"></a>根据go.mod下载依赖库go mod download/vendor</h3><p>其中download是下载到Go Module的缓存中，而vendor是下载到vendor依赖路径。官方推荐前者。</p>
<p>我经常会去手动编辑<code>go.mod</code>文件，然后用这个指令刷新一下依赖库</p>
<h3 id="整理依赖go-mod-tidy"><a href="#整理依赖go-mod-tidy" class="headerlink" title="整理依赖go mod tidy"></a>整理依赖go mod tidy</h3><p>整理并更新go mod的依赖信息，保证当前的<code>go.mod</code>为最新。</p>
<p>然后是<strong>排查依赖库问题</strong>用到的：</p>
<h3 id="查看库的支持版本go-list"><a href="#查看库的支持版本go-list" class="headerlink" title="查看库的支持版本go list"></a>查看库的支持版本go list</h3><ul>
<li><code>go list -m all</code> 查看本项目的所有依赖库与版本</li>
<li><code>go list -m -versions &#123;module名&#125;</code> 查看module支持的版本号</li>
<li><code>go list -m -json &#123;module名&#125;@&#123;版本号&#125;</code> 用json格式查看指定module版本号的信息，如创建时间</li>
</ul>
<h3 id="查看当前库的依赖关系go-mod-graph"><a href="#查看当前库的依赖关系go-mod-graph" class="headerlink" title="查看当前库的依赖关系go mod graph"></a>查看当前库的依赖关系go mod graph</h3><p>查看所有go mod的依赖，一般在查依赖关系时用到</p>
<h3 id="查看指定库是怎么被依赖的go-mod-why"><a href="#查看指定库是怎么被依赖的go-mod-why" class="headerlink" title="查看指定库是怎么被依赖的go mod why"></a>查看指定库是怎么被依赖的go mod why</h3><p>查指定库是怎么被依赖的</p>
<h3 id="查看二进制文件的依赖信息go-version-m"><a href="#查看二进制文件的依赖信息go-version-m" class="headerlink" title="查看二进制文件的依赖信息go version -m"></a>查看二进制文件的依赖信息go version -m</h3><p>查看指定（go文件编译的）二进制文件的版本信息</p>
<h2 id="设置GOPRXOY"><a href="#设置GOPRXOY" class="headerlink" title="设置GOPRXOY"></a>设置GOPRXOY</h2><p>大部分人使用<code>go.mod</code>的最大问题是无法下载代码库，也就是代理的设置，网上也有很多教程，我这边给三个我常用的：</p>
<ol>
<li>阿里云：GOPROXY=<a href="https://mirrors.aliyun.com/goproxy,direct">https://mirrors.aliyun.com/goproxy,direct</a></li>
<li>七牛云：GOPROXY=<a href="https://goproxy.cn,direct/">https://goproxy.cn,direct</a></li>
<li>全球代理：GOPROXY=<a href="https://goproxy.io,direct/">https://goproxy.io,direct</a></li>
</ol>
<blockquote>
<p>公司私有库需要私有代理。</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本讲的内容到这里就告一段落了，相信通过这篇文章，大家已经能应对绝大部分Go Module的场景。</p>
<p>下一讲，我会重点讲Go Module最核心的 <strong>Minimal version selection (MVS)</strong> 机制。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言技巧 - 6.【深入Go Module】探索最小版本选择的机制</title>
    <url>/2021/07/09/go-tip/go-tip-6/</url>
    <content><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="从一个示例讲起"><a href="#从一个示例讲起" class="headerlink" title="从一个示例讲起"></a>从一个示例讲起</h2><p>用一个简单列表来表示我们的模块A依赖：</p>
<ul>
<li>B1<code>v1.0.0</code><ul>
<li>C1<code>v1.1.0</code></li>
<li>C2 <code>v1.2.0</code></li>
</ul>
</li>
<li>B2 <code>v1.2.0</code><ul>
<li>C1<code>v1.1.2</code></li>
<li>C3 <code>v1.2.0</code></li>
</ul>
</li>
</ul>
<p>表示 <em>A依赖B1与B2，而B1又依赖C1、C2，B2依赖C1、C3</em>。</p>
<p>这里，我们把关注点放到有争议的C1，它存在两个版本<code>v1.1.0</code>与<code>v1.1.2</code>。而最终A选择的是<code>v1.1.2</code>版本的C1。</p>
<ul>
<li>B1<code>v1.0.0</code><ul>
<li><del>C1<code>v1.1.0</code></del></li>
<li>C2 <code>v1.2.0</code></li>
</ul>
</li>
<li>B2 <code>v1.2.0</code><ul>
<li>C1<code>v1.1.2</code></li>
<li>C3 <code>v1.2.0</code></li>
</ul>
</li>
</ul>
<span id="more"></span>

<h3 id="问题1：为什么要选择较高版本的C1？"><a href="#问题1：为什么要选择较高版本的C1？" class="headerlink" title="问题1：为什么要选择较高版本的C1？"></a>问题1：为什么要选择较高版本的C1？</h3><p>也许你会疑惑，为什么原则名字叫<strong>最小版本选择</strong>，但反而选择了较高那个版本呢？</p>
<p>我们要明确一点，<strong>最小版本选择</strong>这个概念不是应用在这个场景的！</p>
<p>从两个版本号的语义来看，<code>v1.1.2</code>和<code>v1.1.0</code>的主版本号都是<code>v1</code>，说明是向下兼容的。所以我们自然会选择较高的<code>v1.1.2</code>，毕竟如果用了<code>v1.1.0</code>，可能导致B2具体的代码不可用。</p>
<h3 id="问题2：如果同时出现了v1和v2怎么办？"><a href="#问题2：如果同时出现了v1和v2怎么办？" class="headerlink" title="问题2：如果同时出现了v1和v2怎么办？"></a>问题2：如果同时出现了v1和v2怎么办？</h3><p>如果场景变化，C1的依赖版本为<code>v1.1.0</code>和<code>v2.0.0</code>，也就是大版本发生了变化。</p>
<p>从版本号的语义来看，两者是<strong>不兼容</strong>的！所以，这时不会出现<strong>高版本覆盖低版本</strong>的情况。</p>
<p>这时，就会出现依赖2个版本的C1。</p>
<h3 id="问题3：那什么是最小版本选择中的“最小”呢？"><a href="#问题3：那什么是最小版本选择中的“最小”呢？" class="headerlink" title="问题3：那什么是最小版本选择中的“最小”呢？"></a>问题3：那什么是最小版本选择中的“最小”呢？</h3><p>在C1这个库中，我们能看到很多tag，例如<code>v1.1.0</code>，<code>v1.1.1</code>，<code>v1.1.2</code>，<code>v1.1.3</code>。而我们用到的是<code>v1.1.2</code>和<code>v1.1.0</code>。</p>
<p>从兼容性来看，<code>v1.1.3</code>肯定能兼容前面的版本。但这时，根据<strong>最小版本选择</strong>，我们引用到<code>v1.1.2</code>。</p>
<p>为什么要用这个最小版本原则，而不是每次都去拉取最新的tag？大家不妨思考思考，我这里列两个我能想到的点：</p>
<ol>
<li>保证项目依赖的稳定性：如果存在某个依赖库高频更新，会导致整个项目也频繁升级，造成风险；</li>
<li>完全向下兼容并不可靠：毕竟软件存在不稳定性，最新的tag很有可能会导致代码变更；</li>
</ol>
<h2 id="结合源码巩固知识点"><a href="#结合源码巩固知识点" class="headerlink" title="结合源码巩固知识点"></a>结合源码巩固知识点</h2><p>在阅读源码之前，我们先明确本次阅读源码的预期：<strong>不要为了掌握所有代码细节而读代码，而是希望能通过了解这部分功能的一个大致实现，巩固理论知识</strong>。</p>
<p>这里，我以<code>go语言1.15.11</code>版本为例，具体的代码路径在<code>src/cmd/go/internal/modcmd</code>下。</p>
<p><code>go mod tidy</code>是整理Go Module最常用的指令之一，这里我们就来看看<code>tidy.go</code>文件。</p>
<h3 id="tidy的简介"><a href="#tidy的简介" class="headerlink" title="tidy的简介"></a>tidy的简介</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cmdTidy = &amp;base.Command&#123;</span><br><span class="line">	UsageLine: <span class="string">&quot;go mod tidy [-v]&quot;</span>,</span><br><span class="line">	Short:     <span class="string">&quot;add missing and remove unused modules&quot;</span>,</span><br><span class="line">	Long: <span class="string">`</span></span><br><span class="line"><span class="string">Tidy makes sure go.mod matches the source code in the module.</span></span><br><span class="line"><span class="string">It adds any missing modules necessary to build the current module&#x27;s</span></span><br><span class="line"><span class="string">packages and dependencies, and it removes unused modules that</span></span><br><span class="line"><span class="string">don&#x27;t provide any relevant packages. It also adds any missing entries</span></span><br><span class="line"><span class="string">to go.sum and removes any unnecessary ones.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The -v flag causes tidy to print information about removed modules</span></span><br><span class="line"><span class="string">to standard error.</span></span><br><span class="line"><span class="string">	`</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tidy</code>主要是把缺失的module加入到模块中，并删除弃用的modules。加上<code>-v</code>的标记位，就能把信息打印到标注错误。</p>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p>核心的数据结构为，储存Go Module的路径Path和版本Version:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Version <span class="keyword">struct</span> &#123;</span><br><span class="line">	Path <span class="keyword">string</span></span><br><span class="line">	Version <span class="keyword">string</span> <span class="string">`json:&quot;,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而加载模块的代码，则是下面的<code>mvs.Req</code>函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cmd/go/internal/mvs</span></span><br><span class="line">mvs.Req(Target, direct, &amp;mvsReqs&#123;buildList: keep&#125;)</span><br></pre></td></tr></table></figure>

<p>这个函数的功能，我进行了一定的简化，大家关注重点标注出来的几行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Req</span><span class="params">(target module.Version, base []<span class="keyword">string</span>, reqs Reqs)</span> <span class="params">([]module.Version, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 保存模块与其依赖module的map，用map是为了防止依赖库重复</span></span><br><span class="line">	reqCache := <span class="keyword">map</span>[module.Version][]module.Version&#123;&#125;</span><br><span class="line">	reqCache[target] = <span class="literal">nil</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第一次遍历：walk函数，用于遍历整个依赖</span></span><br><span class="line">	<span class="keyword">var</span> walk <span class="function"><span class="keyword">func</span><span class="params">(module.Version)</span> <span class="title">error</span></span></span><br><span class="line">	walk = <span class="function"><span class="keyword">func</span><span class="params">(m module.Version)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="comment">// 获取m的依赖库required，保存到map中</span></span><br><span class="line">		required, err := reqs.Required(m)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		reqCache[m] = required</span><br><span class="line">    <span class="comment">// 继续遍历依赖的依赖，保证不缺失</span></span><br><span class="line">		<span class="keyword">for</span> _, m1 := <span class="keyword">range</span> required &#123;</span><br><span class="line">			<span class="keyword">if</span> err := walk(m1); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		postorder = <span class="built_in">append</span>(postorder, m)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 真正运行第一次walk的地方</span></span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> list &#123;</span><br><span class="line">		<span class="keyword">if</span> err := walk(m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二次遍历：再次定义一个walk函数，取最大的版本号</span></span><br><span class="line">	have := <span class="keyword">map</span>[module.Version]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">	walk = <span class="function"><span class="keyword">func</span><span class="params">(m module.Version)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> have[m] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		have[m] = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> _, m1 := <span class="keyword">range</span> reqCache[m] &#123;</span><br><span class="line">			walk(m1)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	max := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> list &#123;</span><br><span class="line">		<span class="keyword">if</span> v, ok := max[m.Path]; ok &#123;</span><br><span class="line">      <span class="comment">// 只保存较大的版本号</span></span><br><span class="line">      <span class="comment">// 而v1与v2的问题也是在这里解决的：两者的Path路径不同</span></span><br><span class="line">			max[m.Path] = reqs.Max(m.Version, v)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			max[m.Path] = m.Version</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 真正运行第二次walk的地方</span></span><br><span class="line">	<span class="keyword">var</span> min []module.Version</span><br><span class="line">	<span class="keyword">for</span> _, path := <span class="keyword">range</span> base &#123;</span><br><span class="line">		m := module.Version&#123;Path: path, Version: max[path]&#125;</span><br><span class="line">		min = <span class="built_in">append</span>(min, m)</span><br><span class="line">		walk(m)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 根据名称排序</span></span><br><span class="line">	sort.Slice(min, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> min[i].Path &lt; min[j].Path</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> min, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>Minimal version selection (MVS)</strong> 的整体实现看起来不复杂，但其实里面做了很多兼容性的工作，尤其是<code>indirect</code>和<code>incompatible</code>等特性。这其实在另一层面提醒了我们：<strong>一项功能尽可能在前期做好设计，靠后期补救往往会增加大量兼容性的工作</strong>。</p>
<p>整个Go Module的核心实现在于2点：</p>
<ol>
<li>2个<code>walk</code>函数，一个用于查找所有依赖，另一个选择最大依赖版本；</li>
<li>选择最大依赖版本的核心依赖一个map，<code>max[m.Path] = reqs.Max(m.Version, v)</code></li>
</ol>
<p>至此，对Go Module的讲解告一段落了。而更多的细节问题，需要大家结合上一篇提到的排查问题工具，边实践、边加深理解。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言技巧 - 7.【GORM实战剖析】基本用法和原理解析</title>
    <url>/2021/09/15/go-tip/go-tip-7/</url>
    <content><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="GORM库的官方文档"><a href="#GORM库的官方文档" class="headerlink" title="GORM库的官方文档"></a>GORM库的官方文档</h2><p>GORM库作为Go语言最受欢迎的ORM框架，提供了非常丰富的功能，大家可以通过阅读<a href="https://gorm.io/zh_CN/docs/index.html">中文官网</a>了解详情。</p>
<p>这里，先着重介绍一个背景：<strong>GORM内部会区分v1与v2两个版本</strong>，其中</p>
<ul>
<li>v1的包导入路径为 <code>github.com/jinzhu/gorm</code></li>
<li>v2的包导入路径为 <code>gorm.io/gorm</code></li>
</ul>
<p>v1与v2对使用者来说体验相差不大，今天就主要针对v2版本进行讲解。</p>
<span id="more"></span>

<h2 id="Talk-is-Cheap-Show-me-the-code"><a href="#Talk-is-Cheap-Show-me-the-code" class="headerlink" title="Talk is Cheap. Show me the code."></a>Talk is Cheap. Show me the code.</h2><p>接下来，我先给出一套个人比较推荐的CRUD代码。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><a href="https://gorm.io/zh_CN/docs/create.html">官方链接 - 创建</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;</span><br><span class="line"><span class="comment">// 直接创建</span></span><br><span class="line">result := db.Create(&amp;user)</span><br><span class="line"><span class="comment">// 指定字段创建</span></span><br><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量创建</span></span><br><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu3&quot;</span>&#125;&#125;</span><br><span class="line">db.Create(&amp;users)</span><br></pre></td></tr></table></figure>

<p>推荐：</p>
<ol>
<li>通常：直接用<strong>结构体</strong>或<strong>结构体的切片</strong>进行创建；</li>
<li>特殊：加上指定的字段，也就是其余字段不生效，如上面的<code>Birthday</code>。</li>
</ol>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><a href="https://gorm.io/zh_CN/docs/query.html">官方链接 - 查询</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询所有对象</span></span><br><span class="line"><span class="keyword">var</span> users []User  </span><br><span class="line">result := db.Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定查询条件（where）</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制返回数量</span></span><br><span class="line">db.Limit(<span class="number">10</span>).Offset(<span class="number">5</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询部分字段（即从select * 改造为 select name, age）</span></span><br><span class="line">db.Select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其余扩展</span></span><br><span class="line">db.Order(<span class="string">&quot;age desc, name&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure>

<p>推荐：</p>
<ol>
<li>普通场景：简单查询用<code>Find+Where</code>的函数结合实现，结合<code>Limit+Offset+Order</code>实现分页等高频功能；</li>
<li>追求性能：可以引入<code>Select</code>避免查询所有字段，但会导致返回结果部分字段不存在的奇怪现象，需要权衡；</li>
<li>复杂查询：例如<code>Join+子查询</code>等，推荐使用下面的原生SQL，用GORM拼接的体验并不好。</li>
</ol>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><a href="https://gorm.io/zh_CN/docs/update.html">官方链接 - 更新</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新通常包含两块，一个是要更新的字段Select+Updates，另一个是被更新数据的条件Where</span></span><br><span class="line">db.Model(&amp;user).Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;new_name&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>零值问题：参考<a href="https://gorm.io/zh_CN/docs/update.html#%E6%9B%B4%E6%96%B0%E5%A4%9A%E5%88%97">https://gorm.io/zh_CN/docs/update.html#%E6%9B%B4%E6%96%B0%E5%A4%9A%E5%88%97</a> 下的注释</p>
</blockquote>
<p>推荐：</p>
<ol>
<li>普通场景：利用<code>Select+Updates</code>指定更新字段，利用<code>Where</code>指定更新条件；</li>
<li>特殊场景：复杂SQL用原生SQL。</li>
</ol>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><a href="https://gorm.io/zh_CN/docs/delete.html">官方链接 - 删除</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除条件不建议太复杂，所以可以用简单的Where条件来拼接</span></span><br><span class="line">db.Where(<span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>).Delete(Email&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>推荐：</p>
<ol>
<li>普通场景：利用<code>Where</code>限定删除条件，不建议太复杂；</li>
<li>软删除：在实际项目中，不太建议用<code>硬删除</code>的方式，而是用<code>软删除</code>，即更新一个标记字段。</li>
</ol>
<h3 id="原生SQL"><a href="#原生SQL" class="headerlink" title="原生SQL"></a>原生SQL</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原生SQL，推荐在复杂sql场景下使用</span></span><br><span class="line">db.Raw(<span class="string">&quot;SELECT id, name, age FROM users WHERE name = ?&quot;</span>, <span class="number">3</span>).Scan(&amp;result)</span><br></pre></td></tr></table></figure>

<h2 id="使用GORM的核心思路梳理"><a href="#使用GORM的核心思路梳理" class="headerlink" title="使用GORM的核心思路梳理"></a>使用GORM的核心思路梳理</h2><h3 id="一个对象-一行数据"><a href="#一个对象-一行数据" class="headerlink" title="一个对象 = 一行数据"></a>一个对象 = 一行数据</h3><p>示例中的一个<code>User</code>对象，完整地对应到具体<code>users</code>表中的一行数据，让整个框架更加清晰明了。每当数据库增加了一列，就对应地在结构体中加一个字段。这里有两个注意点：</p>
<ol>
<li>不要在核心结构体<code>User</code>中加入非表中的数据，如一些计算的中间值，引起二义性；</li>
<li><a href="https://gorm.io/zh_CN/docs/models.html#gorm-Model">gorm.Model</a>可以提升编码效率（会减少重复编码），但会限制数据库表中字段的定义，慎用（个人更希望它能开放成一个接口）；</li>
</ol>
<h3 id="选择生效字段-核心结构体-字段数组"><a href="#选择生效字段-核心结构体-字段数组" class="headerlink" title="选择生效字段 = 核心结构体 + 字段数组"></a>选择生效字段 = 核心结构体 + 字段数组</h3><p>在 <strong>查询</strong> 和 <strong>更新</strong> 接口里，我推荐的使用方法是采用核心结构体<code>User</code>+一个fields的数组，前者保存具体的数据、也实现了结构体复用，后者则选择生效的字段。</p>
<p>这种风格代码和Google推荐的<a href="https://cloud.google.com/apis/design/standard_methods#update">API风格</a>非常像，可读性很棒。</p>
<blockquote>
<p>这里还遗留了一个问题，就是fields数组里的字符串必须手输，可以考虑结合go generate自动生成这些fields的字符串常量，减少出错的概率。</p>
</blockquote>
<h3 id="缩短链式调用"><a href="#缩短链式调用" class="headerlink" title="缩短链式调用"></a>缩短链式调用</h3><p>GORM的主要风格是<a href="https://gorm.io/zh_CN/docs/method_chaining.html">链式调用</a>，类似于Builder设计模式、串联堆起一个SQL语句。这种调用方式扩展性很强，但会带来了一个很严重的问题：容易写出一个超长的链式调用，可维护成本大幅度提高。</p>
<p>所以，在我的推荐使用方式里，区分了两种场景：</p>
<ol>
<li>简单场景 - <strong>核心结构体 + 字段数组</strong></li>
<li>复杂场景 - <strong>原生SQL</strong></li>
</ol>
<h3 id="聚焦微服务的场景"><a href="#聚焦微服务的场景" class="headerlink" title="聚焦微服务的场景"></a>聚焦微服务的场景</h3><p>作为一个<code>ORM</code>工具，GORM要考虑兼容各种SQL语句，内部非常庞大的。但如今更多地是考虑微服务的场景，这就能抛开大量的历史包袱，实现得更加简洁。这里我简单列举三个不太推荐使用的SQL特性：</p>
<ol>
<li>减少group by - 考虑将聚合字段再单独放在一个表中</li>
<li>抛弃join - 多表关联采用多次查询（先查A表，然后用In语句去B表查）、或做一定的字段冗余（即同时放在A、B两个表里）</li>
<li>抛弃子查询，将相关逻辑放在代码里</li>
</ol>
<p>当然，真实业务研发过程中无法完全避免复杂SQL，我们只能有意识地减少引入复杂度。</p>
<h3 id="避免引入非原生MySQL的特性"><a href="#避免引入非原生MySQL的特性" class="headerlink" title="避免引入非原生MySQL的特性"></a>避免引入非原生MySQL的特性</h3><p>GORM除了常规的SQL功能，还提供了一些<a href="https://gorm.io/zh_CN/docs/models.html#%E9%AB%98%E7%BA%A7%E9%80%89%E9%A1%B9">高级特性</a>、<a href="https://gorm.io/zh_CN/docs/belongs_to.html">模型关联</a>、<a href="https://gorm.io/zh_CN/docs/hooks.html">钩子</a>等，非常炫酷。</p>
<p>但我不推荐大家在实际项目中使用这些特性。只有尽可能地保证这个框架简洁，才能保证代码后续的可维护性。</p>
<p>熟悉MySQL历史的朋友都知道，<strong>存储过程</strong>在以前相当一段时间都是很好的工具，但如今都倡导<strong>去存储过程</strong>。GORM的这些特性和存储过程有异曲同工之处：一个将业务逻辑放在了数据库，另一个则放到了ORM框架里，会导致后续的迁移成本变高。</p>
<blockquote>
<p>这也是我不推荐使用 gorm.Model的重要原因。</p>
</blockquote>
<h2 id="从查询接口了解GORM的核心实现"><a href="#从查询接口了解GORM的核心实现" class="headerlink" title="从查询接口了解GORM的核心实现"></a>从查询接口了解GORM的核心实现</h2><h3 id="两个核心文件"><a href="#两个核心文件" class="headerlink" title="两个核心文件"></a>两个核心文件</h3><p>在GORM库中，有两个核心的文件，也是我们调用频率最高的函数所在：<strong>chainable_api.go</strong>和 <strong>finisher_api.go</strong>。顾名思义，前者是整个链式调用的中间部分，后者则是最终获取结果的函数。以查询为例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure>

<p>其中<code>Where</code>是chainable，也就是还在拼接SQL条件，<code>Find</code>则是触发真正查询的finisher。</p>
<p>如果一开始过于关注chainable调用，很容易陷入构造SQL的细节，所以这块代码建议从finisher入手，深入看看一个SQL的到底是怎么在GORM中拼接并执行的。</p>
<h3 id="Find的调用链路"><a href="#Find的调用链路" class="headerlink" title="Find的调用链路"></a>Find的调用链路</h3><h4 id="1-Find的主要代码"><a href="#1-Find的主要代码" class="headerlink" title="1. Find的主要代码"></a>1. Find的主要代码</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Find</span><span class="params">(dest <span class="keyword">interface</span>&#123;&#125;, conds ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(tx *DB)</span></span> &#123;</span><br><span class="line">	tx = db.getInstance()</span><br><span class="line">  <span class="comment">// conds是查询的条件，这里忽略，我们默认已经在前面的Chainable中完成了所有参数的拼接</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(conds) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> exprs := tx.Statement.BuildCondition(conds[<span class="number">0</span>], conds[<span class="number">1</span>:]...); <span class="built_in">len</span>(exprs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			tx.Statement.AddClause(clause.Where&#123;Exprs: exprs&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tx.Statement.Dest = dest</span><br><span class="line">  <span class="comment">// 关键的执行逻辑</span></span><br><span class="line">	<span class="keyword">return</span> tx.callbacks.Query().Execute(tx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-tx-callbacks-Query-的实现"><a href="#2-tx-callbacks-Query-的实现" class="headerlink" title="2. tx.callbacks.Query()的实现"></a>2. tx.callbacks.Query()的实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *callbacks)</span> <span class="title">Query</span><span class="params">()</span> *<span class="title">processor</span></span> &#123;</span><br><span class="line">  <span class="comment">// Query 是从processors的 map 中取出 query</span></span><br><span class="line">	<span class="keyword">return</span> cs.processors[<span class="string">&quot;query&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个对应的processor是 gorm.DB，也就是执行DB的Execute</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initializeCallbacks</span><span class="params">(db *DB)</span> *<span class="title">callbacks</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;callbacks&#123;</span><br><span class="line">		processors: <span class="keyword">map</span>[<span class="keyword">string</span>]*processor&#123;</span><br><span class="line">			<span class="string">&quot;create&quot;</span>: &#123;db: db&#125;,</span><br><span class="line">			<span class="string">&quot;query&quot;</span>:  &#123;db: db&#125;,</span><br><span class="line">			<span class="string">&quot;update&quot;</span>: &#123;db: db&#125;,</span><br><span class="line">			<span class="string">&quot;delete&quot;</span>: &#123;db: db&#125;,</span><br><span class="line">			<span class="string">&quot;row&quot;</span>:    &#123;db: db&#125;,</span><br><span class="line">			<span class="string">&quot;raw&quot;</span>:    &#123;db: db&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Execute的执行逻辑"><a href="#3-Execute的执行逻辑" class="headerlink" title="3. Execute的执行逻辑"></a>3. Execute的执行逻辑</h4><p>抛开一些周边逻辑，我们聚焦于下面的核心逻辑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processor)</span> <span class="title">Execute</span><span class="params">(db *DB)</span> *<span class="title">DB</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// processor中注册了多个函数，按顺序执行。</span></span><br><span class="line">  <span class="comment">// 核心的查询逻辑也在这里面</span></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> p.fns &#123;</span><br><span class="line">		f(db)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而fns又是来自callbacks</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processor)</span> <span class="title">compile</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 对 callbacks 会做排序</span></span><br><span class="line">	<span class="keyword">if</span> p.fns, err = sortCallbacks(p.callbacks); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		p.db.Logger.Error(context.Background(), <span class="string">&quot;Got error when compile callbacks, got %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Callback的注册"><a href="#4-Callback的注册" class="headerlink" title="4. Callback的注册"></a>4. Callback的注册</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterDefaultCallbacks</span><span class="params">(db *gorm.DB, config *Config)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 默认注册了create/query/delete/update/raw 五种 callback 大类，这里以query为例</span></span><br><span class="line">	queryCallback := db.Callback().Query()</span><br><span class="line">	queryCallback.Register(<span class="string">&quot;gorm:query&quot;</span>, Query)</span><br><span class="line">	queryCallback.Register(<span class="string">&quot;gorm:preload&quot;</span>, Preload)</span><br><span class="line">	queryCallback.Register(<span class="string">&quot;gorm:after_query&quot;</span>, AfterQuery)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(config.QueryClauses) == <span class="number">0</span> &#123;</span><br><span class="line">		config.QueryClauses = queryClauses</span><br><span class="line">	&#125;</span><br><span class="line">	queryCallback.Clauses = config.QueryClauses</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-Query函数的实现"><a href="#5-Query函数的实现" class="headerlink" title="5. Query函数的实现"></a>5. Query函数的实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Query</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> db.Error == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 构建查询的 SQL 语句</span></span><br><span class="line">		BuildQuerySQL(db)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询数据</span></span><br><span class="line">		<span class="keyword">if</span> !db.DryRun &amp;&amp; db.Error == <span class="literal">nil</span> &#123;</span><br><span class="line">			rows, err := db.Statement.ConnPool.QueryContext(db.Statement.Context, db.Statement.SQL.String(), db.Statement.Vars...)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				db.AddError(err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将结果输出到目标结构体中</span></span><br><span class="line">			gorm.Scan(rows, db, <span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-核心-构建SQL的实现"><a href="#6-核心-构建SQL的实现" class="headerlink" title="6.核心-构建SQL的实现"></a>6.核心-构建SQL的实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildQuerySQL</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line">  <span class="comment">// SQL为空，表示需要自己构建</span></span><br><span class="line">	<span class="keyword">if</span> db.Statement.SQL.String() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		db.Statement.SQL.Grow(<span class="number">100</span>) <span class="comment">// 分配初始空间</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(db.Statement.Selects) &gt; <span class="number">0</span> &#123; </span><br><span class="line">      <span class="comment">// 表示只select某几个字段，而不是select *</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> db.Statement.Schema != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(db.Statement.Omits) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// Omit表示忽略特定字段</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> db.Statement.Schema != <span class="literal">nil</span> &amp;&amp; db.Statement.ReflectValue.IsValid() &#123;</span><br><span class="line">      <span class="comment">// 查询到指定结构体</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 对join的处理，涉及到多表关联，暂时忽略</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(db.Statement.Joins) != <span class="number">0</span> &#123;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			db.Statement.AddClauseIfNotExists(clause.From&#123;&#125;)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用一个map去重，符合名字中的 IfNotExists 含义</span></span><br><span class="line">		db.Statement.AddClauseIfNotExists(clauseSelect)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后拼接出完整 SQL 的地方</span></span><br><span class="line">		db.Statement.Build(db.Statement.BuildClauses...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文旨在介绍GORM的推荐使用方式，并简单阅读对接数据库的相关代码。这里分享我的四个观点：</p>
<ol>
<li><strong>Builder设计模式</strong> - 在面对复杂场景中，Builder设计模式扩展性很好，可分为两个阶段：存储数据+处理数据；GORM的调用就是采用了chainable+finisher的两段实现，前者保存SQL相关元数据，后者拼接SQL并执行；</li>
<li><strong>负重前行</strong> - GORM是一个负重前行的框架：它不仅支持了所有原生SQL的特性，也增加了很多类似Hook的高级特性，导致这个框架非常庞大。如果团队没有历史包袱，更推荐<strong>节制</strong>地使用GORM特性，适当封装一层；</li>
<li><strong>interface{}问题</strong> - GORM中许多函数入参的数据类型都是<code>interface&#123;&#125;</code>，底层又用reflect支持了多种类型，这种实现会导致两个问题：<ol>
<li>reflect导致的底层的性能不高（这点还能接受）</li>
<li>interface{}如果传入了不支持的复杂数据类型时，排查问题麻烦，往往要运行程序时才会报错</li>
</ol>
</li>
<li><strong>高频拼接重复SQL</strong> - 在一个程序运行过程中，执行的SQL语句都比较固定，而变化的往往是参数；从GORM的实现来看，每次执行都需要重新拼接一次SQL语句，是有不小的优化空间的，比如引入一定的cache。</li>
</ol>
<p>希望这四点能对大家的日常工作有所启发~</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言技巧 - 8.【浅析微服务框架】Go-Micro概览</title>
    <url>/2021/12/20/go-tip/go-tip-8/</url>
    <content><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="Go-Micro框架概况"><a href="#Go-Micro框架概况" class="headerlink" title="Go Micro框架概况"></a>Go Micro框架概况</h2><p>截止到本文发布时，Go-Micro在github上的star数达到了10.8k，也已经累计发布了v1、v2、v3这三个大版本，目前前两个已经停止维护。</p>
<p>本文主要以最新的技术视角去看待这个框架，所以会集中目光在v3版本。本文包含大量个人的主观观点，请大家选择性听取，更欢迎与我讨论。</p>
<span id="more"></span>

<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><strong>Micro is a distributed cloud operating system built for real world programming.</strong></p>
<p>Micro框架的定义里有个关键词：distributed cloud operating system - 分布式云操作系统。这是一个很<strong>重量级</strong>的定义，我们根据它的官方介绍了解，从这10个核心模块入手，理解这个框架的功能。</p>
<blockquote>
<p>本人对这个框架研究不深，主要参考官方提供的资料，如果有认知偏差，欢迎大家多多指正~</p>
</blockquote>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/micro-3.0.png" alt="micro"></p>
<h2 id="Micro的十大核心模块"><a href="#Micro的十大核心模块" class="headerlink" title="Micro的十大核心模块"></a>Micro的十大核心模块</h2><h3 id="1-Auth-认证授权"><a href="#1-Auth-认证授权" class="headerlink" title="1. Auth 认证授权"></a>1. Auth 认证授权</h3><p>认证授权是一个很基础的模块，但放在一个微服务的框架里，我个人认为不太合适。为什么呢？</p>
<ol>
<li><strong>大部分的微服务的Auth模块，往往是网关层的一种能力</strong>。也就是说，一般我们在请求入口处做一次Auth即可，接下来我们就认为消息可靠、无需检查；</li>
<li><strong>如果Auth模块必须嵌入到每个服务，更应该采用Service Mesh的side-car模式</strong>。借用Istio的能力，尽可能不要侵入应用的代码；</li>
<li><strong>Auth</strong>会有很多方式，ACL/RBAC/ABAC，往往会和公司内部的系统强结合（如人员管理），抽象为一个组件很难满足通用性和扩展性；</li>
</ol>
<p>所以，常规的微服务框架中，会有个专门的Auth服务，管理权限、认证等功能。</p>
<h3 id="2-Build编译模块"><a href="#2-Build编译模块" class="headerlink" title="2.Build编译模块"></a>2.Build编译模块</h3><p>编译功能放在微服务框架不合适，它更应该与CICD结合起来，交由专门的编译部署平台，实现快速交付。</p>
<h3 id="3-Broker消息管道"><a href="#3-Broker消息管道" class="headerlink" title="3.Broker消息管道"></a>3.Broker消息管道</h3><p>从官方的介绍来看，Broker基本与MQ的功能一致，即发布和订阅消息。</p>
<p>作为跨服务异步通信的主流方式，MQ在中大型工程中被广泛使用，Broker概念的抽象可以让使用者不用过于关心底层具体采用的技术。</p>
<h3 id="4-Config动态配置"><a href="#4-Config动态配置" class="headerlink" title="4.Config动态配置"></a>4.Config动态配置</h3><p>Config定义为动态配置和密码，可类比为配置中心，或者K8s中的ConfigMap与Secret。这个模块的功能更多的是对配置能力的抽象。</p>
<h3 id="5-Events事件流"><a href="#5-Events事件流" class="headerlink" title="5.Events事件流"></a>5.Events事件流</h3><p>事件流中有三个关键词：<strong>顺序、重放和持久化</strong>。这三个特性与MQ的特性基本一致，可以认为是Broker一个具体的实践。</p>
<p>这里抽象出一个事件流的概念，主要强调的是 <strong>可靠性</strong>。</p>
<h3 id="6-Network网络"><a href="#6-Network网络" class="headerlink" title="6.Network网络"></a>6.Network网络</h3><p>网络是计算机中很大的一块，这里特指服务内的网络隔离与路由。我个人认为个定义过于宽泛，很容易引起误解。</p>
<p>从云原生的划分来看，这块更应该放在Service Mesh部分。</p>
<h3 id="7-Registry注册"><a href="#7-Registry注册" class="headerlink" title="7.Registry注册"></a>7.Registry注册</h3><p>服务注册这部分包括两块：</p>
<ol>
<li>服务提供方把服务信息注册到中心节点</li>
<li>服务调用方从中心节点获取服务提供方的信息进行调用</li>
</ol>
<p>这服务注册与发现的工作，K8s等这类Paas平台已经封装得很完善了；而如果公司没有提供Paas平台，也可以通过etcd等注册中心快速实现。这部分也不建议重复建设。</p>
<h3 id="8-Runtime运行时"><a href="#8-Runtime运行时" class="headerlink" title="8.Runtime运行时"></a>8.Runtime运行时</h3><p>云时代以容器为核心构建服务，进程的声明周期就可以通过Pod快捷管理。官方对Runtime的描述，更像是CICD+K8s调度服务的综合描述。</p>
<h3 id="9-Store存储"><a href="#9-Store存储" class="headerlink" title="9.Store存储"></a>9.Store存储</h3><p>官方定义为支持过期+CRUD的K-V存储，用来保证无状态性。</p>
<p>我们可以很直接与Redis类比，相当于<strong>把有状态的数据放在公共的缓存里</strong>。</p>
<h3 id="10-Plugins插件化"><a href="#10-Plugins插件化" class="headerlink" title="10.Plugins插件化"></a>10.Plugins插件化</h3><p>插件化的概念很宽，框架并没有明确说明。</p>
<p>从实现来说，任何一个组件最好都可以支持插件化，如router、存储、消息通知等，可以支持自定义log plugins。</p>
<h2 id="模块总览"><a href="#模块总览" class="headerlink" title="模块总览"></a>模块总览</h2><p>前面的十大模块有很多与云平台的基础功能重合。为了更具有针对性地讨论，我们先聊清楚前提，这样才能更聚焦于框架上。</p>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>从当前主流与未来趋势来看，<strong>微服务框架应基于基础云平台能力，不应有过多的交集</strong>。基础平台能力主要包括两块：</p>
<ul>
<li><p>整套Devops流程（如代码版本管理、编译、部署、运行）</p>
</li>
<li><p>基础的云Paas平台（以k8s为代表）</p>
</li>
</ul>
<blockquote>
<p>虽然对很多基础建设不完善的团队来说，上面两者的落地会有挑战，但从长远发展来看，不应将由基础平台的维护的功能交由微服务框架。</p>
<p>而如果追求短期内快速落地项目，我更建议这些团队借主流公有云服务的能力。</p>
</blockquote>
<h3 id="三大分类"><a href="#三大分类" class="headerlink" title="三大分类"></a>三大分类</h3><ol>
<li>不合适引入到微服务框架中：Build、Config、Runtime</li>
<li>通过Service Mesh实现：Auth、Network、Registry</li>
<li>微服务框架的关键特性：Broker、Events、Store、Plugins</li>
</ol>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>Micro框架提供了二进制工具micro，可以查看server、config、store等信息。虽然看起来使用起来很方便，但其实有诸多限制；比如说，线上环境的服务器，开发者往往没有权限登录。</p>
<p>从整体来说，Micro是一个限制性很大的框架，主要特点是：</p>
<ol>
<li>适合基础平台不完善的团队，框架提供了很多基础平台的功能；</li>
<li>使用框架的初始成本低，但后续切换成本、排查问题成本极高，高度依赖micro的生态；</li>
<li>Micro屏蔽了底层实现细节，虽然能在一定程度上提效，但遇到性能、扩展性、底层原理等问题时，很难解决。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整体来说，我不建议以Micro作为新项目切入时的框架。如果用一个词概括原因，我会用 - <strong>不够透明</strong>。一方面，Micro的门槛不低、需要了解它一整套特有的概念；另一方面，后续团队的维护成本也很高，对个人提升也很有限。</p>
<p>维护成本这个概念也许有的同学不能理解，我以Store为例（假设背后选用Redis作为存储）</p>
<ul>
<li>如果采用Micro框架，我们必须阅读相关代码（重点是封装部分），了解它的封装与底层，结合micro+redis工具排查</li>
<li>如果调用的是Redis的官方库，那只要保证调用方式正确，那就只需要你掌握Redis的原理即可</li>
</ul>
<p>前者的排查链路需要框架+redis，后者只需要排查redis。我个人对编程语言框架有一个认知：<strong>不应过度屏蔽通用中间件的细节，如Redis、Kafka、MySQL等，往往直接在中间件查询问题，比通过框架查询问题更为高效</strong>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Github - <a href="https://github.com/micro/micro">https://github.com/micro/micro</a></p>
<p>文档 - <a href="https://micro.mu/introduction">https://micro.mu/introduction</a></p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC源码分析（一）：gRPC的系统调用过程</title>
    <url>/2021/02/20/grpc/grpc-1/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>参考<a href="https://grpc.io/docs/quickstart/go/">官方文档</a>，进行部署并运行成功</p>
<h2 id="分析思路：GRPC是怎么实现方法调用的"><a href="#分析思路：GRPC是怎么实现方法调用的" class="headerlink" title="分析思路：GRPC是怎么实现方法调用的"></a>分析思路：GRPC是怎么实现方法调用的</h2><ol>
<li>分析PB生成的对应文件</li>
<li>运行server</li>
<li>运行client</li>
</ol>
<h2 id="1-分析PB生成的对应文件"><a href="#1-分析PB生成的对应文件" class="headerlink" title="1. 分析PB生成的对应文件"></a>1. 分析PB生成的对应文件</h2><h3 id="HelloRequest-HelloReply-结构分析"><a href="#HelloRequest-HelloReply-结构分析" class="headerlink" title="HelloRequest/HelloReply 结构分析"></a>HelloRequest/HelloReply 结构分析</h3><p>存在三个冗余字段 <code>XXX_NoUnkeyedLiteral</code> <code>XXX_unrecognized</code> <code>XXX_sizecache</code></p>
<p>这部分主要是兼容proto2的，我们暂时不用细究</p>
<h3 id="GreeterClient客户端"><a href="#GreeterClient客户端" class="headerlink" title="GreeterClient客户端"></a>GreeterClient客户端</h3><p>传入一个 cc grpc.ClientConnInterface 客户端连接</p>
<p>可调用的方法为SayHello，其内部的method为”/helloworld.Greeter/SayHello”，也就是<code>/&#123;package&#125;.&#123;service&#125;/&#123;method&#125;</code> ，作为一个唯一的URI</p>
<h3 id="GreeterServer服务端"><a href="#GreeterServer服务端" class="headerlink" title="GreeterServer服务端"></a>GreeterServer服务端</h3><p>需要自己实现一个SayHello的方法</p>
<p>其中有个 UnimplementedGreeterServer 的接口，可以嵌入到对应的server结构体中（有方法未实现时，会返回codes.Unimplemented）</p>
<h2 id="2-运行server"><a href="#2-运行server" class="headerlink" title="2. 运行server"></a>2. 运行server</h2><h3 id="定义server"><a href="#定义server" class="headerlink" title="定义server"></a>定义server</h3><p>这里pb.UnimplementedGreeterServer被嵌入了server结构，所以即使没有实现SayHello方法，编译也能通过。</p>
<p>但是，我们通常要强制server在编译期就必须实现对应的方法，所以生产中建议不嵌入。</p>
<h3 id="实现自己的业务逻辑"><a href="#实现自己的业务逻辑" class="headerlink" title="实现自己的业务逻辑"></a>实现自己的业务逻辑</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span>&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="注册TCP监听端口"><a href="#注册TCP监听端口" class="headerlink" title="注册TCP监听端口"></a>注册TCP监听端口</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)</span><br></pre></td></tr></table></figure>

<p>因为gRPC的应用层是基于HTTP2的，所以这里不出意外，监听的是tcp端口</p>
<h3 id="grpc-NewServer"><a href="#grpc-NewServer" class="headerlink" title="grpc.NewServer()"></a>grpc.NewServer()</h3><ol>
<li>入参为选项参数options</li>
<li>自带一组defaultServerOptions，最大发送size、最大接收size、连接超时、发送缓冲、接收缓冲</li>
<li><code>s.cv = sync.NewCond(&amp;s.mu)</code> 条件锁，用于关闭连接</li>
<li>全局参数 <code>EnableTraciing</code> ，会调用golang.org/x/net/trace 这个包</li>
</ol>
<h3 id="pb-RegisterGreeterServer-s-amp-server"><a href="#pb-RegisterGreeterServer-s-amp-server" class="headerlink" title="pb.RegisterGreeterServer(s, &amp;server{})"></a>pb.RegisterGreeterServer(s, &amp;server{})</h3><p>对比自己创建的server和pb中定义的server，确定每个方法都已经实现</p>
<p>service放在 <code>m map[string]*service</code> 中，所以一个server可以放多个proto定义的服务</p>
<p>内部的method和stream放在 service 中的两个map中</p>
<h3 id="s-Serve-lis"><a href="#s-Serve-lis" class="headerlink" title="s.Serve(lis)"></a>s.Serve(lis)</h3><ol>
<li>listener 放到内部的map中</li>
<li>for循环，进行tcp连接，这一部分和http源码中的ListenAndServe极其类似</li>
<li>在协程中进行handleRawConn</li>
<li>将tcp连接封装对应的creds认证信息</li>
<li>新建newHTTP2Transport传输层连接</li>
<li>在协程中进行serveStreams，而http1这里为阻塞的</li>
<li>函数HandleStreams中参数为2个函数，前者为处理请求，后者用于trace</li>
<li>进入handleStream，前半段被拆为service，后者为method，通过map查找</li>
<li>method在processUnaryRPC处理，stream在processStreamingRPC处理，这两块内部就比较复杂了，涉及到具体的算法，以后有时间细读</li>
</ol>
<h2 id="3-运行client"><a href="#3-运行client" class="headerlink" title="3. 运行client"></a>3. 运行client</h2><h3 id="grpc-Dial"><a href="#grpc-Dial" class="headerlink" title="grpc.Dial"></a>grpc.Dial</h3><p>新建一个conn连接，这里是一个支持HTTP2.0的客户端，暂不细讲</p>
<h3 id="pb-NewGreeterClient-conn"><a href="#pb-NewGreeterClient-conn" class="headerlink" title="pb.NewGreeterClient(conn)"></a>pb.NewGreeterClient(conn)</h3><p>新建一个client，包装对应的method，方便调用SayHello</p>
<h3 id="调用SayHello"><a href="#调用SayHello" class="headerlink" title="调用SayHello"></a>调用SayHello</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: name&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>核心调用的是 Invoke 方法，具体实现要看grpc.ClientConn中</li>
<li>grpc.ClientConn中实现了Invoke方法，在call.go文件中，详情都在invoke中</li>
</ol>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC源码分析(二)：从官网文档看gRPC的特性</title>
    <url>/2021/02/20/grpc/grpc-2/</url>
    <content><![CDATA[<p>在第一部分，我们学习了gRPC的基本调用过程，这样我们对全局层面有了一定了解。接下来，我们将结合官方文档，继续深入学习、探索下去。</p>
<h2 id="1-Authentication-认证的实现"><a href="#1-Authentication-认证的实现" class="headerlink" title="1. Authentication 认证的实现"></a>1. Authentication 认证的实现</h2><p><a href="https://grpc.io/docs/guides/auth/#with-server-authentication-ssltls">官方示例</a></p>
<p>示例很简单，客户端和服务端都大致分为两步：</p>
<ol>
<li>生成对应的认证信息 <code>creds</code></li>
<li>将认证信息作为 <code>DialOption</code> 传入信息</li>
</ol>
<p>认证方法的底层实现并不在我们今天的讨论范围内。这里值得一提的是，由于请求会存在大量的输入参数，这里提供的方法是 <code>opts ...DialOption</code>，也就是可变长度的参数，这一点很值得我们思考和学习。</p>
<h4 id="客户端的认证实现"><a href="#客户端的认证实现" class="headerlink" title="客户端的认证实现"></a>客户端的认证实现</h4><p>第一步：将认证信息放入连接中</p>
<ul>
<li><code>grpc.WithTransportCredentials</code> 中，将<code>creds</code> 保存到<code>copts.TransportCredentials</code></li>
<li>调用<code>Dial</code>，在内部用 <code>opt.apply(&amp;cc.dopts)</code>将认证信息传递到结构中</li>
<li><code>credsClone = creds.Clone()</code> 使用了一份复制，放到了Balancer中，估计是用于负载均衡的，暂时不用考虑</li>
</ul>
<p>第二步：将认证信息请求中发出</p>
<ul>
<li>首先我们先找到 <code>Invoke</code>函数，这里是发送请求的入口（对这一块有疑问的，查看上一篇）</li>
<li>分析一下函数 <code>invoke</code> ，调用了<code>newClientStream</code>，一大段代码都没有用到<code>copts.TransportCredentials</code>中的参数，大致猜测是在<code>clientStream</code>中</li>
<li>接下来这块，只通过阅读代码，要找到对应使用到<code>copts.TransportCredentials</code>很麻烦，建议第一次可以先通过反向查找，调用到这个参数的地方</li>
<li><code>newHTTP2Client</code> =&gt; <code>NewClientTransport</code> =&gt; <code>createTransport</code> =&gt; <code>tryAllAddrs</code> =&gt; <code>resetTransport</code> =&gt; <code>connect</code> =&gt; <code>getReadyTransport</code> =&gt;<code>pick</code> =&gt; <code>getTransport</code> =&gt;<code>newAttemptLocked</code> =&gt; <code>newAttemptLocked</code> =&gt; <code>newClientStream</code></li>
<li>这时，我们再正向梳理一下其调用逻辑，大致是查找连接情况，对传输层进行初始化。如果你了解认证是基于传输层<code>Transport</code>的，那下次正向查找时，会有一条比较明确的方向了</li>
</ul>
<h4 id="服务端的认证实现"><a href="#服务端的认证实现" class="headerlink" title="服务端的认证实现"></a>服务端的认证实现</h4><p>第一步：将认证信息放入Server结构中</p>
<ul>
<li>将<code>creds</code>包装成<code>ServerOption</code>，传入<code>NewServer</code>中</li>
<li>类似Client中的操作，被存至 <code>opts.creds</code> 里</li>
</ul>
<p>第二步：在连接中进行认证</p>
<ul>
<li>参考之前一讲的分析，我们进入函数 <code>handleRawConn</code></li>
<li>这次，我们的进展很顺利，一下子就看到了关键函数名<code>useTransportAuthenticator</code></li>
<li>在这里，调用了<code>creds</code>实现的<code>ServerHandshake</code>实现了认证。到这里，认证已经完成，不过我们可以再看看，认证信息是怎么传递的</li>
<li>接着，认证信息传入了 <code>newHTTP2Transport</code>，保存到结构体<code>http2Server</code>中的<code>authInfo</code>，最后返回了一个Interface <code>ServerTransport</code></li>
<li>在进行连接时，调用了<code>serveStreams</code>，然后调用了 <code>http2Server</code>的<code>HandleStreams</code>方法，这时，我们大致可以猜测，auth在这里被用到了</li>
<li>往下看，发现有个对header帧的处理<code>operateHeaders</code>，在这里被赋值到 <code>pr.AuthInfo</code>里，并被保存到s的Context中</li>
<li>一般情况下，Context的调用是十分隐蔽的，我们可以通过反向查找，哪里调用了<code>peer.FromContext</code>，然而并没有地方应用，那认证的分析，就告一段落了</li>
</ul>
<h2 id="2-四类gRPC调用的实现"><a href="#2-四类gRPC调用的实现" class="headerlink" title="2. 四类gRPC调用的实现"></a>2. 四类gRPC调用的实现</h2><p>这一块我们暂不深入源码，先了解使用时的特性</p>
<h4 id="2-1-简单RPC"><a href="#2-1-简单RPC" class="headerlink" title="2.1 简单RPC"></a>2.1 简单RPC</h4><p><a href="https://grpc.io/docs/tutorials/basic/go/#simple-rpc">代码链接</a></p>
<p>代码逻辑很直观，即处理后返回</p>
<h4 id="2-2-服务端流式RPC"><a href="#2-2-服务端流式RPC" class="headerlink" title="2.2 服务端流式RPC"></a>2.2 服务端流式RPC</h4><p><a href="https://grpc.io/docs/tutorials/basic/go/#server-side-streaming-rpc">代码链接</a></p>
<p>代码的关键在于两个函数<code>inRange</code>和 <code>stream.Send</code></p>
<h4 id="2-3-客户端流式RPC"><a href="#2-3-客户端流式RPC" class="headerlink" title="2.3 客户端流式RPC"></a>2.3 客户端流式RPC</h4><p><a href="https://grpc.io/docs/tutorials/basic/go/#client-side-streaming-rpc">代码链接</a></p>
<p>用一个for循环进行多次发送，<code>stream.Recv()</code>实现了从服务端获取数据，当EOF时，才调用<code>stream.SendAndClose</code>结束发送</p>
<h4 id="2-4-双向流式RPC"><a href="#2-4-双向流式RPC" class="headerlink" title="2.4 双向流式RPC"></a>2.4 双向流式RPC</h4><p><a href="https://grpc.io/docs/tutorials/basic/go/#bidirectional-streaming-rpc">代码链接</a></p>
<p>将 <code>SendAndClose</code> 变为 <code>Send</code>，其余基本不变。从这里可以看到，正常的关闭都是由服务端发起的。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言技巧 - 9.【浅析微服务框架】Kratos概览</title>
    <url>/2021/12/20/go-tip/go-tip-9/</url>
    <content><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="Kratos框架概况"><a href="#Kratos框架概况" class="headerlink" title="Kratos框架概况"></a>Kratos框架概况</h2><p>截止到本文发布时，Kratos在github上的star数达到了15.9k。其中，在2021年7月，也正式推出了v2这个大版本。</p>
<p>本人并不是Kratos的重度使用者，主要会通过官方介绍对它的特性进行剖析。接下来的内容依旧包含大量主观认知，可能会对官方文档有理解上的偏差，欢迎大家与我讨论。</p>
<span id="more"></span>

<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><strong>Kratos is a web application framework with expressive, elegant syntax. We’ve already laid the foundation.</strong></p>
<p>Kratos的官网上的介绍比较朴实，但有两个词值得我们关注 - <strong>富有表现力的</strong>、<strong>优雅的</strong>。一般在微服务框架里，我们看到最多的形容词，往往来自下面两个维度：</p>
<ul>
<li>开发者维度：比如简单易用、组件丰富</li>
<li>工程化维度：比如高效、通用性强</li>
</ul>
<p>但Kratos的切入点是框架层面的能力，尤其是<code>elegant</code>这个词，隐含了作者对代码洁癖的追求。接下来，我们具体剖析这个框架。</p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/kratos.png" alt="Kratos"></p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p> 参考 <a href="https://go-kratos.dev/docs/intro/layout%EF%BC%8C%E6%88%91%E4%BB%AC%E5%AF%B9%E5%85%B3%E9%94%AE%E7%9B%AE%E5%BD%95%E5%81%9A%E4%B8%80%E4%B8%8B%E5%88%86%E6%9E%90%E3%80%82">https://go-kratos.dev/docs/intro/layout，我们对关键目录做一下分析。</a></p>
<h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── api // 下面维护了微服务使用的proto文件以及根据它们所生成的go文件</span><br><span class="line">│  └── helloworld</span><br><span class="line">│      └── v1</span><br><span class="line">│          ├── error_reason.pb.go</span><br><span class="line">│          ├── error_reason.proto</span><br><span class="line">│          ├── error_reason.swagger.json</span><br><span class="line">│          ├── greeter.pb.go</span><br><span class="line">│          ├── greeter.proto</span><br><span class="line">│          ├── greeter.swagger.json</span><br><span class="line">│          ├── greeter_grpc.pb.go</span><br><span class="line">│          └── greeter_http.pb.go</span><br></pre></td></tr></table></figure>

<p>从目录结构看到，里面包含了三类文件：</p>
<ul>
<li><code>*.proto</code> 原始IDL文件</li>
<li><code>*.go</code> 利用protoc工具生成的go文件，包括http和grpc的服务相关代码</li>
<li><code>*.swagger.json</code> 利用工具生成的swagger接口文档</li>
</ul>
<p>这部分的实现全是基于开源的<code>protobuf</code>解决方案，对开发者很友好。这里提一个点：<strong>尽可能地用目录区分原始IDL文件与生成的文件</strong>。我简单列举两个优点：</p>
<ol>
<li>让开发者更聚焦于原始IDL文件 - 其余文件均是从proto文件自动生成出来的，不应过多关注。</li>
<li>有利于IDL文件的传播 - proto文件可以快速生成其余语言的代码，独立文件夹更有利于扩散给外部调用者。</li>
</ol>
<h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── cmd  // 整个项目启动的入口文件</span><br><span class="line">│  └── server</span><br><span class="line">│      ├── main.go</span><br><span class="line">│      ├── wire.go  // 我们使用wire来维护依赖注入</span><br><span class="line">│      └── wire_gen.go</span><br></pre></td></tr></table></figure>

<p>cmd简单来说就是main函数入口。</p>
<h3 id="internal-biz"><a href="#internal-biz" class="headerlink" title="internal/biz"></a>internal/biz</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── internal  // 该服务所有不对外暴露的代码，通常的业务逻辑都在这下面，使用internal避免错误引用</span><br><span class="line">│   ├── biz   // 业务逻辑的组装层，类似 DDD 的 domain 层，data 类似 DDD 的 repo，而 repo 接口在这里定义，使用依赖倒置的原则。</span><br><span class="line">│  │  ├── README.md</span><br><span class="line">│  │  ├── biz.go</span><br><span class="line">│  │  └── greeter.go</span><br></pre></td></tr></table></figure>

<p>internal目录是go语言的一个特性，内部代码不会暴露给外部。</p>
<p>biz被理解为业务逻辑的组装层，如果能正确地理解这个概念，就能把握整个框架的分层设计了。我们从两个关键词来理解这个biz目录的设计：</p>
<ol>
<li>业务逻辑 - 业务逻辑包括但不限于单个对象的增删改查，会处理很多进阶的内容，例如：<ol>
<li>复合对象操作，如操作对象A后，再操作对象B</li>
<li>特殊逻辑，如创建A对象失败时，等待10s后再创建</li>
<li>并发策略，如并发访问对象A和对象B</li>
</ol>
</li>
<li>组装层 - 重点在于组装底层基础的代码，如CRUD，而不是在biz层直接去操作数据库等</li>
</ol>
<p>整体来说，biz这一层应重点考虑<strong>业务逻辑的信息密度</strong>，让业务开发者的重点放在这一层，把基础实现往下沉。</p>
<h3 id="internal-data"><a href="#internal-data" class="headerlink" title="internal/data"></a>internal/data</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── internal  // 该服务所有不对外暴露的代码，通常的业务逻辑都在这下面，使用internal避免错误引用</span><br><span class="line">│  ├── data  // 业务数据访问，包含 cache、db 等封装，实现了 biz 的 repo 接口。我们可能会把 data 与 dao 混淆在一起，data 偏重业务的含义，它所要做的是将领域对象重新拿出来，我们去掉了 DDD 的 infra层。</span><br><span class="line">│  │  ├── README.md</span><br><span class="line">│  │  ├── data.go</span><br><span class="line">│  │  └── greeter.go</span><br></pre></td></tr></table></figure>

<p>data被理解为缓存与数据库的封装，与底层数据存储相关，一般都是跟着数据库的类型适配。</p>
<h3 id="internal-server"><a href="#internal-server" class="headerlink" title="internal/server"></a>internal/server</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── internal  // 该服务所有不对外暴露的代码，通常的业务逻辑都在这下面，使用internal避免错误引用</span><br><span class="line">│  ├── server  // http和grpc实例的创建和配置</span><br><span class="line">│  │  ├── grpc.go</span><br><span class="line">│  │  ├── http.go</span><br><span class="line">│  │  └── server.go</span><br></pre></td></tr></table></figure>

<p>前面IDL文件（protobuf）生成了RPC方法的接口（interface），这里就是RPC方法的具体实现。</p>
<h3 id="internal-service"><a href="#internal-service" class="headerlink" title="internal/service"></a>internal/service</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── internal  // 该服务所有不对外暴露的代码，通常的业务逻辑都在这下面，使用internal避免错误引用</span><br><span class="line">│  └── service  // 实现了 api 定义的服务层，类似 DDD 的 application 层，处理 DTO 到 biz 领域实体的转换(DTO -&gt; DO)，同时协同各类 biz 交互，但是不应处理复杂逻辑</span><br><span class="line">│      ├── README.md</span><br><span class="line">│      ├── greeter.go</span><br><span class="line">│      └── service.go</span><br></pre></td></tr></table></figure>

<p>service被定义成对数据结构的处理层。</p>
<h2 id="架构概览"><a href="#架构概览" class="headerlink" title="架构概览"></a>架构概览</h2><p>Kratos里包含了大量组件，很多模块都与前面Go-Micro的有共同之处，我就不再赘述了。而且通过上面的目录层面的划分，重点是api -&gt; server -&gt; service -&gt; biz -&gt; data 的调用逻辑。</p>
<p>这里，我们关注两个重要特性：</p>
<ol>
<li>wire - <a href="https://go-kratos.dev/docs/guide/wire">https://go-kratos.dev/docs/guide/wire</a></li>
<li>ent - <a href="https://go-kratos.dev/docs/guide/ent">https://go-kratos.dev/docs/guide/ent</a></li>
</ol>
<p>这两块内容比较多，我会单独出两篇文章进行分享。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Github - <a href="https://github.com/go-kratos/kratos">https://github.com/go-kratos/kratos</a> </p>
<p>文档 - <a href="https://go-kratos.dev/docs/">https://go-kratos.dev/docs/</a></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>Kratos是一个典型的 <strong>基于完善的基建</strong> 而成的Go语言开发框架，可以发现它有3个关键点：</p>
<ol>
<li>RPC层复用protobuf的能力</li>
<li>底层依赖Kubernetes的能力</li>
<li>各类工具复用开源库的能力</li>
</ol>
<p>很多中大型公司的内部框架都是按照这种思路实现的，只是会封装一些公司通用能力，比如通用的RPC能力。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整体来说，Kratos的实现与我推崇的理念基本一致，即复用生态+平台的能力。</p>
<p>在一些细节的技术选型上会存在差异，例如Kratos更注重Bilibili公司的历史沉淀，而我会更关注社区的当前主流实现，并抛开包袱、尽可能地实现自动化。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Go-Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC源码分析(三)：从Github文档了解gRPC的项目细节</title>
    <url>/2021/02/20/grpc/grpc-3/</url>
    <content><![CDATA[<h2 id="官方Git总览"><a href="#官方Git总览" class="headerlink" title="官方Git总览"></a><a href="https://github.com/grpc">官方Git总览</a></h2><p>我们先看看GRPC这个项目的总览，主要分三种：</p>
<ul>
<li>基于C实现，包括了 C++, Python, Ruby, Objective-C, PHP, C#</li>
<li>其余语言实现的，最主要是go，java，node</li>
<li>proposal，即grpc的RFC，关于实现、讨论的文档汇总</li>
</ul>
<p>从这里可以看出，gRPC虽然是支持多语言，但原生的实现并不多。如果想在一些小众语言里引入gRPC，还是有很大风险的，有兴趣的可以搜索下TiDB在探索rust的gRPC的经验分享。</p>
<h2 id="gRPC-Go"><a href="#gRPC-Go" class="headerlink" title="gRPC-Go"></a><a href="https://github.com/grpc/grpc-go">gRPC-Go</a></h2><p>作为一名Go语言开发者，我自然选择从最熟悉的语言入手。同时，值得注意的是，grpc-go是除了<code>C家族系列</code>以外使用量最大的repo，加上Go语言优秀的可读性，是一个很好的入门gRPC的阅读材料。</p>
<p>进入项目，整个README.md文档也不长。通常情况下，如果你能啃完这个文档及相关链接，你对这个开源项目就已经超过99%的人了。</p>
<p>对Repo的相关注意事项，大家逐行阅读即可，整体比较简单，我简单列举下关键点：</p>
<ol>
<li>建议阅读官网文档（恭喜你，上次我们已经读完了官方文档）</li>
<li>在项目中的引入，建议用go mod</li>
<li>优先支持3个Go语言最新发布的版本</li>
<li>FAQ中的常见问题，主要关注<a href="https://github.com/grpc/grpc-go#io-timeout-errors">package下载问题</a>和<a href="https://github.com/grpc/grpc-go#how-to-turn-on-logging">如何开启追踪日志</a></li>
</ol>
<p>通读完成，我们再深入看看<a href="https://github.com/grpc/grpc-go#documentation">文档细节</a>，Example这块我们在官网的测试中已经看过，我们的接下来重点是godoc和具体细节的文档。</p>
<h2 id="go-doc"><a href="#go-doc" class="headerlink" title="go doc"></a><a href="https://godoc.org/google.golang.org/grpc">go doc</a></h2><h4 id="DefaultBackoffConfig"><a href="#DefaultBackoffConfig" class="headerlink" title="DefaultBackoffConfig"></a>DefaultBackoffConfig</h4><p>注意，这个变量被弃用，被挪到 <code>ConnectParams</code>里了(<a href="https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md">详情链接</a>)。那这个所谓的连接参数是什么用呢？代码不长，我们选择几个比较重要的内容来阅读下，原链接可以<a href="https://github.com/grpc/grpc-go/blob/v1.29.x/internal/backoff/backoff.go#L54">点击这里</a>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Backoff returns the amount of time to wait before the next retry given the</span></span><br><span class="line"><span class="comment">// number of retries.</span></span><br><span class="line"><span class="comment">// 根据retries返回等待时间，可以认为是一种退避策略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc Exponential)</span> <span class="title">Backoff</span><span class="params">(retries <span class="keyword">int</span>)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> retries == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 之前没有retries过，就返回BaseDelay</span></span><br><span class="line">		<span class="keyword">return</span> bc.Config.BaseDelay</span><br><span class="line">	&#125;</span><br><span class="line">	backoff, max := <span class="keyword">float64</span>(bc.Config.BaseDelay), <span class="keyword">float64</span>(bc.Config.MaxDelay)</span><br><span class="line">  <span class="comment">// 等待时间不能超过max，等待时间 = BaseDelay * Multiplier的retries次方</span></span><br><span class="line">  <span class="comment">// Multiplier默认1.6，并不是官方http包中的2</span></span><br><span class="line">	<span class="keyword">for</span> backoff &lt; max &amp;&amp; retries &gt; <span class="number">0</span> &#123;</span><br><span class="line">		backoff *= bc.Config.Multiplier</span><br><span class="line">		retries--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> backoff &gt; max &#123;</span><br><span class="line">		backoff = max</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Randomize backoff delays so that if a cluster of requests start at</span></span><br><span class="line">	<span class="comment">// the same time, they won&#x27;t operate in lockstep.</span></span><br><span class="line">  <span class="comment">// 乘以一个随机因子，数值为(1-Jitter,1+Jitter)，默认为(0.8,1.2)，防止同一时刻有大量请求发出，引起锁的问题</span></span><br><span class="line">	backoff *= <span class="number">1</span> + bc.Config.Jitter*(grpcrand.Float64()*<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">if</span> backoff &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> time.Duration(backoff)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="EnableTracing"><a href="#EnableTracing" class="headerlink" title="EnableTracing"></a>EnableTracing</h4><p>用来设置是否开启 trace，追踪日志</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>gRPC的错误码，原代码见<a href="https://github.com/grpc/grpc-go/blob/v1.29.x/codes/codes.go#L29">链接</a>，我们大概了解其原因即可：</p>
<ul>
<li><strong>OK</strong> 正常</li>
<li><strong>Canceled</strong> 客户端取消</li>
<li><strong>Unknown</strong> 未知</li>
<li><strong>InvalidArgument</strong> 未知参数</li>
<li><strong>DeadlineExceeded</strong> 超时</li>
<li><strong>NotFound</strong> 未找到资源</li>
<li><strong>AlreadyExists</strong> 资源已经创建</li>
<li><strong>PermissionDenied</strong> 权限不足</li>
<li><strong>ResourceExhausted</strong> 资源耗尽</li>
<li><strong>FailedPrecondition</strong> 前置条件不满足</li>
<li><strong>Aborted</strong> 异常退出</li>
<li><strong>OutOfRange</strong> 超出范围</li>
<li><strong>Unimplemented</strong> 未实现方法</li>
<li><strong>Internal</strong> 内部问题</li>
<li><strong>Unavailable</strong> 不可用状态</li>
<li><strong>DataLoss</strong> 数据丢失</li>
<li><strong>Unauthenticated</strong> 未认证</li>
</ul>
<p>读完上面的内容，发现跟HTTP/1.1的Status Code非常相似。</p>
<h4 id="CallOption"><a href="#CallOption" class="headerlink" title="CallOption"></a>CallOption</h4><p>调用在客户端 <code>Invoke</code> 方法中，包括before发送前，after为接收后。</p>
<p>官方提供了几个常用的CallOption，按场景调用。</p>
<h4 id="ClientConn"><a href="#ClientConn" class="headerlink" title="ClientConn"></a>ClientConn</h4><p>抽象的客户端连接。</p>
<p>值得注意的是，conns是一个map，所以实际可能有多个tcp连接。</p>
<h4 id="CodeC"><a href="#CodeC" class="headerlink" title="CodeC"></a>CodeC</h4><p>定义了Marshal和Unmarshal的接口，在grpc底层实现是proto，详细可见 <a href="https://github.com/grpc/grpc-go/blob/v1.29.x/encoding/proto/proto.go#L39">codec</a></p>
<h4 id="Compressor"><a href="#Compressor" class="headerlink" title="Compressor"></a>Compressor</h4><p>压缩相关的定义</p>
<h4 id="MetaData"><a href="#MetaData" class="headerlink" title="MetaData"></a>MetaData</h4><p>元数据，也就是key-value，可以类比到http的header</p>
<h4 id="DialOption"><a href="#DialOption" class="headerlink" title="DialOption"></a>DialOption</h4><p>客户端新建连接时的选项，按场景调用。</p>
<h4 id="ServerOption"><a href="#ServerOption" class="headerlink" title="ServerOption"></a>ServerOption</h4><p>服务端监听时的选项，按场景调用。</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://github.com/grpc/grpc-go/tree/master/Documentation">文档链接</a></p>
<h4 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/benchmark.md">benchmark</a></h4><p>性能测试，有兴趣的可以细看gRPC是从哪几个维度做RPC性能测试的。</p>
<h4 id="Compression"><a href="#Compression" class="headerlink" title="Compression"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/compression.md">Compression</a></h4><p>可用<a href="https://github.com/grpc/grpc-go/blob/v1.29.x/encoding/encoding.go#L66">encoding.RegisterCompressor</a>实现自定义的压缩方法。</p>
<p>注意，压缩算法应用于客户端和服务端两侧。</p>
<h4 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/concurrency.md">Concurrency</a></h4><p>支持并发，从三个角度分析：</p>
<ul>
<li><code>ClientConn</code>支持多个Goroutine</li>
<li><code>Steams</code>中，<code>SendMsg</code>/<code>RecvMsg</code>可分别在两个Goroutine中运行，但任何一个方法运行在多个Goroutine上是不安全的</li>
<li><code>Server</code>每个客户端的invoke会对应一个Server端的Goroutine</li>
</ul>
<h4 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/encoding.md">Encoding</a></h4><p>类似Compression，可用<a href="https://github.com/grpc/grpc-go/blob/v1.29.x/encoding/encoding.go#L105">encoding.RegisterCodec</a>实现自定义的序列化方法。</p>
<h4 id="go-mock"><a href="#go-mock" class="headerlink" title="go mock"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/gomock-example.md">go mock</a></h4><p>用mock生成测试代码，详细可细看。</p>
<h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-auth-support.md">Authentication</a></h4><p>认证的相关选项，包括 TLS/OAuth2/GCE/JWT ，一般用前两者即可。</p>
<h4 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md">Metadata</a></h4><p>介绍了Metadata的使用，类比于HTTP/1.1的Header。</p>
<h4 id="Keepalive"><a href="#Keepalive" class="headerlink" title="Keepalive"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/keepalive.md">Keepalive</a></h4><p>长连接的参数分为3类：</p>
<ul>
<li>ClientParameters 客户端侧参数，主要用来探活</li>
<li>SeverParameters 服务端参数，控制连接时间</li>
<li>EnforcementPolicy 服务端加强型参数</li>
</ul>
<h4 id="log-level"><a href="#log-level" class="headerlink" title="log level"></a><a href="zhttps://github.com/grpc/grpc-go/blob/master/Documentation/log_levels.md">log level</a></h4><p>四个级别的log level，针对不同场景：</p>
<ul>
<li><code>Info</code> 用于debug问题</li>
<li><code>Warning</code> 排查非关键性的问题</li>
<li><code>Error</code> gRPC调用出现无法返回到客户端的问题</li>
<li><code>Fatal</code>  导致程序无法恢复的致命问题</li>
</ul>
<h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/proxy.md">proxy</a></h4><p>使用默认的HTTP或HTTPS代理。</p>
<h4 id="rpc-error"><a href="#rpc-error" class="headerlink" title="rpc error"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/rpc-errors.md">rpc error</a></h4><p>结合官方提供的错误码，用 <code>status.New</code> 或者 <code>status.Error</code> 创建错误。</p>
<h4 id="server-reflection"><a href="#server-reflection" class="headerlink" title="server reflection"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md">server reflection</a></h4><p>服务端方法映射，跟着教程走即可。</p>
<p>值得一提的是，采用c++中的grpc_cli模块，可以查看指定端口暴露出来的服务详情。</p>
<h4 id="versioning"><a href="#versioning" class="headerlink" title="versioning"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/versioning.md">versioning</a></h4><p>版本演进，一般情况下每6周一个小版本，紧急修复会打补丁号。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC源码分析(四)：剖析Proto序列化</title>
    <url>/2021/02/20/grpc/grpc-4/</url>
    <content><![CDATA[<p>在前面的分析中，我们已经知道了使用proto序列化的代码在<a href="https://github.com/grpc/grpc-go/tree/v1.29.x/encoding/proto">encoding目录</a>中，路径中只有三个文件，其中2个还是测试文件，看起来这次的工作量并不大。</p>
<p>首先，针对读源码是先看源代码还是测试代码，因人而异。个人建议在对源码毫无头绪时，先从测试入手，了解大致功能；如果有一定基础，那么也可以直接入手源代码。我认为优秀的Go源码可读性是非常高的，所以一般情况下，我都直接从源文件入手，遇到问题才会去对应的测试里阅读。</p>
<h2 id="Marshal"><a href="#Marshal" class="headerlink" title="Marshal"></a>Marshal</h2><p>Marshal的代码不多，关键在于传入参数的类型，有2个分支路线：</p>
<ol>
<li><a href="https://github.com/grpc/grpc-go/blob/v1.29.x/encoding/proto/proto.go#L68">proto.Marshaler类型</a>，实现了<code>Marshal() ([]byte, error)</code>方法</li>
<li><a href="https://github.com/grpc/grpc-go/blob/v1.29.x/encoding/proto/proto.go#L54">proto.Message类型</a>，实现了<code>Reset()</code>、<code>String() string</code> 和<code>ProtoMessage()</code>三个方法</li>
</ol>
<p>我们回头看看proto生成的<a href="https://github.com/grpc/grpc-go/blob/v1.29.x/examples/helloworld/helloworld/helloworld.pb.go#L35">go文件</a>，发现对应的是第二个接口。那我们接着看：</p>
<ol>
<li>调用了protoBufferPool，是一个sync.Pool，是为了加速proto对象的分配</li>
<li>内部采用的是 <code>marshalAppend</code>，字面来看就是 序列化并追加，对应了 <code> wire-format</code>这个概念，并不需要将整个结构加载完毕、再进行序列化</li>
<li>接下来调用的是<code>protoV2.MarshalOptions</code>，需要关注的是protoV2是另一个package，<code>protoV2 &quot;google.golang.org/protobuf/proto&quot;</code></li>
<li>在正式marshal前，调用<code>m.ProtoReflect()</code>方法，根据名字可以猜测是对Message做反射，详细内容不妨后面再看</li>
<li>最后就是正式的marshal了，分两个分支：<code>out, err = methods.Marshal(in)</code>和<code>out.Buf, err = o.marshalMessageSlow(b, m)</code>。后者是慢速的，一般情况下是不会用到，我们重点关注前者，这时就需要回头看4中的实现了</li>
<li>逐个往前搜索，<code>接口protoreflect.Message =&gt; </code> <code>接口Message</code> =&gt;<code>函数MessageV2</code>  =&gt; <code>函数ProtoMessageV2Of</code>  =&gt; <code>函数legacyWrapMessage</code> =&gt; <code>函数MessageOf</code> =&gt; <code>类型messageReflectWrapper</code>，终于，在这里找到了目标函数 <code>ProtoMethods</code></li>
<li>因为我们取的是<code>methods</code>，所以很快将代码定位到 <code>makeCoderMethods</code> =&gt; <code>marshal</code> =&gt; <code>marshalAppendPointer</code> ，最后找到一行核心代码 <code>b, err = f.funcs.marshal(b, fptr, f, opts)</code></li>
<li>那这个marshal什么时候被赋值的呢？在步骤7中，我们查看了methods被赋值的地方，其实旁边就有一个函数 <code>makeReflectFuncs</code> ，最后定位到了 <code>/google.golang.org/protobuf/internal/impl/codec_gen.go</code> 文件中。每种变量的序列化，都是按照特定规则来执行的。</li>
</ol>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>那么 protobuf 实际是如何对每种类型进行Encoding的呢？有兴趣的朋友可以点击<a href="https://developers.google.com/protocol-buffers/docs/encoding">这个链接</a>，阅读原文。这里，我直接拿出一个实例进行讲解。</p>
<h4 id="定义proto"><a href="#定义proto" class="headerlink" title="定义proto"></a>定义proto</h4><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">	<span class="built_in">bool</span> male = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">int32</span> age = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">string</span> address = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="生成对应文件后，编写测试用例"><a href="#生成对应文件后，编写测试用例" class="headerlink" title="生成对应文件后，编写测试用例"></a>生成对应文件后，编写测试用例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	people := &amp;pbmsg.People&#123;</span><br><span class="line">		Male:    <span class="literal">true</span>,</span><br><span class="line">		Age:     <span class="number">80</span>,</span><br><span class="line">		Address: <span class="string">&quot;China Town&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	b, _ := proto.Marshal(people)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="运行生成结果"><a href="#运行生成结果" class="headerlink" title="运行生成结果"></a>运行生成结果</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[1000 1 10000 1010000 11010 1010 1000011 1101000 1101001 1101110 1100001 100000 1010100 1101111 1110111 1101110]</span><br></pre></td></tr></table></figure>



<h4 id="分析第一个字段Bool"><a href="#分析第一个字段Bool" class="headerlink" title="分析第一个字段Bool"></a>分析第一个字段Bool</h4><p>首先，Male是一个bool字段，序号为1。</p>
<p>根据Google上的文档，bool是Varint，所以计算</p>
<p>(field_number &lt;&lt; 3) | wire_type = (1&lt;&lt;3)|0 = 8，对应第一个字节： <code>1000</code></p>
<p>然后，它的值true对应第二个字节<code>1</code></p>
<h4 id="分析第二个字段Int"><a href="#分析第二个字段Int" class="headerlink" title="分析第二个字段Int"></a>分析第二个字段Int</h4><p>同样的，(field_number &lt;&lt; 3) | wire_type = (2&lt;&lt;3)|0 = 16，对应第三个字节<code>10000</code></p>
<p>值80对应<code>1010000</code></p>
<h4 id="分析第三个字段String"><a href="#分析第三个字段String" class="headerlink" title="分析第三个字段String"></a>分析第三个字段String</h4><p>因为string是不定长的，所以需要一个额外的长度字段</p>
<p>(field_number &lt;&lt; 3) | wire_type = (3&lt;&lt;3)|2=26，对应<code>11010</code></p>
<p>接下来是长度字段，我们有10个英文单词，所以长度为10，对应 <code>1010</code></p>
<p>然后就是10个Byte表示”China Town”了</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次的分析到这里就暂时告一段落了，阅读protobuf的相关代码还是非常耗时耗力的。其实这块最主要的复杂度在于为了兼容新老版本，采用了大量的Interface实现。Interface带有面向对象特色，在重构代码时很有意义，不过也给阅读代码时，查找方法对应实现时带来了复杂度。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>技术阅读摘要 - 1.十二要素应用原则</title>
    <url>/2021/10/12/readings/go-digest-1/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QZ3lGpkvgdfXW7R.jpg" alt="Go-Framework"></p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><strong>十二要素应用原则（The Twelve-Factor App）</strong> 在如今的微服务领域非常流行，相信大家或多或少有所耳闻，但了解其中细节的并不多。</p>
<p>今天，我将对这12个原则做一个概要分析，结合Go语言中的相关例子，根据开源与大厂的具体实践，和大家一起看看个中究竟。</p>
<span id="more"></span>

<h2 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h2><ul>
<li>英文链接 <a href="https://12factor.net/">https://12factor.net/</a></li>
<li>中文链接 <a href="https://12factor.net/zh_cn/">https://12factor.net/zh_cn/</a></li>
</ul>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>先对12个概念做一个简单的讲解，让不熟悉的朋友心中有个初步概念。</p>
<h3 id="1-Codebase-基准代码-一份基准代码，多份部署"><a href="#1-Codebase-基准代码-一份基准代码，多份部署" class="headerlink" title="1. Codebase 基准代码 - 一份基准代码，多份部署"></a>1. Codebase 基准代码 - 一份基准代码，多份部署</h3><p>示例：一个应用程序的代码，放在一个Git仓库里。</p>
<blockquote>
<p>分支算不算一个仓库呢？</p>
<p>这点常有不同的理解。我个人会把一个分支认为是一个轻量级的仓库，每个分支对应一个具体的业务场景。</p>
</blockquote>
<p>痛点：在分布式的环境下，保证多个机器上运行的应用程序源代码一致，提升排查问题的效率。</p>
<h3 id="2-Dependencies-依赖-显式声明依赖关系"><a href="#2-Dependencies-依赖-显式声明依赖关系" class="headerlink" title="2. Dependencies 依赖 - 显式声明依赖关系"></a>2. Dependencies 依赖 - 显式声明依赖关系</h3><p>示例：Go语言的go module就显式地声明了项目依赖库与版本，方便维护。</p>
<p>痛点：以前Go vendor模式，将依赖代码都放在本地，没有一个文件集中说明项目的依赖，这就导致想找依赖关系必须去看代码细节。如果某个库的v1.0版本有bug，需要升级到1.1，go module只需查看一个文件，而vendor模式得遍历具体的项目，甚至多次递归。</p>
<h3 id="3-Config-配置-在环境中存储配置"><a href="#3-Config-配置-在环境中存储配置" class="headerlink" title="3. Config 配置 - 在环境中存储配置"></a>3. Config 配置 - 在环境中存储配置</h3><p>示例：将配置信息（端口、数据库、外部服务等）放在环境中，而不要硬编码。</p>
<blockquote>
<p>环境定义的扩展：在微服务中，这个环境指的是代码具体的运行环境，包括配置文件、环境变量、配置中心的数据。</p>
<p>值得一提的是，按照这种实践，配置文件不应该和应用程序代码放在一个代码仓库中，而是单独管理。</p>
</blockquote>
<p>痛点：保证多机器上运行的代码一致后，把变化点转移到配置中，避免硬编码到代码仓库中、导致更新需要整体升级。</p>
<h3 id="4-Backing-Services-后端服务-把后端服务当作附加资源"><a href="#4-Backing-Services-后端服务-把后端服务当作附加资源" class="headerlink" title="4. Backing Services 后端服务 - 把后端服务当作附加资源"></a>4. Backing Services 后端服务 - 把后端服务当作附加资源</h3><p>示例：当前的数据库选型为MySQL，有一天突然转变成了阿里云的RDS，只需要修改一个配置。</p>
<p>痛点：这是一种面向标准接口编程的模式，重点是让非业务相关的代码变得灵活可替代，如数据库、缓存、第三方服务。从被调用方的角度来看，过于理想化，很多重量级的组件很难被替代；而从调用方来看，这一切又显得理所当然，谁都希望外部系统的变化是无感知的。</p>
<blockquote>
<p>这一点，非常考验每个服务的设计者的能力，尤其是API接口。</p>
</blockquote>
<h3 id="5-Build-release-run-构建，发布，运行-严格分离构建和运行"><a href="#5-Build-release-run-构建，发布，运行-严格分离构建和运行" class="headerlink" title="5. Build, release, run 构建，发布，运行 - 严格分离构建和运行"></a>5. Build, release, run 构建，发布，运行 - 严格分离构建和运行</h3><p>示例：Go程序在一个构建机器上用 go build命令生成二进制文件，在发布阶段将这个二进制文件分发到各个待运行的机器上，最后在各个机器上运行这个二进制文件。</p>
<p>痛点：强调了CICD一整套流水线，不要让构建和运行强绑定。举个极端的例子，如果有一台centos和一台ubuntu的机器，我们去两个机器上各自编译+运行，可能因为内核不同而发生奇怪的现象；而如果采用在一台专用的centos机器上编译成统一的可执行文件，再分发到这两台机器上，更加合理。</p>
<blockquote>
<p> 如果centos上可执行文件无法在ubuntu机器上运行，就在部署阶段报错，提醒我们去修复。我们更应该去把部署的机器改成centos统一管理，而不是去花大量精力兼容ubuntu。</p>
<p>随着Docker技术的推广，大量简化了这一步骤。</p>
</blockquote>
<h3 id="6-Processes-进程-以一个或多个无状态进程运行应用"><a href="#6-Processes-进程-以一个或多个无状态进程运行应用" class="headerlink" title="6. Processes 进程 - 以一个或多个无状态进程运行应用"></a>6. Processes 进程 - 以一个或多个无状态进程运行应用</h3><p>示例：程序的内存中不保存具体业务相关的数据，而应该保存在共享存储上。</p>
<p>痛点：程序有状态是横向扩容的一大阻碍。想要完全去掉有状态的数据过于理想化，毕竟放在共享存储上肯定不如本地内存访问快，这对一些性能敏感的应用来说影响很大；但微服务架构强调要面向失败编程，这些有状态的数据在程序崩溃时无法恢复，可能导致级联雪崩的等更可怕情况。这一点，需要服务的负责人仔细权衡。</p>
<h3 id="7-Port-Binding-端口绑定-通过端口绑定提供服务"><a href="#7-Port-Binding-端口绑定-通过端口绑定提供服务" class="headerlink" title="7. Port Binding 端口绑定 - 通过端口绑定提供服务"></a>7. Port Binding 端口绑定 - 通过端口绑定提供服务</h3><p>示例：通过开放端口、以RPC形式提供服务</p>
<p>痛点：历史上有些程序以unix socket的本地形式提供服务，维护成本比较高。目前微服务以HTTP为代表的RPC方式提供服务，适合横向扩展。</p>
<h3 id="8-Concurrency-并发-通过进程模型进行扩展"><a href="#8-Concurrency-并发-通过进程模型进行扩展" class="headerlink" title="8. Concurrency 并发 - 通过进程模型进行扩展"></a>8. Concurrency 并发 - 通过进程模型进行扩展</h3><p>示例：当并发量达到一定程度，通过横向扩容进程（Docker实例）来满足需求</p>
<p>痛点：在并发度比较小时，最简单的提升方式是纵向扩容 - 即提高机器的配置。但当并发程度达到一定级别后，无法再通过提升硬件配置来解决。如果进程做到了无状态，利用外部的调度平台（如k8s）进行扩缩容，更适合长期发展。</p>
<h3 id="9-Disposability-易处理-快速启动和优雅终止可最大化健壮性"><a href="#9-Disposability-易处理-快速启动和优雅终止可最大化健壮性" class="headerlink" title="9. Disposability 易处理 - 快速启动和优雅终止可最大化健壮性"></a>9. Disposability 易处理 - 快速启动和优雅终止可最大化健壮性</h3><p>示例：程序能够快速启动，遇到严重异常时也能尽可能地完成现有的任务，优雅终止。</p>
<p>痛点：启动时间少能让程序遇到问题后快速恢复，也可以更快速地横向扩容；而优雅终止更多地是为了保障数据的一致性。</p>
<h3 id="10-Dev-prod-parity-开发环境与线上环境等价-尽可能的保持开发，预发布，线上环境相同"><a href="#10-Dev-prod-parity-开发环境与线上环境等价-尽可能的保持开发，预发布，线上环境相同" class="headerlink" title="10. Dev/prod parity 开发环境与线上环境等价 - 尽可能的保持开发，预发布，线上环境相同"></a>10. Dev/prod parity 开发环境与线上环境等价 - 尽可能的保持开发，预发布，线上环境相同</h3><p>示例：开发、预发布、线上等环境上部署的代码、配置、第三方服务等，尽可能地保证一致，让故障提前在测试环境发生。</p>
<p>痛点：尽可能地保证线上环境的稳定性，让问题尽可能地在开发环境中暴露出来，结合CICD工作保障环境的一致性。</p>
<h3 id="11-Logs-日志-把日志当作事件流"><a href="#11-Logs-日志-把日志当作事件流" class="headerlink" title="11. Logs 日志 - 把日志当作事件流"></a>11. Logs 日志 - 把日志当作事件流</h3><p>示例：在微服务架构中，通过日志将一个事件（如一个RPC请求）串联起来。</p>
<p>痛点：利用格式化的日志+ELK，将日志收集到统一的管理平台，用于分析数据。</p>
<h3 id="12-Admin-processes-管理进程-后台管理任务当作一次性进程运行"><a href="#12-Admin-processes-管理进程-后台管理任务当作一次性进程运行" class="headerlink" title="12. Admin processes 管理进程 - 后台管理任务当作一次性进程运行"></a>12. Admin processes 管理进程 - 后台管理任务当作一次性进程运行</h3><p>示例：将脚本、定时任务等，也作为一个应用程序提交，由k8s等调度平台执行</p>
<p>痛点：手动执行脚本或任务往往会有两个严重问题：误操作与可追溯性差。更合理的方式是走一个正式的发布流程，方便管理。</p>
<h2 id="案例串讲"><a href="#案例串讲" class="headerlink" title="案例串讲"></a>案例串讲</h2><h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><p>你（研发人员）收到了一个需求，要实现一个分布式的订单服务。于是，你新建了一个git仓库（<strong>1.基准代码</strong>），准备用go语言编写，部署在多个机器上（<strong>8.并发</strong>）。开发期间引用了大量的开源库，用Go Module将这些依赖都管理了起来（<strong>2.依赖</strong>）。</p>
<p>开发过程中，由于测试和线上的数据库地址不同，所以你把这些信息放在了配置中心（<strong>3.配置</strong>），如Etcd、k8s的ConfigMap中。</p>
<p>由于外部服务会依赖这个订单服务，所以要求研发提供的API接口必须向前兼容，所以选用了经典的RESTful风格的HTTP接口作为对外的协议（<strong>7.端口绑定</strong>）。这样，即便订单服务后续不断迭代，对外部来说也只是修改一个调用地址即可（<strong>4.后端服务</strong>）。</p>
<h3 id="上线阶段"><a href="#上线阶段" class="headerlink" title="上线阶段"></a>上线阶段</h3><p>在测试、预发布环境，为了开发与测试人员更好地验证功能，绝大部分的配置参数都保证与线上一致（<strong>10.开发环境与线上环境等价</strong>）。</p>
<p>整个上线流程包括了测试、预发布、线上三个环境的部署和验证，统一采用CICD的技术自动化执行（<strong>5.构建，发布，运行</strong>）。</p>
<h3 id="维护阶段"><a href="#维护阶段" class="headerlink" title="维护阶段"></a>维护阶段</h3><p>订单服务很复杂，经常会发生崩溃，导致很多数据恢复不了。于是，研发组长决定把关键的数据都放在Redis集群中（<strong>6.进程</strong>），保证应用的无状态化。</p>
<p>数据不丢了，但程序崩溃后恢复很慢，发现花大量的时间在加载初始数据上。于是又做了一次优化，利用Lazy Load的思路，按需加载（<strong>9.易处理</strong>）。</p>
<p>程序正常运行了，但用户反馈有个请求经常失败。这时，你利用ELK收集上的日志，排查了整个链路中的信息（<strong>11.日志</strong>），发现某处代码逻辑搞混了。当前的问题修复了，你还需要去数据库修复历史数据，就又写了个sql脚本提交到专门用来维护修改数据的代码仓库，提交给平台自动运行（<strong>12.管理进程</strong>）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>业界对这12个原则的理解并不完全一致，这也是因为<strong>不同角色处于不同的阶段所导致的视野差异性</strong>。</p>
<p>总体来说，这12个原则强调了简单性、可维护性，我们可以把它们作为微服务架构设计的指导性原则。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Digest</tag>
      </tags>
  </entry>
  <entry>
    <title>技术阅读摘要 - 2.OpenTelemetry技术概览</title>
    <url>/2021/10/14/readings/go-digest-2/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QZ3lGpkvgdfXW7R.jpg" alt="Go-Framework"></p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>本系列的第二讲，我原先计划聊一下OpenTracing这个技术，但计划赶不上变化，我发现OpenTracing的官网上已经声明:这部分的技术将迁移到OpenTelemetry。</p>
<p>从OpenTelemetry的官方定义来看： <strong>An observability framework for cloud-native software</strong>，它的重点在于两块：</p>
<ol>
<li>可观察性：通过metrics、logs和traces数据，观察软件的运行情况</li>
<li>云原生：适配云原生理念</li>
</ol>
<p>OpenTelemetry的图标采用了一个<strong>望远镜</strong>，可见其核心在于可观察性。</p>
<span id="more"></span>

<h2 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h2><ul>
<li>OpenTelemetry <a href="https://opentelemetry.io/">https://opentelemetry.io/</a> </li>
<li>OpenTe4lemetry中文文档 <a href="https://github.com/open-telemetry/docs-cn">https://github.com/open-telemetry/docs-cn</a> </li>
<li>OpenTracing <a href="https://opentracing.io/">https://opentracing.io/</a> </li>
<li>OpenCensus <a href="https://opencensus.io/">https://opencensus.io/</a> </li>
</ul>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>我们先引用官方对自身的定义：<strong>OpenTelemetry is a set of APIs, SDKs, tooling and integrations that are designed for the creation and management of <em>telemetry data</em> such as traces, metrics, and logs.</strong></p>
<p>这句话指明了OpenTelemetry实现的3个重点数据：traces、metrics、logs。我们从简单到复杂，逐个讲述一下：</p>
<h3 id="Logs"><a href="#Logs" class="headerlink" title="Logs"></a>Logs</h3><p>日志：依赖程序自身的打印。可通过ELK/EFK等工具采集到统一的平台并展示。</p>
<h3 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h3><p>指标：程序将运行中关键的一些指标数据保存下来，常通过RPC的方式Pull/Push到统一的平台。</p>
<p>常见的如请求数、请求延迟、请求成功率等，也可进行一定的计算后获得更复杂的复合指标。</p>
<h3 id="Traces"><a href="#Traces" class="headerlink" title="Traces"></a>Traces</h3><p>分布式追踪：遵循Dapper等协议，获取一个请求在整个系统中的调用链路。</p>
<p>常见的如根据一个HTTP请求的requestID，获取其各个RPC、数据库、缓存等关键链路中的详情。</p>
<h2 id="技术标准"><a href="#技术标准" class="headerlink" title="技术标准"></a>技术标准</h2><p>到今天，OpenTelemetry还没有完全落地，但这不妨碍我们看清未来的发展方向。</p>
<p><strong>Metrics以Prometheus为标准，Traces以Jaeger为标准，而Logs暂时还没有明确的标准</strong>，但业界基本以ELK或EFK为技术实现。而我们常会把Traces和Logs这两点结合起来，通过在应用程序的打印日志中添加对应的Traces，来更好地排查整个数据链路。</p>
<p>但这样还不够，Opentelemetry期望的是将三者都关联起来，而引入了Context这个概念。熟悉Go语言的同学都清楚，context被定义为上下文，用于程序中传递数据。而Opentelemetry将这个概念进一步扩大，包括了RPC请求、多线程、跨语言、异步调用等各种复杂场景。</p>
<p>OpenTelemetry的推进工作非常困难，但其带来的价值是不言而喻的。今天，我们依旧以Go语言为例，试试窥一斑而见全豹，对这个技术有个基本掌握。</p>
<h2 id="Go语言示例"><a href="#Go语言示例" class="headerlink" title="Go语言示例"></a>Go语言示例</h2><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>参考官方在Go Package上的声明，Traces处于稳定状态，Metrics处于Alpha测试版本，而Logs则处于冻结状态。</p>
<blockquote>
<p>可见日志的优先级放在了Traces和Metrics之后。从最终实现来说，只要确定了Traces和Metrics的具体标准，Logs的实现并没有那么复杂。</p>
</blockquote>
<h3 id="1-创建Exporter"><a href="#1-创建Exporter" class="headerlink" title="1. 创建Exporter"></a>1. 创建Exporter</h3><p>OpenTelemetry要求程序中收集到的数据，都通过一定的途径发送给外部，如控制台、外部存储、端口等，所以就有了Exporter这个概念。</p>
<p>这里以一个简单的控制台Exporter为例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">traceExporter, err := stdouttrace.New(</span><br><span class="line">  stdouttrace.WithPrettyPrint(),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">&quot;failed to initialize stdouttrace export pipeline: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-创建Trace-Provider"><a href="#2-创建Trace-Provider" class="headerlink" title="2. 创建Trace Provider"></a>2. 创建Trace Provider</h3><p>Traces这部分的概念比较多，这里先只讲解一个 - span。在分布式系统中，存在上下游的概念、也就是调用和被调用的关系，在分布式追踪系统中就将它们区分为不同的span。</p>
<p>示例代码初始化了Traces Provider，用于Traces相关的功能：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx := context.Background()</span><br><span class="line">bsp := sdktrace.NewBatchSpanProcessor(traceExporter)</span><br><span class="line">tp := sdktrace.NewTracerProvider(sdktrace.WithSpanProcessor(bsp))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle this error in a sensible manner </span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _ = tp.Shutdown(ctx) &#125;()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果要深入了解分布式追踪技术，建议搜索Dapper论文或网上的相关资料。</p>
</blockquote>
<h3 id="3-创建Meter-Provider"><a href="#3-创建Meter-Provider" class="headerlink" title="3. 创建Meter Provider"></a>3. 创建Meter Provider</h3><p>类似Traces，Metrics也需要一个Provider，但它的名字叫做Meter Provider。</p>
<p>我们看一下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">metricExporter, err := stdoutmetric.New(</span><br><span class="line">  stdoutmetric.WithPrettyPrint(),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pusher := controller.New(</span><br><span class="line">  processor.New(</span><br><span class="line">    simple.NewWithExactDistribution(),</span><br><span class="line">    metricExporter,</span><br><span class="line">  ),</span><br><span class="line">  controller.WithExporter(metricExporter),</span><br><span class="line">  controller.WithCollectPeriod(<span class="number">5</span>*time.Second),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">err = pusher.Start(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle this error in a sensible manner where possible</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _ = pusher.Stop(ctx) &#125;()</span><br></pre></td></tr></table></figure>

<p>抛开初始化部分，其中还包含了2个关键性的内容：</p>
<ol>
<li>程序指标的计算部分</li>
<li>metrics的发送方式采用了push，周期为5s</li>
</ol>
<h3 id="4-设置全局选项"><a href="#4-设置全局选项" class="headerlink" title="4. 设置全局选项"></a>4. 设置全局选项</h3><p>这部分的内容不多，也很容易理解，但在实际工程中的价值很大：<strong>让调用者更方便！</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">otel.SetTracerProvider(tp)</span><br><span class="line">global.SetMeterProvider(pusher.MeterProvider())</span><br><span class="line">propagator := propagation.NewCompositeTextMapPropagator(propagation.Baggage&#123;&#125;,propagation.TraceContext&#123;&#125;)</span><br><span class="line">otel.SetTextMapPropagator(propagator)</span><br></pre></td></tr></table></figure>

<p>这里面做的事情很简单，就是将我们程序中自己创建的trace provider和meter provider设置到官方包中，也就是替换了官方包中的全局变量。接下来，我们想使用provider时，就统一调用官方包即可，<strong>不再需要引用本地的变量</strong>。</p>
<blockquote>
<p> 并不是所有的场景都适合把变量存放到统一的package下，可以延伸思考下~</p>
<p>举个例子，github.com/spf13/viper配置库只支持全局单个对象Viper，而我们程序中要创建多个对象，这时就不适用。</p>
</blockquote>
<h3 id="5-创建Metric-Instruments"><a href="#5-创建Metric-Instruments" class="headerlink" title="5. 创建Metric Instruments"></a>5. 创建Metric Instruments</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置关键属性</span></span><br><span class="line">lemonsKey := attribute.Key(<span class="string">&quot;ex.com/lemons&quot;</span>)</span><br><span class="line">anotherKey := attribute.Key(<span class="string">&quot;ex.com/another&quot;</span>)</span><br><span class="line"></span><br><span class="line">commonAttributes := []attribute.KeyValue&#123;lemonsKey.Int(<span class="number">10</span>), attribute.String(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>), attribute.String(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;2&quot;</span>), attribute.String(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;3&quot;</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Meter实例</span></span><br><span class="line">meter := global.Meter(<span class="string">&quot;ex.com/basic&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步的Observer：通过函数回调</span></span><br><span class="line">observerCallback := <span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, result metric.Float64ObserverResult)</span></span> &#123;</span><br><span class="line">  result.Observe(<span class="number">1</span>, commonAttributes...)</span><br><span class="line">&#125;</span><br><span class="line">_ = metric.Must(meter).NewFloat64ValueObserver(<span class="string">&quot;ex.com.one&quot;</span>, observerCallback,metric.WithDescription(<span class="string">&quot;A ValueObserver set to 1.0&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步的Recorder：创建一个变量，按需使用</span></span><br><span class="line">valueRecorder := metric.Must(meter).NewFloat64ValueRecorder(<span class="string">&quot;ex.com.two&quot;</span>)</span><br><span class="line">boundRecorder := valueRecorder.Bind(commonAttributes...)</span><br><span class="line"><span class="keyword">defer</span> boundRecorder.Unbind()</span><br></pre></td></tr></table></figure>

<h3 id="6-综合示例"><a href="#6-综合示例" class="headerlink" title="6. 综合示例"></a>6. 综合示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个Tracer</span></span><br><span class="line">tracer := otel.Tracer(<span class="string">&quot;ex.com/basic&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了一个包含2个member的baggage，并结合到Go里的context</span></span><br><span class="line">foo, _ := baggage.NewMember(<span class="string">&quot;ex.com.foo&quot;</span>, <span class="string">&quot;foo1&quot;</span>)</span><br><span class="line">bar, _ := baggage.NewMember(<span class="string">&quot;ex.com.bar&quot;</span>, <span class="string">&quot;bar1&quot;</span>)</span><br><span class="line">bag, _ := baggage.New(foo, bar)</span><br><span class="line">ctx = baggage.ContextWithBaggage(ctx, bag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下为一个具体调用的示例，多层嵌套</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 根据传入的ctx，创建一个span</span></span><br><span class="line">  <span class="keyword">var</span> span trace.Span</span><br><span class="line">  ctx, span = tracer.Start(ctx, <span class="string">&quot;operation&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> span.End()</span><br><span class="line"></span><br><span class="line">  span.AddEvent(<span class="string">&quot;Nice operation!&quot;</span>, trace.WithAttributes(attribute.Int(<span class="string">&quot;bogons&quot;</span>, <span class="number">100</span>)))</span><br><span class="line">  span.SetAttributes(anotherKey.String(<span class="string">&quot;yes&quot;</span>))</span><br><span class="line"></span><br><span class="line">  meter.RecordBatch(</span><br><span class="line">    ctx,</span><br><span class="line">    commonAttributes,</span><br><span class="line">    valueRecorder.Measurement(<span class="number">2.0</span>),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 根据传入的ctx，创建一个子span</span></span><br><span class="line">    <span class="keyword">var</span> span trace.Span</span><br><span class="line">    ctx, span = tracer.Start(ctx, <span class="string">&quot;Sub operation...&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> span.End()</span><br><span class="line"></span><br><span class="line">    span.SetAttributes(lemonsKey.String(<span class="string">&quot;five&quot;</span>))</span><br><span class="line">    span.AddEvent(<span class="string">&quot;Sub span event&quot;</span>)</span><br><span class="line">    boundRecorder.Record(ctx, <span class="number">1.3</span>)</span><br><span class="line">  &#125;(ctx)</span><br><span class="line">&#125;(ctx)</span><br></pre></td></tr></table></figure>

<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul>
<li>文档 - <a href="https://opentelemetry.io/docs/go/">https://opentelemetry.io/docs/go/</a></li>
<li>Go Package - <a href="https://pkg.go.dev/go.opentelemetry.io/otel#section-readme">https://pkg.go.dev/go.opentelemetry.io/otel#section-readme</a></li>
<li>Github - <a href="https://github.com/open-telemetry/opentelemetry-go">https://github.com/open-telemetry/opentelemetry-go</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从现状来看，OpenTelemetry仍处于初期阶段，使用起来并不那么方便。我们应该把重点放在标准上：</p>
<p>从官方文档 - <a href="https://opentelemetry.io/docs/go/exporting_data/">https://opentelemetry.io/docs/go/exporting_data/</a> 中可以看出，OpenTelemetry有标准的OTLP Exporter，但目前这块更多的是一个标准，而不是一个具体实践。</p>
<p>针对当前已落地的技术，重要参考就是Jaeger和Prometheus。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Digest</tag>
      </tags>
  </entry>
  <entry>
    <title>技术阅读摘要 - 3.Jaeger技术分析</title>
    <url>/2021/10/20/readings/go-digest-3/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QZ3lGpkvgdfXW7R.jpg" alt="Go-Framework"></p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>通过上一次技术阅读摘要，我们了解了分布式链路追踪这项技术，Jaeger是其主流的实现方案。</p>
<p>今天，我们就一起来看看Jaeger的相关资料，初步掌握这门技术。</p>
<span id="more"></span>

<h2 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h2><ul>
<li>Jaeger官网 <a href="https://www.jaegertracing.io/">https://www.jaegertracing.io/</a></li>
<li>Github <a href="https://github.com/jaegertracing/jaeger">https://github.com/jaegertracing/jaeger</a></li>
<li>Dapper <a href="https://research.google/pubs/pub36356/">https://research.google/pubs/pub36356/</a></li>
<li>OpenZipkin <a href="https://zipkin.io/">https://zipkin.io/</a></li>
</ul>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Jaeger的官方定义非常简洁 - <strong>Jaeger: open source, end-to-end distributed tracing</strong>。</p>
<p>关键词是<strong>端到端的分布式追踪</strong>。怎么理解这个端到端呢？它更多地是关注分布式系统中的<strong>入和出</strong>。从一个HTTP服务来看，它关注的是请求和响应的具体数据。对应到如今k8s中盛行的sidecar模式，就是一个网络的sidecar，将所有的请求进行标注（如带上traceId）。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Jaeger的官方文档上资料很丰富，更新也比较频繁。有些朋友会觉得阅读官方文档非常累，常常通篇阅读后发现抓不到重点、也没有什么印象。这里，我推荐一个页面 - <a href="https://www.jaegertracing.io/docs/1.27/architecture/">https://www.jaegertracing.io/docs/1.27/architecture/</a> ，并结合我的理解，方便大家快速理解。</p>
<h3 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h3><p>Span是分布式链路追踪中一个通用的术语，字面翻译为 <strong>带名称的Jaeger逻辑单元</strong>。</p>
<p>这里对逻辑单元的定义比较有争论，在我看来，逻辑单元的定义因具体场景而变化：</p>
<ul>
<li>在单体架构中，需要拆分成多个模块，每个模块定义成一个逻辑单元</li>
<li>在一个简单的微服务中，可以将服务定义成一个逻辑单元</li>
<li>在一个复杂的微服务中，可能需要根据更细的领域定义成一个逻辑单元</li>
</ul>
<h3 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h3><p>一个具体消息在整个分布式系统中的流转。</p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>Jaeger提供了2种架构的解决方案。我们先看看通用的部分：</p>
<ul>
<li>jaeger-client作为具体语言的内部库，嵌入到应用程序中</li>
<li>jaeger-agent作为sidecar，部署在容器或机器上，用来从jaeger收集数据，并推送到jaeger collector</li>
<li>jaeger collector负责将数据保存到数据库或MQ中</li>
<li>jaeger-query + UI 查询并显示数据</li>
</ul>
<p>而差异点就在于保存和分析数据的技术方案：</p>
<ul>
<li>简单方案：直接保存到数据库中，用Spark Jobs进行分析</li>
<li>高性能方案：用Kafka来削峰填谷，用Flink流式计算提高性能</li>
</ul>
<h2 id="Jaeger-Go"><a href="#Jaeger-Go" class="headerlink" title="Jaeger Go"></a>Jaeger Go</h2><h3 id="Trace的初始化"><a href="#Trace的初始化" class="headerlink" title="Trace的初始化"></a>Trace的初始化</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">traceCfg := &amp;jaegerconfig.Configuration&#123;</span><br><span class="line">  <span class="comment">// 服务名</span></span><br><span class="line">  ServiceName: <span class="string">&quot;MyService&quot;</span>,</span><br><span class="line">  <span class="comment">// 采样参数</span></span><br><span class="line">  Sampler: &amp;jaegerconfig.SamplerConfig&#123;</span><br><span class="line">    Type:  jaeger.SamplerTypeConst,</span><br><span class="line">    Param: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 上报，这里通过jaeger sidecar的端口来上报日志</span></span><br><span class="line">  Reporter: &amp;jaegerconfig.ReporterConfig&#123;</span><br><span class="line">    LocalAgentHostPort: <span class="string">&quot;127.0.0.1:6831&quot;</span>,</span><br><span class="line">    LogSpans:           <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化tracer</span></span><br><span class="line">tracer, closer, err := traceCfg.NewTracer(jaegerconfig.Logger(jaeger.StdLogger))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> closer.Close()</span><br><span class="line"><span class="comment">// 将tracer设置到opentracing的全局变量中</span></span><br><span class="line">opentracing.SetGlobalTracer(tracer)</span><br></pre></td></tr></table></figure>

<p>上面这段逻辑描述了 <strong>创建jaeger的tracer并保存到opentracing的全局变量中</strong>。</p>
<p>这里强调一点：opentracing是一套标准，包括jaeger、zipkin等具体实现。我们可以深入看看<code>NewTracer</code>这个函数。它的注释很好地说明了这一点。具体的细节实现，我们暂时无需关注。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tracer implements opentracing.Tracer.</span></span><br><span class="line"><span class="keyword">type</span> Tracer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="技术组件引入Opentracing"><a href="#技术组件引入Opentracing" class="headerlink" title="技术组件引入Opentracing"></a>技术组件引入Opentracing</h3><p>通过上面的工作，我们已经在程序中引入了jaeger。但在实际的开发过程中，我们程序内部会有一些组件也需要引入jaeger的链路追踪，来实现更精细化的监控。</p>
<p>以gRPC-Gateway为例，引入Opentracing的链接如下： <a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/operations/tracing/#opentracing-support">https://grpc-ecosystem.github.io/grpc-gateway/docs/operations/tracing/#opentracing-support</a> 。这里面的代码可以直接引用，就不细看了。</p>
<p>目前，支持原生的Opentracing的组件越来越多。在引入一个复杂的组件时，我们要先了解清楚是否可以集成Opentracing，降低后续的运维复杂度。</p>
<h3 id="提取TraceId信息"><a href="#提取TraceId信息" class="headerlink" title="提取TraceId信息"></a>提取TraceId信息</h3><p>整个jaeger的引入并不复杂，就已经能很好地实现链路监控了。但在实际的开发过程中，我们仍有一个非常关键的需求：<strong>如何将一个请求的trace信息，引入到业务代码中，跟踪业务代码的处理过程</strong>。这一点，在debug问题时非常有意义，尤其是面对一些自己不太熟悉的代码。</p>
<p>开发人员面对这个场景，最常用的逻辑就是log，那就意味着我们要将traceid注入到日志中。那么怎么获取traceid呢？下面看一段示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从ctx获取span</span></span><br><span class="line"><span class="keyword">if</span> parent := opentracing.SpanFromContext(ctx); parent != <span class="literal">nil</span> &#123;</span><br><span class="line">  parentCtx := parent.Context()</span><br><span class="line">  <span class="comment">// 获取opentracing中的全局tracer</span></span><br><span class="line">  <span class="keyword">if</span> tracer := opentracing.GlobalTracer(); tracer != <span class="literal">nil</span> &#123;</span><br><span class="line">    mySpan := tracer.StartSpan(<span class="string">&quot;my info&quot;</span>, opentracing.ChildOf(parentCtx))</span><br><span class="line">    <span class="comment">// 由于前面opentracing中的tracer是jaeger的，所以你这里转化为jaeger.SpanContext</span></span><br><span class="line">    <span class="keyword">if</span> sc, ok := mySpan.Context().(jaeger.SpanContext); ok &#123;</span><br><span class="line">      <span class="comment">// 这里，就能获取traceid等信息了，可以放在日志里</span></span><br><span class="line">      _ = sc.TraceID()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> mySpan.Finish()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑就是从go语言的上下文context信息中，用Opentracing里定义的全局tracer，提取出traceId等信息。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于Jaeger内容有很多延伸点，但本文只作入门，点到即可。</p>
<p>如果只能记住一点，我希望大家能认识到：<strong>Jaeger是Opentracing标准的一个实现</strong>。从本文能看到，在标准统一后，具体实现的变更会变得非常简单：例如要将Jaeger替换成Zipkin，只需要初始化tracer处做到替换即可。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>成长分享</category>
      </categories>
      <tags>
        <tag>Digest</tag>
      </tags>
  </entry>
  <entry>
    <title>【K8s源码品读】001：Phase 1 - 掌握k8s创建pod的基本流程</title>
    <url>/2021/02/18/k8s/k8s-001/</url>
    <content><![CDATA[<p>部署Kubernetes集群的方法（建议用kubeadm），详细可参考<a href="http://www.junes.tech/?p=150">我的博客</a>，或者可直接参考<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/">官方文档</a>。</p>
<p>本次分析的源码基于release-1.19。</p>
<blockquote>
<p>后续版本如果对某个模块有大改动的话，大家也可以提醒我进行更新</p>
</blockquote>
<h2 id="确立目标"><a href="#确立目标" class="headerlink" title="确立目标"></a>确立目标</h2><ol>
<li>从<code>创建pod</code>的全流程入手，了解各组件的工作内容，组件主要包括<ol>
<li>kubectl</li>
<li>kube-apiserver</li>
<li>etcd</li>
<li>kube-controller</li>
<li>kube-scheduler</li>
<li>kubelet</li>
</ol>
</li>
<li>对<code>核心模块</code>与<code>引用的库</code>有基本的认识，为后续深入做好铺垫</li>
<li>结合源码，掌握kubernetes的<code>核心概念</code></li>
</ol>
<h2 id="写一个Yaml"><a href="#写一个Yaml" class="headerlink" title="写一个Yaml"></a>写一个Yaml</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.8</span></span><br></pre></td></tr></table></figure>



<h2 id="部署Pod"><a href="#部署Pod" class="headerlink" title="部署Pod"></a>部署Pod</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f nginx_pod.yaml</span><br><span class="line"></span><br><span class="line">pod/nginx-pod created</span><br></pre></td></tr></table></figure>

<p>提示创建成功</p>
<h2 id="查询Pod"><a href="#查询Pod" class="headerlink" title="查询Pod"></a>查询Pod</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line">NAME                               READY   STATUS              RESTARTS   AGE</span><br><span class="line">nginx-pod                          1/1     Running             0          4m22s</span><br></pre></td></tr></table></figure>

<p>打印出状态：</p>
<ul>
<li>NAME - nginx-pod就是对应上面 <code>metadata.name</code></li>
<li>READY - 就绪的个数</li>
<li>STATUS - 当前的状态，RUNNING表示运行中</li>
<li>RESTARTS - 重启的次数</li>
<li>AGE - 运行的次数</li>
</ul>
<h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><p>整个操作就这么结束了~</p>
<p>后续的分析，都是基于这个nginx pod的创建示例来的。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>【K8s源码品读】002：Phase 1 - kubectl - create的调用逻辑</title>
    <url>/2021/02/18/k8s/k8s-002/</url>
    <content><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>我们的目标是查看<code>kubectl create -f nginx_pod.yaml</code> 这个命令是怎么运行的。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><p><a href="#main">main函数入口</a></p>
</li>
<li><p><a href="#match">传入参数与子命令的匹配</a></p>
</li>
<li><p><a href="#command">kubectl命令的初始化</a></p>
</li>
<li><p><a href="#create">查看create子命令</a></p>
</li>
<li><p><a href="#runCreate">runCreate的创建逻辑</a></p>
</li>
</ol>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> 	<span class="comment">// 如果不调用rand.Seed，每次重新运行这个main函数，rand下的函数返回值始终一致</span></span><br><span class="line">	<span class="comment">// Seed即随机的种子，每次用时间戳作为种子，就能保证随机性</span></span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建了kubectl命令的默认参数</span></span><br><span class="line">	command := cmd.NewDefaultKubectlCommand()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> once we switch everything over to Cobra commands, we can go back to calling</span></span><br><span class="line">	<span class="comment">// cliflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the</span></span><br><span class="line">	<span class="comment">// normalize func and add the go flag set by hand.</span></span><br><span class="line">	pflag.CommandLine.SetNormalizeFunc(cliflag.WordSepNormalizeFunc)</span><br><span class="line">	pflag.CommandLine.AddGoFlagSet(goflag.CommandLine)</span><br><span class="line">	<span class="comment">// cliflag.InitFlags()</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 日志的初始化与退出</span></span><br><span class="line">	logs.InitLogs()</span><br><span class="line">	<span class="keyword">defer</span> logs.FlushLogs()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行command</span></span><br><span class="line">	<span class="keyword">if</span> err := command.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// k8s的命令行工具采用了 cobra 库，具有命令提示等强大功能，比go语言自带的flag强大很多，可参考 github.com/spf13/cobra</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultKubectlCommand</span><span class="params">()</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewDefaultKubectlCommandWithArgs(NewDefaultPluginHandler(plugin.ValidPluginFilenamePrefixes), os.Args, os.Stdin, os.Stdout, os.Stderr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultKubectlCommandWithArgs</span><span class="params">(pluginHandler PluginHandler, args []<span class="keyword">string</span>, in io.Reader, out, errout io.Writer)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">  <span class="comment">// 初始化NewKubectlCommand，采用标准输入、输出、错误输出</span></span><br><span class="line">	cmd := NewKubectlCommand(in, out, errout)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pluginHandler == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> cmd</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">// 这里为传入的参数，即 create -f nginx_pod.yaml 部分</span></span><br><span class="line">		cmdPathPieces := args[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调用cobra的Find去匹配args</span></span><br><span class="line">		<span class="keyword">if</span> _, _, err := cmd.Find(cmdPathPieces); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := HandlePluginCommand(pluginHandler, cmdPathPieces); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Fprintf(errout, <span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">				os.Exit(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><p>代码较长，我选择关键性的内容进行讲解</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKubectlCommand</span><span class="params">(in io.Reader, out, err io.Writer)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">	warningHandler := rest.NewWarningWriter(err, rest.WarningWriterOptions&#123;Deduplicate: <span class="literal">true</span>, Color: term.AllowsColorOutput(err)&#125;)</span><br><span class="line">	warningsAsErrors := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建主命令</span></span><br><span class="line">	cmds := &amp;cobra.Command&#123;</span><br><span class="line">		Use:   <span class="string">&quot;kubectl&quot;</span>,</span><br><span class="line">		Short: i18n.T(<span class="string">&quot;kubectl controls the Kubernetes cluster manager&quot;</span>),</span><br><span class="line">		Long: templates.LongDesc(<span class="string">`</span></span><br><span class="line"><span class="string">      kubectl controls the Kubernetes cluster manager.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      Find more information at:</span></span><br><span class="line"><span class="string">            https://kubernetes.io/docs/reference/kubectl/overview/`</span>),</span><br><span class="line">		Run: runHelp,</span><br><span class="line">		<span class="comment">// 初始化后，在运行指令前的钩子</span></span><br><span class="line">		PersistentPreRunE: <span class="function"><span class="keyword">func</span><span class="params">(*cobra.Command, []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			rest.SetDefaultWarningHandler(warningHandler)</span><br><span class="line">      <span class="comment">// 这里是做pprof性能分析，跳转到对应代码可以看到，我们可以用参数 --profile xxx 来采集性能指标，默认保存在当前目录下的profile.pprof中</span></span><br><span class="line">			<span class="keyword">return</span> initProfiling()</span><br><span class="line">		&#125;,</span><br><span class="line">    <span class="comment">// 运行指令后的钩子</span></span><br><span class="line">		PersistentPostRunE: <span class="function"><span class="keyword">func</span><span class="params">(*cobra.Command, []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">      <span class="comment">// 保存pprof性能分析指标</span></span><br><span class="line">			<span class="keyword">if</span> err := flushProfiling(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// 打印warning条数</span></span><br><span class="line">			<span class="keyword">if</span> warningsAsErrors &#123;</span><br><span class="line">				count := warningHandler.WarningCount()</span><br><span class="line">				<span class="keyword">switch</span> count &#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">					<span class="comment">// no warnings</span></span><br><span class="line">				<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">					<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%d warning received&quot;</span>, count)</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%d warnings received&quot;</span>, count)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;,</span><br><span class="line">    <span class="comment">// bash自动补齐功能，可通过 kubectl completion bash 命令查看</span></span><br><span class="line">    <span class="comment">// 具体安装可参考 https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion</span></span><br><span class="line">		BashCompletionFunction: bashCompletionFunc,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化Factory接口，工厂模式</span></span><br><span class="line">	f := cmdutil.NewFactory(matchVersionKubeConfigFlags)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略实例化的过程代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// kubectl定义了7类命令，结合Message和各个子命令的package名来看</span></span><br><span class="line">	groups := templates.CommandGroups&#123;</span><br><span class="line">		&#123;</span><br><span class="line">      <span class="comment">// 1. 初级命令，包括 create/expose/run/set</span></span><br><span class="line">			Message: <span class="string">&quot;Basic Commands (Beginner):&quot;</span>,</span><br><span class="line">			Commands: []*cobra.Command&#123;</span><br><span class="line">				create.NewCmdCreate(f, ioStreams),</span><br><span class="line">				expose.NewCmdExposeService(f, ioStreams),</span><br><span class="line">				run.NewCmdRun(f, ioStreams),</span><br><span class="line">				set.NewCmdSet(f, ioStreams),</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">      <span class="comment">// 2. 中级命令，包括explain/get/edit/delete</span></span><br><span class="line">			Message: <span class="string">&quot;Basic Commands (Intermediate):&quot;</span>,</span><br><span class="line">			Commands: []*cobra.Command&#123;</span><br><span class="line">				explain.NewCmdExplain(<span class="string">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class="line">				get.NewCmdGet(<span class="string">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class="line">				edit.NewCmdEdit(f, ioStreams),</span><br><span class="line">				<span class="built_in">delete</span>.NewCmdDelete(f, ioStreams),</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">      <span class="comment">// 3. 部署命令，包括 rollout/scale/autoscale</span></span><br><span class="line">			Message: <span class="string">&quot;Deploy Commands:&quot;</span>,</span><br><span class="line">			Commands: []*cobra.Command&#123;</span><br><span class="line">				rollout.NewCmdRollout(f, ioStreams),</span><br><span class="line">				scale.NewCmdScale(f, ioStreams),</span><br><span class="line">				autoscale.NewCmdAutoscale(f, ioStreams),</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">      <span class="comment">// 4. 集群管理命令，包括 cerfificate/cluster-info/top/cordon/drain/taint</span></span><br><span class="line">			Message: <span class="string">&quot;Cluster Management Commands:&quot;</span>,</span><br><span class="line">			Commands: []*cobra.Command&#123;</span><br><span class="line">				certificates.NewCmdCertificate(f, ioStreams),</span><br><span class="line">				clusterinfo.NewCmdClusterInfo(f, ioStreams),</span><br><span class="line">				top.NewCmdTop(f, ioStreams),</span><br><span class="line">				drain.NewCmdCordon(f, ioStreams),</span><br><span class="line">				drain.NewCmdUncordon(f, ioStreams),</span><br><span class="line">				drain.NewCmdDrain(f, ioStreams),</span><br><span class="line">				taint.NewCmdTaint(f, ioStreams),</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">      <span class="comment">// 5. 故障排查和调试，包括 describe/logs/attach/exec/port-forward/proxy/cp/auth</span></span><br><span class="line">			Message: <span class="string">&quot;Troubleshooting and Debugging Commands:&quot;</span>,</span><br><span class="line">			Commands: []*cobra.Command&#123;</span><br><span class="line">				describe.NewCmdDescribe(<span class="string">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class="line">				logs.NewCmdLogs(f, ioStreams),</span><br><span class="line">				attach.NewCmdAttach(f, ioStreams),</span><br><span class="line">				cmdexec.NewCmdExec(f, ioStreams),</span><br><span class="line">				portforward.NewCmdPortForward(f, ioStreams),</span><br><span class="line">				proxy.NewCmdProxy(f, ioStreams),</span><br><span class="line">				cp.NewCmdCp(f, ioStreams),</span><br><span class="line">				auth.NewCmdAuth(f, ioStreams),</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">      <span class="comment">// 6. 高级命令，包括diff/apply/patch/replace/wait/convert/kustomize</span></span><br><span class="line">			Message: <span class="string">&quot;Advanced Commands:&quot;</span>,</span><br><span class="line">			Commands: []*cobra.Command&#123;</span><br><span class="line">				diff.NewCmdDiff(f, ioStreams),</span><br><span class="line">				apply.NewCmdApply(<span class="string">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class="line">				patch.NewCmdPatch(f, ioStreams),</span><br><span class="line">				replace.NewCmdReplace(f, ioStreams),</span><br><span class="line">				wait.NewCmdWait(f, ioStreams),</span><br><span class="line">				convert.NewCmdConvert(f, ioStreams),</span><br><span class="line">				kustomize.NewCmdKustomize(ioStreams),</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">      <span class="comment">// 7. 设置命令，包括label，annotate，completion</span></span><br><span class="line">			Message: <span class="string">&quot;Settings Commands:&quot;</span>,</span><br><span class="line">			Commands: []*cobra.Command&#123;</span><br><span class="line">				label.NewCmdLabel(f, ioStreams),</span><br><span class="line">				annotate.NewCmdAnnotate(<span class="string">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class="line">				completion.NewCmdCompletion(ioStreams.Out, <span class="string">&quot;&quot;</span>),</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	groups.Add(cmds)</span><br><span class="line"></span><br><span class="line">	filters := []<span class="keyword">string</span>&#123;<span class="string">&quot;options&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// alpha相关的子命令</span></span><br><span class="line">	alpha := cmdpkg.NewCmdAlpha(f, ioStreams)</span><br><span class="line">	<span class="keyword">if</span> !alpha.HasSubCommands() &#123;</span><br><span class="line">		filters = <span class="built_in">append</span>(filters, alpha.Name())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	templates.ActsAsRootCommand(cmds, filters, groups...)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代码补全相关</span></span><br><span class="line">	<span class="keyword">for</span> name, completion := <span class="keyword">range</span> bashCompletionFlags &#123;</span><br><span class="line">		<span class="keyword">if</span> cmds.Flag(name) != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> cmds.Flag(name).Annotations == <span class="literal">nil</span> &#123;</span><br><span class="line">				cmds.Flag(name).Annotations = <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			cmds.Flag(name).Annotations[cobra.BashCompCustom] = <span class="built_in">append</span>(</span><br><span class="line">				cmds.Flag(name).Annotations[cobra.BashCompCustom],</span><br><span class="line">				completion,</span><br><span class="line">			)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加其余子命令，包括 alpha/config/plugin/version/api-versions/api-resources/options</span></span><br><span class="line">	cmds.AddCommand(alpha)</span><br><span class="line">	cmds.AddCommand(cmdconfig.NewCmdConfig(f, clientcmd.NewDefaultPathOptions(), ioStreams))</span><br><span class="line">	cmds.AddCommand(plugin.NewCmdPlugin(f, ioStreams))</span><br><span class="line">	cmds.AddCommand(version.NewCmdVersion(f, ioStreams))</span><br><span class="line">	cmds.AddCommand(apiresources.NewCmdAPIVersions(f, ioStreams))</span><br><span class="line">	cmds.AddCommand(apiresources.NewCmdAPIResources(f, ioStreams))</span><br><span class="line">	cmds.AddCommand(options.NewCmdOptions(ioStreams.Out))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cmds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCmdCreate</span><span class="params">(f cmdutil.Factory, ioStreams genericclioptions.IOStreams)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">  <span class="comment">// create子命令的相关选项</span></span><br><span class="line">	o := NewCreateOptions(ioStreams)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create子命令的相关说明</span></span><br><span class="line">	cmd := &amp;cobra.Command&#123;</span><br><span class="line">		Use:                   <span class="string">&quot;create -f FILENAME&quot;</span>,</span><br><span class="line">		DisableFlagsInUseLine: <span class="literal">true</span>,</span><br><span class="line">		Short:                 i18n.T(<span class="string">&quot;Create a resource from a file or from stdin.&quot;</span>),</span><br><span class="line">		Long:                  createLong,</span><br><span class="line">		Example:               createExample,</span><br><span class="line">    <span class="comment">// 验证参数并运行</span></span><br><span class="line">		Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> cmdutil.IsFilenameSliceEmpty(o.FilenameOptions.Filenames, o.FilenameOptions.Kustomize) &#123;</span><br><span class="line">				ioStreams.ErrOut.Write([]<span class="keyword">byte</span>(<span class="string">&quot;Error: must specify one of -f and -k\n\n&quot;</span>))</span><br><span class="line">				defaultRunFunc := cmdutil.DefaultSubCommandRun(ioStreams.ErrOut)</span><br><span class="line">				defaultRunFunc(cmd, args)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			cmdutil.CheckErr(o.Complete(f, cmd))</span><br><span class="line">			cmdutil.CheckErr(o.ValidateArgs(cmd, args))</span><br><span class="line">      <span class="comment">// 核心的运行代码逻辑是在这里的RunCreate</span></span><br><span class="line">			cmdutil.CheckErr(o.RunCreate(f, cmd))</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	o.RecordFlags.AddFlags(cmd)</span><br><span class="line"></span><br><span class="line">	usage := <span class="string">&quot;to use to create the resource&quot;</span></span><br><span class="line">  <span class="comment">// 加入文件名选项的flag -f，保存到o.FilenameOptions.Filenames中，对应上面</span></span><br><span class="line">	cmdutil.AddFilenameOptionFlags(cmd, &amp;o.FilenameOptions, usage)</span><br><span class="line">	cmdutil.AddValidateFlags(cmd)</span><br><span class="line">	cmd.Flags().BoolVar(&amp;o.EditBeforeCreate, <span class="string">&quot;edit&quot;</span>, o.EditBeforeCreate, <span class="string">&quot;Edit the API resource before creating&quot;</span>)</span><br><span class="line">	cmd.Flags().Bool(<span class="string">&quot;windows-line-endings&quot;</span>, runtime.GOOS == <span class="string">&quot;windows&quot;</span>,</span><br><span class="line">		<span class="string">&quot;Only relevant if --edit=true. Defaults to the line ending native to your platform.&quot;</span>)</span><br><span class="line">	cmdutil.AddApplyAnnotationFlags(cmd)</span><br><span class="line">	cmdutil.AddDryRunFlag(cmd)</span><br><span class="line">	cmd.Flags().StringVarP(&amp;o.Selector, <span class="string">&quot;selector&quot;</span>, <span class="string">&quot;l&quot;</span>, o.Selector, <span class="string">&quot;Selector (label query) to filter on, supports &#x27;=&#x27;, &#x27;==&#x27;, and &#x27;!=&#x27;.(e.g. -l key1=value1,key2=value2)&quot;</span>)</span><br><span class="line">	cmd.Flags().StringVar(&amp;o.Raw, <span class="string">&quot;raw&quot;</span>, o.Raw, <span class="string">&quot;Raw URI to POST to the server.  Uses the transport specified by the kubeconfig file.&quot;</span>)</span><br><span class="line">	cmdutil.AddFieldManagerFlagVar(cmd, &amp;o.fieldManager, <span class="string">&quot;kubectl-create&quot;</span>)</span><br><span class="line"></span><br><span class="line">	o.PrintFlags.AddFlags(cmd)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create的子命令，指定create对象</span></span><br><span class="line">	cmd.AddCommand(NewCmdCreateNamespace(f, ioStreams))</span><br><span class="line">	cmd.AddCommand(NewCmdCreateQuota(f, ioStreams))</span><br><span class="line">	cmd.AddCommand(NewCmdCreateSecret(f, ioStreams))</span><br><span class="line">	cmd.AddCommand(NewCmdCreateConfigMap(f, ioStreams))</span><br><span class="line">	cmd.AddCommand(NewCmdCreateServiceAccount(f, ioStreams))</span><br><span class="line">	cmd.AddCommand(NewCmdCreateService(f, ioStreams))</span><br><span class="line">	cmd.AddCommand(NewCmdCreateDeployment(f, ioStreams))</span><br><span class="line">	cmd.AddCommand(NewCmdCreateClusterRole(f, ioStreams))</span><br><span class="line">	cmd.AddCommand(NewCmdCreateClusterRoleBinding(f, ioStreams))</span><br><span class="line">	cmd.AddCommand(NewCmdCreateRole(f, ioStreams))</span><br><span class="line">	cmd.AddCommand(NewCmdCreateRoleBinding(f, ioStreams))</span><br><span class="line">	cmd.AddCommand(NewCmdCreatePodDisruptionBudget(f, ioStreams))</span><br><span class="line">	cmd.AddCommand(NewCmdCreatePriorityClass(f, ioStreams))</span><br><span class="line">	cmd.AddCommand(NewCmdCreateJob(f, ioStreams))</span><br><span class="line">	cmd.AddCommand(NewCmdCreateCronJob(f, ioStreams))</span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="runCreate"><a href="#runCreate" class="headerlink" title="runCreate"></a>runCreate</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *CreateOptions)</span> <span class="title">RunCreate</span><span class="params">(f cmdutil.Factory, cmd *cobra.Command)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// f为传入的Factory，主要是封装了与kube-apiserver交互客户端</span></span><br><span class="line">  </span><br><span class="line">	schema, err := f.Validator(cmdutil.GetFlagBool(cmd, <span class="string">&quot;validate&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cmdNamespace, enforceNamespace, err := f.ToRawKubeConfigLoader().Namespace()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化Builder，这块的逻辑比较复杂，我们先关注文件部分</span></span><br><span class="line">	r := f.NewBuilder().</span><br><span class="line">		Unstructured().</span><br><span class="line">		Schema(schema).</span><br><span class="line">		ContinueOnError().</span><br><span class="line">		NamespaceParam(cmdNamespace).DefaultNamespace().</span><br><span class="line">  	<span class="comment">// 读取文件信息，发现除了支持简单的本地文件，也支持标准输入和http/https协议访问的文件，保存为Visitor</span></span><br><span class="line">		FilenameParam(enforceNamespace, &amp;o.FilenameOptions).</span><br><span class="line">		LabelSelectorParam(o.Selector).</span><br><span class="line">		Flatten().</span><br><span class="line">		Do()</span><br><span class="line">	err = r.Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">  <span class="comment">// 调用visit函数，创建资源</span></span><br><span class="line">	err = r.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *resource.Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="comment">// 打印结果 xxxx created</span></span><br><span class="line">		<span class="keyword">return</span> o.PrintObj(info.Object)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>【K8s源码品读】003：Phase 1 - kubectl - 设计模式中Visitor的实现</title>
    <url>/2021/02/18/k8s/k8s-003/</url>
    <content><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解kubectl的核心实现之一：<code>Visitor Design Pattern</code> 访问者模式</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><p><a href="#visitor-design-pattern">什么是访问者模式</a></p>
</li>
<li><p><a href="#visitor">kubectl中的Visitor</a></p>
</li>
<li><p><a href="#chained">Visitor的链式处理</a></p>
<ol>
<li>多个对象聚合为一个对象<ol>
<li><a href="#VisitorList">VisitorList</a></li>
<li><a href="#EagerVisitorList">EagerVisitorList </a></li>
</ol>
</li>
<li>多个方法聚合为一个方法<ol>
<li><a href="#DecoratedVisitor">DecoratedVisitor</a></li>
<li><a href="#ContinueOnErrorVisitor">ContinueOnErrorVisitor</a></li>
</ol>
</li>
<li>将对象抽象为多个底层对象，逐个调用方法<ol>
<li><a href="#FlattenListVisitor">FlattenListVisitor</a></li>
<li><a href="#FilteredVisitor">FilteredVisitor</a></li>
</ol>
</li>
</ol>
</li>
<li><p><a href="#implements">Visitor的各类实现</a></p>
<ol>
<li><a href="#StreamVisitor">StreamVisitor</a></li>
<li><a href="#FileVisitor">FileVisitor</a></li>
<li><a href="#URLVisitor">URLVisitor</a></li>
<li><a href="#KustomizeVisitor">KustomizeVisitor</a></li>
</ol>
</li>
</ol>
<h2 id="visitor-design-pattern"><a href="#visitor-design-pattern" class="headerlink" title="visitor design pattern"></a>visitor design pattern</h2><p>在设计模式中，访问者模式的定义为：</p>
<blockquote>
<p>允许一个或者多个操作应用到对象上，解耦操作和对象本身</p>
</blockquote>
<p>那么，对一个程序来说，具体的表现就是：</p>
<ol>
<li>表面：某个对象执行了一个方法</li>
<li>内部：对象内部调用了多个方法，最后统一返回结果</li>
</ol>
<p>举个例子，</p>
<ol>
<li>表面：调用一个查询订单的接口</li>
<li>内部：先从<code>缓存</code>中查询，没查到再去<code>热点数据库</code>查询，还没查到则去<code>归档数据库</code>里查询</li>
</ol>
<h2 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor"></a>Visitor</h2><p>我们来看看kubeadm中的<code>访问者模式</code>的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Visitor 即为访问者这个对象</span></span><br><span class="line"><span class="keyword">type</span> Visitor <span class="keyword">interface</span> &#123;</span><br><span class="line">	Visit(VisitorFunc) error</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// VisitorFunc对应这个对象的方法，也就是定义中的“操作”</span></span><br><span class="line"><span class="keyword">type</span> VisitorFunc <span class="function"><span class="keyword">func</span><span class="params">(*Info, error)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>基本的数据结构很简单，但从当前的数据结构来看，有两个问题：</p>
<ol>
<li><code>单个操作</code> 可以直接调用<code>Visit</code>方法，那<code>多个操作</code>如何实现呢？</li>
<li>在应用<code>多个操作</code>时，如果出现了error，该退出还是继续应用<code>下一个操作</code>呢？</li>
</ol>
<h2 id="Chained"><a href="#Chained" class="headerlink" title="Chained"></a>Chained</h2><h3 id="VisitorList"><a href="#VisitorList" class="headerlink" title="VisitorList"></a>VisitorList</h3><p>封装多个Visitor为一个，出现错误就立刻中止并返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// VisitorList定义为[]Visitor，又实现了Visit方法，也就是将多个[]Visitor封装为一个Visitor</span></span><br><span class="line"><span class="keyword">type</span> VisitorList []Visitor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发生error就立刻返回，不继续遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l VisitorList)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> l &#123;</span><br><span class="line">		<span class="keyword">if</span> err := l[i].Visit(fn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="EagerVisitorList"><a href="#EagerVisitorList" class="headerlink" title="EagerVisitorList"></a>EagerVisitorList</h3><p>封装多个Visitor为一个，出现错误暂存下来，全部遍历完再聚合所有的错误并返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EagerVisitorList 也是将多个[]Visitor封装为一个Visitor</span></span><br><span class="line"><span class="keyword">type</span> EagerVisitorList []Visitor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的错误暂存到[]error中，统一聚合</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l EagerVisitorList)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	errs := []error(<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> l &#123;</span><br><span class="line">		<span class="keyword">if</span> err := l[i].Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err := fn(info, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> utilerrors.NewAggregate(errs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="DecoratedVisitor"><a href="#DecoratedVisitor" class="headerlink" title="DecoratedVisitor"></a>DecoratedVisitor</h3><p>这里借鉴了装饰器的设计模式，将一个Visitor调用多个VisitorFunc方法，封装为调用一个VisitorFunc</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 装饰器Visitor</span></span><br><span class="line"><span class="keyword">type</span> DecoratedVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">	visitor    Visitor</span><br><span class="line">	decorators []VisitorFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// visitor遍历调用decorators中所有函数，有失败立即返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v DecoratedVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v.visitor.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> v.decorators &#123;</span><br><span class="line">			<span class="keyword">if</span> err := v.decorators[i](info, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fn(info, <span class="literal">nil</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ContinueOnErrorVisitor"><a href="#ContinueOnErrorVisitor" class="headerlink" title="ContinueOnErrorVisitor"></a>ContinueOnErrorVisitor</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错依旧继续</span></span><br><span class="line"><span class="keyword">type</span> ContinueOnErrorVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">	Visitor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错不立即返回，聚合所有错误后返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ContinueOnErrorVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	errs := []error&#123;&#125;</span><br><span class="line">	err := v.Visitor.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := fn(info, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(errs) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errs[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> utilerrors.NewAggregate(errs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="FlattenListVisitor"><a href="#FlattenListVisitor" class="headerlink" title="FlattenListVisitor"></a>FlattenListVisitor</h2><p>将runtime.ObjectTyper解析成多个runtime.Object，再转换为多个Info，逐个调用VisitorFunc</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> FlattenListVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">	visitor Visitor</span><br><span class="line">	typer   runtime.ObjectTyper</span><br><span class="line">	mapper  *mapper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="FilteredVisitor"><a href="#FilteredVisitor" class="headerlink" title="FilteredVisitor"></a>FilteredVisitor</h3><p>对Info资源的检验</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 过滤的Info</span></span><br><span class="line"><span class="keyword">type</span> FilteredVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">	visitor Visitor</span><br><span class="line">	filters []FilterFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v FilteredVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v.visitor.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, filter := <span class="keyword">range</span> v.filters &#123;</span><br><span class="line">      <span class="comment">// 检验Info是否满足条件，出错则退出</span></span><br><span class="line">			ok, err := filter(info, <span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fn(info, <span class="literal">nil</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Implements"><a href="#Implements" class="headerlink" title="Implements"></a>Implements</h2><h3 id="StreamVisitor"><a href="#StreamVisitor" class="headerlink" title="StreamVisitor"></a>StreamVisitor</h3><p>最基础的Visitor</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StreamVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 读取信息的来源，实现了Read这个接口，这个&quot;流式&quot;的概念，包括了常见的HTTP、文件、标准输入等各类输入</span></span><br><span class="line">	io.Reader</span><br><span class="line">	*mapper</span><br><span class="line"></span><br><span class="line">	Source <span class="keyword">string</span></span><br><span class="line">	Schema ContentValidator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="FileVisitor"><a href="#FileVisitor" class="headerlink" title="FileVisitor"></a>FileVisitor</h3><p>文件的访问，包括标准输入，底层调用StreamVisitor来访问</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> FileVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 表示文件路径或者STDIN</span></span><br><span class="line">	Path <span class="keyword">string</span></span><br><span class="line">	*StreamVisitor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="URLVisitor"><a href="#URLVisitor" class="headerlink" title="URLVisitor"></a>URLVisitor</h3><p>HTTP用GET方法获取数据，底层也是复用StreamVisitor</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> URLVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">	URL *url.URL</span><br><span class="line">	*StreamVisitor</span><br><span class="line">  <span class="comment">// 提供错误重试次数</span></span><br><span class="line">	HttpAttemptCount <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="KustomizeVisitor"><a href="#KustomizeVisitor" class="headerlink" title="KustomizeVisitor"></a>KustomizeVisitor</h3><p>自定义的Visitor，针对自定义的文件系统</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> KustomizeVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">	Path <span class="keyword">string</span></span><br><span class="line">	*StreamVisitor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>【K8s源码品读】004：Phase 1 - kubectl - 发送创建Pod请求的实现细节</title>
    <url>/2021/02/18/k8s/k8s-004/</url>
    <content><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解kubectl是怎么向kube-apiserver发送请求的</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#send-request">向kube-apiserver发送请求</a></li>
<li><a href="#RESTful-client">RESTful客户端是怎么创建的</a></li>
<li><a href="#object">Object是怎么生成的</a></li>
<li><a href="#post">发送post请求</a></li>
<li><a href="#summary">kubectl第一阶段源码阅读总结</a></li>
</ol>
<h2 id="send-request"><a href="#send-request" class="headerlink" title="send request"></a>send request</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在RunCreate函数中，关键的发送函数</span></span><br><span class="line">obj, err := resource.</span><br><span class="line">				NewHelper(info.Client, info.Mapping).</span><br><span class="line">				DryRun(o.DryRunStrategy == cmdutil.DryRunServer).</span><br><span class="line">				WithFieldManager(o.fieldManager).</span><br><span class="line">				Create(info.Namespace, <span class="literal">true</span>, info.Object)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入create函数，查看到</span></span><br><span class="line">m.createResource(m.RESTClient, m.Resource, namespace, obj, options)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的实现为</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Helper)</span> <span class="title">createResource</span><span class="params">(c RESTClient, resource, namespace <span class="keyword">string</span>, obj runtime.Object, options *metav1.CreateOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Post().</span><br><span class="line">		NamespaceIfScoped(namespace, m.NamespaceScoped).</span><br><span class="line">		Resource(resource).</span><br><span class="line">		VersionedParams(options, metav1.ParameterCodec).</span><br><span class="line">		Body(obj).</span><br><span class="line">		Do(context.TODO()).</span><br><span class="line">		Get()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">到这里，我们发现了2个关键性的定义:</span></span><br><span class="line"><span class="comment">1. RESTClient 与kube-apiserver交互的RESTful风格的客户端</span></span><br><span class="line"><span class="comment">2. runtime.Object 资源对象的抽象，包括Pod/Deployment/Service等各类资源</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="RESTful-Client"><a href="#RESTful-Client" class="headerlink" title="RESTful Client"></a>RESTful Client</h2><p>我们先来看看，与kube-apiserver交互的Client是怎么创建的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从传入参数来看，数据来源于Info这个结构</span></span><br><span class="line">r.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *resource.Info, err error)</span> <span class="title">error</span></span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而info来源于前面的Builder，前面部分都是将Builder参数化，核心的生成为Do函数</span></span><br><span class="line">r := f.NewBuilder().</span><br><span class="line">		Unstructured().</span><br><span class="line">		Schema(schema).</span><br><span class="line">		ContinueOnError().</span><br><span class="line">		NamespaceParam(cmdNamespace).DefaultNamespace().</span><br><span class="line">		FilenameParam(enforceNamespace, &amp;o.FilenameOptions).</span><br><span class="line">		LabelSelectorParam(o.Selector).</span><br><span class="line">		Flatten().</span><br><span class="line">		Do()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大致看一下这些函数，我们可以在Unstructured()中看到getClient函数，其实这就是我们要找的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">getClient</span><span class="params">(gv schema.GroupVersion)</span> <span class="params">(RESTClient, error)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从返回值来看，client包括默认的REST client和配置选项</span></span><br><span class="line">NewClientWithOptions(client, b.requestTransforms...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个Client会在kubernetes项目中大量出现，它是与kube-apiserver交互的核心组件，以后再深入。</span></span><br></pre></td></tr></table></figure>



<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p><code>Object</code>这个对象是怎么获取到的呢？因为我们的数据源是来自文件的，那么我们最直观的想法就是<code>FileVisitor</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *FileVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 省略读取这块的代码，底层调用的是StreamVisitor的逻辑</span></span><br><span class="line">	<span class="keyword">return</span> v.StreamVisitor.Visit(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *StreamVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	d := yaml.NewYAMLOrJSONDecoder(v.Reader, <span class="number">4096</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 这里就是返回info的地方</span></span><br><span class="line">		info, err := v.infoForData(ext.Raw, v.Source)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再往下一层看，来到mapper层，也就是kubernetes的资源对象映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *mapper)</span> <span class="title">infoForData</span><span class="params">(data []<span class="keyword">byte</span>, source <span class="keyword">string</span>)</span> <span class="params">(*Info, error)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 这里就是我们返回Object的地方，其中GVK是Group/Version/Kind的缩写，后续我们会涉及</span></span><br><span class="line">  obj, gvk, err := m.decoder.Decode(data, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这时，我们想回头去看，这个mapper是在什么时候被定义的？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Builder初始化中，我们就找到了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Unstructured</span><span class="params">()</span> *<span class="title">Builder</span></span> &#123;</span><br><span class="line">	b.mapper = &amp;mapper&#123;</span><br><span class="line">		localFn:      b.isLocal,</span><br><span class="line">		restMapperFn: b.restMapperFn,</span><br><span class="line">		clientFn:     b.getClient,</span><br><span class="line">    <span class="comment">// 我们查找资源用到的是这个decoder</span></span><br><span class="line">		decoder:      &amp;metadataValidatingDecoder&#123;unstructured.UnstructuredJSONScheme&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐层往下找，对应的Decode方法的实现，就是对应的数据解析成data：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s unstructuredJSONScheme)</span> <span class="title">decode</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 细节暂时忽略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h2><p>了解了<code>REST Client</code>和<code>Object</code>的大致产生逻辑后，我们再回过头来看发送的方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RESTful接口风格中，POST请求对应的就是CREATE方法</span></span><br><span class="line">c.Post().</span><br><span class="line">		NamespaceIfScoped(namespace, m.NamespaceScoped).</span><br><span class="line">		Resource(resource).</span><br><span class="line">		VersionedParams(options, metav1.ParameterCodec).</span><br><span class="line">		Body(obj).</span><br><span class="line">		Do(context.TODO()). </span><br><span class="line">		Get() </span><br><span class="line"></span><br><span class="line"><span class="comment">// Do方法，发送请求</span></span><br><span class="line">err := r.request(ctx, <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request, resp *http.Response)</span></span> &#123;</span><br><span class="line">		result = r.transformResponse(resp, req)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get方法，获取请求的返回结果，用来打印状态</span></span><br><span class="line"><span class="keyword">switch</span> t := out.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *metav1.Status:</span><br><span class="line">		<span class="keyword">if</span> t.Status != metav1.StatusSuccess &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.FromObject(t)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>到这里我们对kubectl的功能有了初步的了解，希望大家对以下的关键内容有所掌握：</p>
<ol>
<li>命令行采用了<code>cobra</code>库，主要支持7个大类的命令；</li>
<li>掌握Visitor设计模式，这个是kubectl实现各类资源对象的解析和校验的核心；</li>
<li>初步了解<code>RESTClient</code>和<code>Object</code>这两个对象，它们是贯穿kubernetes的核心概念；</li>
<li>调用逻辑<ol>
<li>cobra匹配子命令</li>
<li>用Visitor模式构建Builder</li>
<li>用RESTClient将Object发送到kube-apiserver</li>
</ol>
</li>
</ol>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>【K8s源码品读】005：Phase 1 - kube-apiserver 权限相关的三个核心概念</title>
    <url>/2021/02/18/k8s/k8s-005/</url>
    <content><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解启动kube-apiserver的权限相关的三个核心概念 <code>Authentication</code>/<code>Authorization</code>/<code>Admission</code></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#run">kube-apiserver的启动</a></li>
<li><a href="#three-servers">kube-apiserver的三个Server</a></li>
<li><a href="#KubeAPIServer">KubeAPIServer的创建过程</a><ol>
<li><a href="#GenericConfig">通用配置概况</a></li>
<li><a href="#Authentication">通用配置中的认证</a></li>
<li><a href="#Authorization">通用配置中的授权</a></li>
<li><a href="#Admission">通用配置中的准入机制</a></li>
</ol>
</li>
</ol>
<h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类似kubectl的源代码，kube-apiserver的命令行工具也使用了cobra，我们很快就能找到启动的入口</span></span><br><span class="line">RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			<span class="comment">// 这里包含2个参数，前者是参数completedOptions，后者是一个stopCh &lt;-chan struct&#123;&#125;</span></span><br><span class="line">			<span class="keyword">return</span> Run(completedOptions, genericapiserver.SetupSignalHandler())</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	在这里，我们可以和kubectl结合起来思考：</span></span><br><span class="line"><span class="comment">	kubectl是一个命令行工具，执行完命令就退出；kube-apiserver是一个常驻的服务器进程，监听端口</span></span><br><span class="line"><span class="comment">	这里引入了一个stopCh &lt;-chan struct&#123;&#125;，可以在启动后，用一个 &lt;-stopCh 作为阻塞，使程序不退出</span></span><br><span class="line"><span class="comment">	用channel阻塞进程退出，对比传统的方法 - 用一个永不退出的for循环，是一个很优雅的实现</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="Three-Servers"><a href="#Three-Servers" class="headerlink" title="Three Servers"></a>Three Servers</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在CreateServerChain这个函数下，创建了3个server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateServerChain</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// API扩展服务，主要针对CRD</span></span><br><span class="line">	createAPIExtensionsServer()&#123;&#125; </span><br><span class="line">  <span class="comment">// API核心服务，包括常见的Pod/Deployment/Service，我们今天的重点聚焦在这里</span></span><br><span class="line">  <span class="comment">// 我会跳过很多非核心的配置参数，一开始就去研究细节，很影响整体代码的阅读效率</span></span><br><span class="line">	CreateKubeAPIServer()&#123;&#125; </span><br><span class="line">  <span class="comment">// API聚合服务，主要针对metrics</span></span><br><span class="line">	createAggregatorServer()&#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="KubeAPIServer"><a href="#KubeAPIServer" class="headerlink" title="KubeAPIServer"></a>KubeAPIServer</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建配置的流程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateKubeAPIServerConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 创建通用配置genericConfig</span></span><br><span class="line">  genericConfig, versionedInformers, insecureServingInfo, serviceResolver, pluginInitializers, admissionPostStartHook, storageFactory, err := buildGenericConfig(s.ServerRunOptions, proxyTransport)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="GenericConfig"><a href="#GenericConfig" class="headerlink" title="GenericConfig"></a>GenericConfig</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用配置的创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildGenericConfig</span><span class="params">(s *options.ServerRunOptions,proxyTransport *http.Transport)</span></span>&#123;</span><br><span class="line">  <span class="comment">// Insecure对应的非安全的通信，也就是HTTP</span></span><br><span class="line">  <span class="keyword">if</span> lastErr = s.InsecureServing...</span><br><span class="line">  <span class="comment">// Secure对应的就是HTTPS</span></span><br><span class="line">  <span class="keyword">if</span> lastErr = s.SecureServing...</span><br><span class="line">  <span class="comment">// OpenAPIConfig是对外提供的API文档</span></span><br><span class="line">  genericConfig.OpenAPIConfig = genericapiserver.DefaultOpenAPIConfig()</span><br><span class="line">  <span class="comment">// 这一块是storageFactory的实例化，可以看到采用的是etcd作为存储方案</span></span><br><span class="line">  storageFactoryConfig := kubeapiserver.NewStorageFactoryConfig()</span><br><span class="line">	storageFactoryConfig.APIResourceConfig = genericConfig.MergedResourceConfig</span><br><span class="line">	completedStorageFactoryConfig, err := storageFactoryConfig.Complete(s.Etcd)</span><br><span class="line">	storageFactory, lastErr = completedStorageFactoryConfig.New()</span><br><span class="line">  <span class="comment">// Authentication 认证相关</span></span><br><span class="line">  <span class="keyword">if</span> lastErr = s.Authentication.ApplyTo()...</span><br><span class="line">  <span class="comment">// Authorization 授权相关</span></span><br><span class="line">  genericConfig.Authorization.Authorizer, genericConfig.RuleResolver, err = BuildAuthorizer()</span><br><span class="line">  <span class="comment">// Admission 准入机制</span></span><br><span class="line">  err = s.Admission.ApplyTo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *BuiltInAuthenticationOptions)</span> <span class="title">ApplyTo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 前面都是对认证config进行参数设置，这里才是真正的实例化</span></span><br><span class="line">  authInfo.Authenticator, openAPIConfig.SecurityDefinitions, err = authenticatorConfig.New()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New这块的代码，我们要抓住核心变量authenticators和tokenAuthenticators，也就是各种认证方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(config Config)</span> <span class="title">New</span><span class="params">()</span> <span class="params">(authenticator.Request, *spec.SecurityDefinitions, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 核心变量authenticators和tokenAuthenticators</span></span><br><span class="line">	<span class="keyword">var</span> authenticators []authenticator.Request</span><br><span class="line">  <span class="keyword">var</span> tokenAuthenticators []authenticator.Token</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> config.RequestHeaderConfig != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 1. 添加requestHeader</span></span><br><span class="line">		authenticators = <span class="built_in">append</span>(authenticators, authenticator.WrapAudienceAgnosticRequest(config.APIAudiences, requestHeaderAuthenticator))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> config.ClientCAContentProvider != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 2. 添加ClientCA</span></span><br><span class="line">    authenticators = <span class="built_in">append</span>(authenticators, certAuth)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(config.TokenAuthFile) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 3. token 添加tokenfile</span></span><br><span class="line">		tokenAuthenticators = <span class="built_in">append</span>(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, tokenAuth))</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4. token 添加 service account，分两种来源</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(config.ServiceAccountKeyFiles) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		tokenAuthenticators = <span class="built_in">append</span>(tokenAuthenticators, serviceAccountAuth)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.TokenRequest) &amp;&amp; config.ServiceAccountIssuer != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		tokenAuthenticators = <span class="built_in">append</span>(tokenAuthenticators, serviceAccountAuth)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> config.BootstrapToken &#123;</span><br><span class="line">		<span class="keyword">if</span> config.BootstrapTokenAuthenticator != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 5. token 添加 bootstrap</span></span><br><span class="line">			tokenAuthenticators = <span class="built_in">append</span>(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, config.BootstrapTokenAuthenticator))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(config.OIDCIssuerURL) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(config.OIDCClientID) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 6. token 添加 oidc</span></span><br><span class="line">    Authenticators = <span class="built_in">append</span>(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, oidcAuth))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(config.WebhookTokenAuthnConfigFile) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 7. token 添加 webhook</span></span><br><span class="line">		tokenAuthenticators = <span class="built_in">append</span>(tokenAuthenticators, webhookTokenAuth)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 8. 组合tokenAuthenticators到tokenAuthenticators中</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(tokenAuthenticators) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		tokenAuth := tokenunion.New(tokenAuthenticators...)</span><br><span class="line">		<span class="keyword">if</span> config.TokenSuccessCacheTTL &gt; <span class="number">0</span> || config.TokenFailureCacheTTL &gt; <span class="number">0</span> &#123;</span><br><span class="line">			tokenAuth = tokencache.New(tokenAuth, <span class="literal">true</span>, config.TokenSuccessCacheTTL, config.TokenFailureCacheTTL)</span><br><span class="line">		&#125;</span><br><span class="line">		authenticators = <span class="built_in">append</span>(authenticators, bearertoken.New(tokenAuth), websocket.NewProtocolAuthenticator(tokenAuth))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 9. 没有任何认证方式且启用了Anonymous</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(authenticators) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> config.Anonymous &#123;</span><br><span class="line">			<span class="keyword">return</span> anonymous.NewAuthenticator(), &amp;securityDefinitions, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, &amp;securityDefinitions, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 10. 组合authenticators</span></span><br><span class="line">	authenticator := union.New(authenticators...)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> authenticator, &amp;securityDefinitions, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂的Authentication模块的初始化顺序我们看完了，有初步的了解即可，没必要去强制记忆其中的加载顺序。</p>
<h3 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildAuthorizer</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 与上面一致，实例化是在这个New中</span></span><br><span class="line">  <span class="keyword">return</span> authorizationConfig.New()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不得不说，Authorizer这块的阅读体验更好</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(config Config)</span> <span class="title">New</span><span class="params">()</span> <span class="params">(authorizer.Authorizer, authorizer.RuleResolver, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 必须传入一个Authorizer机制</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(config.AuthorizationModes) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;at least one authorization mode must be passed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		authorizers   []authorizer.Authorizer</span><br><span class="line">		ruleResolvers []authorizer.RuleResolver</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, authorizationMode := <span class="keyword">range</span> config.AuthorizationModes &#123;</span><br><span class="line">		<span class="comment">// 具体的mode定义，可以跳转到对应的链接去看，今天不细讲</span></span><br><span class="line">		<span class="keyword">switch</span> authorizationMode &#123;</span><br><span class="line">		<span class="keyword">case</span> modes.ModeNode:</span><br><span class="line">			authorizers = <span class="built_in">append</span>(authorizers, nodeAuthorizer)</span><br><span class="line">			ruleResolvers = <span class="built_in">append</span>(ruleResolvers, nodeAuthorizer)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> modes.ModeAlwaysAllow:</span><br><span class="line">			authorizers = <span class="built_in">append</span>(authorizers, alwaysAllowAuthorizer)</span><br><span class="line">			ruleResolvers = <span class="built_in">append</span>(ruleResolvers, alwaysAllowAuthorizer)</span><br><span class="line">      </span><br><span class="line">		<span class="keyword">case</span> modes.ModeAlwaysDeny:</span><br><span class="line">			authorizers = <span class="built_in">append</span>(authorizers, alwaysDenyAuthorizer)</span><br><span class="line">			ruleResolvers = <span class="built_in">append</span>(ruleResolvers, alwaysDenyAuthorizer)</span><br><span class="line">      </span><br><span class="line">		<span class="keyword">case</span> modes.ModeABAC:</span><br><span class="line">			authorizers = <span class="built_in">append</span>(authorizers, abacAuthorizer)</span><br><span class="line">			ruleResolvers = <span class="built_in">append</span>(ruleResolvers, abacAuthorizer)</span><br><span class="line">      </span><br><span class="line">		<span class="keyword">case</span> modes.ModeWebhook:</span><br><span class="line">			authorizers = <span class="built_in">append</span>(authorizers, webhookAuthorizer)</span><br><span class="line">			ruleResolvers = <span class="built_in">append</span>(ruleResolvers, webhookAuthorizer)</span><br><span class="line">      </span><br><span class="line">		<span class="keyword">case</span> modes.ModeRBAC:</span><br><span class="line">			authorizers = <span class="built_in">append</span>(authorizers, rbacAuthorizer)</span><br><span class="line">			ruleResolvers = <span class="built_in">append</span>(ruleResolvers, rbacAuthorizer)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unknown authorization mode %s specified&quot;</span>, authorizationMode)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> union.New(authorizers...), union.NewRuleResolvers(ruleResolvers...), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// ModeAlwaysAllow is the mode to set all requests as authorized</span></span><br><span class="line">	ModeAlwaysAllow <span class="keyword">string</span> = <span class="string">&quot;AlwaysAllow&quot;</span></span><br><span class="line">	<span class="comment">// ModeAlwaysDeny is the mode to set no requests as authorized</span></span><br><span class="line">	ModeAlwaysDeny <span class="keyword">string</span> = <span class="string">&quot;AlwaysDeny&quot;</span></span><br><span class="line">	<span class="comment">// ModeABAC is the mode to use Attribute Based Access Control to authorize</span></span><br><span class="line">	ModeABAC <span class="keyword">string</span> = <span class="string">&quot;ABAC&quot;</span></span><br><span class="line">	<span class="comment">// ModeWebhook is the mode to make an external webhook call to authorize</span></span><br><span class="line">	ModeWebhook <span class="keyword">string</span> = <span class="string">&quot;Webhook&quot;</span></span><br><span class="line">	<span class="comment">// ModeRBAC is the mode to use Role Based Access Control to authorize</span></span><br><span class="line">	ModeRBAC <span class="keyword">string</span> = <span class="string">&quot;RBAC&quot;</span></span><br><span class="line">	<span class="comment">// ModeNode is an authorization mode that authorizes API requests made by kubelets.</span></span><br><span class="line">	ModeNode <span class="keyword">string</span> = <span class="string">&quot;Node&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="Admission"><a href="#Admission" class="headerlink" title="Admission"></a>Admission</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看定义</span></span><br><span class="line">err = s.Admission.ApplyTo()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AdmissionOptions)</span> <span class="title">ApplyTo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.GenericAdmission.ApplyTo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *Plugins)</span> <span class="title">NewFromPlugins</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> _, pluginName := <span class="keyword">range</span> pluginNames &#123;</span><br><span class="line">		<span class="comment">// InitPlugin 为初始化的工作</span></span><br><span class="line">		plugin, err := ps.InitPlugin(pluginName, pluginConfig, pluginInitializer)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *Plugins)</span> <span class="title">InitPlugin</span><span class="params">(name <span class="keyword">string</span>, config io.Reader, pluginInitializer PluginInitializer)</span> <span class="params">(Interface, error)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 获取plugin</span></span><br><span class="line">  plugin, found, err := ps.getPlugin(name, config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看一下Interface的定义，就是对准入机制的控制</span></span><br><span class="line"><span class="comment">// Interface is an abstract, pluggable interface for Admission Control decisions.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Handles(operation Operation) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再去看看获取plugin的地方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *Plugins)</span> <span class="title">getPlugin</span><span class="params">(name <span class="keyword">string</span>, config io.Reader)</span> <span class="params">(Interface, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	ps.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> ps.lock.Unlock()</span><br><span class="line">  <span class="comment">// 我们再去研究ps.registry这个参数是在哪里被初始化的</span></span><br><span class="line">	f, found := ps.registry[name]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来，我们从kube-apiserver启动过程，逐步找到Admission被初始化的地方</span></span><br><span class="line"><span class="comment">// 启动命令</span></span><br><span class="line">command := app.NewAPIServerCommand()</span><br><span class="line"><span class="comment">// server配置</span></span><br><span class="line">s := options.NewServerRunOptions()</span><br><span class="line"><span class="comment">// admission选项</span></span><br><span class="line">Admission:               kubeoptions.NewAdmissionOptions()</span><br><span class="line"><span class="comment">// 注册准入机制</span></span><br><span class="line">RegisterAllAdmissionPlugins(options.Plugins)</span><br><span class="line"><span class="comment">// 准入机制的所有内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterAllAdmissionPlugins</span><span class="params">(plugins *admission.Plugins)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 这里有很多plugin的注册</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往上翻，我们能找到所有plugin，也就是准入机制的定义</span></span><br><span class="line"><span class="keyword">var</span> AllOrderedPlugins = []<span class="keyword">string</span>&#123;</span><br><span class="line">	admit.PluginName,                        <span class="comment">// AlwaysAdmit</span></span><br><span class="line">	autoprovision.PluginName,                <span class="comment">// NamespaceAutoProvision</span></span><br><span class="line">	lifecycle.PluginName,                    <span class="comment">// NamespaceLifecycle</span></span><br><span class="line">	exists.PluginName,                       <span class="comment">// NamespaceExists</span></span><br><span class="line">	scdeny.PluginName,                       <span class="comment">// SecurityContextDeny</span></span><br><span class="line">	antiaffinity.PluginName,                 <span class="comment">// LimitPodHardAntiAffinityTopology</span></span><br><span class="line">	podpreset.PluginName,                    <span class="comment">// PodPreset</span></span><br><span class="line">	limitranger.PluginName,                  <span class="comment">// LimitRanger</span></span><br><span class="line">	serviceaccount.PluginName,               <span class="comment">// ServiceAccount</span></span><br><span class="line">	noderestriction.PluginName,              <span class="comment">// NodeRestriction</span></span><br><span class="line">	nodetaint.PluginName,                    <span class="comment">// TaintNodesByCondition</span></span><br><span class="line">	alwayspullimages.PluginName,             <span class="comment">// AlwaysPullImages</span></span><br><span class="line">	imagepolicy.PluginName,                  <span class="comment">// ImagePolicyWebhook</span></span><br><span class="line">	podsecuritypolicy.PluginName,            <span class="comment">// PodSecurityPolicy</span></span><br><span class="line">	podnodeselector.PluginName,              <span class="comment">// PodNodeSelector</span></span><br><span class="line">	podpriority.PluginName,                  <span class="comment">// Priority</span></span><br><span class="line">	defaulttolerationseconds.PluginName,     <span class="comment">// DefaultTolerationSeconds</span></span><br><span class="line">	podtolerationrestriction.PluginName,     <span class="comment">// PodTolerationRestriction</span></span><br><span class="line">	exec.DenyEscalatingExec,                 <span class="comment">// DenyEscalatingExec</span></span><br><span class="line">	exec.DenyExecOnPrivileged,               <span class="comment">// DenyExecOnPrivileged</span></span><br><span class="line">	eventratelimit.PluginName,               <span class="comment">// EventRateLimit</span></span><br><span class="line">	extendedresourcetoleration.PluginName,   <span class="comment">// ExtendedResourceToleration</span></span><br><span class="line">	label.PluginName,                        <span class="comment">// PersistentVolumeLabel</span></span><br><span class="line">	setdefault.PluginName,                   <span class="comment">// DefaultStorageClass</span></span><br><span class="line">	storageobjectinuseprotection.PluginName, <span class="comment">// StorageObjectInUseProtection</span></span><br><span class="line">	gc.PluginName,                           <span class="comment">// OwnerReferencesPermissionEnforcement</span></span><br><span class="line">	resize.PluginName,                       <span class="comment">// PersistentVolumeClaimResize</span></span><br><span class="line">	runtimeclass.PluginName,                 <span class="comment">// RuntimeClass</span></span><br><span class="line">	certapproval.PluginName,                 <span class="comment">// CertificateApproval</span></span><br><span class="line">	certsigning.PluginName,                  <span class="comment">// CertificateSigning</span></span><br><span class="line">	certsubjectrestriction.PluginName,       <span class="comment">// CertificateSubjectRestriction</span></span><br><span class="line">	defaultingressclass.PluginName,          <span class="comment">// DefaultIngressClass</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// new admission plugins should generally be inserted above here</span></span><br><span class="line">	<span class="comment">// webhook, resourcequota, and deny plugins must go at the end</span></span><br><span class="line"></span><br><span class="line">	mutatingwebhook.PluginName,   <span class="comment">// MutatingAdmissionWebhook</span></span><br><span class="line">	validatingwebhook.PluginName, <span class="comment">// ValidatingAdmissionWebhook</span></span><br><span class="line">	resourcequota.PluginName,     <span class="comment">// ResourceQuota</span></span><br><span class="line">	deny.PluginName,              <span class="comment">// AlwaysDeny</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>【K8s源码品读】006：Phase 1 - kube-apiserver - GenericAPIServer的初始化</title>
    <url>/2021/02/18/k8s/k8s-006/</url>
    <content><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解kube-apiserver是中的管理核心资源的<code>KubeAPIServer</code>是怎么启动的</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#genericServer">genericServer的创建</a></li>
<li><a href="#NewAPIServerHandler">创建REST的Handler</a></li>
<li><a href="#installAPI">Generic的API路由规则</a></li>
<li><a href="#apiserver">初始化核心Apiserver</a></li>
<li><a href="#InstallLegacyAPI">核心资源的API路由规则</a></li>
<li><a href="#create-pod">创建Pod的函数</a></li>
</ol>
<h2 id="GenericServer"><a href="#GenericServer" class="headerlink" title="GenericServer"></a>GenericServer</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在APIExtensionsServer、KubeAPIServer和AggregatorServer三种Server启动时，我们都能发现这么一个函数</span></span><br><span class="line"><span class="comment">// APIExtensionsServer</span></span><br><span class="line">genericServer, err := c.GenericConfig.New(<span class="string">&quot;apiextensions-apiserver&quot;</span>, delegationTarget)</span><br><span class="line"><span class="comment">// KubeAPIServer</span></span><br><span class="line">s, err := c.GenericConfig.New(<span class="string">&quot;kube-apiserver&quot;</span>, delegationTarget)</span><br><span class="line"><span class="comment">// AggregatorServer</span></span><br><span class="line">genericServer, err := c.GenericConfig.New(<span class="string">&quot;kube-aggregator&quot;</span>, delegationTarget)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都通过GenericConfig创建了genericServer，我们先大致浏览下</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span> <span class="title">New</span><span class="params">(name <span class="keyword">string</span>, delegationTarget DelegationTarget)</span> <span class="params">(*GenericAPIServer, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 新建Handler</span></span><br><span class="line">	apiServerHandler := NewAPIServerHandler(name, c.Serializer, handlerChainBuilder, delegationTarget.UnprotectedHandler())</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 实例化一个Server</span></span><br><span class="line">	s := &amp;GenericAPIServer&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理钩子hook操作</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> delegationTarget.PostStartHooks() &#123;</span><br><span class="line">		s.postStartHooks[k] = v</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> delegationTarget.PreShutdownHooks() &#123;</span><br><span class="line">		s.preShutdownHooks[k] = v</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 健康监测</span></span><br><span class="line">	<span class="keyword">for</span> _, delegateCheck := <span class="keyword">range</span> delegationTarget.HealthzChecks() &#123;</span><br><span class="line">		skip := <span class="literal">false</span></span><br><span class="line">		<span class="keyword">for</span> _, existingCheck := <span class="keyword">range</span> c.HealthzChecks &#123;</span><br><span class="line">			<span class="keyword">if</span> existingCheck.Name() == delegateCheck.Name() &#123;</span><br><span class="line">				skip = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> skip &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		s.AddHealthChecks(delegateCheck)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 安装API相关参数，这个是重点</span></span><br><span class="line">	installAPI(s, c.Config)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="NewAPIServerHandler"><a href="#NewAPIServerHandler" class="headerlink" title="NewAPIServerHandler"></a>NewAPIServerHandler</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAPIServerHandler</span><span class="params">(name <span class="keyword">string</span>, s runtime.NegotiatedSerializer, handlerChainBuilder HandlerChainBuilderFn, notFoundHandler http.Handler)</span> *<span class="title">APIServerHandler</span></span> &#123;</span><br><span class="line">	<span class="comment">// 采用了 github.com/emicklei/go-restful 这个库作为 RESTful 接口的设计，目前了解即可</span></span><br><span class="line">	gorestfulContainer := restful.NewContainer()</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="installAPI"><a href="#installAPI" class="headerlink" title="installAPI"></a>installAPI</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">installAPI</span><span class="params">(s *GenericAPIServer, c *Config)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 添加 /index.html 路由规则</span></span><br><span class="line">	<span class="keyword">if</span> c.EnableIndex &#123;</span><br><span class="line">		routes.Index&#123;&#125;.Install(s.listedPathProvider, s.Handler.NonGoRestfulMux)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 添加go语言 /pprof 的路由规则，常用于性能分析</span></span><br><span class="line">	<span class="keyword">if</span> c.EnableProfiling &#123;</span><br><span class="line">		routes.Profiling&#123;&#125;.Install(s.Handler.NonGoRestfulMux)</span><br><span class="line">		<span class="keyword">if</span> c.EnableContentionProfiling &#123;</span><br><span class="line">			goruntime.SetBlockProfileRate(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		routes.DebugFlags&#123;&#125;.Install(s.Handler.NonGoRestfulMux, <span class="string">&quot;v&quot;</span>, routes.StringFlagPutHandler(logs.GlogSetter))</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 添加监控相关的 /metrics 的指标路由规则</span></span><br><span class="line">	<span class="keyword">if</span> c.EnableMetrics &#123;</span><br><span class="line">		<span class="keyword">if</span> c.EnableProfiling &#123;</span><br><span class="line">			routes.MetricsWithReset&#123;&#125;.Install(s.Handler.NonGoRestfulMux)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			routes.DefaultMetrics&#123;&#125;.Install(s.Handler.NonGoRestfulMux)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 添加版本 /version 的路由规则</span></span><br><span class="line">	routes.Version&#123;Version: c.Version&#125;.Install(s.Handler.GoRestfulContainer)</span><br><span class="line">	<span class="comment">// 开启服务发现</span></span><br><span class="line">	<span class="keyword">if</span> c.EnableDiscovery &#123;</span><br><span class="line">		s.Handler.GoRestfulContainer.Add(s.DiscoveryGroupManager.WebService())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> feature.DefaultFeatureGate.Enabled(features.APIPriorityAndFairness) &#123;</span><br><span class="line">		c.FlowControl.Install(s.Handler.NonGoRestfulMux)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Apiserver"><a href="#Apiserver" class="headerlink" title="Apiserver"></a>Apiserver</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span> <span class="title">New</span><span class="params">(delegationTarget genericapiserver.DelegationTarget)</span> <span class="params">(*Master, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// genericServer的初始化</span></span><br><span class="line">	s, err := c.GenericConfig.New(<span class="string">&quot;kube-apiserver&quot;</span>, delegationTarget)</span><br><span class="line">	<span class="comment">// 核心KubeAPIServer的实例化</span></span><br><span class="line">	m := &amp;Master&#123;</span><br><span class="line">		GenericAPIServer:          s,</span><br><span class="line">		ClusterAuthenticationInfo: c.ExtraConfig.ClusterAuthenticationInfo,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册Legacy API的注册</span></span><br><span class="line">	<span class="keyword">if</span> c.ExtraConfig.APIResourceConfigSource.VersionEnabled(apiv1.SchemeGroupVersion) &#123;</span><br><span class="line">		legacyRESTStorageProvider := corerest.LegacyRESTStorageProvider&#123;&#125;</span><br><span class="line">		<span class="keyword">if</span> err := m.InstallLegacyAPI(&amp;c, c.GenericConfig.RESTOptionsGetter, legacyRESTStorageProvider); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// REST接口的存储定义，可以看到很多k8s上的常见定义，比如node节点/storage存储/event事件等等</span></span><br><span class="line">	restStorageProviders := []RESTStorageProvider&#123;</span><br><span class="line">		authenticationrest.RESTStorageProvider&#123;Authenticator: c.GenericConfig.Authentication.Authenticator, APIAudiences: c.GenericConfig.Authentication.APIAudiences&#125;,</span><br><span class="line">		authorizationrest.RESTStorageProvider&#123;Authorizer: c.GenericConfig.Authorization.Authorizer, RuleResolver: c.GenericConfig.RuleResolver&#125;,</span><br><span class="line">		autoscalingrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		batchrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		certificatesrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		coordinationrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		discoveryrest.StorageProvider&#123;&#125;,</span><br><span class="line">		extensionsrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		networkingrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		noderest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		policyrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		rbacrest.RESTStorageProvider&#123;Authorizer: c.GenericConfig.Authorization.Authorizer&#125;,</span><br><span class="line">		schedulingrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		settingsrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		storagerest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		flowcontrolrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		<span class="comment">// keep apps after extensions so legacy clients resolve the extensions versions of shared resource names.</span></span><br><span class="line">		<span class="comment">// See https://github.com/kubernetes/kubernetes/issues/42392</span></span><br><span class="line">		appsrest.StorageProvider&#123;&#125;,</span><br><span class="line">		admissionregistrationrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		eventsrest.RESTStorageProvider&#123;TTL: c.ExtraConfig.EventTTL&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 注册API</span></span><br><span class="line">	<span class="keyword">if</span> err := m.InstallAPIs(c.ExtraConfig.APIResourceConfigSource, c.GenericConfig.RESTOptionsGetter, restStorageProviders...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 添加Hook</span></span><br><span class="line">	m.GenericAPIServer.AddPostStartHookOrDie(<span class="string">&quot;start-cluster-authentication-info-controller&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(hookContext genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册API的关键在<code>InstallLegacyAPI</code>和<code>InstallAPIs</code>，如果你对kubernetes的资源有一定的了解，会知道核心资源都放在Legacy中（如果不了解的话，点击函数看一下，就能有所有了解）</p>
<h2 id="InstallLegacyAPI"><a href="#InstallLegacyAPI" class="headerlink" title="InstallLegacyAPI"></a>InstallLegacyAPI</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">InstallLegacyAPI</span><span class="params">(c *completedConfig, restOptionsGetter generic.RESTOptionsGetter, legacyRESTStorageProvider corerest.LegacyRESTStorageProvider)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// RESTStorage的初始化</span></span><br><span class="line">	legacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 前缀为 /api，注册上对应的Version和Resource</span></span><br><span class="line">  <span class="comment">// Pod作为核心资源，没有Group的概念</span></span><br><span class="line">	<span class="keyword">if</span> err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &amp;apiGroupInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error in registering group versions: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们再细看这个RESTStorage的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c LegacyRESTStorageProvider)</span> <span class="title">NewLegacyRESTStorage</span><span class="params">(restOptionsGetter generic.RESTOptionsGetter)</span> <span class="params">(LegacyRESTStorage, genericapiserver.APIGroupInfo, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// pod 模板</span></span><br><span class="line">	podTemplateStorage, err := podtemplatestore.NewREST(restOptionsGetter)</span><br><span class="line">	<span class="comment">// event事件</span></span><br><span class="line">	eventStorage, err := eventstore.NewREST(restOptionsGetter, <span class="keyword">uint64</span>(c.EventTTL.Seconds()))</span><br><span class="line">	<span class="comment">// limitRange资源限制</span></span><br><span class="line">	limitRangeStorage, err := limitrangestore.NewREST(restOptionsGetter)</span><br><span class="line">	<span class="comment">// resourceQuota资源配额</span></span><br><span class="line">	resourceQuotaStorage, resourceQuotaStatusStorage, err := resourcequotastore.NewREST(restOptionsGetter)</span><br><span class="line">	<span class="comment">// secret加密</span></span><br><span class="line">	secretStorage, err := secretstore.NewREST(restOptionsGetter)</span><br><span class="line">	<span class="comment">// PV 存储</span></span><br><span class="line">	persistentVolumeStorage, persistentVolumeStatusStorage, err := pvstore.NewREST(restOptionsGetter)</span><br><span class="line">	<span class="comment">// PVC 存储</span></span><br><span class="line">	persistentVolumeClaimStorage, persistentVolumeClaimStatusStorage, err := pvcstore.NewREST(restOptionsGetter)</span><br><span class="line">	<span class="comment">// ConfigMap 配置</span></span><br><span class="line">	configMapStorage, err := configmapstore.NewREST(restOptionsGetter)</span><br><span class="line">	<span class="comment">// 等等核心资源，暂不一一列举</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// pod模板，我们的示例nginx-pod属于这个类型的资源</span></span><br><span class="line">  podStorage, err := podstore.NewStorage()</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 保存storage的对应关系</span></span><br><span class="line">  restStorageMap := <span class="keyword">map</span>[<span class="keyword">string</span>]rest.Storage&#123;</span><br><span class="line">		<span class="string">&quot;pods&quot;</span>:             podStorage.Pod,</span><br><span class="line">		<span class="string">&quot;pods/attach&quot;</span>:      podStorage.Attach,</span><br><span class="line">		<span class="string">&quot;pods/status&quot;</span>:      podStorage.Status,</span><br><span class="line">		<span class="string">&quot;pods/log&quot;</span>:         podStorage.Log,</span><br><span class="line">		<span class="string">&quot;pods/exec&quot;</span>:        podStorage.Exec,</span><br><span class="line">		<span class="string">&quot;pods/portforward&quot;</span>: podStorage.PortForward,</span><br><span class="line">		<span class="string">&quot;pods/proxy&quot;</span>:       podStorage.Proxy,</span><br><span class="line">		<span class="string">&quot;pods/binding&quot;</span>:     podStorage.Binding,</span><br><span class="line">		<span class="string">&quot;bindings&quot;</span>:         podStorage.LegacyBinding,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Create-Pod"><a href="#Create-Pod" class="headerlink" title="Create Pod"></a>Create Pod</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看Pod初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStorage</span><span class="params">(optsGetter generic.RESTOptionsGetter, k client.ConnectionInfoGetter, proxyTransport http.RoundTripper, podDisruptionBudgetClient policyclient.PodDisruptionBudgetsGetter)</span> <span class="params">(PodStorage, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	store := &amp;genericregistry.Store&#123;</span><br><span class="line">		NewFunc:                  <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">runtime</span>.<span class="title">Object</span></span> &#123; <span class="keyword">return</span> &amp;api.Pod&#123;&#125; &#125;,</span><br><span class="line">		NewListFunc:              <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">runtime</span>.<span class="title">Object</span></span> &#123; <span class="keyword">return</span> &amp;api.PodList&#123;&#125; &#125;,</span><br><span class="line">		PredicateFunc:            registrypod.MatchPod,</span><br><span class="line">		DefaultQualifiedResource: api.Resource(<span class="string">&quot;pods&quot;</span>),</span><br><span class="line">		<span class="comment">// 增改删的策略</span></span><br><span class="line">		CreateStrategy:      registrypod.Strategy,</span><br><span class="line">		UpdateStrategy:      registrypod.Strategy,</span><br><span class="line">		DeleteStrategy:      registrypod.Strategy,</span><br><span class="line">		ReturnDeletedObject: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">		TableConvertor: printerstorage.TableConvertor&#123;TableGenerator: printers.NewTableGenerator().With(printersinternal.AddHandlers)&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查看 Strategy 的初始化</span></span><br><span class="line"><span class="keyword">var</span> Strategy = podStrategy&#123;legacyscheme.Scheme, names.SimpleNameGenerator&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 又查询到Scheme的初始化。Schema可以理解为Kubernetes的注册表，即所有的资源类型必须先注册进Schema才可使用</span></span><br><span class="line"><span class="keyword">var</span> Scheme = runtime.NewScheme()</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>【K8s源码品读】007：Phase 1 - kube-apiserver - Pod数据的保存</title>
    <url>/2021/02/18/k8s/k8s-007/</url>
    <content><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解Pod发送到<code>kube-apiserver</code>后是怎么保存的</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#RESTCreateStrategy">RESTCreateStrategy创建的预处理</a></li>
<li><a href="#Storage">REST Pod数据的存储</a></li>
<li><a href="#storage-implement">存储的底层实现</a></li>
<li><a href="#summary">kube-apiserver第一阶段源码阅读总结</a></li>
</ol>
<h2 id="RESTCreateStrategy"><a href="#RESTCreateStrategy" class="headerlink" title="RESTCreateStrategy"></a>RESTCreateStrategy</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// podStrategy 是封装了 Pod 的各类动作，这里我们先关注create这个操作</span></span><br><span class="line"><span class="keyword">type</span> podStrategy <span class="keyword">struct</span> &#123;</span><br><span class="line">	runtime.ObjectTyper</span><br><span class="line">	names.NameGenerator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// podStrategy 的接口</span></span><br><span class="line"><span class="keyword">type</span> RESTCreateStrategy <span class="keyword">interface</span> &#123;</span><br><span class="line">	runtime.ObjectTyper</span><br><span class="line">	names.NameGenerator</span><br><span class="line">  <span class="comment">// 是否属于当前的 namespace</span></span><br><span class="line">	NamespaceScoped() <span class="keyword">bool</span></span><br><span class="line">  <span class="comment">// 准备创建前的检查</span></span><br><span class="line">	PrepareForCreate(ctx context.Context, obj runtime.Object)</span><br><span class="line">  <span class="comment">// 验证资源对象</span></span><br><span class="line">	Validate(ctx context.Context, obj runtime.Object) field.ErrorList</span><br><span class="line">  <span class="comment">// 规范化</span></span><br><span class="line">	Canonicalize(obj runtime.Object)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成了检查，我们就要保存数据了</span></span><br></pre></td></tr></table></figure>



<h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PodStorage 是 Pod 存储的实现，里面包含了多个存储的定义</span></span><br><span class="line"><span class="keyword">type</span> PodStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// REST implements a RESTStorage for pods</span></span><br><span class="line">	Pod                 *REST</span><br><span class="line">  <span class="comment">// BindingREST implements the REST endpoint for binding pods to nodes when etcd is in use.</span></span><br><span class="line">	Binding             *BindingREST</span><br><span class="line">  <span class="comment">// LegacyBindingREST implements the REST endpoint for binding pods to nodes when etcd is in use.</span></span><br><span class="line">	LegacyBinding       *LegacyBindingREST</span><br><span class="line">	Eviction            *EvictionREST</span><br><span class="line">  <span class="comment">// StatusREST implements the REST endpoint for changing the status of a pod.</span></span><br><span class="line">	Status              *StatusREST</span><br><span class="line">  <span class="comment">// EphemeralContainersREST implements the REST endpoint for adding EphemeralContainers</span></span><br><span class="line">	EphemeralContainers *EphemeralContainersREST</span><br><span class="line">	Log                 *podrest.LogREST</span><br><span class="line">	Proxy               *podrest.ProxyREST</span><br><span class="line">	Exec                *podrest.ExecREST</span><br><span class="line">	Attach              *podrest.AttachREST</span><br><span class="line">	PortForward         *podrest.PortForwardREST</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从上一节的map关系中，保存在REST中</span></span><br><span class="line"><span class="comment">restStorageMap := map[string]rest.Storage&#123;</span></span><br><span class="line"><span class="comment">		&quot;pods&quot;:             podStorage.Pod,</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> REST <span class="keyword">struct</span> &#123;</span><br><span class="line">	*genericregistry.Store</span><br><span class="line">	proxyTransport http.RoundTripper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store是一个通用的数据结构</span></span><br><span class="line"><span class="keyword">type</span> Store <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Storage定义</span></span><br><span class="line">	Storage DryRunnableStorage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DryRunnableStorage中的Storage是一个Interface</span></span><br><span class="line"><span class="keyword">type</span> DryRunnableStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">	Storage storage.Interface</span><br><span class="line">	Codec   runtime.Codec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DryRunnableStorage)</span> <span class="title">Create</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, obj, out runtime.Object, ttl <span class="keyword">uint64</span>, dryRun <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> dryRun &#123;</span><br><span class="line">		<span class="keyword">if</span> err := s.Storage.Get(ctx, key, storage.GetOptions&#123;&#125;, out); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> storage.NewKeyExistsError(key, <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s.copyInto(obj, out)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 这里，就是Create的真正调用</span></span><br><span class="line">	<span class="keyword">return</span> s.Storage.Create(ctx, key, obj, out, ttl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Storage-Implement"><a href="#Storage-Implement" class="headerlink" title="Storage Implement"></a>Storage Implement</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Storage Interface 的定义，包括基本的增删改查，以及watch等等进阶操作</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Versioner() Versioner</span><br><span class="line">	Create(ctx context.Context, key <span class="keyword">string</span>, obj, out runtime.Object, ttl <span class="keyword">uint64</span>) error</span><br><span class="line">	Delete(ctx context.Context, key <span class="keyword">string</span>, out runtime.Object, preconditions *Preconditions, validateDeletion ValidateObjectFunc) error</span><br><span class="line">	Watch(ctx context.Context, key <span class="keyword">string</span>, opts ListOptions) (watch.Interface, error)</span><br><span class="line">	WatchList(ctx context.Context, key <span class="keyword">string</span>, opts ListOptions) (watch.Interface, error)</span><br><span class="line">	Get(ctx context.Context, key <span class="keyword">string</span>, opts GetOptions, objPtr runtime.Object) error</span><br><span class="line">	GetToList(ctx context.Context, key <span class="keyword">string</span>, opts ListOptions, listObj runtime.Object) error</span><br><span class="line">	List(ctx context.Context, key <span class="keyword">string</span>, opts ListOptions, listObj runtime.Object) error</span><br><span class="line">	GuaranteedUpdate(</span><br><span class="line">		ctx context.Context, key <span class="keyword">string</span>, ptrToType runtime.Object, ignoreNotFound <span class="keyword">bool</span>,</span><br><span class="line">		precondtions *Preconditions, tryUpdate UpdateFunc, suggestion ...runtime.Object) error</span><br><span class="line">	Count(key <span class="keyword">string</span>) (<span class="keyword">int64</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRawStorage</span><span class="params">(config *storagebackend.Config)</span> <span class="params">(storage.Interface, factory.DestroyFunc, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> factory.Create(*config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(c storagebackend.Config)</span> <span class="params">(storage.Interface, DestroyFunc, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> c.Type &#123;</span><br><span class="line">  <span class="comment">// 已经不支持etcd2</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;etcd2&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;%v is no longer a supported storage backend&quot;</span>, c.Type)</span><br><span class="line">  <span class="comment">// 默认为etcd3版本</span></span><br><span class="line">	<span class="keyword">case</span> storagebackend.StorageTypeUnset, storagebackend.StorageTypeETCD3:</span><br><span class="line">		<span class="keyword">return</span> newETCD3Storage(c)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unknown storage type: %s&quot;</span>, c.Type)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>我们对第一阶段学习kube-apiserver的知识点进行总结：</p>
<ol>
<li><code>kube-apiserver</code> 包含三个apiserver<code>APIExtensionsServer</code>、<code>KubeAPIServer</code>和<code>AggregatorServer</code><ol>
<li>三个APIServer底层均依赖通用的<code>GenericServer</code>，使用<code>go-restful</code>对外提供RESTful风格的API服务</li>
</ol>
</li>
<li><code>kube-apiserver</code> 对请求进行 <code>Authentication</code>、<code>Authorization</code>和<code>Admission</code>三层验证</li>
<li>完成验证后，请求会根据路由规则，触发到对应资源的handler，主要包括数据的<code>预处理</code>和<code>保存</code></li>
<li><code>kube-apiserver</code> 的底层存储为etcd v3，它被抽象为一种RESTStorage，使请求和存储操作一一对应</li>
</ol>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>【K8s源码品读】008：Phase 1 - kube-scheduler - 初探调度的启动流程与算法</title>
    <url>/2021/02/18/k8s/k8s-008/</url>
    <content><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解kube-scheduler启动的流程</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#run">kube-scheduler的启动</a></li>
<li><a href="#Scheduler">Scheduler的注册</a></li>
<li><a href="#NodeName">了解一个最简单的算法NodeName</a></li>
</ol>
<h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kube-scheduler 类似于kube-apiserver，是个常驻进程，查看其对应的Run函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runCommand</span><span class="params">(cmd *cobra.Command, opts *options.Options, registryOptions ...Option)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 根据入参，返回配置cc与调度sched</span></span><br><span class="line">   cc, sched, err := Setup(ctx, opts, registryOptions...)</span><br><span class="line">	<span class="comment">// 运行</span></span><br><span class="line">   <span class="keyword">return</span> Run(ctx, cc, sched)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行调度策略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(ctx context.Context, cc *schedulerserverconfig.CompletedConfig, sched *scheduler.Scheduler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 将配置注册到configz中，会保存在一个全局map里</span></span><br><span class="line">	<span class="keyword">if</span> cz, err := configz.New(<span class="string">&quot;componentconfig&quot;</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		cz.Set(cc.ComponentConfig)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to register configz: %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 事件广播管理器，涉及到k8s里的一个核心资源 - Event事件，暂时不细讲</span></span><br><span class="line">	cc.EventBroadcaster.StartRecordingToSink(ctx.Done())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 健康监测的服务</span></span><br><span class="line">	<span class="keyword">var</span> checks []healthz.HealthChecker</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 异步各个Informer。Informer是kube-scheduler的一个重点</span></span><br><span class="line">	<span class="keyword">go</span> cc.PodInformer.Informer().Run(ctx.Done())</span><br><span class="line">	cc.InformerFactory.Start(ctx.Done())</span><br><span class="line">	cc.InformerFactory.WaitForCacheSync(ctx.Done())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选举Leader的工作，因为Master节点可以存在多个，选举一个作为Leader</span></span><br><span class="line">	<span class="keyword">if</span> cc.LeaderElection != <span class="literal">nil</span> &#123;</span><br><span class="line">		cc.LeaderElection.Callbacks = leaderelection.LeaderCallbacks&#123;</span><br><span class="line">      <span class="comment">// 两个钩子函数，开启Leading时运行调度，结束时打印报错</span></span><br><span class="line">			OnStartedLeading: sched.Run,</span><br><span class="line">			OnStoppedLeading: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				klog.Fatalf(<span class="string">&quot;leaderelection lost&quot;</span>)</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		leaderElector, err := leaderelection.NewLeaderElector(*cc.LeaderElection)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;couldn&#x27;t create leader elector: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 参与选举的会持续通信</span></span><br><span class="line">		leaderElector.Run(ctx)</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;lost lease&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不参与选举的，也就是单节点的情况时，在这里运行</span></span><br><span class="line">	sched.Run(ctx)</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;finished without leader elect&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">到这里，我们已经接触了kube-scheduler的2个核心概念：</span></span><br><span class="line"><span class="comment">1. scheduler：正如程序名kube-scheduler，这个进程的核心作用是进行调度，会涉及到多种调度策略</span></span><br><span class="line"><span class="comment">2. Informer：k8s中有各种类型的资源，包括自定义的。而Informer的实现就将调度和资源结合了起来</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在创建scheduler的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建scheduler，包括多个选项</span></span><br><span class="line">	sched, err := scheduler.New(cc.Client,</span><br><span class="line">		cc.InformerFactory,</span><br><span class="line">		cc.PodInformer,</span><br><span class="line">		recorderFactory,</span><br><span class="line">		ctx.Done(),</span><br><span class="line">		scheduler.WithProfiles(cc.ComponentConfig.Profiles...),</span><br><span class="line">		scheduler.WithAlgorithmSource(cc.ComponentConfig.AlgorithmSource),</span><br><span class="line">		scheduler.WithPercentageOfNodesToScore(cc.ComponentConfig.PercentageOfNodesToScore),</span><br><span class="line">		scheduler.WithFrameworkOutOfTreeRegistry(outOfTreeRegistry),</span><br><span class="line">		scheduler.WithPodMaxBackoffSeconds(cc.ComponentConfig.PodMaxBackoffSeconds),</span><br><span class="line">		scheduler.WithPodInitialBackoffSeconds(cc.ComponentConfig.PodInitialBackoffSeconds),</span><br><span class="line">		scheduler.WithExtenders(cc.ComponentConfig.Extenders...),</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">return</span> &amp;cc, sched, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们再看一下New这个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="params">(*Scheduler, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 先注册了所有的算法，保存到一个 map[string]PluginFactory 中</span></span><br><span class="line">  registry := frameworkplugins.NewInTreeRegistry()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 重点看一下Scheduler的创建过程</span></span><br><span class="line">  <span class="keyword">var</span> sched *Scheduler</span><br><span class="line">	source := options.schedulerAlgorithmSource</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">   <span class="comment">// 根据Provider创建，重点看这里</span></span><br><span class="line">	<span class="keyword">case</span> source.Provider != <span class="literal">nil</span>:</span><br><span class="line">		sc, err := configurator.createFromProvider(*source.Provider)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;couldn&#x27;t create scheduler using provider %q: %v&quot;</span>, *source.Provider, err)</span><br><span class="line">		&#125;</span><br><span class="line">		sched = sc</span><br><span class="line">  <span class="comment">// 根据用户设置创建，来自文件或者ConfigMap</span></span><br><span class="line">	<span class="keyword">case</span> source.Policy != <span class="literal">nil</span>:</span><br><span class="line">		policy := &amp;schedulerapi.Policy&#123;&#125;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> source.Policy.File != <span class="literal">nil</span>:</span><br><span class="line">			<span class="keyword">if</span> err := initPolicyFromFile(source.Policy.File.Path, policy); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> source.Policy.ConfigMap != <span class="literal">nil</span>:</span><br><span class="line">			<span class="keyword">if</span> err := initPolicyFromConfigMap(client, source.Policy.ConfigMap, policy); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		configurator.extenders = policy.Extenders</span><br><span class="line">		sc, err := configurator.createFromConfig(*policy)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;couldn&#x27;t create scheduler from policy: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		sched = sc</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unsupported algorithm source: %v&quot;</span>, source)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">createFromProvider</span><span class="params">(providerName <span class="keyword">string</span>)</span> <span class="params">(*Scheduler, error)</span></span> &#123;</span><br><span class="line">	klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;Creating scheduler from algorithm provider &#x27;%v&#x27;&quot;</span>, providerName)</span><br><span class="line">  <span class="comment">// 实例化算法的Registry</span></span><br><span class="line">	r := algorithmprovider.NewRegistry()</span><br><span class="line">	defaultPlugins, exist := r[providerName]</span><br><span class="line">	<span class="keyword">if</span> !exist &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;algorithm provider %q is not registered&quot;</span>, providerName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将各种算法作为plugin进行设置</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> c.profiles &#123;</span><br><span class="line">		prof := &amp;c.profiles[i]</span><br><span class="line">		plugins := &amp;schedulerapi.Plugins&#123;&#125;</span><br><span class="line">		plugins.Append(defaultPlugins)</span><br><span class="line">		plugins.Apply(prof.Plugins)</span><br><span class="line">		prof.Plugins = plugins</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.create()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从这个初始化中可以看到，主要分为2类：默认与ClusterAutoscaler两种算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRegistry</span><span class="params">()</span> <span class="title">Registry</span></span> &#123;</span><br><span class="line">  <span class="comment">// 默认算法包括过滤、打分、绑定等，有兴趣的去源码中逐个阅读</span></span><br><span class="line">	defaultConfig := getDefaultConfig()</span><br><span class="line">	applyFeatureGates(defaultConfig)</span><br><span class="line">	<span class="comment">// ClusterAutoscaler 是集群自动扩展的算法，被单独拎出来，</span></span><br><span class="line">	caConfig := getClusterAutoscalerConfig()</span><br><span class="line">	applyFeatureGates(caConfig)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Registry&#123;</span><br><span class="line">		schedulerapi.SchedulerDefaultProviderName: defaultConfig,</span><br><span class="line">		ClusterAutoscalerProvider:                 caConfig,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在这里，熟悉k8s的朋友会有个疑问：以前听说kubernets的调度有个Predicate和Priority两个算法，这里怎么没有分类？</span></span><br><span class="line"><span class="comment">这个疑问，我们在后面具体场景时再进行分析。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="NodeName"><a href="#NodeName" class="headerlink" title="NodeName"></a>NodeName</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了加深大家对Plugin的印象，我选择一个最简单的示例：根据Pod的spec字段中的NodeName，分配到指定名称的节点</span></span><br><span class="line"><span class="keyword">package</span> nodename</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line"></span><br><span class="line">	v1 <span class="string">&quot;k8s.io/api/core/v1&quot;</span></span><br><span class="line">	<span class="string">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span></span><br><span class="line">	framework <span class="string">&quot;k8s.io/kubernetes/pkg/scheduler/framework/v1alpha1&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NodeName <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ framework.FilterPlugin = &amp;NodeName&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个调度算法的名称和错误信息</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Name = <span class="string">&quot;NodeName&quot;</span></span><br><span class="line">	ErrReason = <span class="string">&quot;node(s) didn&#x27;t match the requested hostname&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度算法的明明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeName)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤功能，这个就是NodeName算法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeName)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">  <span class="comment">// 找不到Node</span></span><br><span class="line">	<span class="keyword">if</span> nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> framework.NewStatus(framework.Error, <span class="string">&quot;node not found&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 匹配不到，返回错误</span></span><br><span class="line">	<span class="keyword">if</span> !Fits(pod, nodeInfo) &#123;</span><br><span class="line">		<span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReason)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  匹配的算法，两种条件满足一个就认为成功</span></span><br><span class="line"><span class="comment">  1. spec没有填NodeName </span></span><br><span class="line"><span class="comment">  2.spec的NodeName和节点匹配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fits</span><span class="params">(pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(pod.Spec.NodeName) == <span class="number">0</span> || pod.Spec.NodeName == nodeInfo.Node().Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(_ runtime.Object, _ framework.FrameworkHandle)</span> <span class="params">(framework.Plugin, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;NodeName&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>【K8s源码品读】009：Phase 1 - kube-scheduler - Informer监听资源变化</title>
    <url>/2021/02/18/k8s/k8s-009/</url>
    <content><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>了解<code>Informer</code>是如何从kube-apiserver监听资源变化的情况</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#informer">什么是Informer</a></li>
<li><a href="#Shared-Informer">Shared Informer的实现</a></li>
<li><a href="#PodInformer">PodInformer的背后的实现</a></li>
<li><a href="#Reflect">聚焦Reflect结构</a></li>
<li><a href="#Summary">本节小节</a></li>
</ol>
<h2 id="Informer"><a href="#Informer" class="headerlink" title="Informer"></a>Informer</h2><p>什么是<code>Informer</code>？这一节，我将先抛开代码，重点讲一下这个Informer，因为它是理解k8s运行机制的核心概念。</p>
<p>我没有在官方文档中找到<code>Informer</code>的明确定义，中文直译为<code>通知器</code>。从<a href="https://medium.com/@muhammet.arslan/write-your-own-kubernetes-controller-with-informers-9920e8ab6f84">这个链接</a>中，我们可以看到一个自定义资源的的处理流程。</p>
<p>我简单概况下，<code>Informer</code>的核心功能是 <strong>获取并监听(ListAndWatch)对应资源的增删改，触发相应的事件操作(ResourceEventHandler)</strong></p>
<h2 id="Shared-Informer"><a href="#Shared-Informer" class="headerlink" title="Shared Informer"></a>Shared Informer</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">client 是连接到 kube-apiserver 的客户端。</span></span><br><span class="line"><span class="comment">我们要理解k8s的设计：</span></span><br><span class="line"><span class="comment">1. etcd是核心的数据存储，对资源的修改会进行持久化</span></span><br><span class="line"><span class="comment">2. 只有kube-apiserver可以访问etcd</span></span><br><span class="line"><span class="comment">所以，kube-scheduler要了解资源的变化情况，只能通过kube-apiserver</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了 Shared Informer，其中这个client是用来连接kube-apiserver的</span></span><br><span class="line">c.InformerFactory = informers.NewSharedInformerFactory(client, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里解答了为什么叫shared：一个资源会对应多个Informer，会导致效率低下，所以让一个资源对应一个sharedInformer，而一个sharedInformer内部自己维护多个Informer</span></span><br><span class="line"><span class="keyword">type</span> sharedInformerFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">	client           kubernetes.Interface</span><br><span class="line">	namespace        <span class="keyword">string</span></span><br><span class="line">	tweakListOptions internalinterfaces.TweakListOptionsFunc</span><br><span class="line">	lock             sync.Mutex</span><br><span class="line">	defaultResync    time.Duration</span><br><span class="line">	customResync     <span class="keyword">map</span>[reflect.Type]time.Duration</span><br><span class="line">  <span class="comment">// 这个map就是维护多个Informer的关键实现</span></span><br><span class="line">	informers <span class="keyword">map</span>[reflect.Type]cache.SharedIndexInformer</span><br><span class="line">	startedInformers <span class="keyword">map</span>[reflect.Type]<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">Start</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">	<span class="keyword">for</span> informerType, informer := <span class="keyword">range</span> f.informers &#123;</span><br><span class="line">		<span class="keyword">if</span> !f.startedInformers[informerType] &#123;</span><br><span class="line">      <span class="comment">// goroutine异步处理</span></span><br><span class="line">			<span class="keyword">go</span> informer.Run(stopCh)</span><br><span class="line">      <span class="comment">// 标记为已经运行，这样即使下次Start也不会重复运行</span></span><br><span class="line">			f.startedInformers[informerType] = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找对应的informer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">InformerFor</span><span class="params">(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc)</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">	<span class="comment">// 找到就直接返回</span></span><br><span class="line">	informerType := reflect.TypeOf(obj)</span><br><span class="line">	informer, exists := f.informers[informerType]</span><br><span class="line">	<span class="keyword">if</span> exists &#123;</span><br><span class="line">		<span class="keyword">return</span> informer</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resyncPeriod, exists := f.customResync[informerType]</span><br><span class="line">	<span class="keyword">if</span> !exists &#123;</span><br><span class="line">		resyncPeriod = f.defaultResync</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 没找到就会新建</span></span><br><span class="line">	informer = newFunc(f.client, resyncPeriod)</span><br><span class="line">	f.informers[informerType] = informer</span><br><span class="line">	<span class="keyword">return</span> informer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SharedInformerFactory 是 sharedInformerFactory 的接口定义</span></span><br><span class="line"><span class="keyword">type</span> SharedInformerFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 我们这一阶段关注的Pod的Informer，属于核心资源</span></span><br><span class="line">	Core() core.Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// core.Interface的定义</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// V1 provides access to shared informers for resources in V1.</span></span><br><span class="line">	V1() v1.Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v1.Interface 的定义</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// Pod的定义</span></span><br><span class="line">	Pods() PodInformer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PodInformer 是对应的接口</span></span><br><span class="line"><span class="keyword">type</span> PodInformer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Informer() cache.SharedIndexInformer</span><br><span class="line">	Lister() v1.PodLister</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// podInformer 是具体的实现</span></span><br><span class="line"><span class="keyword">type</span> podInformer <span class="keyword">struct</span> &#123;</span><br><span class="line">	factory          internalinterfaces.SharedInformerFactory</span><br><span class="line">	tweakListOptions internalinterfaces.TweakListOptionsFunc</span><br><span class="line">	namespace        <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后，我们可以看到podInformer调用了InformerFor函数进行了添加</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *podInformer)</span> <span class="title">Informer</span><span class="params">()</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> f.factory.InformerFor(&amp;corev1.Pod&#123;&#125;, f.defaultInformer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="PodInformer"><a href="#PodInformer" class="headerlink" title="PodInformer"></a>PodInformer</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化PodInformer，把对应的List/Watch操作方法传入到实例化函数，生成统一的SharedIndexInformer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFilteredPodInformer</span><span class="params">()</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> cache.NewSharedIndexInformer(</span><br><span class="line">    <span class="comment">// List和Watch实现从PodInterface里面查询</span></span><br><span class="line">		&amp;cache.ListWatch&#123;</span><br><span class="line">			ListFunc: <span class="function"><span class="keyword">func</span><span class="params">(options metav1.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">				<span class="keyword">if</span> tweakListOptions != <span class="literal">nil</span> &#123;</span><br><span class="line">					tweakListOptions(&amp;options)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> client.CoreV1().Pods(namespace).List(context.TODO(), options)</span><br><span class="line">			&#125;,</span><br><span class="line">			WatchFunc: <span class="function"><span class="keyword">func</span><span class="params">(options metav1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line">				<span class="keyword">if</span> tweakListOptions != <span class="literal">nil</span> &#123;</span><br><span class="line">					tweakListOptions(&amp;options)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> client.CoreV1().Pods(namespace).Watch(context.TODO(), options)</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&amp;corev1.Pod&#123;&#125;,</span><br><span class="line">		resyncPeriod,</span><br><span class="line">		indexers,</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们先看看Pod基本的List和Watch是怎么定义的</span></span><br><span class="line"><span class="comment">// Pod基本的增删改查等操作</span></span><br><span class="line"><span class="keyword">type</span> PodInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	List(ctx context.Context, opts metav1.ListOptions) (*v1.PodList, error)</span><br><span class="line">	Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pods 是PodInterface的实现</span></span><br><span class="line"><span class="keyword">type</span> pods <span class="keyword">struct</span> &#123;</span><br><span class="line">	client rest.Interface</span><br><span class="line">	ns     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List 和 Watch 是依赖客户端，也就是从kube-apiserver中查询的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pods)</span> <span class="title">List</span><span class="params">(ctx context.Context, opts metav1.ListOptions)</span> <span class="params">(result *v1.PodList, err error)</span></span> &#123;</span><br><span class="line">	err = c.client.Get().</span><br><span class="line">		Namespace(c.ns).</span><br><span class="line">		Resource(<span class="string">&quot;pods&quot;</span>).</span><br><span class="line">		VersionedParams(&amp;opts, scheme.ParameterCodec).</span><br><span class="line">		Timeout(timeout).</span><br><span class="line">		Do(ctx).</span><br><span class="line">		Into(result)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pods)</span> <span class="title">Watch</span><span class="params">(ctx context.Context, opts metav1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.client.Get().</span><br><span class="line">		Namespace(c.ns).</span><br><span class="line">		Resource(<span class="string">&quot;pods&quot;</span>).</span><br><span class="line">		VersionedParams(&amp;opts, scheme.ParameterCodec).</span><br><span class="line">		Timeout(timeout).</span><br><span class="line">		Watch(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在上面，我们看到了异步运行Informer的代码 go informer.Run(stopCh)，我们看看是怎么run的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 这里有个 DeltaFIFO 的对象，</span></span><br><span class="line">  fifo := NewDeltaFIFOWithOptions(DeltaFIFOOptions&#123;</span><br><span class="line">		KnownObjects:          s.indexer,</span><br><span class="line">		EmitDeltaTypeReplaced: <span class="literal">true</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 传入这个fifo到cfg</span></span><br><span class="line">	cfg := &amp;Config&#123;</span><br><span class="line">		Queue:            fifo,</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 新建controller</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s.startedLock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line"></span><br><span class="line">		s.controller = New(cfg)</span><br><span class="line">		s.controller.(*controller).clock = s.clock</span><br><span class="line">		s.started = <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 运行controller</span></span><br><span class="line">	s.controller.Run(stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Controller的运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	r := NewReflector(</span><br><span class="line">		c.config.ListerWatcher,</span><br><span class="line">		c.config.ObjectType,</span><br><span class="line">		c.config.Queue,</span><br><span class="line">		c.config.FullResyncPeriod,</span><br><span class="line">	)</span><br><span class="line">	r.ShouldResync = c.config.ShouldResync</span><br><span class="line">	r.clock = c.clock</span><br><span class="line">	<span class="keyword">if</span> c.config.WatchErrorHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">		r.watchErrorHandler = c.config.WatchErrorHandler</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.reflectorMutex.Lock()</span><br><span class="line">	c.reflector = r</span><br><span class="line">	c.reflectorMutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg wait.Group</span><br><span class="line">  <span class="comment">// 生产，往Queue里放数据</span></span><br><span class="line">	wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line">  <span class="comment">// 消费，从Queue消费数据</span></span><br><span class="line">	wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们再回头看看这个Reflect结构</span></span><br><span class="line">r := NewReflector(</span><br><span class="line">  	<span class="comment">// ListerWatcher 我们已经有了解，就是通过client监听kube-apiserver暴露出来的Resource</span></span><br><span class="line">		c.config.ListerWatcher,</span><br><span class="line">		c.config.ObjectType,</span><br><span class="line">  	<span class="comment">// Queue 是我们前文看到的一个 DeltaFIFOQueue，认为这是一个先进先出的队列</span></span><br><span class="line">		c.config.Queue,</span><br><span class="line">		c.config.FullResyncPeriod,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;Starting reflector %s (%s) from %s&quot;</span>, r.expectedTypeName, r.resyncPeriod, r.name)</span><br><span class="line">	wait.BackoffUntil(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调用了ListAndWatch</span></span><br><span class="line">		<span class="keyword">if</span> err := r.ListAndWatch(stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			r.watchErrorHandler(r, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, r.backoffManager, <span class="literal">true</span>, stopCh)</span><br><span class="line">	klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;Stopping reflector %s (%s) from %s&quot;</span>, r.expectedTypeName, r.resyncPeriod, r.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">ListAndWatch</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="comment">// watchHandler顾名思义，就是Watch到对应的事件，调用对应的Handler</span></span><br><span class="line">		<span class="keyword">if</span> err := r.watchHandler(start, w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err != errorStopRequested &#123;</span><br><span class="line">				<span class="keyword">switch</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> isExpiredError(err):</span><br><span class="line">					klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;%s: watch of %v closed with: %v&quot;</span>, r.name, r.expectedTypeName, err)</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					klog.Warningf(<span class="string">&quot;%s: watch of %v ended with: %v&quot;</span>, r.name, r.expectedTypeName, err)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">watchHandler</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">loop:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 一个经典的GO语言select监听多channel的模式</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// 整体的step channel</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">			<span class="keyword">return</span> errorStopRequested</span><br><span class="line">    <span class="comment">// 错误相关的error channel</span></span><br><span class="line">		<span class="keyword">case</span> err := &lt;-errc:</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">    <span class="comment">// 接收事件event的channel</span></span><br><span class="line">		<span class="keyword">case</span> event, ok := &lt;-w.ResultChan():</span><br><span class="line">      <span class="comment">// channel被关闭，退出loop</span></span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">break</span> loop</span><br><span class="line">			&#125;</span><br><span class="line">      </span><br><span class="line">			<span class="comment">// 一系列的资源验证代码跳过</span></span><br><span class="line">      </span><br><span class="line">			<span class="keyword">switch</span> event.Type &#123;</span><br><span class="line">      <span class="comment">// 增删改三种Event，分别对应到去store，即DeltaFIFO中，操作object</span></span><br><span class="line">			<span class="keyword">case</span> watch.Added:</span><br><span class="line">				err := r.store.Add(event.Object)</span><br><span class="line">			<span class="keyword">case</span> watch.Modified:</span><br><span class="line">				err := r.store.Update(event.Object)</span><br><span class="line">			<span class="keyword">case</span> watch.Deleted:</span><br><span class="line">				err := r.store.Delete(event.Object)</span><br><span class="line">			<span class="keyword">case</span> watch.Bookmark:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;%s: unable to understand watch event %#v&quot;</span>, r.name, event))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ol>
<li><code>Informer</code> 依赖于 <code>Reflector</code> 模块，它有个组件为 xxxInformer，如 <code>podInformer</code> </li>
<li>具体资源的 <code>Informer</code> 包含了一个连接到<code>kube-apiserver</code>的<code>client</code>，通过<code>List</code>和<code>Watch</code>接口查询资源变更情况</li>
<li>检测到资源发生变化后，通过<code>Controller</code> 将数据放入队列<code>DeltaFIFOQueue</code>里，生产阶段完成</li>
</ol>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>【K8s源码品读】010：Phase 1 - kube-scheduler - Informer是如何保存数据的</title>
    <url>/2021/02/18/k8s/k8s-010/</url>
    <content><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>了解Informer在发现资源变化后，是怎么处理的</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol start="5">
<li><a href="#Process">查看消费的过程</a></li>
<li><a href="#Index">掌握Index数据结构</a></li>
<li><a href="#distribute">信息的分发distribute</a></li>
<li><a href="#Summary">Informer的综合思考</a></li>
</ol>
<h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">processLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// Pop出Object元素</span></span><br><span class="line">		obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == ErrFIFOClosed &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.config.RetryOnError &#123;</span><br><span class="line">				<span class="comment">// 重新进队列</span></span><br><span class="line">				c.config.Queue.AddIfNotPresent(obj)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去查看Pop的具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FIFO)</span> <span class="title">Pop</span><span class="params">(process PopProcessFunc)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 调用process去处理item，然后返回</span></span><br><span class="line">		item, ok := f.items[id]</span><br><span class="line">		<span class="built_in">delete</span>(f.items, id)</span><br><span class="line">		err := process(item)</span><br><span class="line">		<span class="keyword">return</span> item, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后去查一下 PopProcessFunc 的定义，在创建controller前</span></span><br><span class="line">cfg := &amp;Config&#123;</span><br><span class="line">		Process:           s.HandleDeltas,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">HandleDeltas</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	s.blockDeltas.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.blockDeltas.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, d := <span class="keyword">range</span> obj.(Deltas) &#123;</span><br><span class="line">		<span class="keyword">switch</span> d.Type &#123;</span><br><span class="line">    <span class="comment">// 增、改、替换、同步</span></span><br><span class="line">		<span class="keyword">case</span> Sync, Replaced, Added, Updated:</span><br><span class="line">			s.cacheMutationDetector.AddObject(d.Object)</span><br><span class="line">      <span class="comment">// 先去indexer查询</span></span><br><span class="line">			<span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">        <span class="comment">// 如果数据已经存在，就执行Update逻辑</span></span><br><span class="line">				<span class="keyword">if</span> err := s.indexer.Update(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				isSync := <span class="literal">false</span></span><br><span class="line">				<span class="keyword">switch</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> d.Type == Sync:</span><br><span class="line">					isSync = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">case</span> d.Type == Replaced:</span><br><span class="line">					<span class="keyword">if</span> accessor, err := meta.Accessor(d.Object); err == <span class="literal">nil</span> &#123;</span><br><span class="line">							isSync = accessor.GetResourceVersion() == oldAccessor.GetResourceVersion()</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">      	<span class="comment">// 分发Update事件</span></span><br><span class="line">				s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 没查到数据，就执行Add操作</span></span><br><span class="line">				<span class="keyword">if</span> err := s.indexer.Add(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">      	<span class="comment">// 分发 Add 事件</span></span><br><span class="line">				s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">			&#125;</span><br><span class="line">   	<span class="comment">// 删除</span></span><br><span class="line">		<span class="keyword">case</span> Deleted:</span><br><span class="line">    	<span class="comment">// 去indexer删除</span></span><br><span class="line">			<span class="keyword">if</span> err := s.indexer.Delete(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">    	<span class="comment">// 分发 delete 事件</span></span><br><span class="line">			s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p><code>Index</code> 的定义为资源的本地存储，保持与etcd中的资源信息一致。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们去看看Index是怎么创建的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSharedIndexInformer</span><span class="params">(lw ListerWatcher, exampleObject runtime.Object, defaultEventHandlerResyncPeriod time.Duration, indexers Indexers)</span> <span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	realClock := &amp;clock.RealClock&#123;&#125;</span><br><span class="line">	sharedIndexInformer := &amp;sharedIndexInformer&#123;</span><br><span class="line">		processor:                       &amp;sharedProcessor&#123;clock: realClock&#125;,</span><br><span class="line">    <span class="comment">// indexer 的初始化</span></span><br><span class="line">		indexer:                         NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers),</span><br><span class="line">		listerWatcher:                   lw,</span><br><span class="line">		objectType:                      exampleObject,</span><br><span class="line">		resyncCheckPeriod:               defaultEventHandlerResyncPeriod,</span><br><span class="line">		defaultEventHandlerResyncPeriod: defaultEventHandlerResyncPeriod,</span><br><span class="line">		cacheMutationDetector:           NewCacheMutationDetector(fmt.Sprintf(<span class="string">&quot;%T&quot;</span>, exampleObject)),</span><br><span class="line">		clock:                           realClock,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sharedIndexInformer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个map和func组合而成的Indexer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIndexer</span><span class="params">(keyFunc KeyFunc, indexers Indexers)</span> <span class="title">Indexer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;cache&#123;</span><br><span class="line">		cacheStorage: NewThreadSafeStore(indexers, Indices&#123;&#125;),</span><br><span class="line">		keyFunc:      keyFunc,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadSafeStore的底层是一个并发安全的map，具体实现我们暂不考虑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewThreadSafeStore</span><span class="params">(indexers Indexers, indices Indices)</span> <span class="title">ThreadSafeStore</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;threadSafeMap&#123;</span><br><span class="line">		items:    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		indexers: indexers,</span><br><span class="line">		indices:  indices,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="distribute"><a href="#distribute" class="headerlink" title="distribute"></a>distribute</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在上面的Process代码中，我们看到了将数据存储到Indexer后，调用了一个分发的函数</span></span><br><span class="line">s.processor.distribute()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分发process的创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSharedIndexInformer</span><span class="params">()</span> <span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	sharedIndexInformer := &amp;sharedIndexInformer&#123;</span><br><span class="line">		processor:                       &amp;sharedProcessor&#123;clock: realClock&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sharedIndexInformer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sharedProcessor的结构</span></span><br><span class="line"><span class="keyword">type</span> sharedProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">	listenersStarted <span class="keyword">bool</span></span><br><span class="line"> 	<span class="comment">// 读写锁</span></span><br><span class="line">	listenersLock    sync.RWMutex</span><br><span class="line">  <span class="comment">// 普通监听列表</span></span><br><span class="line">	listeners        []*processorListener</span><br><span class="line">  <span class="comment">// 同步监听列表</span></span><br><span class="line">	syncingListeners []*processorListener</span><br><span class="line">	clock            clock.Clock</span><br><span class="line">	wg               wait.Group</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看distribute函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">distribute</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;, sync <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	p.listenersLock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">	<span class="comment">// 将object分发到 同步监听 或者 普通监听 的列表</span></span><br><span class="line">	<span class="keyword">if</span> sync &#123;</span><br><span class="line">		<span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.syncingListeners &#123;</span><br><span class="line">			listener.add(obj)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">			listener.add(obj)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个add的操作是利用了channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">add</span><span class="params">(notification <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	p.addCh &lt;- notification</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ol>
<li><code>Informer</code> 依赖于 <code>Reflector</code> 模块，它有个组件为 xxxInformer，如 <code>podInformer</code> </li>
<li>具体资源的 <code>Informer</code> 包含了一个连接到<code>kube-apiserver</code>的<code>client</code>，通过<code>List</code>和<code>Watch</code>接口查询资源变更情况</li>
<li>检测到资源发生变化后，通过<code>Controller</code> 将数据放入队列<code>DeltaFIFOQueue</code>里，生产阶段完成</li>
<li>在<code>DeltaFIFOQueue</code>的另一端，有消费者在不停地处理资源变化的事件，处理逻辑主要分2步<ol>
<li>将数据保存到本地存储Indexer，它的底层实现是一个并发安全的threadSafeMap</li>
<li>有些组件需要实时关注资源变化，会实时监听listen，就将事件分发到对应注册上来的listener上，自行处理</li>
</ol>
</li>
</ol>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>【K8s源码品读】011：Phase 1 - kube-scheduler - 了解分配pod的大致流程</title>
    <url>/2021/02/18/k8s/k8s-011/</url>
    <content><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解一个pod的被调度的大致流程 </p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#Scheduler">分析Scheduler的结构体</a></li>
<li><a href="#SchedulingQueue">往SchedulingQueue里</a></li>
<li><a href="#scheduleOne">调度一个pod对象</a><ol>
<li><a href="#ScheduleResult">调度计算结果 - ScheduleResult</a></li>
<li><a href="#Assume">初步推算 - Assume</a></li>
<li><a href="#Bind">实际绑定 - Bind</a></li>
</ol>
</li>
<li><a href="#update-to-etcd">将绑定成功后的数据更新到etcd</a></li>
<li><a href="#Summary">pod绑定Node的总结</a></li>
</ol>
<h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p>在前面，我们了解了<code>Pod调度算法的注册</code>和<code>Informer机制来监听kube-apiserver上的资源变化</code>，今天这一讲，我们就将两者串联起来，看看在kube-scheduler中，Informer监听到资源变化后，如何用调度算法将pod进行调度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在运行 kube-scheduler 的初期，我们创建了一个Scheduler的数据结构，回头再看看有什么和pod调度算法相关的</span></span><br><span class="line"><span class="keyword">type</span> Scheduler <span class="keyword">struct</span> &#123;</span><br><span class="line">	SchedulerCache internalcache.Cache</span><br><span class="line">	Algorithm core.ScheduleAlgorithm</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取下一个需要调度的Pod</span></span><br><span class="line">	NextPod <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">framework</span>.<span class="title">QueuedPodInfo</span></span></span><br><span class="line"></span><br><span class="line">	Error <span class="function"><span class="keyword">func</span><span class="params">(*framework.QueuedPodInfo, error)</span></span></span><br><span class="line">	StopEverything &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待调度的Pod队列，我们重点看看这个队列是什么</span></span><br><span class="line">	SchedulingQueue internalqueue.SchedulingQueue</span><br><span class="line"></span><br><span class="line">	Profiles profile.Map</span><br><span class="line">	scheduledPodsHasSynced <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">	client clientset.Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scheduler的实例化函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sched *Scheduler</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">  <span class="comment">// 从 Provider 创建</span></span><br><span class="line">	<span class="keyword">case</span> source.Provider != <span class="literal">nil</span>:</span><br><span class="line">		sc, err := configurator.createFromProvider(*source.Provider)</span><br><span class="line">		sched = sc</span><br><span class="line">  <span class="comment">// 从文件或者ConfigMap中创建</span></span><br><span class="line">	<span class="keyword">case</span> source.Policy != <span class="literal">nil</span>:</span><br><span class="line">		sc, err := configurator.createFromConfig(*policy)</span><br><span class="line">		sched = sc</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unsupported algorithm source: %v&quot;</span>, source)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个创建方式，底层都是调用的 create 函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">createFromProvider</span><span class="params">(providerName <span class="keyword">string</span>)</span> <span class="params">(*Scheduler, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.create()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">createFromConfig</span><span class="params">(policy schedulerapi.Policy)</span> <span class="params">(*Scheduler, error)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> c.create()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">create</span><span class="params">()</span> <span class="params">(*Scheduler, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 实例化 podQueue</span></span><br><span class="line">	podQueue := internalqueue.NewSchedulingQueue(</span><br><span class="line">		lessFn,</span><br><span class="line">		internalqueue.WithPodInitialBackoffDuration(time.Duration(c.podInitialBackoffSeconds)*time.Second),</span><br><span class="line">		internalqueue.WithPodMaxBackoffDuration(time.Duration(c.podMaxBackoffSeconds)*time.Second),</span><br><span class="line">		internalqueue.WithPodNominator(nominator),</span><br><span class="line">	)</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span> &amp;Scheduler&#123;</span><br><span class="line">		SchedulerCache:  c.schedulerCache,</span><br><span class="line">		Algorithm:       algo,</span><br><span class="line">		Profiles:        profiles,</span><br><span class="line">    <span class="comment">// NextPod 函数依赖于 podQueue</span></span><br><span class="line">		NextPod:         internalqueue.MakeNextPodFunc(podQueue),</span><br><span class="line">		Error:           MakeDefaultErrorFunc(c.client, c.informerFactory.Core().V1().Pods().Lister(), podQueue, c.schedulerCache),</span><br><span class="line">		StopEverything:  c.StopEverything,</span><br><span class="line">    <span class="comment">// 调度队列被赋值为podQueue</span></span><br><span class="line">		SchedulingQueue: podQueue,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再看看这个调度队列的初始化函数，从命名可以看到是一个优先队列，它的实现细节暂不细看</span></span><br><span class="line"><span class="comment">// 结合实际情况思考下，pod会有重要程度的区分，所以调度的顺序需要考虑优先级的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSchedulingQueue</span><span class="params">(lessFn framework.LessFunc, opts ...Option)</span> <span class="title">SchedulingQueue</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewPriorityQueue(lessFn, opts...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SchedulingQueue"><a href="#SchedulingQueue" class="headerlink" title="SchedulingQueue"></a>SchedulingQueue</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在上面实例化Scheduler后，有个注册事件 Handler 的函数：addAllEventHandlers(sched, informerFactory, podInformer)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addAllEventHandlers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	sched *Scheduler,</span></span></span><br><span class="line"><span class="params"><span class="function">	informerFactory informers.SharedInformerFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">	podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	函数前后有很多注册的Handler，但是和未调度pod添加到队列相关的，只有这个</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	podInformer.Informer().AddEventHandler(</span><br><span class="line">		cache.FilteringResourceEventHandler&#123;</span><br><span class="line">      <span class="comment">// 定义过滤函数：必须为未调度的pod</span></span><br><span class="line">			FilterFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">				<span class="keyword">switch</span> t := obj.(<span class="keyword">type</span>) &#123;</span><br><span class="line">				<span class="keyword">case</span> *v1.Pod:</span><br><span class="line">					<span class="keyword">return</span> !assignedPod(t) &amp;&amp; responsibleForPod(t, sched.Profiles)</span><br><span class="line">				<span class="keyword">case</span> cache.DeletedFinalStateUnknown:</span><br><span class="line">					<span class="keyword">if</span> pod, ok := t.Obj.(*v1.Pod); ok &#123;</span><br><span class="line">						<span class="keyword">return</span> !assignedPod(pod) &amp;&amp; responsibleForPod(pod, sched.Profiles)</span><br><span class="line">					&#125;</span><br><span class="line">					utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;unable to convert object %T to *v1.Pod in %T&quot;</span>, obj, sched))</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;unable to handle object in %T: %T&quot;</span>, sched, obj))</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">     	<span class="comment">// 增改删三个操作对应的Handler，操作到对应的Queue</span></span><br><span class="line">			Handler: cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">				AddFunc:    sched.addPodToSchedulingQueue,</span><br><span class="line">				UpdateFunc: sched.updatePodInSchedulingQueue,</span><br><span class="line">				DeleteFunc: sched.deletePodFromSchedulingQueue,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 牢记我们第一阶段要分析的对象：create nginx pod，所以进入这个add的操作，对应加入到队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">addPodToSchedulingQueue</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	pod := obj.(*v1.Pod)</span><br><span class="line">	klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;add event for unscheduled pod %s/%s&quot;</span>, pod.Namespace, pod.Name)</span><br><span class="line">  <span class="comment">// 加入到队列</span></span><br><span class="line">	<span class="keyword">if</span> err := sched.SchedulingQueue.Add(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;unable to queue %T: %v&quot;</span>, obj, err))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队操作我们清楚了，那出队呢？我们回过头去看看上面定义的NextPod的方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeNextPodFunc</span><span class="params">(queue SchedulingQueue)</span> <span class="title">func</span><span class="params">()</span> *<span class="title">framework</span>.<span class="title">QueuedPodInfo</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">framework</span>.<span class="title">QueuedPodInfo</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从队列中弹出</span></span><br><span class="line">		podInfo, err := queue.Pop()</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;About to try and schedule pod %v/%v&quot;</span>, podInfo.Pod.Namespace, podInfo.Pod.Name)</span><br><span class="line">			<span class="keyword">return</span> podInfo</span><br><span class="line">		&#125;</span><br><span class="line">		klog.Errorf(<span class="string">&quot;Error while retrieving next pod from scheduling queue: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="scheduleOne"><a href="#scheduleOne" class="headerlink" title="scheduleOne"></a>scheduleOne</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 了解入队和出队操作后，我们看一下Scheduler运行的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">Run</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForCacheSync(ctx.Done(), sched.scheduledPodsHasSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	sched.SchedulingQueue.Run()</span><br><span class="line">  <span class="comment">// 调度一个pod对象</span></span><br><span class="line">	wait.UntilWithContext(ctx, sched.scheduleOne, <span class="number">0</span>)</span><br><span class="line">	sched.SchedulingQueue.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来scheduleOne方法代码很长，我们一步一步来看</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">scheduleOne</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">  <span class="comment">// podInfo 就是从队列中获取到的pod对象</span></span><br><span class="line">	podInfo := sched.NextPod()</span><br><span class="line">	<span class="comment">// 检查pod的有效性</span></span><br><span class="line">	<span class="keyword">if</span> podInfo == <span class="literal">nil</span> || podInfo.Pod == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	pod := podInfo.Pod</span><br><span class="line">  <span class="comment">// 根据定义的 pod.Spec.SchedulerName 查到对应的profile</span></span><br><span class="line">	prof, err := sched.profileForPod(pod)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Error(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 可以跳过调度的情况，一般pod进不来</span></span><br><span class="line">	<span class="keyword">if</span> sched.skipPodSchedule(prof, pod) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用调度算法，获取结果</span></span><br><span class="line">	scheduleResult, err := sched.Algorithm.Schedule(schedulingCycleCtx, prof, state, pod)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		出现调度失败的情况：</span></span><br><span class="line"><span class="comment">		这个时候可能会触发抢占preempt，抢占是一套复杂的逻辑，后面我们专门会讲</span></span><br><span class="line"><span class="comment">		目前假设各类资源充足，能正常调度</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	metrics.SchedulingAlgorithmLatency.Observe(metrics.SinceInSeconds(start))</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// assumePod 是假设这个Pod按照前面的调度算法分配后，进行验证</span></span><br><span class="line">	assumedPodInfo := podInfo.DeepCopy()</span><br><span class="line">	assumedPod := assumedPodInfo.Pod</span><br><span class="line">	<span class="comment">// SuggestedHost 为建议的分配的Host</span></span><br><span class="line">	err = sched.assume(assumedPod, scheduleResult.SuggestedHost)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 失败就重新分配，不考虑这种情况</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 运行相关插件的代码先跳过</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 异步绑定pod</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 有一系列的检查工作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 真正做绑定的动作</span></span><br><span class="line">		err := sched.bind(bindingCycleCtx, prof, assumedPod, scheduleResult.SuggestedHost, state)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 错误处理，清除状态并重试</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 打印结果，调试时将log level调整到2以上</span></span><br><span class="line">			<span class="keyword">if</span> klog.V(<span class="number">2</span>).Enabled() &#123;</span><br><span class="line">				klog.InfoS(<span class="string">&quot;Successfully bound pod to node&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;node&quot;</span>, scheduleResult.SuggestedHost, <span class="string">&quot;evaluatedNodes&quot;</span>, scheduleResult.EvaluatedNodes, <span class="string">&quot;feasibleNodes&quot;</span>, scheduleResult.FeasibleNodes)</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// metrics中记录相关的监控指标</span></span><br><span class="line">			metrics.PodScheduled(prof.Name, metrics.SinceInSeconds(start))</span><br><span class="line">			metrics.PodSchedulingAttempts.Observe(<span class="keyword">float64</span>(podInfo.Attempts))</span><br><span class="line">      metrics.PodSchedulingDuration.WithLabelValues(getAttemptsLabel(podInfo)).Observe(metrics.SinceInSeconds(podInfo.InitialAttemptTimestamp))</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 运行绑定后的插件</span></span><br><span class="line">			prof.RunPostBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ScheduleResult"><a href="#ScheduleResult" class="headerlink" title="ScheduleResult"></a>ScheduleResult</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用算法下的Schedule</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span>&#123;</span><br><span class="line">  scheduleResult, err := sched.Algorithm.Schedule(schedulingCycleCtx, prof, state, pod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">create</span><span class="params">()</span> <span class="params">(*Scheduler, error)</span></span> &#123;</span><br><span class="line">  algo := core.NewGenericScheduler(</span><br><span class="line">		c.schedulerCache,</span><br><span class="line">		c.nodeInfoSnapshot,</span><br><span class="line">		extenders,</span><br><span class="line">		c.informerFactory.Core().V1().PersistentVolumeClaims().Lister(),</span><br><span class="line">		c.disablePreemption,</span><br><span class="line">		c.percentageOfNodesToScore,</span><br><span class="line">	)</span><br><span class="line">  <span class="keyword">return</span> &amp;Scheduler&#123;</span><br><span class="line">		Algorithm:       algo,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// genericScheduler 的 Schedule 的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">Schedule</span><span class="params">(ctx context.Context, prof *profile.Profile, state *framework.CycleState, pod *v1.Pod)</span> <span class="params">(result ScheduleResult, err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 对 pod 进行 pvc 的信息检查</span></span><br><span class="line">	<span class="keyword">if</span> err := podPassesBasicChecks(pod, g.pvcLister); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对当前的信息做一个快照</span></span><br><span class="line">	<span class="keyword">if</span> err := g.snapshot(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Node 节点数量为0，表示无可用节点</span></span><br><span class="line">	<span class="keyword">if</span> g.nodeInfoSnapshot.NumNodes() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result, ErrNoNodesAvailable</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// Predict阶段：找到所有满足调度条件的节点feasibleNodes，不满足的就直接过滤</span></span><br><span class="line">	feasibleNodes, filteredNodesStatuses, err := g.findNodesThatFitPod(ctx, prof, state, pod)</span><br><span class="line">	<span class="comment">// 没有可用节点直接报错</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(feasibleNodes) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result, &amp;FitError&#123;</span><br><span class="line">			Pod:                   pod,</span><br><span class="line">			NumAllNodes:           g.nodeInfoSnapshot.NumNodes(),</span><br><span class="line">			FilteredNodesStatuses: filteredNodesStatuses,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 只有一个节点就直接选用</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(feasibleNodes) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ScheduleResult&#123;</span><br><span class="line">			SuggestedHost:  feasibleNodes[<span class="number">0</span>].Name,</span><br><span class="line">			EvaluatedNodes: <span class="number">1</span> + <span class="built_in">len</span>(filteredNodesStatuses),</span><br><span class="line">			FeasibleNodes:  <span class="number">1</span>,</span><br><span class="line">		&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Priority阶段：通过打分，找到一个分数最高、也就是最优的节点</span></span><br><span class="line">	priorityList, err := g.prioritizeNodes(ctx, prof, state, pod, feasibleNodes)</span><br><span class="line">	host, err := g.selectHost(priorityList)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ScheduleResult&#123;</span><br><span class="line">		SuggestedHost:  host,</span><br><span class="line">		EvaluatedNodes: <span class="built_in">len</span>(feasibleNodes) + <span class="built_in">len</span>(filteredNodesStatuses),</span><br><span class="line">		FeasibleNodes:  <span class="built_in">len</span>(feasibleNodes),</span><br><span class="line">	&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Predict 和 Priority 是选择调度节点的两个关键性步骤， 它的底层调用了各种algorithm算法。我们暂时不细看。</span></span><br><span class="line"><span class="comment">以我们前面讲到过的 NodeName 算法为例，节点必须与 NodeName 匹配，它是属于Predict阶段的。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="Assume"><a href="#Assume" class="headerlink" title="Assume"></a>Assume</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">assume</span><span class="params">(assumed *v1.Pod, host <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 将 host 填入到 pod spec字段的nodename，假定分配到对应的节点上</span></span><br><span class="line">	assumed.Spec.NodeName = host</span><br><span class="line">  <span class="comment">// 调用 SchedulerCache 下的 AssumePod</span></span><br><span class="line">	<span class="keyword">if</span> err := sched.SchedulerCache.AssumePod(assumed); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Errorf(<span class="string">&quot;scheduler cache AssumePod failed: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> sched.SchedulingQueue != <span class="literal">nil</span> &#123;</span><br><span class="line">		sched.SchedulingQueue.DeleteNominatedPodIfExists(assumed)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回头去找 SchedulerCache 初始化的地方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">create</span><span class="params">()</span> <span class="params">(*Scheduler, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Scheduler&#123;</span><br><span class="line">		SchedulerCache:  c.schedulerCache,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="params">(*Scheduler, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 这里就是初始化的实例 schedulerCache</span></span><br><span class="line">	schedulerCache := internalcache.New(<span class="number">30</span>*time.Second, stopEverything)</span><br><span class="line">	configurator := &amp;Configurator&#123;</span><br><span class="line">		schedulerCache:           schedulerCache,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看看AssumePod做了什么</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span> <span class="title">AssumePod</span><span class="params">(pod *v1.Pod)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取 pod 的 uid</span></span><br><span class="line">	key, err := framework.GetPodKey(pod)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 加锁操作，保证并发情况下的一致性</span></span><br><span class="line">	cache.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> cache.mu.Unlock()</span><br><span class="line">  <span class="comment">// 根据 uid 找不到 pod 当前的状态</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := cache.podStates[key]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;pod %v is in the cache, so can&#x27;t be assumed&quot;</span>, key)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 Assume Pod 的信息放到对应 Node 节点中</span></span><br><span class="line">	cache.addPod(pod)</span><br><span class="line">  <span class="comment">// 把 pod 状态设置为 Assume 成功</span></span><br><span class="line">	ps := &amp;podState&#123;</span><br><span class="line">		pod: pod,</span><br><span class="line">	&#125;</span><br><span class="line">	cache.podStates[key] = ps</span><br><span class="line">	cache.assumedPods[key] = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">bind</span><span class="params">(ctx context.Context, prof *profile.Profile, assumed *v1.Pod, targetNode <span class="keyword">string</span>, state *framework.CycleState)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">  <span class="comment">// 把 assumed 的 pod 信息保存下来</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		sched.finishBinding(prof, assumed, targetNode, start, err)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 阶段1： 运行扩展绑定进行验证，如果已经绑定报错</span></span><br><span class="line">	bound, err := sched.extendersBinding(assumed, targetNode)</span><br><span class="line">	<span class="keyword">if</span> bound &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 阶段2：运行绑定插件验证状态</span></span><br><span class="line">	bindStatus := prof.RunBindPlugins(ctx, state, assumed, targetNode)</span><br><span class="line">	<span class="keyword">if</span> bindStatus.IsSuccess() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> bindStatus.Code() == framework.Error &#123;</span><br><span class="line">		<span class="keyword">return</span> bindStatus.AsError()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;bind status: %s, %v&quot;</span>, bindStatus.Code().String(), bindStatus.Message())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Update-To-Etcd"><a href="#Update-To-Etcd" class="headerlink" title="Update To Etcd"></a>Update To Etcd</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这块的代码我不做细致的逐层分析了，大家根据兴趣自行探索</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b DefaultBinder)</span> <span class="title">Bind</span><span class="params">(ctx context.Context, state *framework.CycleState, p *v1.Pod, nodeName <span class="keyword">string</span>)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">	klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;Attempting to bind %v/%v to %v&quot;</span>, p.Namespace, p.Name, nodeName)</span><br><span class="line">	binding := &amp;v1.Binding&#123;</span><br><span class="line">		ObjectMeta: metav1.ObjectMeta&#123;Namespace: p.Namespace, Name: p.Name, UID: p.UID&#125;,</span><br><span class="line">		Target:     v1.ObjectReference&#123;Kind: <span class="string">&quot;Node&quot;</span>, Name: nodeName&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// ClientSet就是访问kube-apiserver的客户端，将数据更新上去</span></span><br><span class="line">	err := b.handle.ClientSet().CoreV1().Pods(binding.Namespace).Bind(ctx, binding, metav1.CreateOptions&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> framework.NewStatus(framework.Error, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>今天这一次分享比较长，我们一起来总结一下：</p>
<ol>
<li>Pod的调度是通过一个队列<code>SchedulingQueue</code>异步工作的<ol>
<li>监听到对应pod事件后，放入队列</li>
<li>有个消费者从队列中获取pod，进行调度</li>
</ol>
</li>
<li>单个pod的调度主要分为3个步骤：<ol>
<li>根据Predict和Priority两个阶段，调用各自的算法插件，选择最优的Node</li>
<li>Assume这个Pod被调度到对应的Node，保存到cache</li>
<li>用extender和plugins进行验证，如果通过则绑定</li>
</ol>
</li>
<li>绑定成功后，将数据通过client向kube-apiserver发送，更新etcd</li>
</ol>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>【K8s源码品读】012：Phase 1 - kube-controller-manager - 了解控制管理中心</title>
    <url>/2021/02/18/k8s/k8s-012/</url>
    <content><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解 kube-controller-manager 的运行机制</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#Run">运行的主函数</a></li>
<li><a href="#StartControllers">控制器的启动函数</a></li>
<li><a href="#ReplicaSet">引入概念ReplicaSet</a></li>
<li><a href="#ReplicaSetController">查看ReplicaSetController</a></li>
<li><a href="#syncReplicaSet">ReplicaSet的核心实现函数</a></li>
<li><a href="#Summary">总结</a></li>
</ol>
<h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><p>我们找到了对应的主函数，看看其中的内容</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(c *config.CompletedConfig, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// configz 模块，在kube-scheduler分析中已经了解</span></span><br><span class="line">	<span class="keyword">if</span> cfgz, err := configz.New(ConfigzName); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		cfgz.Set(c.ComponentConfig)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		klog.Errorf(<span class="string">&quot;unable to register configz: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 健康监测与http服务，跳过</span></span><br><span class="line">	<span class="keyword">var</span> checks []healthz.HealthChecker</span><br><span class="line">	<span class="keyword">var</span> unsecuredMux *mux.PathRecorderMux</span><br><span class="line"></span><br><span class="line">	run := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		rootClientBuilder := controller.SimpleControllerClientBuilder&#123;</span><br><span class="line">			ClientConfig: c.Kubeconfig,</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// client认证相关</span></span><br><span class="line">		<span class="keyword">var</span> clientBuilder controller.ControllerClientBuilder</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 创建controller的上下文context</span></span><br><span class="line">		controllerContext, err := CreateControllerContext(c, rootClientBuilder, clientBuilder, ctx.Done())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.Fatalf(<span class="string">&quot;error building controller context: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		saTokenControllerInitFunc := serviceAccountTokenControllerStarter&#123;rootClientBuilder: rootClientBuilder&#125;.startServiceAccountTokenController</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := StartControllers(controllerContext, saTokenControllerInitFunc, NewControllerInitializers(controllerContext.LoopMode), unsecuredMux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.Fatalf(<span class="string">&quot;error starting controllers: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 InformerFactory 和我们在kube-scheduler中看的 SharedInformerFactory 基本一致</span></span><br><span class="line">		controllerContext.InformerFactory.Start(controllerContext.Stop)</span><br><span class="line">		controllerContext.ObjectOrMetadataInformerFactory.Start(controllerContext.Stop)</span><br><span class="line">		<span class="built_in">close</span>(controllerContext.InformersStarted)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否进行选举</span></span><br><span class="line">	<span class="keyword">if</span> !c.ComponentConfig.Generic.LeaderElection.LeaderElect &#123;</span><br><span class="line">		run(context.TODO())</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拼接出一个全局唯一的id</span></span><br><span class="line">	id, err := os.Hostname()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	id = id + <span class="string">&quot;_&quot;</span> + <span class="keyword">string</span>(uuid.NewUUID())</span><br><span class="line"></span><br><span class="line">	rl, err := resourcelock.New(c.ComponentConfig.Generic.LeaderElection.ResourceLock,</span><br><span class="line">		c.ComponentConfig.Generic.LeaderElection.ResourceNamespace,</span><br><span class="line">		c.ComponentConfig.Generic.LeaderElection.ResourceName,</span><br><span class="line">		c.LeaderElectionClient.CoreV1(),</span><br><span class="line">		c.LeaderElectionClient.CoordinationV1(),</span><br><span class="line">		resourcelock.ResourceLockConfig&#123;</span><br><span class="line">			Identity:      id,</span><br><span class="line">			EventRecorder: c.EventRecorder,</span><br><span class="line">		&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatalf(<span class="string">&quot;error creating lock: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正常情况下都是阻塞在RunOrDie这个函数中，不停地进行选举相关的工作</span></span><br><span class="line">	leaderelection.RunOrDie(context.TODO(), leaderelection.LeaderElectionConfig&#123;</span><br><span class="line">		Lock:          rl,</span><br><span class="line">		LeaseDuration: c.ComponentConfig.Generic.LeaderElection.LeaseDuration.Duration,</span><br><span class="line">		RenewDeadline: c.ComponentConfig.Generic.LeaderElection.RenewDeadline.Duration,</span><br><span class="line">		RetryPeriod:   c.ComponentConfig.Generic.LeaderElection.RetryPeriod.Duration,</span><br><span class="line">		Callbacks: leaderelection.LeaderCallbacks&#123;</span><br><span class="line">      <span class="comment">// 开始成为Leader的时候，调用run函数</span></span><br><span class="line">			OnStartedLeading: run,</span><br><span class="line">			OnStoppedLeading: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				klog.Fatalf(<span class="string">&quot;leaderelection lost&quot;</span>)</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		WatchDog: electionChecker,</span><br><span class="line">		Name:     <span class="string">&quot;kube-controller-manager&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="StartControllers"><a href="#StartControllers" class="headerlink" title="StartControllers"></a>StartControllers</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartControllers</span><span class="params">(ctx ControllerContext, startSATokenController InitFunc, controllers <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc, unsecuredMux *mux.PathRecorderMux)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 关键性的循环，启动每个controllers，key为控制器名字，value为初始化函数</span></span><br><span class="line">	<span class="keyword">for</span> controllerName, initFn := <span class="keyword">range</span> controllers &#123;</span><br><span class="line">    <span class="comment">// 是否允许启动</span></span><br><span class="line">		<span class="keyword">if</span> !ctx.IsControllerEnabled(controllerName) &#123;</span><br><span class="line">			klog.Warningf(<span class="string">&quot;%q is disabled&quot;</span>, controllerName)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(wait.Jitter(ctx.ComponentConfig.Generic.ControllerStartInterval.Duration, ControllerStartJitter))</span><br><span class="line">		klog.V(<span class="number">1</span>).Infof(<span class="string">&quot;Starting %q&quot;</span>, controllerName)</span><br><span class="line">    <span class="comment">// 调用init函数进行启动</span></span><br><span class="line">		debugHandler, started, err := initFn(ctx)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.Errorf(<span class="string">&quot;Error starting %q&quot;</span>, controllerName)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !started &#123;</span><br><span class="line">			klog.Warningf(<span class="string">&quot;Skipping %q&quot;</span>, controllerName)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 注册对应controller到debug的url中</span></span><br><span class="line">		<span class="keyword">if</span> debugHandler != <span class="literal">nil</span> &amp;&amp; unsecuredMux != <span class="literal">nil</span> &#123;</span><br><span class="line">			basePath := <span class="string">&quot;/debug/controllers/&quot;</span> + controllerName</span><br><span class="line">			unsecuredMux.UnlistedHandle(basePath, http.StripPrefix(basePath, debugHandler))</span><br><span class="line">			unsecuredMux.UnlistedHandlePrefix(basePath+<span class="string">&quot;/&quot;</span>, http.StripPrefix(basePath, debugHandler))</span><br><span class="line">		&#125;</span><br><span class="line">		klog.Infof(<span class="string">&quot;Started %q&quot;</span>, controllerName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们再去传入controller的函数去看看，对应的controller有哪些，这里有我们很多常见的概念，今天不一一细讲</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerInitializers</span><span class="params">(loopMode ControllerLoopMode)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">InitFunc</span></span> &#123;</span><br><span class="line">	controllers := <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc&#123;&#125;</span><br><span class="line">	controllers[<span class="string">&quot;endpoint&quot;</span>] = startEndpointController</span><br><span class="line">	controllers[<span class="string">&quot;endpointslice&quot;</span>] = startEndpointSliceController</span><br><span class="line">	controllers[<span class="string">&quot;endpointslicemirroring&quot;</span>] = startEndpointSliceMirroringController</span><br><span class="line">	controllers[<span class="string">&quot;replicationcontroller&quot;</span>] = startReplicationController</span><br><span class="line">	controllers[<span class="string">&quot;podgc&quot;</span>] = startPodGCController</span><br><span class="line">	controllers[<span class="string">&quot;resourcequota&quot;</span>] = startResourceQuotaController</span><br><span class="line">	controllers[<span class="string">&quot;namespace&quot;</span>] = startNamespaceController</span><br><span class="line">	controllers[<span class="string">&quot;serviceaccount&quot;</span>] = startServiceAccountController</span><br><span class="line">	controllers[<span class="string">&quot;garbagecollector&quot;</span>] = startGarbageCollectorController</span><br><span class="line">	controllers[<span class="string">&quot;daemonset&quot;</span>] = startDaemonSetController</span><br><span class="line">	controllers[<span class="string">&quot;job&quot;</span>] = startJobController</span><br><span class="line">	controllers[<span class="string">&quot;deployment&quot;</span>] = startDeploymentController</span><br><span class="line">	controllers[<span class="string">&quot;replicaset&quot;</span>] = startReplicaSetController</span><br><span class="line">	controllers[<span class="string">&quot;horizontalpodautoscaling&quot;</span>] = startHPAController</span><br><span class="line">	controllers[<span class="string">&quot;disruption&quot;</span>] = startDisruptionController</span><br><span class="line">	controllers[<span class="string">&quot;statefulset&quot;</span>] = startStatefulSetController</span><br><span class="line">	controllers[<span class="string">&quot;cronjob&quot;</span>] = startCronJobController</span><br><span class="line">	controllers[<span class="string">&quot;csrsigning&quot;</span>] = startCSRSigningController</span><br><span class="line">	controllers[<span class="string">&quot;csrapproving&quot;</span>] = startCSRApprovingController</span><br><span class="line">	controllers[<span class="string">&quot;csrcleaner&quot;</span>] = startCSRCleanerController</span><br><span class="line">	controllers[<span class="string">&quot;ttl&quot;</span>] = startTTLController</span><br><span class="line">	controllers[<span class="string">&quot;bootstrapsigner&quot;</span>] = startBootstrapSignerController</span><br><span class="line">	controllers[<span class="string">&quot;tokencleaner&quot;</span>] = startTokenCleanerController</span><br><span class="line">	controllers[<span class="string">&quot;nodeipam&quot;</span>] = startNodeIpamController</span><br><span class="line">	controllers[<span class="string">&quot;nodelifecycle&quot;</span>] = startNodeLifecycleController</span><br><span class="line">	<span class="keyword">if</span> loopMode == IncludeCloudLoops &#123;</span><br><span class="line">		controllers[<span class="string">&quot;service&quot;</span>] = startServiceController</span><br><span class="line">		controllers[<span class="string">&quot;route&quot;</span>] = startRouteController</span><br><span class="line">		controllers[<span class="string">&quot;cloud-node-lifecycle&quot;</span>] = startCloudNodeLifecycleController</span><br><span class="line">	&#125;</span><br><span class="line">	controllers[<span class="string">&quot;persistentvolume-binder&quot;</span>] = startPersistentVolumeBinderController</span><br><span class="line">	controllers[<span class="string">&quot;attachdetach&quot;</span>] = startAttachDetachController</span><br><span class="line">	controllers[<span class="string">&quot;persistentvolume-expander&quot;</span>] = startVolumeExpandController</span><br><span class="line">	controllers[<span class="string">&quot;clusterrole-aggregation&quot;</span>] = startClusterRoleAggregrationController</span><br><span class="line">	controllers[<span class="string">&quot;pvc-protection&quot;</span>] = startPVCProtectionController</span><br><span class="line">	controllers[<span class="string">&quot;pv-protection&quot;</span>] = startPVProtectionController</span><br><span class="line">	controllers[<span class="string">&quot;ttl-after-finished&quot;</span>] = startTTLAfterFinishedController</span><br><span class="line">	controllers[<span class="string">&quot;root-ca-cert-publisher&quot;</span>] = startRootCACertPublisher</span><br><span class="line">	controllers[<span class="string">&quot;ephemeral-volume&quot;</span>] = startEphemeralVolumeController</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> controllers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h2><p>由于我们的示例是创建一个nginx的pod，涉及到kube-controller-manager的内容很少。</p>
<p>但是，为了加深大家对 kube-controller-manager 的认识，我们引入一个新的概念 - ReplicaSet，下面是官方说明：</p>
<blockquote>
<p>A ReplicaSet’s purpose is to maintain a stable set of replica Pods running at any given time. As such, it is often used to guarantee the availability of a specified number of identical Pods.</p>
</blockquote>
<blockquote>
<p>ReplicaSet 的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。</p>
</blockquote>
<p>简单来说，ReplicaSet 就是用来生成指定个数的Pod。</p>
<h2 id="ReplicaSetController"><a href="#ReplicaSetController" class="headerlink" title="ReplicaSetController"></a>ReplicaSetController</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startReplicaSetController</span><span class="params">(ctx ControllerContext)</span> <span class="params">(http.Handler, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !ctx.AvailableResources[schema.GroupVersionResource&#123;Group: <span class="string">&quot;apps&quot;</span>, Version: <span class="string">&quot;v1&quot;</span>, Resource: <span class="string">&quot;replicasets&quot;</span>&#125;] &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 用goroutine异步运行，包含了 ReplicaSet和Pod 的两个Informer</span></span><br><span class="line">  <span class="comment">// 这一点很好理解：我们是要控制ReplicaSet声明的数量和运行的Pod数量一致，需要同时观察者两种资源</span></span><br><span class="line">	<span class="keyword">go</span> replicaset.NewReplicaSetController(</span><br><span class="line">		ctx.InformerFactory.Apps().V1().ReplicaSets(),</span><br><span class="line">		ctx.InformerFactory.Core().V1().Pods(),</span><br><span class="line">		ctx.ClientBuilder.ClientOrDie(<span class="string">&quot;replicaset-controller&quot;</span>),</span><br><span class="line">		replicaset.BurstReplicas,</span><br><span class="line">	).Run(<span class="keyword">int</span>(ctx.ComponentConfig.ReplicaSetController.ConcurrentRSSyncs), ctx.Stop)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">Run</span><span class="params">(workers <span class="keyword">int</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">defer</span> rsc.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">	controllerName := strings.ToLower(rsc.Kind)</span><br><span class="line">	klog.Infof(<span class="string">&quot;Starting %v controller&quot;</span>, controllerName)</span><br><span class="line">	<span class="keyword">defer</span> klog.Infof(<span class="string">&quot;Shutting down %v controller&quot;</span>, controllerName)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(rsc.Kind, stopCh, rsc.podListerSynced, rsc.rsListerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">    <span class="comment">// 工作的函数</span></span><br><span class="line">		<span class="keyword">go</span> wait.Until(rsc.worker, time.Second, stopCh)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;-stopCh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 继续查找实现</span></span><br><span class="line">	<span class="keyword">for</span> rsc.processNextWorkItem() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">processNextWorkItem</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">// 这里也有个queue的概念，可以类比kube-scheduler中的实现</span></span><br><span class="line">  <span class="comment">// 不同的是，这里的queue是 workqueue.RateLimitingInterface ，也就是限制速率的，具体实现今天不细看</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取元素</span></span><br><span class="line">	key, quit := rsc.queue.Get()</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> rsc.queue.Done(key)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理对应的元素</span></span><br><span class="line">	err := rsc.syncHandler(key.(<span class="keyword">string</span>))</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		rsc.queue.Forget(key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;sync %q failed with %v&quot;</span>, key, err))</span><br><span class="line">	rsc.queue.AddRateLimited(key)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再回过头，去查看syncHandler的具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBaseController</span><span class="params">(rsInformer appsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, kubeClient clientset.Interface, burstReplicas <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	gvk schema.GroupVersionKind, metricOwnerName, queueName <span class="keyword">string</span>, podControl controller.PodControlInterface)</span> *<span class="title">ReplicaSetController</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	rsc.syncHandler = rsc.syncReplicaSet</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rsc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="syncReplicaSet"><a href="#syncReplicaSet" class="headerlink" title="syncReplicaSet"></a>syncReplicaSet</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">syncReplicaSet</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Finished syncing %v %q (%v)&quot;</span>, rsc.Kind, key, time.Since(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 从key中拆分出 namespace 和 name</span></span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据name，从 Lister 获取对应的 ReplicaSets 信息</span></span><br><span class="line">	rs, err := rsc.rsLister.ReplicaSets(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;%v %v has been deleted&quot;</span>, rsc.Kind, key)</span><br><span class="line">		rsc.expectations.DeleteExpectations(key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rsNeedsSync := rsc.expectations.SatisfiedExpectations(key)</span><br><span class="line">  <span class="comment">// 获取 selector (k8s 是根据selector中的label来匹配 ReplicaSets 和 Pod 的)</span></span><br><span class="line">	selector, err := metav1.LabelSelectorAsSelector(rs.Spec.Selector)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;error converting pod selector to selector: %v&quot;</span>, err))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据namespace和labels获取所有的pod</span></span><br><span class="line">	allPods, err := rsc.podLister.Pods(rs.Namespace).List(labels.Everything())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 过滤无效的pod</span></span><br><span class="line">	filteredPods := controller.FilterActivePods(allPods)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据selector再过滤pod</span></span><br><span class="line">	filteredPods, err = rsc.claimPods(rs, selector, filteredPods)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> manageReplicasErr error</span><br><span class="line">	<span class="keyword">if</span> rsNeedsSync &amp;&amp; rs.DeletionTimestamp == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 管理 ReplicaSet，下面详细分析</span></span><br><span class="line">		manageReplicasErr = rsc.manageReplicas(filteredPods, rs)</span><br><span class="line">	&#125;</span><br><span class="line">	rs = rs.DeepCopy()</span><br><span class="line">	newStatus := calculateStatus(rs, filteredPods, manageReplicasErr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新状态</span></span><br><span class="line">	updatedRS, err := updateReplicaSetStatus(rsc.kubeClient.AppsV1().ReplicaSets(rs.Namespace), rs, newStatus)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> manageReplicasErr == <span class="literal">nil</span> &amp;&amp; updatedRS.Spec.MinReadySeconds &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">		updatedRS.Status.ReadyReplicas == *(updatedRS.Spec.Replicas) &amp;&amp;</span><br><span class="line">		updatedRS.Status.AvailableReplicas != *(updatedRS.Spec.Replicas) &#123;</span><br><span class="line">		rsc.queue.AddAfter(key, time.Duration(updatedRS.Spec.MinReadySeconds)*time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> manageReplicasErr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们再一起看看，当Pod数量和ReplicaSet中声明的不同时，是怎么工作的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">manageReplicas</span><span class="params">(filteredPods []*v1.Pod, rs *apps.ReplicaSet)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// diff = 当前pod数 - 期望pod数</span></span><br><span class="line">  diff := <span class="built_in">len</span>(filteredPods) - <span class="keyword">int</span>(*(rs.Spec.Replicas))</span><br><span class="line">	rsKey, err := controller.KeyFunc(rs)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;couldn&#x27;t get key for %v %#v: %v&quot;</span>, rsc.Kind, rs, err))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// diff小于0，表示需要扩容，即新增Pod</span></span><br><span class="line">	<span class="keyword">if</span> diff &lt; <span class="number">0</span> &#123;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 具体的实现暂时不细看</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// diff 大于0，即需要缩容</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> diff &gt; <span class="number">0</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>kube-controller-manager 的核心思想是： 根据<code>期望状态</code>和<code>当前状态</code>，管理Kubernetes中的资源。</p>
<p>以ReplicaSet为例，它对比了<code>定义声明的Pod数</code>和<code>当前集群中满足条件的Pod数</code>，进行相对应的扩缩容。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>【K8s源码品读】013：Phase 1 - kubelet - 节点上控制容器生命周期的管理者</title>
    <url>/2021/02/18/k8s/k8s-013/</url>
    <content><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解 kubelet 的运行机制</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#Run">运行的主函数</a></li>
<li><a href="#RunKubelet">运行kubelet</a></li>
<li><a href="#Kubelet">核心数据管理Kubelet</a></li>
<li><a href="#syncLoop">同步循环</a></li>
<li><a href="#handler">处理pod的同步工作</a></li>
<li><a href="#Summary">总结</a></li>
</ol>
<h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><p>从主函数找到run函数，代码较长，我精简了一下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(ctx context.Context, s *options.KubeletServer, kubeDeps *kubelet.Dependencies, featureGate featuregate.FeatureGate)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 一长串的配置初始化与验证</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// done channel，用来通知运行结束</span></span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 注册到configz模块</span></span><br><span class="line">	err = initConfigz(&amp;s.KubeletConfiguration)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Errorf(<span class="string">&quot;unable to register KubeletConfiguration with configz, error: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取节点的相关信息</span></span><br><span class="line">	hostName, err := nodeutil.GetHostname(s.HostnameOverride)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	nodeName, err := getNodeName(kubeDeps.Cloud, hostName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">  <span class="comment">// 独立运行模式</span></span><br><span class="line">	<span class="keyword">case</span> standaloneMode:</span><br><span class="line">	<span class="comment">// 对客户端进行初始化</span></span><br><span class="line">	<span class="keyword">case</span> kubeDeps.KubeClient == <span class="literal">nil</span>, kubeDeps.EventClient == <span class="literal">nil</span>, kubeDeps.HeartbeatClient == <span class="literal">nil</span>:</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cgroup 相关初始化</span></span><br><span class="line">	<span class="keyword">var</span> cgroupRoots []<span class="keyword">string</span></span><br><span class="line">	nodeAllocatableRoot := cm.NodeAllocatableRoot(s.CgroupRoot, s.CgroupsPerQOS, s.CgroupDriver)</span><br><span class="line">	cgroupRoots = <span class="built_in">append</span>(cgroupRoots, nodeAllocatableRoot)</span><br><span class="line">	kubeletCgroup, err := cm.GetKubeletContainer(s.KubeletCgroups)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Warningf(<span class="string">&quot;failed to get the kubelet&#x27;s cgroup: %v.  Kubelet system container metrics may be missing.&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> kubeletCgroup != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		cgroupRoots = <span class="built_in">append</span>(cgroupRoots, kubeletCgroup)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	runtimeCgroup, err := cm.GetRuntimeContainer(s.ContainerRuntime, s.RuntimeCgroups)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Warningf(<span class="string">&quot;failed to get the container runtime&#x27;s cgroup: %v. Runtime system container metrics may be missing.&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> runtimeCgroup != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		cgroupRoots = <span class="built_in">append</span>(cgroupRoots, runtimeCgroup)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.SystemCgroups != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		cgroupRoots = <span class="built_in">append</span>(cgroupRoots, s.SystemCgroups)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面一大块都是对 ContainerManager 的初始化</span></span><br><span class="line">	<span class="keyword">if</span> kubeDeps.ContainerManager == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> s.CgroupsPerQOS &amp;&amp; s.CgroupRoot == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			klog.Info(<span class="string">&quot;--cgroups-per-qos enabled, but --cgroup-root was not specified.  defaulting to /&quot;</span>)</span><br><span class="line">			s.CgroupRoot = <span class="string">&quot;/&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// cpu相关信息</span></span><br><span class="line">		<span class="keyword">var</span> reservedSystemCPUs cpuset.CPUSet</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ContainerManager的实例化</span></span><br><span class="line">		kubeDeps.ContainerManager, err = cm.NewContainerManager(</span><br><span class="line">			kubeDeps.Mounter,</span><br><span class="line">			kubeDeps.CAdvisorInterface,</span><br><span class="line">      <span class="comment">// Node 相关配置</span></span><br><span class="line">			cm.NodeConfig&#123;&#125;,</span><br><span class="line">			s.FailSwapOn,</span><br><span class="line">			devicePluginEnabled,</span><br><span class="line">			kubeDeps.Recorder)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 内存OOM相关</span></span><br><span class="line">	oomAdjuster := kubeDeps.OOMAdjuster</span><br><span class="line">	<span class="keyword">if</span> err := oomAdjuster.ApplyOOMScoreAdj(<span class="number">0</span>, <span class="keyword">int</span>(s.OOMScoreAdj)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Warning(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 预初始化Runtime</span></span><br><span class="line">	err = kubelet.PreInitRuntimeService(&amp;s.KubeletConfiguration,</span><br><span class="line">		kubeDeps, &amp;s.ContainerRuntimeOptions,</span><br><span class="line">		s.ContainerRuntime,</span><br><span class="line">		s.RuntimeCgroups,</span><br><span class="line">		s.RemoteRuntimeEndpoint,</span><br><span class="line">		s.RemoteImageEndpoint,</span><br><span class="line">		s.NonMasqueradeCIDR)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行Kubelet</span></span><br><span class="line">	<span class="keyword">if</span> err := RunKubelet(s, kubeDeps, s.RunOnce); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通知deamon的systemd</span></span><br><span class="line">	<span class="keyword">go</span> daemon.SdNotify(<span class="literal">false</span>, <span class="string">&quot;READY=1&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻塞</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-done:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RunKubelet"><a href="#RunKubelet" class="headerlink" title="RunKubelet"></a>RunKubelet</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunKubelet</span><span class="params">(kubeServer *options.KubeletServer, kubeDeps *kubelet.Dependencies, runOnce <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取节点信息</span></span><br><span class="line">  hostname, err := nodeutil.GetHostname(kubeServer.HostnameOverride)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	nodeName, err := getNodeName(kubeDeps.Cloud, hostname)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	hostnameOverridden := <span class="built_in">len</span>(kubeServer.HostnameOverride) &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建并初始化 kubelet</span></span><br><span class="line">	k, err := createAndInitKubelet()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to create kubelet: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> runOnce &#123;</span><br><span class="line">		<span class="keyword">if</span> _, err := k.RunOnce(podCfg.Updates()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;runonce failed: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		klog.Info(<span class="string">&quot;Started kubelet as runonce&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 开始kubelet</span></span><br><span class="line">		startKubelet(k, podCfg, &amp;kubeServer.KubeletConfiguration, kubeDeps, kubeServer.EnableCAdvisorJSONEndpoints, kubeServer.EnableServer)</span><br><span class="line">		klog.Info(<span class="string">&quot;Started kubelet&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始运行，都是并发的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startKubelet</span><span class="params">(k kubelet.Bootstrap, podCfg *config.PodConfig, kubeCfg *kubeletconfiginternal.KubeletConfiguration, kubeDeps *kubelet.Dependencies, enableCAdvisorJSONEndpoints, enableServer <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 运行</span></span><br><span class="line">	<span class="keyword">go</span> k.Run(podCfg.Updates())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启kubelet的http服务端</span></span><br><span class="line">	<span class="keyword">if</span> enableServer &#123;</span><br><span class="line">		<span class="keyword">go</span> k.ListenAndServe(net.ParseIP(kubeCfg.Address), <span class="keyword">uint</span>(kubeCfg.Port), kubeDeps.TLSOptions, kubeDeps.Auth,</span><br><span class="line">			enableCAdvisorJSONEndpoints, kubeCfg.EnableDebuggingHandlers, kubeCfg.EnableContentionProfiling, kubeCfg.EnableSystemLogHandler)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 只读端口</span></span><br><span class="line">	<span class="keyword">if</span> kubeCfg.ReadOnlyPort &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">go</span> k.ListenAndServeReadOnly(net.ParseIP(kubeCfg.Address), <span class="keyword">uint</span>(kubeCfg.ReadOnlyPort), enableCAdvisorJSONEndpoints)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.KubeletPodResources) &#123;</span><br><span class="line">		<span class="keyword">go</span> k.ListenAndServePodResources()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的k是一个interface定义，我们需要回头看看</span></span><br><span class="line"><span class="keyword">type</span> Bootstrap <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetConfiguration() kubeletconfiginternal.KubeletConfiguration</span><br><span class="line">	BirthCry()</span><br><span class="line">	StartGarbageCollection()</span><br><span class="line">	ListenAndServe(address net.IP, port <span class="keyword">uint</span>, tlsOptions *server.TLSOptions, auth server.AuthInterface, enableCAdvisorJSONEndpoints, enableDebuggingHandlers, enableContentionProfiling, enableSystemLogHandler <span class="keyword">bool</span>)</span><br><span class="line">	ListenAndServeReadOnly(address net.IP, port <span class="keyword">uint</span>, enableCAdvisorJSONEndpoints <span class="keyword">bool</span>)</span><br><span class="line">	ListenAndServePodResources()</span><br><span class="line">	Run(&lt;-<span class="keyword">chan</span> kubetypes.PodUpdate)</span><br><span class="line">	RunOnce(&lt;-<span class="keyword">chan</span> kubetypes.PodUpdate) ([]RunPodResult, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看对应的实例化函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createAndInitKubelet</span><span class="params">()</span> <span class="params">(k kubelet.Bootstrap, err error)</span></span> &#123;</span><br><span class="line">	k, err = kubelet.NewMainKubelet()</span><br><span class="line">	<span class="keyword">return</span> k, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMainKubelet</span><span class="params">()</span> <span class="params">(*Kubelet, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 参数的初始化</span></span><br><span class="line">	</span><br><span class="line">  <span class="comment">// klet 的实例化结构</span></span><br><span class="line">	klet := &amp;Kubelet&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面是klet中各种参数的填充</span></span><br><span class="line">	<span class="keyword">return</span> klet, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">Run</span><span class="params">(updates &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 内部模块的初始化</span></span><br><span class="line">	<span class="keyword">if</span> err := kl.initializeModules(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		kl.recorder.Eventf(kl.nodeRef, v1.EventTypeWarning, events.KubeletSetupFailed, err.Error())</span><br><span class="line">		klog.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> kl.volumeManager.Run(kl.sourcesReady, wait.NeverStop)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> kl.kubeClient != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 与kube-apiserver同步节点状态</span></span><br><span class="line">		<span class="keyword">go</span> wait.Until(kl.syncNodeStatus, kl.nodeStatusUpdateFrequency, wait.NeverStop)</span><br><span class="line">		<span class="keyword">go</span> kl.fastStatusUpdateOnce()</span><br><span class="line">		<span class="keyword">go</span> kl.nodeLeaseController.Run(wait.NeverStop)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> wait.Until(kl.updateRuntimeUp, <span class="number">5</span>*time.Second, wait.NeverStop)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> kl.makeIPTablesUtilChains &#123;</span><br><span class="line">		kl.initNetworkUtil()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个kill pod的goroutine</span></span><br><span class="line">	<span class="keyword">go</span> wait.Until(kl.podKiller.PerformPodKillingWork, <span class="number">1</span>*time.Second, wait.NeverStop)</span><br><span class="line"></span><br><span class="line">	kl.statusManager.Start()</span><br><span class="line">	kl.probeManager.Start()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> kl.runtimeClassManager != <span class="literal">nil</span> &#123;</span><br><span class="line">		kl.runtimeClassManager.Start(wait.NeverStop)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kl.pleg.Start()</span><br><span class="line">  <span class="comment">// 同步的主逻辑</span></span><br><span class="line">	kl.syncLoop(updates, kl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="syncLoop"><a href="#syncLoop" class="headerlink" title="syncLoop"></a>syncLoop</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncLoop</span><span class="params">(updates &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 开始运行kubelet的主同步循环</span></span><br><span class="line">	klog.Info(<span class="string">&quot;Starting kubelet main sync loop.&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ticker每秒一次</span></span><br><span class="line">	syncTicker := time.NewTicker(time.Second)</span><br><span class="line">	<span class="keyword">defer</span> syncTicker.Stop()</span><br><span class="line">  <span class="comment">// housekeeping 清理周期</span></span><br><span class="line">	housekeepingTicker := time.NewTicker(housekeepingPeriod)</span><br><span class="line">	<span class="keyword">defer</span> housekeepingTicker.Stop()</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		kl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class="line">    <span class="comment">// 同步</span></span><br><span class="line">		<span class="keyword">if</span> !kl.syncLoopIteration(updates, handler, syncTicker.C, housekeepingTicker.C, plegCh) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		kl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的3个channel比较重要：configCh用于配置，syncCh用于触发同步，housekeepingCh用于触发清理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncLoopIteration</span><span class="params">(configCh &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span></span></span><br><span class="line"><span class="params"><span class="function">	syncCh &lt;-<span class="keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="keyword">chan</span> time.Time, plegCh &lt;-<span class="keyword">chan</span> *pleg.PodLifecycleEvent)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> u, open := &lt;-configCh:</span><br><span class="line">    <span class="comment">// config channel关闭</span></span><br><span class="line">		<span class="keyword">if</span> !open &#123;</span><br><span class="line">			klog.Errorf(<span class="string">&quot;Update channel is closed. Exiting the sync loop.&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 对应不同的操作</span></span><br><span class="line">		<span class="keyword">switch</span> u.Op &#123;</span><br><span class="line">		<span class="keyword">case</span> kubetypes.ADD:</span><br><span class="line">			klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;SyncLoop (ADD, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class="line">			handler.HandlePodAdditions(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.UPDATE:</span><br><span class="line">			klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;SyncLoop (UPDATE, %q): %q&quot;</span>, u.Source, format.PodsWithDeletionTimestamps(u.Pods))</span><br><span class="line">			handler.HandlePodUpdates(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.REMOVE:</span><br><span class="line">			klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;SyncLoop (REMOVE, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class="line">			handler.HandlePodRemoves(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.RECONCILE:</span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;SyncLoop (RECONCILE, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class="line">			handler.HandlePodReconcile(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.DELETE:</span><br><span class="line">			klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;SyncLoop (DELETE, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class="line">			handler.HandlePodUpdates(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.SET:</span><br><span class="line">			klog.Errorf(<span class="string">&quot;Kubelet does not support snapshot update&quot;</span>)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			klog.Errorf(<span class="string">&quot;Invalid event type received: %d.&quot;</span>, u.Op)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		kl.sourcesReady.AddSource(u.Source)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> e := &lt;-plegCh:</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">case</span> &lt;-syncCh:</span><br><span class="line">		<span class="comment">// 获取需要同步的pod，里面的逻辑暂不细看</span></span><br><span class="line">    <span class="comment">// 我们在这里接收到示例中要创建的nginx pod</span></span><br><span class="line">		podsToSync := kl.getPodsToSync()</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(podsToSync) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;SyncLoop (SYNC): %d pods; %s&quot;</span>, <span class="built_in">len</span>(podsToSync), format.Pods(podsToSync))</span><br><span class="line">    <span class="comment">// 开始处理</span></span><br><span class="line">		handler.HandlePodSyncs(podsToSync)</span><br><span class="line">	<span class="keyword">case</span> update := &lt;-kl.livenessManager.Updates():</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> &lt;-housekeepingCh:</span><br><span class="line">		<span class="keyword">if</span> !kl.sourcesReady.AllReady() &#123;</span><br><span class="line">      <span class="comment">// 清理没有ready，直接跳过</span></span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;SyncLoop (housekeeping, skipped): sources aren&#x27;t ready yet.&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 开始清理pod</span></span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;SyncLoop (housekeeping)&quot;</span>)</span><br><span class="line">			<span class="keyword">if</span> err := handler.HandlePodCleanups(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.Errorf(<span class="string">&quot;Failed cleaning pods: %v&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><p>往前查找代码，handler就是Kubelet</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">HandlePodSyncs</span><span class="params">(pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">	start := kl.clock.Now()</span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">    <span class="comment">// 获取pod，然后分发</span></span><br><span class="line">		mirrorPod, _ := kl.podManager.GetMirrorPodByPod(pod)</span><br><span class="line">		kl.dispatchWork(pod, kubetypes.SyncPodSync, mirrorPod, start)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">dispatchWork</span><span class="params">(pod *v1.Pod, syncType kubetypes.SyncPodType, mirrorPod *v1.Pod, start time.Time)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 调用UpdatePod的函数</span></span><br><span class="line">	kl.podWorkers.UpdatePod(&amp;UpdatePodOptions&#123;</span><br><span class="line">		Pod:        pod,</span><br><span class="line">		MirrorPod:  mirrorPod,</span><br><span class="line">		UpdateType: syncType,</span><br><span class="line">		OnCompleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				metrics.PodWorkerDuration.WithLabelValues(syncType.String()).Observe(metrics.SinceInSeconds(start))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查到初始化的地方 	klet.podWorkers = newPodWorkers(klet.syncPod, kubeDeps.Recorder, klet.workQueue, klet.resyncInterval, backOffPeriod, klet.podCache)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span> <span class="title">UpdatePod</span><span class="params">(options *UpdatePodOptions)</span></span> &#123;</span><br><span class="line">	pod := options.Pod</span><br><span class="line">	uid := pod.UID</span><br><span class="line">	<span class="keyword">var</span> podUpdates <span class="keyword">chan</span> UpdatePodOptions</span><br><span class="line">	<span class="keyword">var</span> exists <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	p.podLock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.podLock.Unlock()</span><br><span class="line">  <span class="comment">// 当pod不存在时，满足示例，是新建的pod</span></span><br><span class="line">	<span class="keyword">if</span> podUpdates, exists = p.podUpdates[uid]; !exists &#123;</span><br><span class="line">		podUpdates = <span class="built_in">make</span>(<span class="keyword">chan</span> UpdatePodOptions, <span class="number">1</span>)</span><br><span class="line">		p.podUpdates[uid] = podUpdates</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发处理</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> runtime.HandleCrash()</span><br><span class="line">			p.managePodLoop(podUpdates)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !p.isWorking[pod.UID] &#123;</span><br><span class="line">		p.isWorking[pod.UID] = <span class="literal">true</span></span><br><span class="line">		podUpdates &lt;- *options</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		update, found := p.lastUndeliveredWorkUpdate[pod.UID]</span><br><span class="line">		<span class="keyword">if</span> !found || update.UpdateType != kubetypes.SyncPodKill &#123;</span><br><span class="line">			p.lastUndeliveredWorkUpdate[pod.UID] = *options</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span> <span class="title">managePodLoop</span><span class="params">(podUpdates &lt;-<span class="keyword">chan</span> UpdatePodOptions)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> lastSyncTime time.Time</span><br><span class="line">	<span class="keyword">for</span> update := <span class="keyword">range</span> podUpdates &#123;</span><br><span class="line">		err := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">      <span class="comment">// 同步pod的函数</span></span><br><span class="line">			err = p.syncPodFn(syncPodOptions&#123;</span><br><span class="line">				mirrorPod:      update.MirrorPod,</span><br><span class="line">				pod:            update.Pod,</span><br><span class="line">				podStatus:      status,</span><br><span class="line">				killPodOptions: update.KillPodOptions,</span><br><span class="line">				updateType:     update.UpdateType,</span><br><span class="line">			&#125;)</span><br><span class="line">			lastSyncTime = time.Now()</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;()</span><br><span class="line">		</span><br><span class="line">		p.wrapUp(update.Pod.UID, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到syncPodFn被实例化的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncPod</span><span class="params">(o syncPodOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里有一长串逻辑，不方便阅读，我们只关注最核心的部分</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调用 container runtime进行创建pod，再往下就是容器相关了</span></span><br><span class="line">	result := kl.containerRuntime.SyncPod(pod, podStatus, pullSecrets, kl.backOff)</span><br><span class="line">	kl.reasonCache.Update(pod.UID, result)</span><br><span class="line">	<span class="keyword">if</span> err := result.Error(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, r := <span class="keyword">range</span> result.SyncResults &#123;</span><br><span class="line">			<span class="keyword">if</span> r.Error != kubecontainer.ErrCrashLoopBackOff &amp;&amp; r.Error != images.ErrImagePullBackOff &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ol>
<li><p><code>kubelet</code>是kubernetes的<code>Node</code>节点上的管理者</p>
</li>
<li><p><code>kubelet</code>接收来自<code>kube-apiserver</code>上的pod消息，用<code>Ticker</code>这种周期性的方式触发同步函数</p>
</li>
<li><p><code>kubelet</code>会异步地对容器进行管理，调用对应容器的接口（Container Runtime Interface）</p>
</li>
</ol>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号：golangcoding</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>五分钟技术小分享 - 2022Week02</title>
    <url>/2022/01/04/sharing-5min/2022-01/2022Week02/</url>
    <content><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg" alt="2022-01"></p>
<h2 id="2022-01-04-Go1-18概览"><a href="#2022-01-04-Go1-18概览" class="headerlink" title="2022-01-04 Go1.18概览"></a>2022-01-04 Go1.18概览</h2><p>在2021年年底，<code>Go</code>推出了<code>1.18Beta</code>版本。由于正式版本没有完全敲定，普通开发人员没有必要研究到底层实现，但如果能先形成一个全局上的认知，能帮助我们领先一步。</p>
<p>关于1.18的核心改动，是 <strong>对泛型(Generics)的支持</strong>。Go语言的泛型语法比较简单，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> numeric <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="keyword">int</span>, <span class="keyword">int8</span>, <span class="keyword">int16</span>, <span class="keyword">int32</span>, <span class="keyword">int64</span>, <span class="keyword">uint</span>, <span class="keyword">uint8</span>, <span class="keyword">uint16</span>, <span class="keyword">uint32</span>, <span class="keyword">uint64</span>, <span class="keyword">float32</span>, <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span>[<span class="title">T</span> <span class="title">numeric</span>]<span class="params">(a, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要在实际工程上落地，还有很多考量点，我这边重点提三点：</p>
<ol>
<li><strong>主流IDE的支持</strong> - 包括Goland与VSCode，尽量帮助开发者能在编码时发现问题；</li>
<li><strong>历史库的迁移与兼容</strong> - 实现泛型后，许多主流库会有大量的冗余函数，如何提供迁移方案，值得我们去关注；</li>
<li><strong>泛型的最佳工程实践</strong> - 作为一种新特性，Go的泛型如何应用在工程中、尤其是复杂工程中，需要一定的实践摸索，并总结规律（可借鉴其余支持泛型的语言）；</li>
</ol>
<p>除了泛型，另外一个比较大的特性就是<code>Fuzzy Testing</code>。</p>
<p>这个特性是为<strong>单元测试提供更全面的数据输入</strong>，这样就能覆盖更多的case，提前发现问题。关键词<code>Fuzzy</code>支持的主要特性是将一个输入参数，<strong>从具体的值变成范围</strong>，如原先输入<code>a=1</code>，现在支持<code>a</code>输入范围为<code>[-10,10]</code>。在跑单元测试时，大量的<code>Fuzzy</code>肯定会带来一定的性能压力，这时可以引入一定的并发特性。</p>
<p>总体来说，<code>Go1.18</code>对工程侧的影响更多地是提高代码的 <strong>简洁性</strong>。新特性的学习成本很低，我们不用过于急着引入，可以多花时间学习底层原理。</p>
<blockquote>
<p><strong>Go Blog</strong> - <a href="https://go.dev/blog/go1.18beta1">https://go.dev/blog/go1.18beta1</a></p>
<p><strong>Medium</strong> - <a href="https://betterprogramming.pub/golang-1-18-what-you-need-to-know-a5701f7e14ab">https://betterprogramming.pub/golang-1-18-what-you-need-to-know-a5701f7e14ab</a></p>
</blockquote>
<h2 id="2022-01-05-CNCF-概览"><a href="#2022-01-05-CNCF-概览" class="headerlink" title="2022-01-05 CNCF-概览"></a>2022-01-05 CNCF-概览</h2><p>CNCF作为云原生的代表性组织，提供了大量开源的软件，以及配套的、开箱即用的解决方案。有很多朋友对CNCF和云原生的认识可能仍停留在新闻报道里。今天，我先带大家在整体上入个门，后续选择具有代表性的软件进行分析。</p>
<blockquote>
<p>由于篇幅所限，我的分享只会提重点知识，帮大家建立这部分的知识框架，更详细的内容需要大家自行学习。</p>
</blockquote>
<p>CNCF的概览可以参考这个全景图 - <a href="https://landscape.cncf.io/%EF%BC%8C%E6%9B%B4%E6%96%B0%E8%BF%AD%E4%BB%A3%E9%9D%9E%E5%B8%B8%E9%A2%91%E7%B9%81%E3%80%82%E5%85%B6%E4%B8%AD%EF%BC%8C%E6%9C%80%E6%A0%B8%E5%BF%83%E7%9A%84%E4%B8%BA%E4%B8%8B%E9%9D%A2%E4%BA%94%E5%9D%97%EF%BC%9A">https://landscape.cncf.io/，更新迭代非常频繁。其中，最核心的为下面五块：</a></p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/landscape.png" alt="landscape"></p>
<ul>
<li>App Definition and Development 应用定义与开发<ul>
<li>Database 数据库</li>
<li>Streaming &amp; Messaging 流处理和消息通信</li>
<li>Application Definition &amp; Image Build 应用定义与镜像构建</li>
<li>Continuous Integration &amp; Delivery 持续集成与交付</li>
</ul>
</li>
<li>Orchestration &amp; Management 编排和管理<ul>
<li>Scheduling &amp; Orchestration 调度与编排</li>
<li>Coordination &amp; Service Discovery 协调与服务发现</li>
<li>Remote Procedure Call 远程过程调用</li>
<li>Service Proxy 服务代理</li>
<li>API Gateway API网关</li>
<li>Service Mesh 服务网格</li>
</ul>
</li>
<li>RunTime 运行时<ul>
<li>Cloud Native Storage 云原生存储</li>
<li>Container Runtime 容器运行时</li>
<li>Cloud Native Network 云原生网络</li>
</ul>
</li>
<li>Provisioning 提供者<ul>
<li>Automation &amp; Configuration 自动化与配置</li>
<li>Container Registry 容器注册</li>
<li>Security &amp; Compliance 安全与合规</li>
<li>Key Management 密钥管理</li>
</ul>
</li>
<li>Observability and Analysis 可观察性和分析<ul>
<li>Monitoring 监控</li>
<li>Logging 日志</li>
<li>Tracing 跟踪</li>
<li>Chaos Engineering 混沌工程</li>
</ul>
</li>
</ul>
<p>其余还包括Kubernetes的平台提供商、Serverless、成员、认证的服务提供商等周边内容，并不在我们讨论的范围之内。但从基金会来看，它提供了一整套生态，非常有助于落地。</p>
<p>那么，如何认识这五块呢？其实Landscape提供了很好的图形效果，我们只要记住两点：</p>
<ol>
<li><strong>应用定义与开发</strong>、<strong>编排和管理</strong>、<strong>运行时</strong>、<strong>提供者</strong> 这四块是自上而下的核心链路，下层为上层提供能力支撑</li>
<li><strong>Observability and Analysis</strong> 是核心链路旁边的重要支撑</li>
</ol>
<p>相信到这里，你对CNCF已经有了初步认识。</p>
<h2 id="2022-01-06-《我做系统架构的一些原则》From-陈皓"><a href="#2022-01-06-《我做系统架构的一些原则》From-陈皓" class="headerlink" title="2022-01-06 《我做系统架构的一些原则》From 陈皓"></a>2022-01-06 《我做系统架构的一些原则》From 陈皓</h2><p>今天，给大家推荐一篇来自左耳朵耗子-陈皓的<a href="https://coolshell.cn/articles/21672.html">文章</a>。</p>
<ol>
<li>关注于真正的收益而不是技术本身</li>
<li>以应用服务和 API 为视角，而不是以资源和技术为视角</li>
<li>选择最主流和成熟的技术</li>
<li>完备性会比性能更重要</li>
<li>制定并遵循服从标准、规范和最佳实践</li>
<li>重视架构扩展性和可运维性</li>
<li>对控制逻辑进行全面收口</li>
<li>不要迁就老旧系统的技术债务</li>
<li>不要依赖自己的经验，要依赖于数据和学习</li>
<li>千万要小心 X – Y 问题，要追问原始需求</li>
<li>激进胜于保守，创新与实用并不冲突</li>
</ol>
<p>以上11点，理解会因人而异，我重点挑三个争议性比较大的聊聊，其余的内容建议大家阅读原文。</p>
<h3 id="完备性会比性能更重要"><a href="#完备性会比性能更重要" class="headerlink" title="完备性会比性能更重要"></a>完备性会比性能更重要</h3><p>借用书中的一句话：<strong>使用最科学严谨的技术模型为主，并以不严谨的模型作为补充</strong>，也就是先紧后松。</p>
<p>有不少开发者在实际工程中的实践往往相反：为了追求快速落地，会希望毕其功于一役，引入所谓的“一站式解决方案”（如例子中NoSQL），但实践下来引入大量的问题，让后人叫苦不迭。</p>
<p>关于这个问题，我个人有三个思考：</p>
<ul>
<li><strong>不断提高自己的基础能力</strong>。很多架构上的局限性，往往是设计者停留于自己的舒适区，不愿意往前一步。</li>
<li><strong>分清主次、合理分工。</strong> 在设计时，我们要分清楚核心功能和非核心功能，懂得取舍，将功能交由合适的模块或软件。</li>
<li><strong>功能的实现不是对应到单模块，而是整个系统的涌现。</strong>性能问题的解法不仅仅限于单个软件，而是有一整套生态，可以多去查一些大厂的分享。</li>
</ul>
<h3 id="不要迁就老旧系统的技术债务"><a href="#不要迁就老旧系统的技术债务" class="headerlink" title="不要迁就老旧系统的技术债务"></a>不要迁就老旧系统的技术债务</h3><p>为了缩小讨论范围，我对这里 <strong>技术债务</strong> 做一个收口：不仅仅是指有弊端的技术问题，更是需要投入时间精力等成本去维护。有技术债务，不代表就一定要去还，而需要一个契机 - <strong>维护的成本 &gt; 修复的收益</strong>。</p>
<p>举个例子，某个程序写得很烂，性能很差：</p>
<ul>
<li>前期可以通过扩容快速解决，上线后业务收益很高，那就是 成本大于收益，不需要排到最高优先级去修复；</li>
<li>但随着业务收益稳定下来，增长只有个位数，但发现在机器上投入的成本很高，通过优化预计能缩容50%，可以让总收益提升20%，那这时还技术债务的优先级就很高了。</li>
</ul>
<p>还技术债，技术能力只是一个基本，以下两点更为重要：</p>
<ul>
<li>评估成本与收益，尽可能地做到有数据支撑，有助于决策者下决心还债；</li>
<li>用更长远、更广维度地看待技术债务问题，不要拆东墙补西墙。</li>
</ul>
<h3 id="激进胜于保守，创新与实用并不冲突"><a href="#激进胜于保守，创新与实用并不冲突" class="headerlink" title="激进胜于保守，创新与实用并不冲突"></a>激进胜于保守，创新与实用并不冲突</h3><p>这个观点是很aggressive的，遇到这样的观念冲突时，决策者找不到客观标准去评估，就很难有二义性的定义：要么激进，要么保守；要么创新，要么实用。这种情况下，我遇到过的比较好的解法有两种：</p>
<ol>
<li>决策者自身技术能力强，能掌控团队技术的大致走向。</li>
<li>决策者和执行者之间培养出足够的信任，适当评审与把控，放权实践。</li>
</ol>
<p>第一种情况在实际工作场景中并不多见，尤其当团队规模很大时，就像CTO往往不是公司技术最强的那位。所以，我更倾向于大家多尝试第二种途径。</p>
<p>当然，我也遇到过很多效果不好的解法，比如说：决策者既然不清楚怎么做才好，那就找2个执行者进行battle，一个代表创新方，另一个代表保守方。也许在少数情况下，最后能帮助决策者找到正确的方向；但更多的实际场景中，会产生如下问题：</p>
<ul>
<li>两个执行者碰撞越来越激烈，但始终谁也说服不了谁</li>
<li>决策者越听越迷茫，不知道该如何抉择</li>
</ul>
<p>在我看来，这类决策者往往是偏管理，技术上的掌控力不足，导致在决策时没有足够的倾向性；同时，与执行者之间的信任也不足，就希望把决策这件事下移、尝试着走平衡之道。</p>
<p>我个人的想法是：先选择一个能力相对优秀的执行者，认真评估其方案，然后交由对方执行；最后哪怕失败了，也可以通过复盘改进，想想下次如何更好地决策，更好地把控方案；当然，如果你认为纯粹是执行者的问题，那就换个可信赖的人。</p>
<blockquote>
<p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>
]]></content>
      <categories>
        <category>每日技术分享</category>
      </categories>
      <tags>
        <tag>Daily-Sharing</tag>
      </tags>
  </entry>
</search>
