<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"8.0.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="Blog信息">
<meta property="og:type" content="website">
<meta property="og:title" content="Junedayday Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Junedayday Blog">
<meta property="og:description" content="Blog信息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Junedayday">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Junedayday Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Junedayday Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">六月天天的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Junedayday</p>
  <div class="site-description" itemprop="description">Blog信息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">83</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/go-leetcode/go-leetcode-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/go-leetcode/go-leetcode-11/" class="post-title-link" itemprop="url">Go算法实战 - 11.【全排列LeetCode-46】</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-21 12:00:00" itemprop="dateCreated datePublished" datetime="2022-02-21T12:00:00+08:00">2022-02-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-02-20 21:33:17" itemprop="dateModified" datetime="2022-02-20T21:33:17+08:00">2022-02-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">算法实战</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="Leetcode-46-全排列"><a href="#Leetcode-46-全排列" class="headerlink" title="Leetcode-46 全排列"></a>Leetcode-46 全排列</h2><p>原题链接 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/21/go-leetcode/go-leetcode-11/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/sharing-5min/2022-02/2022Week08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/sharing-5min/2022-02/2022Week08/" class="post-title-link" itemprop="url">五分钟技术小分享 - 2022Week08</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-02-21 12:00:00 / 修改时间：22:06:19" itemprop="dateCreated datePublished" datetime="2022-02-21T12:00:00+08:00">2022-02-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">每日技术分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57581641299795_.pic_hd.jpg" alt="2022-02"></p>
<h2 id="2022-02-21-自顶向下地写出优雅的Goroutine（下）"><a href="#2022-02-21-自顶向下地写出优雅的Goroutine（下）" class="headerlink" title="2022-02-21 自顶向下地写出优雅的Goroutine（下）"></a>2022-02-21 自顶向下地写出优雅的Goroutine（下）</h2><p>通过前面两篇的铺垫，我们对 <strong>父子进程的生命周期管理</strong> 与 <strong>select代码的核心机制</strong> 有了基本的了解。</p>
<p>今天我们再接着看看在具体工程中的优化点。注意，在上一篇，我们已经把问题聚焦到了耗时较长的处理函数中。</p>
<h3 id="实时处理"><a href="#实时处理" class="headerlink" title="实时处理"></a>实时处理</h3><p>我们先看回顾上一讲的这段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">	<span class="keyword">go</span> LongLogic()</span><br></pre></td></tr></table></figure>

<p>简单想一下，我们会觉得<code>LongLogic()</code>这里会很容易出现性能问题：当<code>dataCh</code>的数据写入速度很快时，有大量的<code>LongLogic()</code>还未结束、仍在程序内运行，导致CPU超负荷。</p>
<p>但是，如果这些代码编写的逻辑问题确实就是业务逻辑，即：<strong>程序确确实实需要实时处理这么多的数据</strong>，那我们该怎么做呢？</p>
<p>常规思路中引入 <strong>排队机制</strong> 确实是一个方案，但很容易破坏原始需求 - <strong>实时计算处理</strong>，排队机制会导致延迟，那这就是业务无法接收的。在现实中，扩增资源是最直观的解决方案，最常见是利用Kubernetes平台的Pod水平扩容机制，保证CPU使用率到达一定程度后自动扩容，而不用在程序中加上限制。</p>
<p>这个问题的本质上是实时计算资源的需求。</p>
<h3 id="非实时处理-程序外优化"><a href="#非实时处理-程序外优化" class="headerlink" title="非实时处理 - 程序外优化"></a>非实时处理 - 程序外优化</h3><p>在实际工程中，我们其实往往对实时性要求没有那么高，所以排队等限流机制带来的延时可以接受的。而综合考虑到研发代码质量的不确定性，迭代过程可能中会引入bug导致调用量暴增，这时限流机制能提升程序的健壮性。</p>
<p>在程序外部，我们可以依赖消息队列进行削峰填谷：</p>
<ul>
<li>配置消息积压的告警来保证生产者程序的监控</li>
<li>配置限流参数来保证不要超过消费者程序的处理极限</li>
</ul>
<p>在这里，消费队列在软件架构中是一个 <strong>分离生产与消费程序</strong> 的设计，有利于两侧程序的健壮性。在计算密集型的场景中，意义尤为重大。</p>
<h3 id="非实时处理-程序内优化"><a href="#非实时处理-程序内优化" class="headerlink" title="非实时处理 - 程序内优化"></a>非实时处理 - 程序内优化</h3><p>上面消息队列方案虽然很棒，但从系统来说引入了一个新的组件，有时一种杀鸡用牛刀的感觉，对部分没有消息队列的团队来说也比较难以接受。</p>
<p>那么，我们尝试在程序中做一下优化。首先，我们在上层要做一次抽象，将逻辑收敛到一个独立的package中(示例中为logic)，方便后续优化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">			<span class="comment">// logic包内部保证</span></span><br><span class="line">			logic.Run()</span><br><span class="line">		<span class="keyword">case</span> result := &lt;-logic.Finish():</span><br><span class="line">			fmt.Println(<span class="string">&quot;result&quot;</span>, result)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而logic包中的大致框架如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> logic</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> finishedCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在这里引入排队机制</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// long time process</span></span><br><span class="line">		</span><br><span class="line">		&lt;-finishedCh</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Finish</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> finishedCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以在这里加一个<code>error</code>返回，在排队满时返回给调用方，由调用方决定怎么处理，如丢弃或重新排队等。排队机制的代码是业务场景决定的，我就不具体写了，本质上类似于一个线程池管理。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从今天，我们分别从三个场景分析了耗时较长的处理函数：</p>
<ul>
<li><strong>实时处理</strong> - 结合Paas平台进行资源扩容</li>
<li><strong>非实时处理 - 程序外优化</strong> - 引入消息队列</li>
<li><strong>非实时处理 - 程序内优化</strong> - 程序内的线程池</li>
</ul>
<p>到这里，我们自顶向下地写出优雅的Goroutine的三讲已经完成了，希望对大家有所启发，也欢迎向我提问。</p>
<h2 id="2022-02-22-CNCF-Prometheus"><a href="#2022-02-22-CNCF-Prometheus" class="headerlink" title="2022-02-22 CNCF-Prometheus"></a>2022-02-22 CNCF-Prometheus</h2><p>看完了调度管理层与应用层的项目后，我们接下来看看可观察性和分析这块，这块非常有助于提升我们对整套系统的掌控程度。</p>
<p>作为CNCF中第二个毕业的项目 - Prometheus，它提供了软件系统核心的监控功能。我们今天就从核心架构入手，了解其特性。</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/prom-architecture.png" alt="prom-architecture"></p>
<p>这张图中的内容核心分为五块：</p>
<ul>
<li>指标收集端 - Exporters + Pushgateway</li>
<li>服务端 - Prometheus Server</li>
<li>服务发现 - Kubernetes等</li>
<li>告警 - Alertmanager</li>
<li>展示 - Prometheus web UI + Grafana等</li>
</ul>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/19/go-leetcode/go-leetcode-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/19/go-leetcode/go-leetcode-10/" class="post-title-link" itemprop="url">Go算法实战 - 10.【圆环回原点问题】</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-02-19 12:00:00 / 修改时间：21:32:23" itemprop="dateCreated datePublished" datetime="2022-02-19T12:00:00+08:00">2022-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">算法实战</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="经典面试题-圆环回原点问题"><a href="#经典面试题-圆环回原点问题" class="headerlink" title="经典面试题 圆环回原点问题"></a>经典面试题 圆环回原点问题</h2><p>0-12共13个数构成一个环，从0出发，每次走1步，走n步回到0共有多少种走法？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CircleToOrigin</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/19/go-leetcode/go-leetcode-10/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/14/sharing-5min/2022-02/2022Week07/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/14/sharing-5min/2022-02/2022Week07/" class="post-title-link" itemprop="url">五分钟技术小分享 - 2022Week07</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-14 12:00:00" itemprop="dateCreated datePublished" datetime="2022-02-14T12:00:00+08:00">2022-02-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-02-18 21:50:32" itemprop="dateModified" datetime="2022-02-18T21:50:32+08:00">2022-02-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">每日技术分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57581641299795_.pic_hd.jpg" alt="2022-02"></p>
<h2 id="2022-02-14-CNCF-Argo"><a href="#2022-02-14-CNCF-Argo" class="headerlink" title="2022-02-14 CNCF-Argo"></a>2022-02-14 CNCF-Argo</h2><p><code>Argo</code>是Kubernetes上最受欢迎的工作流引擎，已经有大量的用户群体与软件生态。围绕着Workflow这个关键词，我们来一起初步了解<code>Argo</code>。</p>
<blockquote>
<p>Workflow engine for Kubernetes</p>
</blockquote>
<ul>
<li>官网 - <a target="_blank" rel="noopener" href="https://argoproj.github.io/">https://argoproj.github.io/</a></li>
<li>Github - <a target="_blank" rel="noopener" href="https://github.com/argoproj/argo-workflows">https://github.com/argoproj/argo-workflows</a></li>
</ul>
<h3 id="Argo-Workflow"><a href="#Argo-Workflow" class="headerlink" title="Argo Workflow"></a>Argo Workflow</h3><p>官方的介绍分为四点（前两点描述的是基本原理，后两者描述的是特定应用的价值）：</p>
<ol>
<li>工作流的每一个步骤都是一个容器；</li>
<li>以DAG（有向无环图）来分析工作流的依赖；</li>
<li>对计算密集型任务（如机器学习、大数据处理），能充分利用k8s集群的相对空闲的碎片时间；</li>
<li>结合CICD流水线，让应用能运行在云原生环境里快速迭代；</li>
</ol>
<h3 id="为什么使用Argo-Workflow"><a href="#为什么使用Argo-Workflow" class="headerlink" title="为什么使用Argo Workflow"></a>为什么使用Argo Workflow</h3><p><code>Argo</code>的工作流对标传统的CICD有很多亮点，但如果谈论其核心价值，主要集中在两点：</p>
<ol>
<li>保证应用的整个生命周期都基于云原生生态，彻底抛弃原来的虚拟机等模式；</li>
<li>完全对接云原生，有利于充分利用Kubernetes实现更便捷的并行、扩缩容等操作；</li>
</ol>
<p>我们就以一个经典的CICD Workflow的发展历程来看：</p>
<ol>
<li>传统Jenkins为核心的CICD<ol>
<li>提交代码到Gitlab</li>
<li>触发Jenkins编译任务，某VM服务器编译出二进制文件并发布</li>
<li>触发Jenkins部署任务，将二进制文件发布到对应机器并重新运行程序</li>
</ol>
</li>
<li>改进版 - 容器化，将Gitlab/Jenkins/编译服务器等都改造到容器化平台中</li>
<li>云原生化 - 利用Argo Workflow</li>
</ol>
<blockquote>
<p>第二与第三阶段的区分并不清晰，我个人会从 <strong>配置是否集中化</strong> 这个特点进行分析。</p>
</blockquote>
<p>目前很多大公司的CICD仍处于第二阶段，但它们沉淀出了不少类似于<code>Argo</code>工作流的能力。我们可以从以下三点进行思考：</p>
<ol>
<li><strong>工作流是和公司强相关的</strong>：往往依赖公司内的各种平台，如OA；</li>
<li><strong>工作流的开发难度不高</strong>：只要规则清晰、要求严格，整体的开发量并不大，所以有能力、有资源的大公司，并不愿意太依赖开源生态；</li>
<li><strong>云原生的工作流价值仍比较有限</strong>：<code>Argo</code>体现出的价值，有不少类似的方案可以替代；</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>Argo</code>项目的用户在社区中日趋增长，这其实体现出了一个趋势 - <strong>互联网进入精耕细作的阶段</strong>。</p>
<p>在野蛮生长阶段遇到瓶颈时，公司会趋向于用扩增大量的人力或机器资源来解决问题；而在精耕细作阶段，随着Kubenetes为代表的基础平台能力的标准化，整个生态提供了丰富的能力集，技术人员更应重视遵循规范，把时间投入到合理的方向，来快速地迭代业务。</p>
<p>这时，以<code>Argo</code>为代表的工作流引擎，能帮助整个开发体系落地自动化的规范，自然越来越受到欢迎。</p>
<h2 id="2022-02-15-谈谈对Go接口断言的误区"><a href="#2022-02-15-谈谈对Go接口断言的误区" class="headerlink" title="2022-02-15 谈谈对Go接口断言的误区"></a>2022-02-15 谈谈对Go接口断言的误区</h2><p>最近有好几个朋友和我聊到Go语言里的接口interface相关的使用方法，发现了一个常见的误区。今天，我分享一下我的思考，希望能给大家带来启发。</p>
<h3 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">interface</span> &#123;</span><br><span class="line">  Pay() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">orderImpl1</span> <span class="title">struct</span></span>&#123;</span><br><span class="line">  Id <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(order *orderImpl1)</span><span class="title">Pay</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">orderImpl2</span> <span class="title">struct</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(order *orderImpl2)</span><span class="title">Pay</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很常见的接口与实现的示例。</p>
<h3 id="接口断言背后的真正问题"><a href="#接口断言背后的真正问题" class="headerlink" title="接口断言背后的真正问题"></a>接口断言背后的真正问题</h3><p>在代码中，我们经常会对抽象进行断言，来获取更详细的信息，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 在这里是一个接口</span></span><br><span class="line">  <span class="keyword">var</span> order Order</span><br><span class="line">  <span class="comment">// 断言是orderImpl1，并打印其中内容</span></span><br><span class="line">  <span class="keyword">if</span> o,ok := order.(orderImpl1); ok &#123;</span><br><span class="line">    fmt.Println(o.Id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很清晰，让我们层层递进，思考一下这段代码背后的真正逻辑：程序要使用 <strong>接口背后的具体实现</strong>（orderImpl1中的Id字段）。</p>
<p>这种做法，就和接口所要解决的问题背道而驰了：接口是为了屏蔽具体的实现细节，而这里的代码又回退成了具体实现。所以，这个现象的真正问题是：<strong>接口抽象得不够完全</strong>。</p>
<h3 id="解法1：新增获取方法"><a href="#解法1：新增获取方法" class="headerlink" title="解法1：新增获取方法"></a>解法1：新增获取方法</h3><p>这个解法很直接，我们增加一个接口方法即可，如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Order <span class="keyword">interface</span> &#123;</span><br><span class="line">  Pay() error</span><br><span class="line">  GetId() <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果要区分具体实现，即orderImpl2没有Id字段，我们最好采用一个error字段进行区分：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Order <span class="keyword">interface</span> &#123;</span><br><span class="line">  Pay() error</span><br><span class="line">  GetId() (<span class="keyword">int64</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：封装背后的真正逻辑"><a href="#解法2：封装背后的真正逻辑" class="headerlink" title="解法2：封装背后的真正逻辑"></a>解法2：封装背后的真正逻辑</h3><p>上面<code>GetId</code>这个方法，只是一个具体动作，按DDD的说法，这是一个贫血的模型。我们真正要关注的是 - <strong>获取Id后真正的业务逻辑，将其封装成一个方法</strong>。</p>
<p>比如说，我们要获取这个Id后，想要根据这个Id取消这个订单，那么完全可以封装到一个<code>Cancel()</code>函数中；</p>
<p>又比如说，我们仅仅想要打印具体实现的内部信息，那么完全可以实现一个<code>Debug() string</code>方法，将想要的内容都拼成字符串返回出来。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>今天讲的这个case在业务开发中非常常见，它是一种惯性思维解决问题的产物。我们无需苛求所有抽象都要到位，但心里一定要有明确的解决方案。</p>
<h2 id="2022-02-16-CNCF-Flux"><a href="#2022-02-16-CNCF-Flux" class="headerlink" title="2022-02-16 CNCF-Flux"></a>2022-02-16 CNCF-Flux</h2><p>今天我们来看CNCF中另一款持续交付的项目 - <code>Flux</code>。相对于<code>Argo</code>，<code>Flux</code>的应用范围不广，但它的功能更加简洁、使用起来也更为便捷。</p>
<ul>
<li>官网 - <a target="_blank" rel="noopener" href="https://fluxcd.io/">https://fluxcd.io/</a></li>
<li>Github - <a target="_blank" rel="noopener" href="https://github.com/fluxcd/flux2">https://github.com/fluxcd/flux2</a></li>
</ul>
<h3 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h3><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/gitops-toolkit.png" alt="gitops-toolkit"></p>
<p><code>Flux</code>的核心实现非常清晰，主要分为两块：</p>
<ol>
<li>Source controller用于监听Source的变化，如常见的github、gitlab、helm；</li>
<li>将部署任务，交由Kustomize controller 或 Helm controller进行实现；</li>
</ol>
<blockquote>
<p>这里有一个秀英语单词的技巧，在软件系统里经常会将定制化这个词，Customize用Kustomize代替。</p>
</blockquote>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>官方的核心概念如下：<a target="_blank" rel="noopener" href="https://fluxcd.io/docs/concepts/">https://fluxcd.io/docs/concepts/</a></p>
<ol>
<li>GitOps的理念有很多说法，可以简单认为就是：<strong>围绕着Git而展开的一套CICD机制</strong>。</li>
</ol>
<blockquote>
<p>GitOps is a way of managing your infrastructure and applications so that whole system is described declaratively and version controlled (most likely in a Git repository), and having an automated process that ensures that the deployed environment matches the state specified in a repository.</p>
</blockquote>
<ol start="2">
<li>Source源，包括期望状态与获取的途径。</li>
</ol>
<blockquote>
<p>A <em>Source</em> defines the origin of a repository containing the desired state of the system and the requirements to obtain it (e.g. credentials, version selectors). </p>
</blockquote>
<ol start="3">
<li>Reconciliation协调，重点是怎么协调、也就是Controller执行的逻辑，最常见的就是自己编写一个Operator。</li>
</ol>
<blockquote>
<p>Reconciliation refers to ensuring that a given state (e.g. application running in the cluster, infrastructure) matches a desired state declaratively defined somewhere (e.g. a Git repository).</p>
</blockquote>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>CICD相关软件目前的格局还不是很清晰，建议大家多花时间在选型上，尽可能地符合自己的业务场景，而不建议做过多的二次开发。<code>Flux</code>是一个非常轻量级的CD项目，对接起来很方便，很适合无历史包袱的研发团队快速落地。</p>
<h2 id="2022-02-17-自顶向下地写出优雅的Goroutine（上）"><a href="#2022-02-17-自顶向下地写出优雅的Goroutine（上）" class="headerlink" title="2022-02-17 自顶向下地写出优雅的Goroutine（上）"></a>2022-02-17 自顶向下地写出优雅的Goroutine（上）</h2><p><code>Go</code>语言的Goroutine特性广受好评，让初学者也能快速地实现并发。但随着不断地学习与深入，有很多开发者都陷入了对<code>goroutine</code>、<code>channel</code>、<code>context</code>、<code>select</code>等并发机制的迷惑中。</p>
<p>那么，我将自顶向下地介绍这部分的知识，帮助大家形成体系。具体的代码以下面这段为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> SubFoo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>Foo()</code>为<strong>父Goroutine</strong>，内部开启了一个<strong>子Goroutine</strong> - <code>SubFoo()</code>。</p>
<h3 id="聚焦核心"><a href="#聚焦核心" class="headerlink" title="聚焦核心"></a>聚焦核心</h3><p><strong>父Goroutine</strong> 与 <strong>子Goroutine</strong> 最重要的交集 - 是两者的生命周期管理。包括三种：</p>
<ol>
<li>互不影响 - 两者完全独立</li>
<li>parent控制children - 父Goroutine结束时，子Goroutine也能随即结束</li>
<li>children控制parent - 子Goroutine结束时，父Goroutine也能随即结束</li>
</ol>
<p>这个生命周期的关系，体现了一种控制流的思想。</p>
<blockquote>
<p>注意，这个时候不要去关注具体的数据或代码实现，初学者容易绕晕。</p>
</blockquote>
<h3 id="1-互不影响"><a href="#1-互不影响" class="headerlink" title="1-互不影响"></a>1-互不影响</h3><p>两个Goroutine互不影响的代码很简单，如同示例。</p>
<p>不过我们要注意一点，如果子goroutine需要context这个入参，尽量新建。这点我们看第二个例子就清楚了。</p>
<h3 id="2-parent控制children"><a href="#2-parent控制children" class="headerlink" title="2-parent控制children"></a>2-parent控制children</h3><p>下面是一个最常见的用法，也就是利用了context：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="comment">// 退出前执行，表示parent执行完了</span></span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> SubFoo(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		<span class="comment">// parent完成后，就退出</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，context并不是唯一的解法，我们也可以自建一个channel用来通知关闭。但综合考虑整个Go语言的生态，更建议大家尽可能地使用context，这里不扩散了。</p>
<blockquote>
<p>延伸 - 如果1个parent要终止多个children时，context的这种方式依然适用。</p>
</blockquote>
<h3 id="3-children控制parent"><a href="#3-children控制parent" class="headerlink" title="3-children控制parent"></a>3-children控制parent</h3><p>这部分的逻辑也比较直观：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> SubFoo(ch)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 获取通知并退出</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ch:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 通知parent的channel</span></span><br><span class="line">	ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="情况3的延伸"><a href="#情况3的延伸" class="headerlink" title="情况3的延伸"></a>情况3的延伸</h3><p>如果1个parent产生了n个children时，又会有以下两种情况：</p>
<ol>
<li>n个children都结束了，才停止parent</li>
<li>n个children中有m个结束，就停止parent</li>
</ol>
<p>其中，前者的最常用的解决方案如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg = <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line">	wg.Add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> SubFoo(wg)</span><br><span class="line">	<span class="keyword">go</span> SubFoo(wg)</span><br><span class="line">	<span class="keyword">go</span> SubFoo(wg)</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这两个延伸情况更多的解法，就留给大家自己去思考了，它们有不止一种解法。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>从生命周期入手，我们能快速地形成代码的基本结构：</p>
<ol>
<li>互不影响 - 注意context独立</li>
<li>parent控制children - 优先用context控制</li>
<li>children控制parent - 一对一时用channel，一对多时用sync.WaitGroup等</li>
</ol>
<p>但在实际的开发场景中，parent和children的处理逻辑会有很多复杂的情况，导致我们很难像示例那样写出优雅的<code>select</code>等方法，我们会在下期继续分析，但不会影响我们今天梳理出的框架。</p>
<h2 id="2022-02-18-自顶向下地写出优雅的Goroutine（中）"><a href="#2022-02-18-自顶向下地写出优雅的Goroutine（中）" class="headerlink" title="2022-02-18 自顶向下地写出优雅的Goroutine（中）"></a>2022-02-18 自顶向下地写出优雅的Goroutine（中）</h2><p>通过上一篇，我们通过生命周期管理了解了父子进程的大致模型。</p>
<p>今天，我们将更进一步，分析优雅的Goroutine的核心语法 - select。</p>
<h3 id="了解select的核心意义"><a href="#了解select的核心意义" class="headerlink" title="了解select的核心意义"></a>了解select的核心意义</h3><p>我们看一个官方的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> c &lt;- x:</span><br><span class="line">			x, y = y, x+y</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			fmt.Println(&lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">		quit &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line">	fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很长，我们聚焦于select这块，它实现了两个功能：</p>
<ol>
<li>传递数据</li>
<li>传递停止的信号</li>
</ol>
<p>这时，如果你深入去理解这两个channel的用法，容易陷入对select理解的误区；而我们应该从更高的维度，去看这两个case中获取到数据后的操作，才能真正掌握。</p>
<h3 id="分析select中的case"><a href="#分析select中的case" class="headerlink" title="分析select中的case"></a>分析select中的case</h3><p>我们要注意到，在case里代码运行的过程中，整个goroutine都是忙碌的（除非调用panic，return，os.Exit()等函数退出）。</p>
<p>以上面的代码为例，如果<code>x, y = y, x+y</code>函数的处理耗时，远大于<code>x</code>这个通道中塞入数据的速度，那么这个<code>x</code>的写入处，将长期处于排队的阻塞状态。这时，不适合采用select这种模式。</p>
<p>所以说，<strong>select适合IO密集型逻辑，而不适合计算密集型</strong>。也就是说，select中的每个case，应尽量花费少的时间。IO密集型常指文件、网络等操作，它消耗的CPU很少、更多的时间在等待返回。</p>
<blockquote>
<p>Go 的 select这个关键词，可以结合网络模型中的select进行理解。</p>
</blockquote>
<h3 id="父子进程中的长逻辑处理"><a href="#父子进程中的长逻辑处理" class="headerlink" title="父子进程中的长逻辑处理"></a>父子进程中的长逻辑处理</h3><p>这时，如果我们的父子进程里，就是有那么一长段的业务逻辑，那代码该怎么写呢？我们来看看下面这一段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">			LongLogic()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LongLogic</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如1累加到10000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>LongLogic()</code>会花费很长的运行时间，所以当外部的context取消了，也就是父Goroutine发出通知可以结束了，这个子Goroutine是无法快速触发到<code>&lt;-ctx.Done()</code>的，因为它还在跑<code>LongLogic()</code>里的代码。也就是说，子进程生命周期结束的时间点延长到<code>LongLogic()</code>之后了。</p>
<p>所以，根本原因在于违背了我们上面说的原则，即在select的case/default里包含了计算密集型任务。</p>
<blockquote>
<p>case里包含长逻辑不代表程序一定有问题，但或多或少地不符合select+channel的设计理念。</p>
</blockquote>
<h3 id="两个长逻辑处理"><a href="#两个长逻辑处理" class="headerlink" title="两个长逻辑处理"></a>两个长逻辑处理</h3><p>这时，我们再来写个长进程处理，整个代码结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">			LongLogic()</span><br><span class="line">		<span class="keyword">case</span> &lt;-dataCh2:</span><br><span class="line">			LongLogic()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，dataCh和dataCh2会产生竞争，也就是两个通道的 <strong>写长期阻塞、读都在等待LongLogic执行完成</strong>。给channel加个buffer可以减轻这个问题，但无法根治，运行一段时间依旧阻塞。</p>
<h3 id="改造思路"><a href="#改造思路" class="headerlink" title="改造思路"></a>改造思路</h3><p>有了上面代码的基础，改造思路比较直观了，将<code>LongLogic</code>异步化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">			<span class="keyword">go</span> LongLogic()</span><br><span class="line">		<span class="keyword">case</span> &lt;-finishedCh:</span><br><span class="line">			fmt.Println(<span class="string">&quot;LongLogic finished&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LongLogic</span><span class="params">()</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Minute)</span><br><span class="line">	finishedCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要注意一个点，如果<code>LongLogic()</code>是一段需要CPU密集计算的代码，比如计算1累加到10000，它是没有办法通过channel等其余方式突然中止的。它具备一定的原子性 - <strong>要么不跑，要么跑完，没有Channel的插手的地方</strong>。</p>
<p>而如果硬要中断<code>LongLogic()</code>，那就是杀掉整个进程。</p>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>今天的内容是围绕着select这个关键词展开的，我们记住select代码块设计的核心要领 - IO密集型。Go语言的goroutine特性，更多地是为了解决IO密集型程序的问题所设计的编程语言，对计算密集型的任务较其它语言很难体现出其价值。</p>
<p>落到具体实践上，就是让每个case中代码的运行时间尽可能地短，快速回到for循环里的select去继续监听各个case中的channel。</p>
<p>上面这段代码比较粗糙，在具体工程中会遇到很多问题，比如无脑地开启了大量的<code>LongLogic()</code>协程。我们会放在最后一讲再来细谈。</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/07/sharing-5min/2022-02/2022Week06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/07/sharing-5min/2022-02/2022Week06/" class="post-title-link" itemprop="url">五分钟技术小分享 - 2022Week06</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-07 12:00:00" itemprop="dateCreated datePublished" datetime="2022-02-07T12:00:00+08:00">2022-02-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-02-13 13:34:40" itemprop="dateModified" datetime="2022-02-13T13:34:40+08:00">2022-02-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">每日技术分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57581641299795_.pic_hd.jpg" alt="2022-02"></p>
<h2 id="2022-02-07-CNCF-CloudEvents"><a href="#2022-02-07-CNCF-CloudEvents" class="headerlink" title="2022-02-07 CNCF-CloudEvents"></a>2022-02-07 CNCF-CloudEvents</h2><p>今天，我们一起来看<code>CloudEvents</code>，并不是一款成熟的软件系统，而更像是一种协议与标准。不过，它提出的相关概念，对我们开发与设计软件系统时，很有参考意义。</p>
<ul>
<li>官网 - <a target="_blank" rel="noopener" href="https://cloudevents.io/">https://cloudevents.io/</a> </li>
<li>Github - <a target="_blank" rel="noopener" href="https://github.com/cloudevents/spec">https://github.com/cloudevents/spec</a></li>
</ul>
<h3 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h3><blockquote>
<p>CloudEvents is a vendor-neutral specification for defining the format of event data.</p>
</blockquote>
<p>顾名思义，<code>CloudEvents</code>项目旨在定义 <strong>云时代的事件</strong>。事件是一个很广的定义，在不同的软件系统里有不同的表现形式。</p>
<p>想要将所有软件系统里的事件进行标准化，这里面的工作量与难度可想而知，在很长一段时间内很难落地。在我看来，这个项目的意义是长期的 - <strong>先提供一套切实可行的标准与SDK，再尝试结合云原生生态的在核心项目中落地，最后再大规模推广</strong>。</p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>事件里涉及到了很多概念，我选择其中的核心概念，并将其分成了两类。</p>
<blockquote>
<p> 完整的内容可以参考： <a target="_blank" rel="noopener" href="https://github.com/cloudevents/spec/blob/v1.0.1/spec.md#notations-and-terminology">https://github.com/cloudevents/spec/blob/v1.0.1/spec.md#notations-and-terminology</a> </p>
</blockquote>
<p>数据类：</p>
<ol>
<li>Occurrence - 发生（客观事实）</li>
<li>Data - 数据</li>
<li>Context - 上下文</li>
<li>Event - 事件</li>
</ol>
<p>传输类：</p>
<ol>
<li>Producer - 生产者</li>
<li>Intermediary - 中介</li>
<li>Consumer - 消费者</li>
<li>Event Format - 事件格式</li>
<li>Message - 消息</li>
<li>Protocol - 协议</li>
</ol>
<h3 id="关键字段"><a href="#关键字段" class="headerlink" title="关键字段"></a>关键字段</h3><p><code>CloudEvents</code>给出了规范的同时，也给出了多语言的SDK。我们可以参考它的命名方式，引入到自己的开发系统中。</p>
<p>必填字段：</p>
<ol>
<li>id - string</li>
<li>source - URI-reference</li>
<li>specversion - string</li>
<li>type - string</li>
</ol>
<blockquote>
<p>保证 id+source 全局唯一</p>
</blockquote>
<p>可选字段：</p>
<ol>
<li>datacontenttype - string</li>
<li>dataschema - string</li>
<li>subject -string</li>
<li>time - timestamp，推荐RFC-3339</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>CloudEvents</code> 目前仍处于非常早期的阶段，有兴趣的朋友，可以尝试引入其SDK，将内部的RPC、MQ等通信数据统一起来。</p>
<p>从长期来看，将一个系统中的事件格式统一起来，对整个系统的帮助是很大的。比如说，我们完全可以将服务注册、服务发现等功能认为是一种事件，要求<code>Etcd</code>、<code>Zookeeper</code>、<code>Consul</code>等均支持该方式，就能有利于相关功能的标准化。</p>
<h2 id="2022-02-08-CNCF-NATS"><a href="#2022-02-08-CNCF-NATS" class="headerlink" title="2022-02-08 CNCF-NATS"></a>2022-02-08 CNCF-NATS</h2><p>作为CNCF中消息系统的核心项目，<code>NATS</code>受到了各大公司的青睐，近年来使用量也在逐步提升。有不少同学对消息系统的认识还比较模糊，今天我们就借<code>NATS</code>的核心模型，对消息系统有进一步的认识。</p>
<p>官网 - <a target="_blank" rel="noopener" href="https://nats.io/">https://nats.io/</a></p>
<p>Github - <a target="_blank" rel="noopener" href="https://github.com/nats-io/nats-server">https://github.com/nats-io/nats-server</a></p>
<h3 id="三种消息传递模型"><a href="#三种消息传递模型" class="headerlink" title="三种消息传递模型"></a>三种消息传递模型</h3><p><strong>发布-订阅模式</strong>：类似于广播模式</p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/publish-subscribe.png" alt="publish-subscribe"></p>
<p><strong>请求-响应模式</strong>：对应关系可自行调整，请求者必须等待到响应才认为是成功</p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/request-reply.png" alt="request-reply"></p>
<p><strong>队列-订阅模式</strong>：分布式系统中非常重要的消息队列功能，实现消息分发</p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/queue-groups.png" alt="queue-groups"></p>
<h3 id="分布式系统中的消息系统"><a href="#分布式系统中的消息系统" class="headerlink" title="分布式系统中的消息系统"></a>分布式系统中的消息系统</h3><p>了解上面三种消息传递模型后，你可能仍不清楚它们的适用场景。我建议大家深入地了解这三种模型的本质，这样更方便记忆与理解。其实，在分布式系统中，最核心的是 <strong>队列-订阅</strong> 模式，其余两种模式意义并不大。</p>
<ol>
<li><strong>发布订阅</strong> 只是 <strong>队列订阅</strong> 的一种特殊的广播模式；</li>
<li><strong>请求响应</strong> 更多地应结合服务发现能力，在RPC框架中进行实现；</li>
</ol>
<blockquote>
<p>第一点的使用场景不多见，举个例子：</p>
<p>服务2有多个实例，本地内存里保存了一些信息；现在服务1要更新所有服务2中内存的信息，就需要采用发布-订阅模式，否则会导致服务间数据不一致。</p>
<p>如果服务2引入了分布式缓存，那就是队列-订阅模式。</p>
</blockquote>
<p>那么，<strong>队列-订阅模式</strong> 对分布式系统来说有什么意义呢？这其实就是消息队列的价值，我这里列举最关键的两点：</p>
<ol>
<li>削峰填谷：针对分布式系统中的性能问题，通过队列的形式，将高峰期的msg积压到Queue中，在低峰期时交给消费者处理。</li>
<li>解耦强依赖：从调用关系可以看到，其实Publisher是要将信息传递给Subscriber；但增加了Queue后，Publisher只与Queue交互，Subscriber也只与Queue交互。可以想象，即便Subscriber短暂地挂了，重启后依旧可以正常使用。</li>
</ol>
<p>分布式的消息队列还有很多注意点，这里我就不一一列举了，更多的资料大家可以自行搜索。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>虽然从生产环境的应用范围来看，<code>NATS</code>仍与老牌的重量级消息队列Kafka有相当大的差距，尤其是在大数据的系统中。但对比RocketMQ、RabbitMQ等轻量级产品，<code>NATS</code>的优势已经越来越明显，尤其是在性能与多语言的SDK上，建议有条件的朋友可以尝试使用。</p>
<h2 id="2022-02-09-CNCF-Helm"><a href="#2022-02-09-CNCF-Helm" class="headerlink" title="2022-02-09 CNCF-Helm"></a>2022-02-09 CNCF-Helm</h2><p><code>Helm</code>在整个云原生平台中扮演了重要角色。值得注意的是，<code>Helm</code>自身的复杂度并不高，它更多依赖的是优秀的设计理念与当前包含大量软件的生态。</p>
<p>官方的定义很简洁，即Kubernetes中的包管理者，即一个公共的软件仓。</p>
<blockquote>
<p>The Kubernetes Package Manager</p>
</blockquote>
<ul>
<li>官网 - <a target="_blank" rel="noopener" href="https://helm.sh/">https://helm.sh/</a></li>
<li>Github - <a target="_blank" rel="noopener" href="https://github.com/helm/helm">https://github.com/helm/helm</a></li>
<li>仓库 - <a target="_blank" rel="noopener" href="https://artifacthub.io/packages">https://artifacthub.io/packages</a></li>
</ul>
<h3 id="使用Helm"><a href="#使用Helm" class="headerlink" title="使用Helm"></a>使用Helm</h3><p>类似于Dockerhub，<code>Helm</code>的一大特色就是使用起来非常简单，可快速地在Kubernetes环境中安装软件。</p>
<p>以Kubernetes中的证书管理为例，我们可以参考链接 - <a target="_blank" rel="noopener" href="https://artifacthub.io/packages/helm/cert-manager/cert-manager">https://artifacthub.io/packages/helm/cert-manager/cert-manager</a> ，可以快速地通过几个命令就能完成下载与部署。</p>
<p>我希望大家能注意到：<strong>低门槛是吸引用户的重要因素，但真正决定软件长期走向的，是它自身的核心功能</strong>。所以，<code>Helm</code>中的软件有三点需要特别关注：</p>
<ol>
<li>契合Kubernetes平台：许多软件原生并不支持Kubernetes，需要做一定的改造；</li>
<li>保证常规功能：如安装时要判断依赖项、卸载时清理哪些数据、升降版本兼容性等等，都是很琐碎、又是很重要的事情；</li>
<li>人工维护问题：软件是高频迭代的，尤其是在云原生环境下，核心项目往往要大量的人力投入到 FAQ、配置参数说明、兼容性问题的处理；</li>
</ol>
<p>这三点给<code>Helm</code>带来的是一种滚雪球效应，即越滚越大、越难以被替代；而这种雪球最终能支撑多大的市场，非常依赖<code>Helm</code>内部的核心设计，尤其是扩展性部分。</p>
<h3 id="Charts"><a href="#Charts" class="headerlink" title="Charts"></a>Charts</h3><p><code>Helm</code>称自己是Kubernetes平台中的包管理器，而这个包的格式被称为Charts，我们一起来看看一个官方示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wordpress/</span><br><span class="line">  Chart.yaml          # A YAML file containing information about the chart</span><br><span class="line">  LICENSE             # OPTIONAL: A plain text file containing the license for the chart</span><br><span class="line">  README.md           # OPTIONAL: A human-readable README file</span><br><span class="line">  values.yaml         # The default configuration values for this chart</span><br><span class="line">  values.schema.json  # OPTIONAL: A JSON Schema for imposing a structure on the values.yaml file</span><br><span class="line">  charts/             # A directory containing any charts upon which this chart depends.</span><br><span class="line">  crds/               # Custom Resource Definitions</span><br><span class="line">  templates/          # A directory of templates that, when combined with values,</span><br><span class="line">                      # will generate valid Kubernetes manifest files.</span><br><span class="line">  templates/NOTES.txt # OPTIONAL: A plain text file containing short usage notes</span><br></pre></td></tr></table></figure>

<p>关键在于三个目录：</p>
<ol>
<li>charts - 保存当前chart的依赖子chart</li>
<li>crds - 这是chart依赖Kubernetes实现软件运行的关键（CRD是k8s可扩展性的一大特色）</li>
<li>templates - 用来绑定chart自定义参数</li>
</ol>
<p>换一个视角，这三个文件夹体现了三种能力：</p>
<ol>
<li>charts - package能力复用</li>
<li>crds - 自定义对接Paas平台（k8s）</li>
<li>templates - 定制化参数</li>
</ol>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><code>Helm</code>是Kubernetes使用人员需要非常重视的一个产品，它能快速地帮助我们安装与部署软件。</p>
<p>不过，我不建议大家去阅读它的相关源码，它的代码并不优秀；相反地，我更建议大家可以去尝试自己做一个chart（最好能结合自己开发的程序+依赖的中间件，如go程序+redis），这样既能结合<code>Helm</code>实现应用程序的快速部署，又能去实践Kubernetes的CRD。</p>
<h2 id="2022-02-10-CNCF-Buildpacks"><a href="#2022-02-10-CNCF-Buildpacks" class="headerlink" title="2022-02-10 CNCF-Buildpacks"></a>2022-02-10 CNCF-Buildpacks</h2><p><code>Buildpacks</code>是一款对标<code>Docker</code>的镜像打包工具，虽然在CNCF中作为核心项目，但在目前的主流开发场景中用到的并不多。</p>
<ul>
<li>官网 - <a target="_blank" rel="noopener" href="https://buildpacks.io/">https://buildpacks.io/</a></li>
<li>Github - <a target="_blank" rel="noopener" href="https://github.com/buildpacks/pack">https://github.com/buildpacks/pack</a></li>
</ul>
<p>我们不妨来思考一下<code>Buildpacks</code>与竞品的核心优势：</p>
<p><code>Buildpacks</code>官网介绍自身的核心特性为3个：<code>Control</code>、<code>Compliance</code>和<code>Maintainability</code>。我们今天挑选两个关键性的特征来聊一聊。</p>
<h3 id="Control-Balanced-control-between-App-Devs-and-Operators"><a href="#Control-Balanced-control-between-App-Devs-and-Operators" class="headerlink" title="Control - Balanced control between App Devs and Operators."></a>Control - Balanced control between App Devs and Operators.</h3><p>平衡开发者与运维人员。这个也是<code>Buildpacks</code>对标<code>Docker</code>的最大优势。</p>
<p>刚熟悉Dockerfile的同学，会觉得体验很棒，只需要少数几行就能快速制作出一个镜像；但是，如果你是重度使用的用户，就会有不一样的体验：</p>
<ol>
<li>多应用的Dockerfile中有大量重复、但又有少量定制化的内容（如依赖的软件）</li>
<li>由于定制化的内容存在，往往需要开发工程师编写Dockerfile</li>
</ol>
<p>所以，维护Dockerfile成为了开发工程师很琐碎的工作，而<code>Buildpacks</code>则是希望将部分工作转移给运维人员。但在我看来，这个收益并不明显：</p>
<ol>
<li>现状：大部分的公司会封装一些基础镜像，在基础镜像上的Dockerfile所需要的命令已经很少了，整体的复杂度不会很高；</li>
<li>工作平衡：平衡的意义并没有减少整体的工作量，两种角色的人数总量仍不会有大的变化；</li>
<li>责任明确：目前大型公司的运维人员越来越少，更强调的是开发人员自己管理应用的整个生命周期；</li>
</ol>
<p>但换一个角度，<code>Buildpacks</code>理念是可以降低开发人员对Dockerfile这块的门槛，更专注于业务代码的开发。但是，编写Dockerfile这项技能本身难度不高，而且有利于研发自行排查问题，我个人是非常建议开发人员去学习的。</p>
<h3 id="Maintainability-Perform-upgrades-with-minimal-effort-and-intervention"><a href="#Maintainability-Perform-upgrades-with-minimal-effort-and-intervention" class="headerlink" title="Maintainability - Perform upgrades with minimal effort and intervention."></a>Maintainability - Perform upgrades with minimal effort and intervention.</h3><p>这一点是<code>Buildpacks</code>的一大特色。</p>
<p>如果你对Docker的镜像底层有一定的了解，会清楚一个镜像就是一层层layer的堆叠；从最上层来看，就是一个完整的操作系统。但如果只对某个layer进行更改，就得销毁老容器、再起一个新的。而<code>Buildpacks</code>则提供了rebase的能力，也就是在运行中的容器中做到快速替换某个layer，而不需要整个重建。</p>
<p>举一个例子，当前运行的容器有层layer是设置环境变量（参考Dockerfile中的ENV指令），我们要进行增加或者更改参数，就能快速实现rebase。当然，rebase肯定是有不少限制条件的，尤其是rebase中的内容不能影响到程序的运行。</p>
<p>我们不妨发散地思考这个特性的价值：由于它核心解决了无需重启整个容器的作用，所以对启动成本比较大的程序，它的意义是很大的，尤其是Java程序。</p>
<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p><code>Buildpacks</code>在社区中活跃度并不高，这也间接证明了<code>Docker</code>的统治地位，而它则需要一个合适的契机才可能得到大幅度的应用。这也提醒了我们，不要一味地追求新的技术，更应该结合现状理性分析。</p>
<h2 id="2022-02-11-CNCF-Operator-Framework"><a href="#2022-02-11-CNCF-Operator-Framework" class="headerlink" title="2022-02-11 CNCF-Operator Framework"></a>2022-02-11 CNCF-Operator Framework</h2><p><code>Operator Framework</code>是为了降低Kubernetes中Operator开发门槛，而由CNCF社区提供的一套框架。由于这一整套的解决方案门槛很高，需要使用者对Kubernetes的原理有相当的基础，所以今天我们不会深入其细节，而是通过借由这个项目更好地理解Kubernetes。</p>
<ul>
<li>官网 - <a target="_blank" rel="noopener" href="https://cloud.redhat.com/learn/topics/operators">https://cloud.redhat.com/learn/topics/operators</a></li>
<li>Github - <a target="_blank" rel="noopener" href="https://github.com/operator-framework/operator-sdk">https://github.com/operator-framework/operator-sdk</a></li>
<li>公开库 - <a target="_blank" rel="noopener" href="https://operatorhub.io/">https://operatorhub.io/</a></li>
</ul>
<h3 id="Controller的工作原理"><a href="#Controller的工作原理" class="headerlink" title="Controller的工作原理"></a>Controller的工作原理</h3><p><strong>Operator本质上，是一种定制化的Controller；而控制器的核心思想，是根据期望状态与当前状态，管理k8s中的资源。</strong>我们这边可以结合下面这张图，来了解Controller的工作原理。</p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/k8s-controller.png" alt="k8s-controller"></p>
<ol>
<li>client-go是k8s提供的代码生成工具，相关的代码会自动生成；而controller-specific是自行开发的内容；</li>
<li>期望状态与当前状态的对比逻辑，决策的结果是 新增、更新、删除对应的资源，触发对应的callbacks；</li>
<li>具体的执行工作，交给Worker执行，而结果如果未达到预期，依然会再次触发整个流程；</li>
</ol>
<blockquote>
<p>关于k8s中的controller，源码分析可以参考我之前的一篇博客 <a target="_blank" rel="noopener" href="https://junedayday.github.io/2021/02/18/k8s/k8s-012/">https://junedayday.github.io/2021/02/18/k8s/k8s-012/</a> </p>
</blockquote>
<h3 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h3><ol>
<li>Operator SDK - 快速生成Operator相关代码</li>
<li>Operator Lifecycle Manager - k8s中的生命周期管理</li>
<li>Operator Metering - 监控</li>
</ol>
<p>其中监控部分很重要，能帮助使用人员在复杂的K8s系统中排查问题。</p>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>目前<code>Operator Framework</code>虽然在社区比较受欢迎，但使用者往往仅限于k8s的深度用户；而许多大型公司又往往会自行封装k8s，不能完美兼容<code>Operator Framework</code>，导致它的推广很受限。</p>
<p>我个人有三点建议：</p>
<ol>
<li>优先去Helm里搜索成熟应用，不要自行开发Operator；</li>
<li>如果有切实的使用需求，优先去公开库 - <a target="_blank" rel="noopener" href="https://operatorhub.io/">https://operatorhub.io/</a> 搜索；</li>
<li>k8s深度玩家可忽略以上两点~</li>
</ol>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/02/go-tip/go-tip-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/02/go-tip/go-tip-14/" class="post-title-link" itemprop="url">Go语言技巧 - 14.【浅析微服务框架】go-zero概览</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-02-02 12:00:00 / 修改时间：21:59:21" itemprop="dateCreated datePublished" datetime="2022-02-02T12:00:00+08:00">2022-02-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="go-zero概况"><a href="#go-zero概况" class="headerlink" title="go-zero概况"></a>go-zero概况</h2><p><code>go-zero</code>是当前处于CNCF孵化中的一个<code>Go</code>z语言框架项目，在Github上的star数目前达到14.3K。</p>
<p>作为一款起源于国内的项目，<code>go-zero</code>的中文资料比较齐全，对国内开发者相对友好。但前景如何，还需要进一步的观察。今天我们一起来了解这个项目。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/02/go-tip/go-tip-14/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/24/sharing-5min/2022-01/2022Week04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/sharing-5min/2022-01/2022Week04/" class="post-title-link" itemprop="url">五分钟技术小分享 - 2022Week04</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-24 12:00:00" itemprop="dateCreated datePublished" datetime="2022-01-24T12:00:00+08:00">2022-01-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-01-29 12:40:40" itemprop="dateModified" datetime="2022-01-29T12:40:40+08:00">2022-01-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">每日技术分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg" alt="2022-01"></p>
<h2 id="2022-01-24-CNCF-Linkerd"><a href="#2022-01-24-CNCF-Linkerd" class="headerlink" title="2022-01-24 CNCF-Linkerd"></a>2022-01-24 CNCF-Linkerd</h2><p>今天我们来看 <strong>Orchestration &amp; Management 编排和管理</strong> 层最后一个核心项目 - Linkerd。从严格意义上来说，我们应称它为Linkerd2，区别于原来的1.0版本。</p>
<blockquote>
<p>Linkerd是Service Mesh的第一个产品，但在Google的Istio入场后在功能与性能上完全超越。这一段的历史很有意思，大家可以自行搜索了解。</p>
</blockquote>
<p>关于Service Mesh，我们已经聊过两款CNCF中的软件了 - Envoy/Contour，这个Linkerd是两者的结合。我们来看一下它的架构示意图，整体来说分为三块：</p>
<img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/control-plane.png" alt="Linkerd2" style="zoom:50%;" />

<ol>
<li>CLI - 客户端，对Linkerd2进行管理</li>
<li>Control Plane 控制平面<ol>
<li>destination 获取各类信息，如服务发现、网络策略、性能和监控指标</li>
<li>indentity 主要是TLS安全相关</li>
<li>proxy-injector 是一种Kubernetes的Admission Controller，用于对初始化pod注入linkerd相关的信息</li>
</ol>
</li>
<li>Data Plane 数据平面<ol>
<li>linkerd-proxy 核心的功能实现，包括代理、路由、TLS、限流等等</li>
<li>linkerd-init 是一种Kubernetes的Init Containter，用iptables的特性将Pod的流量都导向linkerd-proxy</li>
</ol>
</li>
</ol>
<p>Linkerd的架构非常清晰明了，与Kubernetes的特性紧密结合。我们也不难看到，它的核心能力非常依赖linkerd-proxy这个组件。linkerd-proxy采用了Rust语言编写，而对应的Envoy使用的是C++，从性能来看两者相差无几，更多的是语言生态上的选择不同。</p>
<p>我们再一起读一段<a target="_blank" rel="noopener" href="https://linkerd.io/what-is-a-service-mesh/">Linkerd官方对Service Mesh的定义</a>：</p>
<blockquote>
<p>A service mesh like Linkerd is a tools for adding observability, security, and reliability features to “cloud native” applications by transparently inserting this functionality at the platform layer rather than the application layer.</p>
</blockquote>
<ul>
<li><p>observability - 可观察性：logging、metrics、tracing</p>
</li>
<li><p>security - 安全性：TLS等特性</p>
</li>
<li><p>reliability - 可靠性：体现在对网络层的统一管理</p>
</li>
</ul>
<p>从目前来看，Linkerd仍处于一个比较早期的阶段，对标Istio还有大量的功能缺失，我在短期内不太看好。不过它引入了Rust语言有可能吸引一批优秀的人才，成为突破口。</p>
<h2 id="2022-01-25-Go1-18的两个教程"><a href="#2022-01-25-Go1-18的两个教程" class="headerlink" title="2022-01-25 Go1.18的两个教程"></a>2022-01-25 Go1.18的两个教程</h2><p>在1月初，我们已经一起看了Go官方对1.18的新特性讲解，想回顾的朋友可以点击这个链接：<a target="_blank" rel="noopener" href="https://junedayday.github.io/2022/01/04/sharing-5min/2022-01/2022Week01/#2022-01-04-Go1-18%E6%A6%82%E8%A7%88">Go1.18概览</a>。前几天，官方又发布了对泛型和Fuzzing的两个教程，我们再一起浏览下，查漏补缺。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://go.dev/doc/tutorial/generics">Tutorial: Getting started with generics</a></li>
<li><a target="_blank" rel="noopener" href="https://go.dev/doc/tutorial/fuzz">Tutorial: Getting started with fuzzing</a></li>
</ul>
<h3 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumIntsOrFloats</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">int64</span> | <span class="title">float64</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span> <span class="title">V</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s V</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        s += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>comparable 是个关键词，指的是支持操作符<code>==</code> 和 <code>!=</code></li>
<li>int64 | float64 则用简洁的语法表示了两种支持的类型</li>
</ul>
<p>但第二点，如果支持的类型太多，就需要做一次抽象，如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Number <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int64</span> | <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumNumbers</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">Number</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span> <span class="title">V</span></span> &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言的泛型表示方法非常简单，其支持的能力也很有限。相对于C++与JAVA中的泛型，无疑逊色了很多。我们可以简单地归纳Go泛型的使用场景：用于 <strong>基础类型</strong> 的通用操作，如int/int32/int64/float64等这种重复性很高的基本运算。</p>
<p>作为一种标准，Go的泛型落地非常坎坷，短期内官方也不太可能在这块扩增新的特性，所以Go的泛型适用性会比较窄。</p>
<p>随着1.18的完全落地，我们可以在很多基础库中看到泛型的实践，到时候我们再可以根据具体case进行了解。</p>
<h3 id="Fuzzing"><a href="#Fuzzing" class="headerlink" title="Fuzzing"></a>Fuzzing</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuzzReverse</span><span class="params">(f *testing.F)</span></span> &#123;</span><br><span class="line">    testcases := []<span class="keyword">string</span>&#123;<span class="string">&quot;Hello, world&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;!12345&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, tc := <span class="keyword">range</span> testcases &#123;</span><br><span class="line">        f.Add(tc)  <span class="comment">// Use f.Add to provide a seed corpus</span></span><br><span class="line">    &#125;</span><br><span class="line">    f.Fuzz(<span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, orig <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        rev := Reverse(orig)</span><br><span class="line">        doubleRev := Reverse(rev)</span><br><span class="line">        <span class="keyword">if</span> orig != doubleRev &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;Before: %q, after: %q&quot;</span>, orig, doubleRev)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> utf8.ValidString(orig) &amp;&amp; !utf8.ValidString(rev) &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;Reverse produced invalid UTF-8 string %q&quot;</span>, rev)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对于传统的单元测试，Fuzzing Test更强调一种 <strong>不确定性的输入</strong> 理念 - 由于输入的数据是随机的，输出往往是不确定的，那我们最好可以通过一定的操作，<strong>减少甚至消除输出的不确定性</strong>，才能保证测试的完备性：</p>
<p>比如说，示例中对字符串的反转，转变成了两个测试点：</p>
<ol>
<li>Reversing a string twice preserves the original value 即两次反转后成为原字符串，</li>
<li>The reversed string preserves its state as valid UTF-8 字符串依然为UTF-8编码格式</li>
</ol>
<p>从输入和输出来看，如果每个输入都对应枚举出一个输出，那就是单元测试；而Fuzzing Test的理念是尽可能地将输出做到可控，更方便地写各种测试。</p>
<p>在实际工程中，能用到Fuzzing特性的地方很少，更多的还是依赖简单地单元测试保障我们的代码质量。</p>
<h2 id="2022-01-26-如何避免分布式事务"><a href="#2022-01-26-如何避免分布式事务" class="headerlink" title="2022-01-26 如何避免分布式事务"></a>2022-01-26 如何避免分布式事务</h2><p>最近，有朋友和我交流分布式事务的实践心得，而我的建议是：<strong>尽量避免分布式事务</strong>。</p>
<p>这里的避免并非完全的不要使用，毕竟像金融场景中，这还是一个必要的特性。但对于绝大多数系统，分布式事务带来的复杂度是非常高的，也需要很高的维护成本与理解成本，远超其收益，我不太建议大家刻意地使用这个技术。</p>
<p>举一个简单的case - 用户下了一个订单，经过如下步骤：</p>
<ol>
<li>订单服务生成订单</li>
<li>库存服务扣去库存</li>
<li>付费服务完成扣款</li>
<li>用户积分服务增加积分</li>
</ol>
<p>这时，最直观的解法是要有一套成熟的分布式事务的方案。但事实上，我更推荐在工程上采用下面两种解决方案，而其中的关键词就是 - <strong>补偿</strong>。</p>
<h3 id="在MQ中重试"><a href="#在MQ中重试" class="headerlink" title="在MQ中重试"></a>在MQ中重试</h3><p>我们经常会利用MQ来解耦服务，那么自然会用它来驱动大量的消息。</p>
<p>例如，我们将扣款请求放到MQ里，扣款服务处理成功后通过另一个MQ通知成功。而当扣款服务出现问题时、也就是扣款失败，常见的有2种选择：</p>
<ol>
<li>如果要求是必须成功的，消费时就不要返回成功，在服务中反复重试，即便MQ积压产生告警、再人工恢复；</li>
<li>如果允许失败，那就设置一个最大重试次数，超过最大重试次数则通知给对应的补偿服务；</li>
</ol>
<h3 id="利用trace-id-ELK"><a href="#利用trace-id-ELK" class="headerlink" title="利用trace-id+ELK"></a>利用trace-id+ELK</h3><p>trace-id是分布式链路追踪的关键信息，用于串联信息；而ELK又通过日志收集系统，将这块收集到了一个系统。</p>
<p>我们可以在生成订单时，同时记录这个关键性的trace-id，然后调用各个服务。有任何一个服务失败，我们就将订单状态修改为失败或超时；而数据不一致的问题，就由对应的补偿服务，根据这些有问题的订单的trace-id去分析。</p>
<blockquote>
<p>其实可以从这个方案延伸出类似的，比如直接将错误通过trace-id+信息发送给补偿服务，统一收集。</p>
</blockquote>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>补偿不代表只能手动，我们可以在补偿服务内根据错误码，实现一定的自动化；</li>
<li>补偿更多体现的是一种<strong>最终一致性</strong>的思想，会有延时，我们要保证中间状态的数据不会污染系统；</li>
</ol>
<p>在微服务+云原生时代，我们非常提倡 <strong>面向错误编程</strong>，正是为了能更好地面对各种不确定的异常case。分布式事务带来了大量的复杂度，目前也没有一套跨语言、跨组件的通用解决方案，目前主流几个方案对应用的侵入性很强，所以我不太建议大部分朋友在生产环境使用，而花更多时间学习相关理论、应付面试就行了。</p>
<h2 id="2022-01-27-CNCF-TiKV"><a href="#2022-01-27-CNCF-TiKV" class="headerlink" title="2022-01-27 CNCF-TiKV"></a>2022-01-27 CNCF-TiKV</h2><p>了解完核心的 <strong>调度与管理</strong> 相关的软件后，我们接下来开始接触 <strong>应用定义与开发</strong> 的相关软件，这部分与我们实际开发接触最为紧密，也更容易理解。</p>
<ul>
<li>官网 - <a target="_blank" rel="noopener" href="https://tikv.org/">https://tikv.org/</a></li>
<li>Github - <a target="_blank" rel="noopener" href="https://github.com/tikv/tikv">https://github.com/tikv/tikv</a></li>
</ul>
<p>官方的定义为：</p>
<blockquote>
<p>TiKV provides both raw and ACID-compliant transactional key-value API, which is widely used in online serving services, such as the metadata storage system for object storage service, the storage system for recommendation systems, the online feature store, etc.</p>
</blockquote>
<p>也就是TiKV支持 <strong>简单的与满足ACID事务性的KV存储</strong>，被应用在各种存储系统上，如关系型数据库、非关系型数据库、分布式文件系统，最具有代表性的即同属一个公司的TiDB。按官方的定义，我们可以将它对标Redis。</p>
<p>我们结合TiKV的核心特性来看看。</p>
<h3 id="Low-and-stable-latency"><a href="#Low-and-stable-latency" class="headerlink" title="Low and stable latency"></a>Low and stable latency</h3><blockquote>
<p>RawKV’s average response time less than 1 ms (P99=10 ms).</p>
</blockquote>
<p>延迟是IO相关的软件很重要的特性。但对于这个特性，我们要注意两点：</p>
<ol>
<li>只针对简单KV，而不针对事务</li>
<li>真实延迟很依赖存储介质</li>
</ol>
<p>从这点来看，在TiKV层面引入事务的特性前，需要我们要斟酌一下它对延迟的影响。</p>
<h3 id="High-scalabilit"><a href="#High-scalabilit" class="headerlink" title="High scalabilit"></a>High scalabilit</h3><blockquote>
<p>With the Placement Driver and carefully designed Raft groups, TiKV excels in horizontal scalability and can easily scale to 100+ terabytes of data. Scale-out your TiKV cluster to fit the data size growth without any impact on the application.</p>
</blockquote>
<p>强调了高扩展性，可支持100TB+的数据。</p>
<p>TiKV采用了Raft作为分布式一致性的协议，这一点与Etcd一致。关于Raft这块是目前工程化的主流，相对于Paxos更容易落地。不过，各家在实现Raft时都或多或少有一些变种，这块我们暂时不细聊。</p>
<h3 id="Consistent-distributed-transactions"><a href="#Consistent-distributed-transactions" class="headerlink" title="Consistent distributed transactions"></a>Consistent distributed transactions</h3><blockquote>
<p>Similar to Google’s Spanner, TiKV (TxnKV mode) supports externally consistent distributed transactions.</p>
</blockquote>
<p>支持一致性的分布式事务。</p>
<p>分布式事务对强一致性的业务非常有价值，但它的实现必然会带来一定的性能问题，尤其体现在延迟上。以金融服务为例，分布式事务能保证资金的一致性，不产生资损；但延迟问题又会带来一些异常case，所以需要做好权衡。</p>
<h3 id="Adjustable-consistency"><a href="#Adjustable-consistency" class="headerlink" title="Adjustable consistency"></a>Adjustable consistency</h3><blockquote>
<p>In RawKV and TxnKV modes, you can customize the balance between consistency and performance.</p>
</blockquote>
<p>对简单KV模式与事务性的KV模式，提供了可调节的一致性功能。</p>
<p>这就是一致性与性能上的权衡。关于这点，大家可以了解一下ACID与BASE对业务的价值。从我的观察来看，目前越来越多的服务倾向于最终一致性，主要有以下优点：</p>
<ol>
<li><strong>对外部服务来说视角清晰，更容易理解</strong> - 从外部服务视角来看，本服务最终会趋于一致，而不需要关心各种异常的中间状态，这非常有助于微服务的边界划分；</li>
<li><strong>服务更具健壮性</strong> - 软件系统的不稳定因素很多，最终一致性可以更好地处理这些异常。</li>
</ol>
<p>当然，对应的代价是该服务需要引入重试、幂等、异步校验、状态机、恢复日志等特性，自身的复杂度是比较高的。这些技术我也会在后面和大家分享。</p>
<h2 id="2022-01-28-CNCF-Vitess"><a href="#2022-01-28-CNCF-Vitess" class="headerlink" title="2022-01-28 CNCF-Vitess"></a>2022-01-28 CNCF-Vitess</h2><p>今天我们来聊聊一款和关系型数据库相关的产品 - <code>Vitess</code>。<code>Vitess</code>的定位很简洁：</p>
<blockquote>
<p>A database clustering system for horizontal scaling of MySQL</p>
</blockquote>
<p>我们直接从架构图入手，来了解它是怎么实现 <strong>MySQL横向扩展</strong> 的。</p>
<img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/20220127221720.png" style="zoom:50%;" />

<p>我们关注最核心的两个模块：</p>
<h3 id="VTTablet"><a href="#VTTablet" class="headerlink" title="VTTablet"></a>VTTablet</h3><blockquote>
<p>A <em>tablet</em> is a combination of a <code>mysqld</code> process and a corresponding <code>vttablet</code> process, usually running on the same machine. Each tablet is assigned a <em>tablet type</em>, which specifies what role it currently performs.</p>
</blockquote>
<p>一个<code>Tablet</code>对应到一个具体的<code>MySQL</code>实例，类似于sidecar模式。我之前基于VTTablet做过一定的二次开发，和大家分享一下我对这块的认识：</p>
<p><code>VTTablet</code>最核心实现，是 <strong>模拟一个MySQL，与真正的MySQL进行连接</strong>。所以，可以体现如下的特点：</p>
<ol>
<li>无侵入式 - 充分利用了MySQL集群间通信的协议，不会侵入原MySQL。这点能衍生出很多价值，例如兼容多版本的MySQL。</li>
<li>性能较优 - 通过MySQL内部通信的协议交互。</li>
<li>可扩展性强 - 从原先对大MySQL集群的维护，转变成了相对轻量级的<code>VTTablet</code>集群的维护</li>
</ol>
<h3 id="VTGate"><a href="#VTGate" class="headerlink" title="VTGate"></a>VTGate</h3><blockquote>
<p>VTGate is a lightweight proxy server that routes traffic to the correct VTTablet servers and returns consolidated results back to the client. It speaks both the MySQL Protocol and the Vitess gRPC protocol. Thus, your applications can connect to VTGate as if it is a MySQL Server.</p>
</blockquote>
<p><code>VTGate</code>是网关层的角色，主要分三块功能：</p>
<ol>
<li>对外暴露出原生的MySQL协议与gRPC协议；</li>
<li>对内维护与<code>VTTablet</code>集群的连接；</li>
<li>核心依赖Topology服务中的数据，主要是<code>VTTablet</code>的状态数据和Admin的配置数据</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>Vitess</code>是用Go语言编写的软件，我比较推荐对数据库原理感兴趣的朋友去阅读<code>VTTablet</code>相关的源码，从中你可以了解到很多MySQL的关键性功能，会比直接阅读MySQL的C++简单很多。比如我曾经做过的：</p>
<ol>
<li>SQL解析 - 用于自研的查询平台</li>
<li>Binlog同步 - 用于MySQL到异构数据库的同步平台</li>
</ol>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/23/go-tip/go-tip-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/23/go-tip/go-tip-13/" class="post-title-link" itemprop="url">Go语言技巧 - 13.【浅析微服务框架】Go-Kit概览</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-23 12:00:00" itemprop="dateCreated datePublished" datetime="2022-01-23T12:00:00+08:00">2022-01-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-01-27 15:02:49" itemprop="dateModified" datetime="2022-01-27T15:02:49+08:00">2022-01-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="Go-Kit概况"><a href="#Go-Kit概况" class="headerlink" title="Go-Kit概况"></a>Go-Kit概况</h2><p>截止到本文发布时，<code>Go-Kit</code>在github上的star数为22.2k，超过了我们已经一起看过的<code>Go-Micro</code>与<code>Kratos</code>。</p>
<p><code>Go-Kit</code>不同于前两者，它更像是一种Go语言的工具集，而不是一种统一化的框架。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/01/23/go-tip/go-tip-13/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/17/sharing-5min/2022-01/2022Week03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/17/sharing-5min/2022-01/2022Week03/" class="post-title-link" itemprop="url">五分钟技术小分享 - 2022Week03</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-17 12:00:00" itemprop="dateCreated datePublished" datetime="2022-01-17T12:00:00+08:00">2022-01-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-01-22 21:49:36" itemprop="dateModified" datetime="2022-01-22T21:49:36+08:00">2022-01-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">每日技术分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg" alt="2022-01"></p>
<h2 id="2022-01-17-CNCF-gRPC"><a href="#2022-01-17-CNCF-gRPC" class="headerlink" title="2022-01-17 CNCF-gRPC"></a>2022-01-17 CNCF-gRPC</h2><p>今天，我们一起来看CNCF的 <strong>Remote Procedure Call - RPC</strong> 模块中最具代表性的项目 - gRPC。</p>
<p>gRPC官网的定义很简洁，重点强调了其<strong>高性能</strong>的特点：</p>
<blockquote>
<p>A high performance, open source universal RPC framework.</p>
</blockquote>
<p>我们再看一段官方更详细的描述：</p>
<blockquote>
<p>gRPC is a modern open source high performance Remote Procedure Call (RPC) framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking and authentication. It is also applicable in last mile of distributed computing to connect devices, mobile applications and browsers to backend services.</p>
</blockquote>
<p>除了高性能，这里还提到了两个重要特性：</p>
<ul>
<li><strong>插件化的支持</strong>：负载均衡、tracing、健康监测、认证等</li>
<li><strong>最后一公里</strong>：将手机app、浏览器与后端服务器的联通</li>
</ul>
<p>第一点体现出了gRPC的高度可扩展性。这里的插件化不仅体现在上面列举的这些具体功能，甚至像序列化的方案、底层通信的协议，都可以做到快速替换与迭代。</p>
<p>第二点在实际生产上应用的case并不多，仍需要大量的实践与经验沉淀后，才建议大家尝试。目前，绝大多数的gRPC通信都是发生在后端服务之间。</p>
<p>接下来，我们来谈谈官网列举的四个特性：</p>
<h3 id="Simple-service-definition"><a href="#Simple-service-definition" class="headerlink" title="Simple service definition"></a>Simple service definition</h3><p>gRPC采用<code>Protocol Buffers</code>进行定义，从整体来说阅读体验确实是比较简洁的，但在实际工程中仍存在两个问题：</p>
<ol>
<li><strong>迁移成本大</strong>：gRPC没有提供从很多历史RPC解决方案中迁移的途径，如Thrift等，完全是另起炉灶，这对有历史包袱的团队来说很难接受；</li>
<li><strong>配套开发工具缺失</strong>：高频使用<code>Protocol Buffers</code>的朋友都有了解，主流IDE对<code>pb</code>文件的错误提示和文件格式化都有缺失，很多问题都无法在coding的过程中实时提示，而是需要运行二进制命令<code>protoc</code>后才能了解。</li>
</ol>
<h3 id="Start-quickly-and-scale"><a href="#Start-quickly-and-scale" class="headerlink" title="Start quickly and scale"></a>Start quickly and scale</h3><p><strong>快速启动</strong> - 强调的是通过<code>Protocol Buffers</code>生成的代码，可以在各语言内用简洁的代码就可运行（这部分与各语言强相关）</p>
<p><strong>快速扩容</strong> - 这个特性需要与<code>Kubernetes</code>的能力结合。</p>
<h3 id="Works-across-languages-and-platforms"><a href="#Works-across-languages-and-platforms" class="headerlink" title="Works across languages and platforms"></a>Works across languages and platforms</h3><p>跨语言与平台的特性，非常依赖背后的生态 - 需要大量的工作去兼容多语言，也要兼顾性能、稳定性等问题。</p>
<p>所以，这不仅仅是技术上的问题，更需要社区、资金等复杂因素的支持。</p>
<h3 id="Bi-directional-streaming-and-integrated-auth"><a href="#Bi-directional-streaming-and-integrated-auth" class="headerlink" title="Bi-directional streaming and integrated auth"></a>Bi-directional streaming and integrated auth</h3><ul>
<li><strong>双向流式通信</strong> - 这点是gRPC的核心特性，体现出了与其它RPC方案的差异</li>
<li><strong>集成认证功能</strong> - Auth是gRPC插件化生态中的重要一环，这部分其实与服务网格的功能存在一定的重叠</li>
</ul>
<h2 id="2022-01-18-CNCF-Envoy"><a href="#2022-01-18-CNCF-Envoy" class="headerlink" title="2022-01-18 CNCF-Envoy"></a>2022-01-18 CNCF-Envoy</h2><p>作为云原生Service Mesh代表性的产品之一，Envoy占据了大壁江山。</p>
<blockquote>
<p>Envoy is an L7 proxy and communication bus designed for large modern service oriented architectures.</p>
</blockquote>
<ol>
<li>定位：L7 代理和通信总线</li>
<li>重点服务对象：SOA面向服务架构（也完全适用于微服务架构）</li>
</ol>
<p>核心理念：</p>
<blockquote>
<p>The network should be transparent to applications. When network and application problems do occur it should be easy to determine the source of the problem.</p>
<p>网络应对应用程序透明。当网络和应用程序出现问题时，应该很容易地确定问题根源。</p>
</blockquote>
<p>文档资料：</p>
<ul>
<li>官方：<a target="_blank" rel="noopener" href="https://www.envoyproxy.io/docs/envoy/latest/intro/intro">https://www.envoyproxy.io/docs/envoy/latest/intro/intro</a></li>
<li>中文版：<a target="_blank" rel="noopener" href="https://www.servicemesher.com/envoy/">https://www.servicemesher.com/envoy/</a></li>
</ul>
<p>我们依旧挑选三个核心特性展开：</p>
<h3 id="Out-of-process-architecture-进程外架构"><a href="#Out-of-process-architecture-进程外架构" class="headerlink" title="Out of process architecture 进程外架构"></a>Out of process architecture 进程外架构</h3><p>进程外架构，其实就是一种微服务理念的体现，它的利与弊也是和微服务强相关的。</p>
<p>优点很直观 - Envoy可以支持多语言，也可以独立于业务快速迭代与发展。</p>
<p>而弊端在官网上没有体现，最关键的一点是：<strong>性能损耗</strong>。作为一种side-car模式，Envoy是在本机内、进程间进行通信，远远地比进程内调用的压栈、出栈更花时间。</p>
<h3 id="Service-discovery-and-dynamic-configuration-服务发现和动态配置"><a href="#Service-discovery-and-dynamic-configuration-服务发现和动态配置" class="headerlink" title="Service discovery and dynamic configuration 服务发现和动态配置"></a>Service discovery and dynamic configuration 服务发现和动态配置</h3><p>很多运维同学都会拿Envoy去对比Nginx，确实在很多特性上，两者有很大的相似之处。但在这个特性上，Envoy有得天独厚的优势。</p>
<p>以一个常见的动态负载均衡为例，nginx需要结合consul template来实现，还需要对应用程序做一定的侵入。而Envoy可以与Kubernetes完美契合，大幅度减少维护成本。</p>
<h3 id="Best-in-class-observability-最佳的可观察性"><a href="#Best-in-class-observability-最佳的可观察性" class="headerlink" title="Best in class observability 最佳的可观察性"></a>Best in class observability 最佳的可观察性</h3><p>Envoy 的最主要目标是使网络透明，而最佳的可观测性往往会从OpenTelemetry推荐的三点入手：Metrics、Logging、Tracing。</p>
<p>Envoy提供了大量的插件，一方面保证了Envoy内部的问题清晰明了，同时也能快速地协助定位到应用侧的问题。</p>
<h2 id="2022-01-19-CNCF-Contour"><a href="#2022-01-19-CNCF-Contour" class="headerlink" title="2022-01-19 CNCF-Contour"></a>2022-01-19 CNCF-Contour</h2><p>作为CNCF中的控制平面的主打产品，Contour的知名度远不如Google的Istio。但由于种种原因，Istio并没有被捐献给云原生基金会，于是CNCF就孵化了Contour。</p>
<blockquote>
<p>定义</p>
<p>Contour is an open source Kubernetes ingress controller providing the control plane for the Envoy edge and service proxy. Contour supports dynamic configuration updates and multi-team ingress delegation out of the box while maintaining a lightweight profile.</p>
<p>三大特性</p>
<ul>
<li>Envoy Inside</li>
<li>Flexible Architecture</li>
<li>TLS Certificate Delegation</li>
</ul>
</blockquote>
<p>从定义与三个特性的描述里，我们很难真实地感受到Contour的特点。</p>
<p>今天我将换一个角度：从控制平面与数据平面进行分析。如果我们能清楚地认识到这两者的定义与边界，那么会对云原生的Service Mesh理念，以及Envoy、Contour、Istio等产品有更深的理解。</p>
<p><a target="_blank" rel="noopener" href="http://dockone.io/article/9919">这篇博客</a>的定义很具有参考意义：</p>
<ul>
<li><strong>控制平面</strong> - 通过配置和控制消息来组织编排网络的逻辑，并下发给数据平面</li>
<li><strong>数据平面</strong> - 以 Sidecar 的形式与应用部署在一起，承载其流量的发送与接收</li>
</ul>
<p>控制平面的关键功能就是<strong>控制与管理</strong>，重点对象是<strong>配置信息</strong>。</p>
<p>我们可以将数据平面看作为基础的Nginx服务，它是和底层的应用强相关的，解析相关的数据包并实现路由、负载均衡等功能。但Nginx自身也需要有一定的配置信息，比如说：</p>
<ul>
<li>数据平面的服务发现中心往往是因服务而异的；</li>
<li>数据平面的超时参数会频繁调整；</li>
<li>在做蓝绿测试时，需要频繁调整流量；</li>
<li>认证相关的设置往往需要统一更新，如证书；</li>
</ul>
<p>在我看来，控制平面更像是数据平面的配置中心，解决的是高频变化或应用间差异性很大的配置信息，让数据平面更稳定地运行。</p>
<blockquote>
<p>从架构层面来说，如果一层解决不了问题，那就再抽象一层。</p>
</blockquote>
<p>从具体的工程实践来说，数据平面主要负责的是底层实现，在保证稳定性的情况下更要兼具性能，所以不宜有太多丰富的功能。这时，引入了控制平面，我们可以将很多的配置信息通过界面UI方式进行管理，下发到各个控制平面，然后控制平面再针对性地进行转发到数据平面，就能大幅度地提高整个Service Mesh方案的可维护性。</p>
<h2 id="2022-01-20-CNCF-Emissary-Ingress"><a href="#2022-01-20-CNCF-Emissary-Ingress" class="headerlink" title="2022-01-20 CNCF-Emissary-Ingress"></a>2022-01-20 CNCF-Emissary-Ingress</h2><p>Emissary-Ingress是CNCF中又一个与网络相关的项目。这款软件的前身叫作Ambassador。但Ambassador是一款商业软件，为了避免相关的问题，更名为Emissary-Ingress后被捐献给了CNCF。因为网上资料更多的都是Ambassador，下面统一用Ambassador对这款软件进行描述。</p>
<p>CNCF上的定义为：</p>
<blockquote>
<p>open source Kubernetes-native API gateway for microservices built on the Envoy Proxy</p>
</blockquote>
<p>我们很容易将这个产品与Istio、Envoy混淆起来，那它们之间的区别是什么呢？这里有篇<a target="_blank" rel="noopener" href="https://itnext.io/ambassador-and-istio-edge-proxy-and-service-mesh-814aac9f23df">文章</a>，介绍了具体的实践，但我们直接可以从标题中得到关键信息：</p>
<ul>
<li>Ambassador - Edge proxy</li>
<li>Istio - service mesh</li>
</ul>
<p>而Envoy+Contour对标的是Istio，所以不难看出，云原生推荐将Ambassador作为一种边缘网关，更多地是作为整体流量的出入口。如果说service mesh是一种对网络的精细化管理，那么边缘网关更多地是对整体流量的管理。</p>
<p>但在实际使用中，两者有大量的重叠功能，如路由、认证、限速等，而我也没有在网上找到相关的Best Practice，这部分就很需要大家的经验与摸索了。从我的角度来看，更倾向于大家多使用Envoy的特性，毕竟它的生态最成熟。即便后续有了替代品，对方也往往会提供对应的兼容方案。</p>
<p>这里，我引用了一个<a target="_blank" rel="noopener" href="https://www.getambassador.io/docs/emissary/latest/topics/concepts/microservices-api-gateways/#microservices-api-gateways-vs-enterprise-api-gateways">链接</a>，讲述了微服务网关(Emissary-Ingress定位)与传统企业级网关的差异。</p>
<h3 id="Primary-Purpose-主要目标"><a href="#Primary-Purpose-主要目标" class="headerlink" title="Primary Purpose 主要目标"></a>Primary Purpose 主要目标</h3><ul>
<li>传统企业级网关 - Expose, compose, and manage internal business APIs</li>
<li>微服务网关 - Expose and observe internal business services</li>
</ul>
<p>微服务网关相对而言会更轻量级，而且对外以服务的维度呈现。</p>
<h3 id="Publishing-Functionality-发布功能"><a href="#Publishing-Functionality-发布功能" class="headerlink" title="Publishing Functionality 发布功能"></a>Publishing Functionality 发布功能</h3><ul>
<li>传统企业级网关 - API management team or service team registers / updates gateway via admin API</li>
<li>微服务网关 - Service team registers / updates gateway via declarative code as part of the deployment process</li>
</ul>
<p>微服务网关更倡导自运维的方式。</p>
<h3 id="Handling-and-Debugging-Issues-处理和Debug问题"><a href="#Handling-and-Debugging-Issues-处理和Debug问题" class="headerlink" title="Handling and Debugging Issues 处理和Debug问题"></a>Handling and Debugging Issues 处理和Debug问题</h3><ul>
<li><p>传统企业级网关 - L7 error-handling (e.g. custom error page or payload). Run gateway/API with additional logging. Troubleshoot issue in staging environment</p>
</li>
<li><p>微服务网关 - Configure more detailed monitoring. Enable traffic shadowing and / or canarying</p>
</li>
</ul>
<p>微服务网关更强调的是网络侧的更细致化的管理，突出了灵活性。</p>
<h2 id="2022-01-21-谈谈Context在Go程序外的传递"><a href="#2022-01-21-谈谈Context在Go程序外的传递" class="headerlink" title="2022-01-21 谈谈Context在Go程序外的传递"></a>2022-01-21 谈谈Context在Go程序外的传递</h2><p>这两天，有个读者跟我讨论了一个关于链路追踪的问题 - 他发现通过context传递的trace-id丢失了。从根本上来说，这涉及到了<strong>Context在Go程序外的传递</strong>的理解，细想的话很有意思，所以我今天专门拿出来讲讲。</p>
<p>如果你对Go语言有一定的基础，会很习惯地使用Context作为上下文信息的传递：无论是内部函数的调用，还是RPC的调用，这就会产生一种错觉：<strong>context的传递是水到渠成的</strong>。</p>
<p>这位同学的调用链路是 Go程序 - MQ - Go程序，发现context中的trace-id丢失了。</p>
<blockquote>
<p>trace-id用于分布式的链路追踪</p>
</blockquote>
<p>分析这个问题不难，有很多种思路，但我比较建议大家从底层实现去理解：</p>
<ol>
<li>context的本质，是一种key-value的数据结构；</li>
<li>服务之间的调用，本质上是一种网络上的二进制数据的传递，而<strong>context信息肯定是保存在其中的</strong>；</li>
<li>HTTP是一种二进制数据上的协议表达格式，我们常见的RESTful API 的 json数据是填入到body中，但HTTP协议还有很多地方可以保存数据，尤其是HTTP Header。context信息大概率是被保存在Header里的；</li>
</ol>
<p><strong>Go语言的Client将context封装到Header里，Server将context从Header中解析出来</strong>。</p>
<blockquote>
<p>默认的官方库是不会写直接写的，需要做一层浅封装：</p>
<p>发送前，从ctx中将对应的k-v填入到header；</p>
<p>收到后，从header中提取k-v，写入到context。</p>
</blockquote>
<p>要验证一下上面的猜想很简单，我强烈大家用最底层的方式：<strong>Wireshark抓包</strong>。事实也如我们的预期，Go语言的ctx传递正是用这种方式实现的。而MQ这种第三方组件，往往不会去解析这种特定的Header，所以会发生丢失。</p>
<p>这时，我们有什么样的解决方案呢？</p>
<ol>
<li>制定标准。这也是OpenTracing等规范推崇的，对广大的开发者来说非常友好，尤其是跨语言的情况，但这块非常依赖生态，需要大量的SDK，整体来说推进进度比较难。（这就体现了Service Mesh的价值）</li>
<li>显示传递。相当于把关键信息填到HTTP的body里，对具体代码的实现来说侵入性很强，但不失为中小型公司快速落地的方案；遇到一些不支持标准的第三方软件，我们也往往只能采用这种方式。</li>
</ol>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/10/sharing-5min/2022-01/2022Week02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/10/sharing-5min/2022-01/2022Week02/" class="post-title-link" itemprop="url">五分钟技术小分享 - 2022Week02</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-10 12:00:00" itemprop="dateCreated datePublished" datetime="2022-01-10T12:00:00+08:00">2022-01-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-01-15 21:28:52" itemprop="dateModified" datetime="2022-01-15T21:28:52+08:00">2022-01-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">每日技术分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg" alt="2022-01"></p>
<h2 id="2022-01-10-Unix设计哲学概览"><a href="#2022-01-10-Unix设计哲学概览" class="headerlink" title="2022-01-10 Unix设计哲学概览"></a>2022-01-10 Unix设计哲学概览</h2><p>Unix设计哲学在程序员的圈子里经久不衰，备受追捧。而<code>Go</code>语言背后有很多<code>Unix</code>与<code>C语言</code>的影子，三位创始人Rob Pike（罗伯. 派克），Ken Thompson（肯. 汤普森）和Robert Griesemer（罗伯特. 格利茨默）都是这两块领域的泰山北斗。了解Unix的设计哲学，对写出优秀的代码很有帮助。</p>
<ul>
<li>英文资料 - <a target="_blank" rel="noopener" href="https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html">https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html</a></li>
<li>中文wiki - <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unix%E5%93%B2%E5%AD%A6">https://zh.wikipedia.org/wiki/Unix%E5%93%B2%E5%AD%A6</a></li>
</ul>
<h3 id="Doug-McIlroy的总结"><a href="#Doug-McIlroy的总结" class="headerlink" title="Doug McIlroy的总结"></a>Doug McIlroy的总结</h3><blockquote>
<p>Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface.</p>
<p>做一件事，做好它。让程序能够互相协同工作。应该让程序处理文本数据流，因为这是一个通用的接口。</p>
</blockquote>
<p>作为管道机制的发明者，Doug McIlroy对这块的解释重点很具有管道特色。这里，我们聚焦于一个点：<strong>做好一件事</strong>。</p>
<p>将其拆分一下，主要分为两块：</p>
<ol>
<li><strong>做好。</strong>做一件事，可能只需要10分的能力；而做好，则需要100分的能力（但 <code>做好</code> 这个标准，尽可能地按照自己的认知上限去做，才可能有成长）。</li>
<li><strong>一件事。</strong>怎么定义一件事呢？边界的定义就难倒了很多人。这个非常考验能力，更具体可能需要<code>case by case</code>去看。</li>
</ol>
<h3 id="Rob-Pike的总结"><a href="#Rob-Pike的总结" class="headerlink" title="Rob Pike的总结"></a>Rob Pike的总结</h3><blockquote>
<ol>
<li>你永远不会知道你的程序会在什么地方耗费时间。程序的瓶颈常常出现在意想不到的地方，因此在你确信找到瓶颈后再动手优化代码吧。</li>
<li>测试代码。只有在你详细测试了代码，并且发现一部分代码耗费了绝大部分的运行时间时再对程序作速度优化。</li>
<li>功能全面的算法（fancy algorithm）在处理小规模问题时效率很低，这是因为算法时间效率中的常量很大，而问题往往规模很小。除非你知道你遇到的常常是复杂的情况，否则就让代码丑陋但是简单而高效吧。（即使问题规模确实很大，也首先尝试第二条规则。）</li>
<li>功能全面的算法比简单的算法更容易产生bug，更难实现。尽量使用简单的算法和数据结构。</li>
<li>数据决定一切。如果选择的数据结构能很好的管理数据，算法部分往往不言自明。记住，数据结构，而非算法，才是编程的关键。</li>
<li>没有第六条规则。</li>
</ol>
</blockquote>
<p>按照wiki上的说法，1、2可以归纳为 <strong>过早的优化是一切罪恶的根源</strong>，3、4可以理解为 <strong>疑惑不定之时最适合穷举</strong>。</p>
<p>而第五条就非常有意思，也就是 <strong>数据结构比算法更重要</strong>。</p>
<p>这点，和我们在刷算法题时认知相反 - 在做算法题目时，我们往往已经得到了一个具体的数据结构，要做的更多是根据这个数据结构选择合适的算法。当数据结构确定时，可选择的算法就很有限了，这也大大缩小了题解的范围。</p>
<p>在复杂的场景中，我们首先得确定数据结构，这一步尤为复杂：</p>
<ol>
<li>复合 - 数据结构往往是复合的、嵌套的，单一的数据结构很少见；</li>
<li>抓住核心 - 可用数据结构解往往有多种，关键是识别其中决定性的因素；</li>
<li>不确定性 - 最优解的数据结构，往往会根据时间变化而变化；</li>
<li>简单性 - 性能最优解并不一定是最终的解，实际工程中多考虑简单性；</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关于Unix的设计哲学还有很多优秀的见解，但综合起来，可以归纳为<code>KISS</code>原则，也就是<strong>简单性</strong>。希望大家能在工程实践中，多多思考怎么保证简单性，对做出优秀的设计会很有启发。</p>
<h2 id="2022-01-11-CNCF-CrossPlane"><a href="#2022-01-11-CNCF-CrossPlane" class="headerlink" title="2022-01-11 CNCF-CrossPlane"></a>2022-01-11 CNCF-CrossPlane</h2><p>今天我们一起来看CNCF中的第二个项目 - <code>CrossPlane</code> 。它位于CNCF全景图中<code>Kubernetes</code>旁，受众比较小。</p>
<p>先看一段来自官网 <a target="_blank" rel="noopener" href="https://crossplane.io/">https://crossplane.io/</a> 的信息：</p>
<blockquote>
<p> Crossplane is an open source Kubernetes add-on that enables platform teams to assemble infrastructure from multiple vendors, and expose higher level self-service APIs for application teams to consume, without having to write any code.</p>
</blockquote>
<p>我们依旧抽取其中关键的词进行解析：</p>
<ul>
<li><code>Kubernetes add-on</code> CrossPlane的定位是<code>Kubernetes</code>的插件，并非一个独立的平台</li>
<li><code>assemble infrastructure from multiple vendors</code> 统一封装多个依赖方的基础设施</li>
<li><code>expose higher level self-service APIs</code> 暴露高层接口</li>
</ul>
<p>然后，官方描述了五个关键性的特征：</p>
<ul>
<li>Provision and manage cloud infrastructure and services using kubectl</li>
<li>There is a flavor of infrastructure for everyone on Crossplane</li>
<li>Publish simplified infrastructure abstractions for your applications</li>
<li>The Universal Cloud API</li>
<li>Run Crossplane anywhere</li>
</ul>
<p>概括起来，可以定义为：<strong>使用 kubectl 封装了各类云的API，来统一管理基础设施、服务和应用</strong>。</p>
<p>我们从具体的实践角度来看，统一封装接口往往只是加分项，而核心在于 <strong>支持的云基础设施与服务的范围</strong>。</p>
<p>从 <a target="_blank" rel="noopener" href="https://crossplane.io/docs/v1.6/getting-started/provision-infrastructure.html">官方文档</a> 可以看到，<code>CrossPlane</code>主要支持了亚马逊云、谷歌云、微软云等厂商。可以看到，这款产品主要面向的是<strong>国外的公有云厂商</strong>。这其实也决定了<code>CrossPlane</code>更多面向的是国外开发者。</p>
<p>学习<code>CrossPlane</code>的更多细节，对我们来说暂时没有更大的意义。我们可以尝试着从其理念中得到以下启发：</p>
<ol>
<li><strong>对接各类云厂商是复杂的。</strong>尽管<code>CNCF</code>统一了大致上的理念，但细节上的实现各有不同；尤其是结合了账号、权限、资源分配等各类特性后，对接起来的复杂度很高。</li>
<li><strong>如果一层不能解决，那就加一层。</strong> 直接对接各类公有云复杂度很高，也会为<code>Kubernetes</code>这个核心项目带来大量侵入性极强的代码。这时，引入另一个项目作为<strong>防腐层</strong>，很具有扩展意义。</li>
<li><strong>一个核心项目不一定需要做成大型平台，更重要的是它的特性符合整个生态的发展理念。</strong></li>
</ol>
<h2 id="2022-01-12-微服务架构特征"><a href="#2022-01-12-微服务架构特征" class="headerlink" title="2022-01-12 微服务架构特征"></a>2022-01-12 微服务架构特征</h2><p>今天的话题将围绕着一篇谈论微服务架构的文章展开。下面给出原文链接，以及一个翻译的版本：</p>
<ul>
<li>原文 - <a target="_blank" rel="noopener" href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a></li>
<li>中文翻译 - <a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15127669/4175353">https://blog.51cto.com/u_15127669/4175353</a> </li>
</ul>
<p>文中给出了以下九个微服务特征：</p>
<ol>
<li>Componentization via Services 通过服务来实现组件化</li>
<li>Organized around Business Capabilities 围绕业务能力构建</li>
<li>Products not Projects 面向产品，而不是面向项目</li>
<li>Smart endpoints and dumb pipes 终端智能化，通讯轻量化</li>
<li>Decentralized Governance 分散治理</li>
<li>Decentralized Data Management 数据去中心化管理</li>
<li>Infrastructure Automation 基础设施自动化</li>
<li>Design for failure 容错性设计</li>
<li>Evolutionary Design 演进式设计</li>
</ol>
<p>这些点，每个抛出来都可以写一篇长文。建议有兴趣的各位可以阅读原文，结合自己的实践多多思考。</p>
<p>这里，我选择三个最近感触比较深的点，自己也曾经陷入过的认知误区，在这里和大家聊聊：</p>
<h3 id="围绕业务能力构建"><a href="#围绕业务能力构建" class="headerlink" title="围绕业务能力构建"></a>围绕业务能力构建</h3><p>业务能力的概念很抽象，虽然我们会经常提及，但在实践过程中又往往容易忽略。</p>
<p>从系统的角度来看，业务能力往往就是对外呈现的功能，对应到内部的技术模块，往往已经决定了七七八八。如何将这些技术模块做合理的拆分与合并，就是微服务架构需要考量的点。这里我谈谈最近比较有心得的三个考量点：</p>
<ul>
<li>拆分高频变化与低频变化</li>
<li>分离计算密集型和IO密集型</li>
<li>基础能力尽早引入业界的通用模块</li>
</ul>
<p>当然，还有更多的内容，需要大家在实践中摸索。</p>
<h3 id="终端智能化，通讯轻量化"><a href="#终端智能化，通讯轻量化" class="headerlink" title="终端智能化，通讯轻量化"></a>终端智能化，通讯轻量化</h3><p>这一点在云原生的服务中体现得淋漓尽致：以<strong>RPC</strong>、<strong>Service Mesh</strong>、<strong>服务发现</strong>等技术为代表。</p>
<p>终端体现在<code>Pod</code>这一层，也就是对一个具体运行的App来说，通过Istio、CoreDNS等技术将分布式的服务做到和单体应用一致，然后通过轻量级的通讯方案，如HTTP进行交互。这种方式的优点很明显：</p>
<ol>
<li>分布式服务之间的通讯复杂度最高的部分，由专用的、成熟的组件，引入到Pod层面完成；</li>
<li>开发者的代码实现只需要关心RPC的数据出入，复杂度大幅度降低；</li>
</ol>
<p>目前云原生的Service Mesh技术还未完全形成行业标准，相信很快随着它的落地，将迎来微服务的又一波热潮。</p>
<h3 id="容错性设计"><a href="#容错性设计" class="headerlink" title="容错性设计"></a>容错性设计</h3><p>容错性设计，也就是为错误而设计，这一点很反直觉。</p>
<p>作为一名开发者，我们实现功能的思路往往是按照顺序的逻辑步骤；一个一个步骤的串联，才能保证最后的功能实现。但这个时候，如果要我们去关注各类错误的发生，小到网络波动、程序崩溃，大到机房断电，很容易无所适从。</p>
<p>这里，我谈谈自己的理解：<strong>主要从发生的概率与影响的严重程度来思考，不要过度追求细节</strong>。这里有一个很重要的权衡点 - **健壮性 **与 <strong>简单性</strong> ：一般来说，要保证程序足够健壮，会引入各种异常的容错性设计，增加系统的复杂度，但这一点并不是绝对的。</p>
<p><strong>从系统整体功能的维度，虽然看起来增加了复杂度，但通过分层、模块化、服务拆分等方式，分而治之 - 一些简单的模块用简单的规则组合成一个大模块，可维护性远远高于一个复杂的模块。</strong></p>
<h2 id="2022-01-13-CNCF-CoreDNS"><a href="#2022-01-13-CNCF-CoreDNS" class="headerlink" title="2022-01-13 CNCF-CoreDNS"></a>2022-01-13 CNCF-CoreDNS</h2><p><code>CoreDNS</code>是CNCF全景图中 <strong>协调与服务发现</strong> 模块的核心项目，在<code>Kubernetes</code>1.12版本之后成为了默认的DNS服务。熟悉<code>CoreDNS</code>是掌握<code>Kubernetes</code>必不可少的技能。</p>
<p>照例，我们先一起看下其核心定义，非常简洁明了：</p>
<blockquote>
<p>官网 - CoreDNS: DNS and Service Discovery</p>
<p>CNCF - CoreDNS is a DNS server that chains plugins</p>
</blockquote>
<p>今天，我们将围绕一个关键词<code>chains plugins</code> - <strong>链式插件</strong> 展开，这也是<code>CoreDNS</code>实现的核心特性。</p>
<p>官方对这个特性的定义如下，</p>
<blockquote>
<p>CoreDNS chains plugins. Each plugin performs a DNS function, such as Kubernetes service discovery, prometheus metrics, rewriting queries, or just serving from zone files. And many more.</p>
</blockquote>
<p>从中不难看出，<code>CoreDNS</code>将各种<code>DNS</code>的功能抽象成一个插件，进行链式调用。</p>
<p>我们用 <a target="_blank" rel="noopener" href="https://github.com/coredns/coredns">官方github上的Corefile</a> 来了解这个特性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example.org:1053 &#123;</span><br><span class="line">    file /var/lib/coredns/example.org.signed</span><br><span class="line">    transfer &#123;</span><br><span class="line">        to * 2001:500:8f::53</span><br><span class="line">    &#125;</span><br><span class="line">    errors</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. &#123;</span><br><span class="line">    any</span><br><span class="line">    forward . 8.8.8.8:53</span><br><span class="line">    errors</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>当访问<code>example.org:1053</code> 时，依次触发 file、transfer、errors、log四个插件</li>
<li>访问其余DNS时，依次触发 any、forward、errors、log四个插件</li>
</ol>
<p>上面的语法与<code>nginx</code>非常类似，而作者实际上是参考<code>Caddy</code>软件进行设计的，有兴趣的可以查阅相关资料，例如这个 <a target="_blank" rel="noopener" href="https://mritd.com/2021/06/30/understand-caddyfile-syntax/">博客</a>。</p>
<p>链式调用是一种表述形式非常强的语法：<strong>它以一个大众容易接受的顺序逻辑，讲述了一个完整的调用过程，将各个细节也描述地很清晰</strong>。</p>
<p>既然链式调用的描述方式那么棒，为什么目前没有大规模地推广到各类工具上呢？这里，我谈谈个人的三个理解：</p>
<ol>
<li><strong>核心模块支持插件化</strong> - 链式调用需要动态加载各类插件，这一点对核心的模块要求很高，很多软件设计之初就决定了很难走插件化的道路；</li>
<li><strong>无需兼容历史问题</strong> - 很多的工具都存在大量的历史版本，很难做到完全兼容这种表达形式；而<code>CoreDNS</code>在设计之初就强制采用这种规范，没有历史包袱；</li>
<li><strong>每个插件的输入与输出保持一致</strong> - 作为一种链式调用，为了保证前者输入可以作为后者输出，两者支持的数据格式必须一样（可以参考Unix中的管道）。DNS服务的功能比较简单，可以保证一致；</li>
</ol>
<p>同样的，Corefile这种声明方式，也或多或少带来了一些问题，例如：</p>
<ol>
<li><strong>文件解析的复杂性</strong>（这点与链式调用本身无关） - 比如数据类型的问题，很难确定文件中的<code>5</code>是数字还是字符串；</li>
<li><strong>链式调用很难解决前后有依赖的情况</strong> - 如调用A插件的结果有个特别的输出，用于插件B的输入时，很难解决；</li>
<li><strong>长链式调用的复杂度</strong> - 如果链式调用过长，一方面带来了异常情况下排查问题的复杂度，另一方面很容易出现性能问题；</li>
</ol>
<p><code>CoreDNS</code>的成功，<strong>链式调用插件</strong> 这个特性只体现了简单性的理念，并不是关键性的原因，而更多地是依赖大量开箱即用的<a target="_blank" rel="noopener" href="https://coredns.io/plugins/">插件</a>。</p>
<h2 id="2022-01-14-不可变基础设施"><a href="#2022-01-14-不可变基础设施" class="headerlink" title="2022-01-14 不可变基础设施"></a>2022-01-14 不可变基础设施</h2><p>看起来，这功能描述与<code>CICD</code>流程差不多，但使用体验差距很大。在传统的模式下，我们执行的是一个<strong>具体的动作</strong>，比如扩1个应用、升级2个程序等；而在k8s里，使用者只要<strong>声明最终的预期状态</strong>，比如5个应用运行v1.0版本的程序，那么整个系统该扩容还是缩容、该升级还是回滚，都由k8s自行根据当前状态进行判断。</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>ab4ea1c14f669e0e42040689da7aa074c4e479f3</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>云原生有五大代表性的技术 - <strong>容器、服务网格、微服务、不可变基础设施和声明式 API</strong>。相对于其余四种概念，不可变基础设施 - <code>Immutable Infrastructure</code> 更难理解，今天我们来一起看看。</p>
<blockquote>
<p>入门可以参考这篇文章 - <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/382203966">https://zhuanlan.zhihu.com/p/382203966</a> </p>
</blockquote>
<p>网上可搜索到的<strong>不可变基础设施</strong>定义有很多，这里我选择一个比较有代表性的：</p>
<blockquote>
<p>Immutable infrastructure refers to servers (or VMs) that are never modified after deployment.</p>
</blockquote>
<p>从开发者的角度来看，不可变基础设施是一个很棒的概念。如果用一个词总结它的优点，那就是 <strong>时间与空间上的一致性</strong>。</p>
<p>如果有一个传统应用希望改造成适配 <strong>不可变基础设施</strong> 的场景，那么会有哪些常见的改造点呢？</p>
<ol>
<li>将传统应用的运行环境打造成一个具体的服务器，例如虚拟机、容器；</li>
<li>重点分析该应用的输出形式，让其与 <strong>服务器无关</strong>；</li>
</ol>
<p>第二点有些抽象，这里我举三个具体的例子：</p>
<ol>
<li>本地缓存 - 转移到分布式缓存服务；</li>
<li>本地保存的文件 - 转移到分布式存储服务中；</li>
<li>本地日志 - 将原来打印到本地文件的日志服务，重定向到标准输出，由日志采集的side-car收集后统一汇总；</li>
</ol>
<p>但在实际的工程中，追求 <strong>不可变基础设施</strong> 很难完全落地，我们可以适当地做一些权衡：</p>
<ol>
<li>如果日志不允许落盘对部分程序的改造成本很高，那么我们可以用ELK等一套日志收集方案做准实时的同步，保证日志可丢失；</li>
<li>如果完全依赖分布式缓存对性能压力过大，那么就建立一套分布式缓存与本地缓存的自动同步机制，保证重启后本地缓存丢失，仍可以恢复；</li>
</ol>
<p>不难看出，只要我们保证应用在基础设施上产生的数据 <strong>可在任意时间丢失</strong>，就能实现了一定程度上 <strong>应用无状态化</strong>，也能保证了<strong>不可变基础设施</strong>的落地。</p>
<p><strong>不可变基础设施</strong>是一种理念，具体落地的技术非常依赖容器或虚拟机，以及分布式存储等配套设施。我们没有必要把它作为一种技术标准去强制执行，而应该结合现状，选择性地朝着这个方向不断优化。</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junedayday</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<div class=BbeiAn-info">
  浙ICP备 -
  <a target="_blank" rel="noopener" href="http://www.miitbeian.gov.cn/">19051676号-1</a>
  </a>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  















  








  

  

</body>
</html>
