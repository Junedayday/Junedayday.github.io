<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Junedayday Blog</title>
  
  <subtitle>六月天天的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-19T11:50:31.048Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Junedayday</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go算法实战 - 4.【寻找两个正序数组的中位数LeetCode-4】</title>
    <link href="http://example.com/2021/07/19/go-leetcode/go-leetcode-4/"/>
    <id>http://example.com/2021/07/19/go-leetcode/go-leetcode-4/</id>
    <published>2021-07-19T04:00:00.000Z</published>
    <updated>2021-07-19T11:50:31.048Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-4-寻找两个正序数组的中位数"><a href="#Leetcode-4-寻找两个正序数组的中位数" class="headerlink" title="Leetcode-4 寻找两个正序数组的中位数"></a>Leetcode-4 寻找两个正序数组的中位数</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解这个题之前，我们要注意<strong>奇数和偶数</strong>的边界情况。</p><ul><li>奇数2n+1个，我们要取第n+1小的数</li><li>偶数2n个，我们要取第n和n+1小的数</li></ul><p>在Go语言中，因为是强类型的，切片<code>nums1</code>与<code>nums2</code>是整数，返回值则是浮点数</p><blockquote><p>这是我们遇到的第一道hard级别的题目，让我们一起尝试攻克它！</p></blockquote><h2 id="基本解法"><a href="#基本解法" class="headerlink" title="基本解法"></a>基本解法</h2><h3 id="常规思路1-逐个寻找"><a href="#常规思路1-逐个寻找" class="headerlink" title="常规思路1 - 逐个寻找"></a>常规思路1 - 逐个寻找</h3><p>常规思路来看，我们就是找第X小的数，那我们就一个一个找：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    length1, length2 := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="comment">// 注意，这里是向下取整</span></span><br><span class="line">    mid := (length1 + length2) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区分一下奇数与偶数，奇数为mid+1，偶数为mid/mid+1</span></span><br><span class="line">    <span class="comment">// 奇数为2n+1个，mid=n,这样下一个就是中位数</span></span><br><span class="line">    <span class="comment">// 偶数为2n个，mid=n，所以处理一下，让mid=n-1，这样接下来两个就是中位数</span></span><br><span class="line">    <span class="keyword">var</span> isOdd <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">if</span> (length1 + length2) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        isOdd = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mid =  mid - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> i1, i2 <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 移动两个索引i1与i2，找到最小的mid个</span></span><br><span class="line">    <span class="comment">// 关键是注意两个边界情况的判定</span></span><br><span class="line">    <span class="keyword">for</span> mid &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i1 &gt;= <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">            i2++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> i2 &gt;= <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">            i1++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i1] &gt; nums2[i2] &#123;</span><br><span class="line">            i2++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i1++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mid--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到mid后下一个</span></span><br><span class="line">    <span class="keyword">var</span> n1 <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> i1 &gt;= <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">        n1 = nums2[i2]</span><br><span class="line">        i2++</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> i2 &gt;= <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">        n1 = nums1[i1]</span><br><span class="line">        i1++</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i1] &gt; nums2[i2] &#123;</span><br><span class="line">        n1 = nums2[i2]</span><br><span class="line">        i2++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n1 = nums1[i1]</span><br><span class="line">        i1++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 奇数直接返回结果</span></span><br><span class="line">    <span class="keyword">if</span> isOdd &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(n1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偶数找到再下一个，再返回</span></span><br><span class="line">    <span class="keyword">var</span> n2 <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> i1 &gt;= <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">        n2 = nums2[i2]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> i2 &gt;= <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">        n2 = nums1[i1]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i1] &gt; nums2[i2] &#123;</span><br><span class="line">        n2 = nums2[i2]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n2 = nums1[i1]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(n1 + n2) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码很长，但性能不差，因为都是顺序的逻辑。</p><p>分析一下复杂度，空间复杂度是O(1)，时间复杂度为O(m+n)，其中m=len(nums1)，n=len(nums2)。</p><h3 id="常规思路2-排序后直接根据索引查找"><a href="#常规思路2-排序后直接根据索引查找" class="headerlink" title="常规思路2 - 排序后直接根据索引查找"></a>常规思路2 - 排序后直接根据索引查找</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="comment">// Go里面不支持对 []int 直接进行排序，必须通过 sort.IntSlice 做一次转化</span></span><br><span class="line">    <span class="keyword">var</span> intSlice sort.IntSlice</span><br><span class="line">    intSlice = <span class="built_in">append</span>(intSlice, nums1...)</span><br><span class="line">    intSlice = <span class="built_in">append</span>(intSlice, nums2...)</span><br><span class="line"></span><br><span class="line">    sort.Sort(intSlice)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(intSlice) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 注意这里的索引，切勿再+1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(intSlice[<span class="built_in">len</span>(intSlice) / <span class="number">2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(intSlice[<span class="built_in">len</span>(intSlice) / <span class="number">2</span> - <span class="number">1</span>] + intSlice[<span class="built_in">len</span>(intSlice) / <span class="number">2</span> ]) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我个人觉得Go语言里的排序函数<code>sort.Sort</code>对使用者的体验不是很好，尤其是对一些基础类型的支持。</p><p>这个解法的问题是对nums1和nums2进行了重新排序，没有充分利用nums1与nums2为<strong>有序数组</strong>这个条件。</p><h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><h3 id="递归的基本思路"><a href="#递归的基本思路" class="headerlink" title="递归的基本思路"></a>递归的基本思路</h3><p>我们注意到，这道题中给出的两个数组都是 <strong>已排序</strong> 的，所以可以利用<strong>数组的随机访问</strong>特性，做一定的加速。</p><p>这道题的问题是取中位数，但由于<strong>数组长度的奇偶性</strong>问题，这个中位数很难递归。所以，我们需要将问题做一个转化，实现<strong>找到第K小的数字</strong>，也就是下面的<code>findKthSortedArrays</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    length1, length2 := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="comment">// 奇数可以一步计算得出</span></span><br><span class="line">    <span class="keyword">if</span> (length1 + length2) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthSortedArrays(nums1, nums2, (length1 + length2) / <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 偶数的拆分为两个子问题</span></span><br><span class="line">    <span class="keyword">return</span> (findKthSortedArrays(nums1, nums2, (length1 + length2) / <span class="number">2</span>) +</span><br><span class="line">        findKthSortedArrays(nums1, nums2, (length1 + length2) / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    length1, length2 := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="comment">// 技巧1：保证nums1比nums2长，能减少下面很多条件的判断</span></span><br><span class="line">    <span class="keyword">if</span> length1 &lt; length2 &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthSortedArrays(nums2, nums1, k)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> length2 == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(nums1[k - <span class="number">1</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> k == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nums1[<span class="number">0</span>] &gt; nums2[<span class="number">0</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">float64</span>(nums2[<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(nums1[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们要保证i1和i2都要小于k，否则下面很难递归</span></span><br><span class="line">    i2 := k / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> i2 &gt; length2 &#123;</span><br><span class="line">      i2 = length2</span><br><span class="line">    &#125;</span><br><span class="line">    i1 := k - i2</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归的核心思路</span></span><br><span class="line">    <span class="keyword">if</span> nums1[i1 - <span class="number">1</span>] &lt; nums2[i2 - <span class="number">1</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthSortedArrays(nums1[i1:], nums2, k - i1)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i1 - <span class="number">1</span>] &gt; nums2[i2 - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthSortedArrays(nums1, nums2[i2:], k - i2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(nums1[i1 - <span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决这道题的难点在于3点：</p><ul><li>大量<strong>边界条件</strong>的编写，很容易发生遗漏导致运行失败</li><li>第n个数字转化为数组索引时，自带一个<code>-1</code>操作，在递归时容易混淆</li><li>递归的核心思路：<strong>将第k个元素转化为2个数组的索引之和，并保证不小于各自数组的长度</strong></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解决本题的难点在于大量的条件判断，存在大量<code>if-else</code>的代码，很容易让我们在编写代码时产生混乱，常常需要大量的调试。</p><p>我个人比较推荐用<strong>常规解法1</strong>这种笨办法来思路梳理，完整地处理好各种边界条件。接下来，再通过<strong>进阶解法</strong>来提升自己的抽象水平。</p><p>恭喜我们，正式解决了第一道困难的Leetcode！</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-4-寻找两个正序数组的中位数&quot;&gt;&lt;a href=&quot;#Leetcode-4
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 3.【无重复字符的最长子串LeetCode-3】</title>
    <link href="http://example.com/2021/07/14/go-leetcode/go-leetcode-3/"/>
    <id>http://example.com/2021/07/14/go-leetcode/go-leetcode-3/</id>
    <published>2021-07-14T04:00:00.000Z</published>
    <updated>2021-07-15T07:02:07.921Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-3-无重复字符的最长子串"><a href="#Leetcode-3-无重复字符的最长子串" class="headerlink" title="Leetcode-3 无重复字符的最长子串"></a>Leetcode-3 无重复字符的最长子串</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归解题思路"><a href="#递归解题思路" class="headerlink" title="递归解题思路"></a>递归解题思路</h2><p>从函数签名<code>func lengthOfLongestSubstring(s string) int </code>来看，我们可以将问题拆分成子问题</p><ol><li>首字符<ol><li>包含s[0]的最长无重复子串</li><li>lengthOfLongestSubstring(s[1:n])</li></ol></li><li>尾字符<ol><li>lengthOfLongestSubstring(s[0:n-1])</li><li>包含s[n]的最长无重复子串</li></ol></li></ol><h3 id="利用首字符的递归问题"><a href="#利用首字符的递归问题" class="headerlink" title="利用首字符的递归问题"></a>利用首字符的递归问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// guard clauses，也就是卫语句，在递归中非常重要</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局的字符串，用于保存</span></span><br><span class="line">    <span class="keyword">var</span> mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := mp[s[i]]; ok &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// 找到重复的，直接退出</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mp[s[i]] = i <span class="comment">// 没找到重复的，加上这个子串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    length := lengthOfLongestSubstring(s[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">if</span> i &gt; length &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归的解法可读性较佳，但实际的时间复杂度会比较高，因为它的每一次 <strong>递归操作都要维护一个新的数据栈</strong>。</p><h2 id="非递归实现思路"><a href="#非递归实现思路" class="headerlink" title="非递归实现思路"></a>非递归实现思路</h2><h3 id="先用“笨办法”实现"><a href="#先用“笨办法”实现" class="headerlink" title="先用“笨办法”实现"></a>先用“笨办法”实现</h3><p>我们先不追求<strong>复杂度</strong>，先写一个简单的解法，搭建出解题框架：</p><p>从左往右看字符串s，如果我们限制了起始字符，然后逐个往右查找、找到第一个重复字符串，就是最长子串。</p><p>所以，如果s为<code>b1b2b3...bn</code>，它就能被拆解为 <strong>起始字符为<code>b1</code>，<code>b2</code>,<code>b3</code> …. <code>bn</code>这样n个子问题中的最大值</strong>。</p><p>于是，我们尝试写一下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 遍历s，以i作为起始点，找到最长的子串</span></span><br><span class="line">    <span class="comment">// 注意：在string中如果用range的方法遍历，类型不是byte，而是rune</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">        mp[s[i]] = i</span><br><span class="line">        <span class="comment">// j 作为一个从i往后移动的游标，找到第一个重复的词或者达到len(s)，也就是末尾</span></span><br><span class="line">        <span class="keyword">var</span> j <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(s); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> _, ok := mp[s[j]]; ok &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="comment">// 找到重复的，直接退出</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mp[s[j]] = j <span class="comment">// 没找到重复的，加上这个子串</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 算出以i为起点的最长子串</span></span><br><span class="line">        length := j - i</span><br><span class="line">        <span class="keyword">if</span> length &gt; max &#123;</span><br><span class="line">            max = length</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面存在一些边界条件的判定，需要大家认证思考。</p><h3 id="从核心map切入"><a href="#从核心map切入" class="headerlink" title="从核心map切入"></a>从核心map切入</h3><p>在上面的解法中，我们用到了一个<code>map[byte]int</code>，用来保存 <strong>字符与位置的映射关系</strong>。但在整个循环的过程中，我们反复地<code>var mp = make(map[byte]int)</code>创建了空间。</p><p>由于s是一个固定的字符串，我们可以换一个思路尝试，先写出一个纯过程式的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 全局的字符串，用于保存</span></span><br><span class="line">    <span class="keyword">var</span> mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="comment">// Case1: 这是一个暂时未出现过的字符</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := mp[s[i]]; !ok &#123;</span><br><span class="line">            length := i - left + <span class="number">1</span> <span class="comment">// 到最左边的距离</span></span><br><span class="line">            <span class="keyword">if</span> length &gt; max &#123;</span><br><span class="line">                max = length</span><br><span class="line">            &#125;</span><br><span class="line">            mp[s[i]] = i <span class="comment">// 不存在的新元素，直接添加进来</span></span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// 打断逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Case2: 这是一个出现过的重复字符</span></span><br><span class="line">        length := i - left + <span class="number">1</span> <span class="comment">// 到最左边的距离</span></span><br><span class="line">        length2 := i - mp[s[i]] <span class="comment">// 到上一个重复字符串的距离</span></span><br><span class="line">        <span class="keyword">if</span> length &gt; length2 &#123;</span><br><span class="line">            length = length2 <span class="comment">// 取较短值</span></span><br><span class="line">            left = mp[s[i]] + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> length &gt; max &#123;</span><br><span class="line">            max = length</span><br><span class="line">        &#125;</span><br><span class="line">        mp[s[i]] = i <span class="comment">// 更新索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理一下最后一个字符串</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) - left &gt; max &#123;</span><br><span class="line">        max = <span class="built_in">len</span>(s) - left </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码的关键实现在于<strong>两个索引index</strong>：</p><ol><li><code>i</code>，用于遍历s</li><li><code>left</code>，0 &lt;= left &lt;= i，s[left:i]是<strong>不存在重复字符的字符串</strong>，其中left尽量取最小。换一个说法，s[left:i]是<strong>以s[i]为右节点的、无重复的、最长的子字符串</strong>。</li></ol><p>我们再回头看一下上面的代码，可读性有不少改进空间，我们尝试做一下优化，让可读性更好：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        length := i - left + <span class="number">1</span> <span class="comment">// 到最左边的距离</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := mp[s[i]]; ok &#123;</span><br><span class="line">            length2 := i - mp[s[i]] <span class="comment">// 到上一个重复字符串的距离</span></span><br><span class="line">            <span class="keyword">if</span> length &gt; length2 &#123;</span><br><span class="line">                length = length2</span><br><span class="line">                left = mp[s[i]] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> length &gt; max &#123;</span><br><span class="line">            max = length</span><br><span class="line">        &#125;</span><br><span class="line">        mp[s[i]] = i </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) - left &gt; max &#123;</span><br><span class="line">        max = <span class="built_in">len</span>(s) - left </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改动点并不大，但抽离了不少共性的代码，整体的性能有所提升。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面对<strong>明显可用递归方案解决</strong>的题目时，个人比较推荐的解题思路是：</p><ul><li><strong>用递归的解决方案理清思路，写出一个可用的方案，此时不要关注性能</strong></li><li><strong>从复杂度的角度思考，哪部分的工作是重复性的，提取出一个非递归的方案</strong></li></ul><p>如果一开始就去抠所谓的最佳方案，很容易陷入细节问题，而丢失了全局视野。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-3-无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#Leetcode-3-无
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 1.【两数相加LeetCode-2】递归解法</title>
    <link href="http://example.com/2021/07/10/go-leetcode/go-leetcode-1/"/>
    <id>http://example.com/2021/07/10/go-leetcode/go-leetcode-1/</id>
    <published>2021-07-10T04:00:00.000Z</published>
    <updated>2021-07-11T04:32:17.604Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-2-两数相加"><a href="#Leetcode-2-两数相加" class="headerlink" title="Leetcode-2 两数相加"></a>Leetcode-2 两数相加</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="keyword">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能保证代码都能执行，我会贴出所有代码，<strong>重点会用注释着重说明</strong>。</p><h2 id="递归实现的思路"><a href="#递归实现的思路" class="headerlink" title="递归实现的思路"></a>递归实现的思路</h2><h3 id="简化问题"><a href="#简化问题" class="headerlink" title="简化问题"></a>简化问题</h3><p>这道题的难点在于处理<strong>进位</strong>。那我们就先<strong>简化问题、把框架搭起来</strong>，看看先不考虑进位的大致代码怎么写的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// 先判断边界情况</span></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val</span><br><span class="line">        node.Next = addTwoNumbers(l1.Next, l2.Next)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val </span><br><span class="line">        node.Next = addTwoNumbers(l1.Next, l2)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val </span><br><span class="line">        node.Next = addTwoNumbers(l1, l2.Next)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这块代码有个问题- 当<code>l1</code>和<code>l2</code>都为空时，还会进入一次<code>addTwoNumbers</code>，导致最高位必定是0。</p><p>所以，我们需要保证<strong>最高位不要产生一个冗余，也就是l1和l2都为nil时，不要再进入addTwoNumbers函数</strong>。</p><h3 id="修复最高位的问题"><a href="#修复最高位的问题" class="headerlink" title="修复最高位的问题"></a>修复最高位的问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="comment">// 这里l1和l2作为指针传递下去</span></span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val </span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果都为空，无需继续处理</span></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续处理下一个节点</span></span><br><span class="line">    node.Next = addTwoNumbers(l1, l2)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归函数增加进位参数carry"><a href="#递归函数增加进位参数carry" class="headerlink" title="递归函数增加进位参数carry"></a>递归函数增加进位参数carry</h3><p>进位carry是一个在不同位中传递的参数，所以必须要加到函数签名中，所以我们得对递归函数进行改造。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的函数参数 carry</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val + carry</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + carry</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val + carry</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newCarry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> node.Val &gt; <span class="number">9</span> &#123;</span><br><span class="line">        node.Val = node.Val - <span class="number">10</span></span><br><span class="line">        newCarry = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; newCarry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, newCarry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="边界条件修复"><a href="#边界条件修复" class="headerlink" title="边界条件修复"></a>边界条件修复</h3><p>到了这里，我们看似完成了功能，但还有个边界条件没有修复：引入进位后，当<code>l1/l2</code>为nil，carry为1时，我们很容易就修复了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val + carry</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + carry</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val + carry</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        node.Val = carry <span class="comment">// 修复进位的边界问题</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newCarry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> node.Val &gt; <span class="number">9</span> &#123;</span><br><span class="line">        node.Val = node.Val - <span class="number">10</span></span><br><span class="line">        newCarry = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; newCarry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, newCarry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="持续优化"><a href="#持续优化" class="headerlink" title="持续优化"></a>持续优化</h2><p>首先，先明确一下优化的原则：</p><p><strong>我并不是单纯地为了提升性能而去优化，而是更应该从全局入手，考虑代码的可读性和扩展性！</strong></p><p>所以，下面的优化并不一定是性能最优的，但或多或少可能让你感受到代码的迭代升级。</p><h3 id="A-复用变量"><a href="#A-复用变量" class="headerlink" title="A - 复用变量"></a>A - 复用变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val + carry</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + carry</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val + carry</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.Val = carry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node.Val &gt; <span class="number">9</span> &#123;</span><br><span class="line">        node.Val = node.Val - <span class="number">10</span></span><br><span class="line">        carry = <span class="number">1</span> <span class="comment">// 复用carry变量</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; carry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, carry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除<code>newCarry</code>变量，节省了内存。</p><p>虽然这点改进很小，但我想表达的重点是：<strong>大家不要小看变量的复用，尤其是在一些递归调用的场景下，能节省大量的空间。</strong>上面的<code>l1</code>与<code>l2</code>这两个指针也进行了变量的复用。</p><h3 id="B-增加位操作，去除if-else分支"><a href="#B-增加位操作，去除if-else分支" class="headerlink" title="B - 增加位操作，去除if-else分支"></a>B - 增加位操作，去除if-else分支</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val + carry</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + carry</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val + carry</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.Val = carry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> <span class="comment">// 引入位操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; carry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, carry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-增加代码的扩展性（推荐）"><a href="#C-增加代码的扩展性（推荐）" class="headerlink" title="C - 增加代码的扩展性（推荐）"></a>C - 增加代码的扩展性（推荐）</h3><p>在这个代码里，我们只支持2个<code>ListNode</code>的相加，就引入了4个<code>if-else</code>的分支，这就很难支持大量<code>ListNode</code>的扩展。</p><p><strong>总体来说，我个人推荐这个解法，它的思路很清晰，也不会出现边界问题。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val += l1.Val</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val += l2.Val</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Val += carry</span><br><span class="line">    carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> <span class="comment">// 引入位操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; carry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, carry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战化特性"><a href="#实战化特性" class="headerlink" title="实战化特性"></a>实战化特性</h2><p>在实际的项目中，我们会希望这个函数的扩展性能更好，例如支持多个输入参数。</p><h3 id="引入不定参数的特性"><a href="#引入不定参数的特性" class="headerlink" title="引入不定参数的特性"></a>引入不定参数的特性</h3><p>我们进一步改造成<strong>不定参数</strong>形式的函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(<span class="number">0</span>, l1, l2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不定参数必须是最后一个函数签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(carry <span class="keyword">int</span>, nodes ...*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">        <span class="keyword">if</span> nodes[k] != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += nodes[k].Val</span><br><span class="line">            nodes[k] = nodes[k].Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Val += carry</span><br><span class="line">    carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> <span class="comment">// 引入位操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断所有node是否为空</span></span><br><span class="line">    <span class="keyword">var</span> isEnd = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">        <span class="keyword">if</span> nodes[k] != <span class="literal">nil</span> &#123;</span><br><span class="line">            isEnd = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> isEnd &amp;&amp; carry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(carry, nodes...)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-2-两数相加&quot;&gt;&lt;a href=&quot;#Leetcode-2-两数相加&quot; c
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 2.【两数相加LeetCode-2】非递归解法</title>
    <link href="http://example.com/2021/07/10/go-leetcode/go-leetcode-2/"/>
    <id>http://example.com/2021/07/10/go-leetcode/go-leetcode-2/</id>
    <published>2021-07-10T04:00:00.000Z</published>
    <updated>2021-07-13T02:56:50.647Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-2-两数相加"><a href="#Leetcode-2-两数相加" class="headerlink" title="Leetcode-2 两数相加"></a>Leetcode-2 两数相加</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></p><p>我们继续看上一个题目，这次我们尝试写一个非递归的解法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="keyword">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能保证代码都能执行，我会贴出所有代码，<strong>重点会用注释着重说明</strong>。</p><blockquote><p>我个人认为，非递归比递归写法更加麻烦，所以放到了第二讲。一开始直接上手用非递归的解法，很容易迷失在 边界条件 和 循环条件 中，排查问题也比较麻烦。</p></blockquote><h2 id="非递归实现的思路"><a href="#非递归实现的思路" class="headerlink" title="非递归实现的思路"></a>非递归实现的思路</h2><h3 id="简化问题"><a href="#简化问题" class="headerlink" title="简化问题"></a>简化问题</h3><p>我们不考虑进位问题，看看大致的代码架构：</p><h3 id="不考虑进位的解法"><a href="#不考虑进位的解法" class="headerlink" title="不考虑进位的解法"></a>不考虑进位的解法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// 哨兵节点，也就是作为初始化的节点</span></span><br><span class="line">    <span class="comment">// 在单向链表时引入这个哨兵，有利于我们找到起始的点</span></span><br><span class="line">    <span class="keyword">var</span> sentinel = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="comment">// walker节点，也就是用于遍历的节点</span></span><br><span class="line">    <span class="keyword">var</span> walker = sentinel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l1.Val</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l2.Val</span><br><span class="line">            l2l1 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把node追加到后面，walker继续往后走</span></span><br><span class="line">        walker.Next = node</span><br><span class="line">        walker = walker.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentinel.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增加进位参数carry"><a href="#增加进位参数carry" class="headerlink" title="增加进位参数carry"></a>增加进位参数carry</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sentinel = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> walker = sentinel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l1.Val</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        node.Val += carry</span><br><span class="line">        carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> <span class="comment">// 利用位操作</span></span><br><span class="line"></span><br><span class="line">        walker.Next = node</span><br><span class="line">        walker = walker.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentinel.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，<strong>非递归的实现会比递归的性能更高，但可读性较差</strong>。</p><ol><li>非递归减少了函数的堆栈，所以性能更高；</li><li>递归通过递归函数简化了复杂度，而非递归则需要循环；</li></ol><h2 id="持续优化"><a href="#持续优化" class="headerlink" title="持续优化"></a>持续优化</h2><h3 id="A-简单优化代码结构（推荐）"><a href="#A-简单优化代码结构（推荐）" class="headerlink" title="A - 简单优化代码结构（推荐）"></a>A - 简单优化代码结构（推荐）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sentinel = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> walker = sentinel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">        node.Val = carry <span class="comment">// 将carry直接放到初始化位置</span></span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l1.Val</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将两个指针赋值放在一起，含义比较清晰</span></span><br><span class="line">        <span class="comment">// 建议此类表达式尽量用于 多个强相关的变量 赋值，而不要贪图方便</span></span><br><span class="line">        walker.Next, walker = node, node </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentinel.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内存消耗：4.7 MB, 在所有 Go 提交中击败了29.47%的用户</li></ul><h3 id="B-进一步节省空间"><a href="#B-进一步节省空间" class="headerlink" title="B - 进一步节省空间"></a>B - 进一步节省空间</h3><p>至此，其实我们的代码已经相当简洁了，但有同学追求更好的数据。</p><p>这里，我们可以看一下，因为<code>l1</code>和<code>l2</code>这两个链表相加后，新的链表长度肯定是大于这两者的。所以，我们可以尝试复用一下其中一个链表，节省一下内存空间。这里，我们尝试复用一下链表<code>l1</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> walker = l1</span><br><span class="line"></span><br><span class="line">    <span class="comment">// walker用于遍历l1，而l1指针自身不动，用于返回</span></span><br><span class="line">    <span class="keyword">for</span> walker != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Val += l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        walker.Val += carry </span><br><span class="line"></span><br><span class="line">        carry, walker.Val = walker.Val/<span class="number">10</span>, walker.Val%<span class="number">10</span> </span><br><span class="line">        walker = walker.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的整体逻辑是正确的，但存在边界问题：如果<code>l1</code>比<code>l2</code>短时，后续的元素怎么生成？</p><p>于是，我们就有了改进：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> walker = l1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> walker != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Val += l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        walker.Val += carry </span><br><span class="line"></span><br><span class="line">        carry, walker.Val = walker.Val/<span class="number">10</span>, walker.Val%<span class="number">10</span> </span><br><span class="line">        <span class="comment">// 当walker下个节点为nil时，但后续节点还需要继续遍历，就新建一个Node</span></span><br><span class="line">        <span class="keyword">if</span> walker.Next == <span class="literal">nil</span> &amp;&amp; (l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            walker.Next = <span class="built_in">new</span>(ListNode)</span><br><span class="line">        &#125;</span><br><span class="line">        walker = walker.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内存消耗：4.4 MB, 在所有 Go 提交中击败了96.97%的用户</li></ul><h3 id="C-再次节省空间"><a href="#C-再次节省空间" class="headerlink" title="C - 再次节省空间"></a>C - 再次节省空间</h3><p>从上一个例子不难想到，我们还有继续优化的空间：如果<code>l2</code>比<code>l1</code>长时，我们想办法把walker节点指向<code>l2</code>，于是就有了下面的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 由于两个链表均为非空，所以初始化会简单一点</span></span><br><span class="line">    <span class="keyword">var</span> sentinel = l1</span><br><span class="line">    <span class="keyword">var</span> walker = l1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// walker与l1为统一节点时，Val已经有值了</span></span><br><span class="line">            <span class="keyword">if</span> walker != l1 &#123;</span><br><span class="line">                walker.Val += l1.Val</span><br><span class="line">            &#125;</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> walker != l2 &#123;</span><br><span class="line">                walker.Val += l2.Val</span><br><span class="line">            &#125;</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        walker.Val += carry </span><br><span class="line"></span><br><span class="line">        carry, walker.Val = walker.Val/<span class="number">10</span>, walker.Val%<span class="number">10</span> </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里就是去找下一个walker节点，先看l1，再看l2，最后看carry位有没有</span></span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Next = l1</span><br><span class="line">            walker = walker.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Next = l2</span><br><span class="line">            walker = walker.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> carry &gt; <span class="number">0</span> &#123;</span><br><span class="line">            walker.Next = <span class="built_in">new</span>(ListNode)</span><br><span class="line">            walker = walker.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentinel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再次做一个简单的优化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> sentinel, walker = l1, l1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> walker != l1 &#123;</span><br><span class="line">                walker.Val += l1.Val</span><br><span class="line">            &#125;</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> walker != l2 &#123;</span><br><span class="line">                walker.Val += l2.Val</span><br><span class="line">            &#125;</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        walker.Val += carry </span><br><span class="line">        carry, walker.Val = walker.Val/<span class="number">10</span>, walker.Val%<span class="number">10</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Next = l1</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            walker.Next = l2</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> carry &gt; <span class="number">0</span> &#123;</span><br><span class="line">            walker.Next = <span class="built_in">new</span>(ListNode)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从循环中跳出，也就是l1/l2为nil,carry=0</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将上面三个判断分支中的共性提取出</span></span><br><span class="line">        walker = walker.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentinel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在解单向链表的问题时，<code>Sentinel哨兵</code> + <code>Walker遍历</code>是一个很好的组合。</p><ul><li><code>Sentinel</code>放在单向链表的起始，指向我们的链表，能解决很多初始情况问题，例如链表本身为<code>nil</code></li><li><code>Walker</code>是一个遍历指针，聚焦于<code>walker = walker.Next</code>这个关键的移动操作</li></ul><p>总体来说，非递归的代码可读性会比递归的差一点，比较考验程序员的解题思路。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-2-两数相加&quot;&gt;&lt;a href=&quot;#Leetcode-2-两数相加&quot; c
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 6.【深入Go Module】探索最小版本选择的机制</title>
    <link href="http://example.com/2021/07/09/go-tip/go-tip-6/"/>
    <id>http://example.com/2021/07/09/go-tip/go-tip-6/</id>
    <published>2021-07-09T04:00:00.000Z</published>
    <updated>2021-07-10T02:24:32.768Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg" alt="Go-Study"></p><h2 id="从一个示例讲起"><a href="#从一个示例讲起" class="headerlink" title="从一个示例讲起"></a>从一个示例讲起</h2><p>用一个简单列表来表示我们的模块A依赖：</p><ul><li>B1<code>v1.0.0</code><ul><li>C1<code>v1.1.0</code></li><li>C2 <code>v1.2.0</code></li></ul></li><li>B2 <code>v1.2.0</code><ul><li>C1<code>v1.1.2</code></li><li>C3 <code>v1.2.0</code></li></ul></li></ul><p>表示 <em>A依赖B1与B2，而B1又依赖C1、C2，B2依赖C1、C3</em>。</p><p>这里，我们把关注点放到有争议的C1，它存在两个版本<code>v1.1.0</code>与<code>v1.1.2</code>。而最终A选择的是<code>v1.1.2</code>版本的C1。</p><ul><li>B1<code>v1.0.0</code><ul><li><del>C1<code>v1.1.0</code></del></li><li>C2 <code>v1.2.0</code></li></ul></li><li>B2 <code>v1.2.0</code><ul><li>C1<code>v1.1.2</code></li><li>C3 <code>v1.2.0</code></li></ul></li></ul><h3 id="问题1：为什么要选择较高版本的C1？"><a href="#问题1：为什么要选择较高版本的C1？" class="headerlink" title="问题1：为什么要选择较高版本的C1？"></a>问题1：为什么要选择较高版本的C1？</h3><p>也许你会疑惑，为什么原则名字叫<strong>最小版本选择</strong>，但反而选择了较高那个版本呢？</p><p>我们要明确一点，<strong>最小版本选择</strong>这个概念不是应用在这个场景的！</p><p>从两个版本号的语义来看，<code>v1.1.2</code>和<code>v1.1.0</code>的主版本号都是<code>v1</code>，说明是向下兼容的。所以我们自然会选择较高的<code>v1.1.2</code>，毕竟如果用了<code>v1.1.0</code>，可能导致B2具体的代码不可用。</p><h3 id="问题2：如果同时出现了v1和v2怎么办？"><a href="#问题2：如果同时出现了v1和v2怎么办？" class="headerlink" title="问题2：如果同时出现了v1和v2怎么办？"></a>问题2：如果同时出现了v1和v2怎么办？</h3><p>如果场景变化，C1的依赖版本为<code>v1.1.0</code>和<code>v2.0.0</code>，也就是大版本发生了变化。</p><p>从版本号的语义来看，两者是<strong>不兼容</strong>的！所以，这时不会出现<strong>高版本覆盖低版本</strong>的情况。</p><p>这时，就会出现依赖2个版本的C1。</p><h3 id="问题3：那什么是最小版本选择中的“最小”呢？"><a href="#问题3：那什么是最小版本选择中的“最小”呢？" class="headerlink" title="问题3：那什么是最小版本选择中的“最小”呢？"></a>问题3：那什么是最小版本选择中的“最小”呢？</h3><p>在C1这个库中，我们能看到很多tag，例如<code>v1.1.0</code>，<code>v1.1.1</code>，<code>v1.1.2</code>，<code>v1.1.3</code>。而我们用到的是<code>v1.1.2</code>和<code>v1.1.0</code>。</p><p>从兼容性来看，<code>v1.1.3</code>肯定能兼容前面的版本。但这时，根据<strong>最小版本选择</strong>，我们引用到<code>v1.1.2</code>。</p><p>为什么要用这个最小版本原则，而不是每次都去拉取最新的tag？大家不妨思考思考，我这里列两个我能想到的点：</p><ol><li>保证项目依赖的稳定性：如果存在某个依赖库高频更新，会导致整个项目也频繁升级，造成风险；</li><li>完全向下兼容并不可靠：毕竟软件存在不稳定性，最新的tag很有可能会导致代码变更；</li></ol><h2 id="结合源码巩固知识点"><a href="#结合源码巩固知识点" class="headerlink" title="结合源码巩固知识点"></a>结合源码巩固知识点</h2><p>在阅读源码之前，我们先明确本次阅读源码的预期：<strong>不要为了掌握所有代码细节而读代码，而是希望能通过了解这部分功能的一个大致实现，巩固理论知识</strong>。</p><p>这里，我以<code>go语言1.15.11</code>版本为例，具体的代码路径在<code>src/cmd/go/internal/modcmd</code>下。</p><p><code>go mod tidy</code>是整理Go Module最常用的指令之一，这里我们就来看看<code>tidy.go</code>文件。</p><h3 id="tidy的简介"><a href="#tidy的简介" class="headerlink" title="tidy的简介"></a>tidy的简介</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cmdTidy = &amp;base.Command&#123;</span><br><span class="line">UsageLine: <span class="string">&quot;go mod tidy [-v]&quot;</span>,</span><br><span class="line">Short:     <span class="string">&quot;add missing and remove unused modules&quot;</span>,</span><br><span class="line">Long: <span class="string">`</span></span><br><span class="line"><span class="string">Tidy makes sure go.mod matches the source code in the module.</span></span><br><span class="line"><span class="string">It adds any missing modules necessary to build the current module&#x27;s</span></span><br><span class="line"><span class="string">packages and dependencies, and it removes unused modules that</span></span><br><span class="line"><span class="string">don&#x27;t provide any relevant packages. It also adds any missing entries</span></span><br><span class="line"><span class="string">to go.sum and removes any unnecessary ones.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The -v flag causes tidy to print information about removed modules</span></span><br><span class="line"><span class="string">to standard error.</span></span><br><span class="line"><span class="string">`</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tidy</code>主要是把缺失的module加入到模块中，并删除弃用的modules。加上<code>-v</code>的标记位，就能把信息打印到标注错误。</p><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p>核心的数据结构为，储存Go Module的路径Path和版本Version:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Version <span class="keyword">struct</span> &#123;</span><br><span class="line">Path <span class="keyword">string</span></span><br><span class="line">Version <span class="keyword">string</span> <span class="string">`json:&quot;,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而加载模块的代码，则是下面的<code>mvs.Req</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cmd/go/internal/mvs</span></span><br><span class="line">mvs.Req(Target, direct, &amp;mvsReqs&#123;buildList: keep&#125;)</span><br></pre></td></tr></table></figure><p>这个函数的功能，我进行了一定的简化，大家关注重点标注出来的几行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Req</span><span class="params">(target module.Version, base []<span class="keyword">string</span>, reqs Reqs)</span> <span class="params">([]module.Version, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 保存模块与其依赖module的map，用map是为了防止依赖库重复</span></span><br><span class="line">reqCache := <span class="keyword">map</span>[module.Version][]module.Version&#123;&#125;</span><br><span class="line">reqCache[target] = <span class="literal">nil</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第一次遍历：walk函数，用于遍历整个依赖</span></span><br><span class="line"><span class="keyword">var</span> walk <span class="function"><span class="keyword">func</span><span class="params">(module.Version)</span> <span class="title">error</span></span></span><br><span class="line">walk = <span class="function"><span class="keyword">func</span><span class="params">(m module.Version)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取m的依赖库required，保存到map中</span></span><br><span class="line">required, err := reqs.Required(m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">reqCache[m] = required</span><br><span class="line">    <span class="comment">// 继续遍历依赖的依赖，保证不缺失</span></span><br><span class="line"><span class="keyword">for</span> _, m1 := <span class="keyword">range</span> required &#123;</span><br><span class="line"><span class="keyword">if</span> err := walk(m1); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">postorder = <span class="built_in">append</span>(postorder, m)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 真正运行第一次walk的地方</span></span><br><span class="line"><span class="keyword">for</span> _, m := <span class="keyword">range</span> list &#123;</span><br><span class="line"><span class="keyword">if</span> err := walk(m); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二次遍历：再次定义一个walk函数，取最大的版本号</span></span><br><span class="line">have := <span class="keyword">map</span>[module.Version]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">walk = <span class="function"><span class="keyword">func</span><span class="params">(m module.Version)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> have[m] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">have[m] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> _, m1 := <span class="keyword">range</span> reqCache[m] &#123;</span><br><span class="line">walk(m1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">max := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, m := <span class="keyword">range</span> list &#123;</span><br><span class="line"><span class="keyword">if</span> v, ok := max[m.Path]; ok &#123;</span><br><span class="line">      <span class="comment">// 只保存较大的版本号</span></span><br><span class="line">      <span class="comment">// 而v1与v2的问题也是在这里解决的：两者的Path路径不同</span></span><br><span class="line">max[m.Path] = reqs.Max(m.Version, v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">max[m.Path] = m.Version</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 真正运行第二次walk的地方</span></span><br><span class="line"><span class="keyword">var</span> min []module.Version</span><br><span class="line"><span class="keyword">for</span> _, path := <span class="keyword">range</span> base &#123;</span><br><span class="line">m := module.Version&#123;Path: path, Version: max[path]&#125;</span><br><span class="line">min = <span class="built_in">append</span>(min, m)</span><br><span class="line">walk(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据名称排序</span></span><br><span class="line">sort.Slice(min, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> min[i].Path &lt; min[j].Path</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> min, <span class="literal">nil</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>Minimal version selection (MVS)</strong> 的整体实现看起来不复杂，但其实里面做了很多兼容性的工作，尤其是<code>indirect</code>和<code>incompatible</code>等特性。这其实在另一层面提醒了我们：<strong>一项功能尽可能在前期做好设计，靠后期补救往往会增加大量兼容性的工作</strong>。</p><p>整个Go Module的核心实现在于2点：</p><ol><li>2个<code>walk</code>函数，一个用于查找所有依赖，另一个选择最大依赖版本；</li><li>选择最大依赖版本的核心依赖一个map，<code>max[m.Path] = reqs.Max(m.Version, v)</code></li></ol><p>至此，对Go Module的讲解告一段落了。而更多的细节问题，需要大家结合上一篇提到的排查问题工具，边实践、边加深理解。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;从一个示例讲起&quot;&gt;&lt;a href=&quot;#从一个示例讲起&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 5.【初探Go Module】Go语言的版本管理</title>
    <link href="http://example.com/2021/07/03/go-tip/go-tip-5/"/>
    <id>http://example.com/2021/07/03/go-tip/go-tip-5/</id>
    <published>2021-07-03T04:00:00.000Z</published>
    <updated>2021-07-03T04:52:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg" alt="Go-Study"></p><h2 id="Go-Mod的官方说明"><a href="#Go-Mod的官方说明" class="headerlink" title="Go Mod的官方说明"></a>Go Mod的官方说明</h2><p>Go语言自从推出了<code>go mod</code>作为版本管理工具后，结束Go语言版本管理工具的纷争，实现了大一统。</p><p>相信有很多人都对这个版本管理的机制都有基础的概念、但并不深入。而官方把最核心的实现，都放在这一篇 <a href="https://golang.org/ref/mod">https://golang.org/ref/mod</a> 文档中。</p><p>今天，我们一起来读读这一篇文章。</p><h2 id="快速入门-5篇介绍Go-Mod系列的官方博客"><a href="#快速入门-5篇介绍Go-Mod系列的官方博客" class="headerlink" title="快速入门 - 5篇介绍Go Mod系列的官方博客"></a>快速入门 - 5篇介绍Go Mod系列的官方博客</h2><p>新手直接阅读这篇文章的门槛有点高，我建议可以先看看下面这五篇较为通俗的官方博客，能帮助我们了解一些背景知识。</p><h3 id="1-using-go-modules"><a href="#1-using-go-modules" class="headerlink" title="1. using-go-modules"></a>1. using-go-modules</h3><p><a href="https://blog.golang.org/using-go-modules">https://blog.golang.org/using-go-modules</a> </p><ol><li><code>go.mod</code>放在项目的根目录，抛弃原来的<code>GOPATH</code></li><li>用<code>MAJOR.MINOR.PATCH</code>格式管理版本，详细可参考<a href="https://semver.org/">Semantic Versioning 2.0.0</a></li><li>用<code>go.sum</code>保证依赖文件被完整下载（如果公司搭建私有库就会出现校验问题，需要关闭GOSUM）</li><li>项目内部的库，不再是相对路径，而用的是 <code>go mod模块名</code> + <code>相对路径</code> ，定义更加清晰</li></ol><blockquote><p>第四点的价值很大，可读性大大提高，我们可以将一整个path来辅助命名，如 market/order，前者market可以帮助后者order的含义做一定补充</p></blockquote><h3 id="2-migrating-to-go-modules"><a href="#2-migrating-to-go-modules" class="headerlink" title="2. migrating-to-go-modules"></a>2. migrating-to-go-modules</h3><p><a href="https://blog.golang.org/migrating-to-go-modules">https://blog.golang.org/migrating-to-go-modules</a></p><p>将项目迁移到go mod，主要讲的是对接老的版本管理系统，如<code>godeps</code>。</p><h3 id="3-publishing-go-modules"><a href="#3-publishing-go-modules" class="headerlink" title="3. publishing-go-modules"></a>3. publishing-go-modules</h3><p><a href="https://blog.golang.org/publishing-go-modules">https://blog.golang.org/publishing-go-modules</a></p><p>版本命名规则：推荐不稳定版本用<code>v0.x.x</code>开始，稳定后改成<code>v1.x.x</code>。</p><p><strong>pseudo-version</strong> 直译为假的版本，一般是直接依赖branch，而不是按规范依赖tag</p><h3 id="4-v2-go-modules"><a href="#4-v2-go-modules" class="headerlink" title="4. v2-go-modules"></a>4. v2-go-modules</h3><p><a href="https://blog.golang.org/v2-go-modules">https://blog.golang.org/v2-go-modules</a></p><p>注意主版本名为<code>v2</code>之后的，项目里对应的要新增一个<code>v2</code>或者更高版本号的目录。</p><blockquote><p>我个人感觉升级到v2这种方式不太友好，需要我们再维护一整个目录</p></blockquote><h3 id="5-module-compatibility"><a href="#5-module-compatibility" class="headerlink" title="5. module-compatibility"></a>5. module-compatibility</h3><p><a href="https://blog.golang.org/module-compatibility">https://blog.golang.org/module-compatibility</a></p><ol><li>用不定参数<code>...</code>的特性提高函数的入参扩展性</li><li>引入函数式的参数，也就是将具体的执行逻辑作为参数，传递进来</li><li>引入<code>Option types</code>模式，更详细地可以参考我的<a href="https://junedayday.github.io/2021/02/20/go-patterns/go-patterns-5/">文章</a></li><li>用接口<code>interface</code>分离调用和实现</li><li>如果结构体<code>struct</code>明确不能对比，就用一个<code>doNotCompare</code>的<code>field</code>来告诉调用者</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> doNotCompare [<span class="number">0</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">        doNotCompare</span><br><span class="line">        X <span class="keyword">int</span></span><br><span class="line">        Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第五点非常有意思，也就是要求我们在前期设计对象时，就要考虑清楚这个对象后续的特性，比如示例中的是否可以对比</p></blockquote><h2 id="从go-mod的文件格式讲起"><a href="#从go-mod的文件格式讲起" class="headerlink" title="从go.mod的文件格式讲起"></a>从go.mod的文件格式讲起</h2><p>进入正题，我们来一起看看<code>go.mod</code>，它的定义简单示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module example.com/my/thing</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require example.com/other/thing v1.0.2</span><br><span class="line">require example.com/new/thing/v2 v2.3.4</span><br><span class="line">exclude example.com/old/thing v1.2.3</span><br><span class="line">replace example.com/bad/thing v1.4.5 =&gt; example.com/good/thing v1.4.5</span><br><span class="line">retract [v1.9.0, v1.9.5]</span><br></pre></td></tr></table></figure><p>IDE会帮助你格式化，记住以下关键词即可（重点为前三个）</p><ol><li><strong>module</strong> - go mod init指令定义的<strong>库名</strong></li><li><strong>go</strong> - <strong>要求go语言的最低版本</strong>，会影响到后面依赖库的下载</li><li><strong>require</strong> - <strong>必备库</strong>，也就是代码中直接import的部分</li><li><strong>replace</strong> - <strong>替换库</strong>，在重构时挺好用（比如某个开源组件有问题，内部fork了一版，直接replace即可）</li><li><strong>retract</strong> <strong>撤回版本</strong>，告诉调用本库的项目，部分版本有严重问题、不要引用</li></ol><blockquote><p>go mod 底层实现依赖 - <strong>MVS</strong> 最小版本选择。</p><p>这个特性很有意思，后续单独来讲讲这块，一开始就不深入到细节了</p></blockquote><h2 id="加深理解-incompatible和indirect"><a href="#加深理解-incompatible和indirect" class="headerlink" title="加深理解 - incompatible和indirect"></a>加深理解 - incompatible和indirect</h2><p>在我们整理<code>go.mod</code>文件时，经常能看到两个奇怪的字符<code>indirect</code>和<code>incompatible</code>。我们来详细地分析一下。</p><h3 id="incompatible-兼容v2及以上的版本号"><a href="#incompatible-兼容v2及以上的版本号" class="headerlink" title="incompatible - 兼容v2及以上的版本号"></a>incompatible - 兼容v2及以上的版本号</h3><p>上面我们已经讲过，如果一个库的tag为v1以上，如v2，就必须得创建一个v2的目录。例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require example.com/new/thing/v2 v2.3.4</span><br></pre></td></tr></table></figure><p>这就要求我们在项目<code>example.com/new/thing</code>下新建v2目录，再存放代码。但是，很多库往往只是升级个主版本号，并不会去新建目录、还需要迁移代码。为了兼容这个情况，就会引入<code>+incompatible</code>。例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require example.com/new/thing v2.3.4+incompatible</span><br></pre></td></tr></table></figure><h3 id="indirect-未在go-mod里定义、但间接调用的库"><a href="#indirect-未在go-mod里定义、但间接调用的库" class="headerlink" title="indirect - 未在go.mod里定义、但间接调用的库"></a>indirect - 未在go.mod里定义、但间接调用的库</h3><p>我们先聊一个简单的场景：<strong>当前项目为A，调用了项目B，B又调用了C。对A进行编译，需要B和C的相关代码</strong>。</p><p>在完全规范的项目中：</p><ul><li><strong>条件1</strong> - A的go.mod里包含B</li><li><strong>条件2</strong> - B的go.mod里包含C</li></ul><p>在编译A时，会在go.mod找到B的信息，所以B是<code>require</code>字段；而C的信息已经被维护在B的go.mod里了，不需要在A的go.mod里维护。</p><p>而什么样的情况会发生indirect呢？它对应的是 <strong>条件2</strong> 缺失的场景</p><ol><li>B<strong>没有启用Go Module</strong>，采用的是老项目管理方式</li><li>B的<strong>go.mod部分缺失</strong>，未填写模块C</li></ol><blockquote><p>最常见的部分缺失场景是：项目虽然有go.mod，但实际编译不走Go Module，而是如vendor目录等方式</p></blockquote><p>用一句话总结，<strong>A库无法根据B库的<code>go.mod</code>找到C库</strong>。</p><h2 id="常见命令介绍"><a href="#常见命令介绍" class="headerlink" title="常见命令介绍"></a>常见命令介绍</h2><p>相关的指令有很多，我重点分两块来说：</p><p>先是<strong>高频使用</strong>的命令：</p><h3 id="用go-mod-init初始化项目"><a href="#用go-mod-init初始化项目" class="headerlink" title="用go mod init初始化项目"></a>用go mod init初始化项目</h3><p>初始化项目，保证module名称与git路径一致。</p><p>例如 <code>go mod init github.com/example/a</code></p><h3 id="用go-get下载指定依赖库与版本"><a href="#用go-get下载指定依赖库与版本" class="headerlink" title="用go get下载指定依赖库与版本"></a>用go get下载指定依赖库与版本</h3><p>常见的flags</p><ul><li><strong>-d</strong> 只更新<code>go.mod</code>中的依赖，轻量级</li><li><strong>-u</strong> 更新指定库与依赖它的库，全量</li></ul><p>例如<code>go get -d github.com/example/b</code></p><h3 id="根据go-mod下载依赖库go-mod-download-vendor"><a href="#根据go-mod下载依赖库go-mod-download-vendor" class="headerlink" title="根据go.mod下载依赖库go mod download/vendor"></a>根据go.mod下载依赖库go mod download/vendor</h3><p>其中download是下载到Go Module的缓存中，而vendor是下载到vendor依赖路径。官方推荐前者。</p><p>我经常会去手动编辑<code>go.mod</code>文件，然后用这个指令刷新一下依赖库</p><h3 id="整理依赖go-mod-tidy"><a href="#整理依赖go-mod-tidy" class="headerlink" title="整理依赖go mod tidy"></a>整理依赖go mod tidy</h3><p>整理并更新go mod的依赖信息，保证当前的<code>go.mod</code>为最新。</p><p>然后是<strong>排查依赖库问题</strong>用到的：</p><h3 id="查看库的支持版本go-list"><a href="#查看库的支持版本go-list" class="headerlink" title="查看库的支持版本go list"></a>查看库的支持版本go list</h3><ul><li><code>go list -m all</code> 查看本项目的所有依赖库与版本</li><li><code>go list -m -versions &#123;module名&#125;</code> 查看module支持的版本号</li><li><code>go list -m -json &#123;module名&#125;@&#123;版本号&#125;</code> 用json格式查看指定module版本号的信息，如创建时间</li></ul><h3 id="查看当前库的依赖关系go-mod-graph"><a href="#查看当前库的依赖关系go-mod-graph" class="headerlink" title="查看当前库的依赖关系go mod graph"></a>查看当前库的依赖关系go mod graph</h3><p>查看所有go mod的依赖，一般在查依赖关系时用到</p><h3 id="查看指定库是怎么被依赖的go-mod-why"><a href="#查看指定库是怎么被依赖的go-mod-why" class="headerlink" title="查看指定库是怎么被依赖的go mod why"></a>查看指定库是怎么被依赖的go mod why</h3><p>查指定库是怎么被依赖的</p><h3 id="查看二进制文件的依赖信息go-version-m"><a href="#查看二进制文件的依赖信息go-version-m" class="headerlink" title="查看二进制文件的依赖信息go version -m"></a>查看二进制文件的依赖信息go version -m</h3><p>查看指定（go文件编译的）二进制文件的版本信息</p><h2 id="设置GOPRXOY"><a href="#设置GOPRXOY" class="headerlink" title="设置GOPRXOY"></a>设置GOPRXOY</h2><p>大部分人使用<code>go.mod</code>的最大问题是无法下载代码库，也就是代理的设置，网上也有很多教程，我这边给三个我常用的：</p><ol><li>阿里云：GOPROXY=<a href="https://mirrors.aliyun.com/goproxy,direct">https://mirrors.aliyun.com/goproxy,direct</a></li><li>七牛云：GOPROXY=<a href="https://goproxy.cn,direct/">https://goproxy.cn,direct</a></li><li>全球代理：GOPROXY=<a href="https://goproxy.io,direct/">https://goproxy.io,direct</a></li></ol><blockquote><p>公司私有库需要私有代理。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本讲的内容到这里就告一段落了，相信通过这篇文章，大家已经能应对绝大部分Go Module的场景。</p><p>下一讲，我会重点讲Go Module最核心的 <strong>Minimal version selection (MVS)</strong> 机制。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Go-Mod的官方说明&quot;&gt;&lt;a href=&quot;#Go-Mod的官方说明&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 4.【错误的三种处理】探索不同代码风格背后的哲学</title>
    <link href="http://example.com/2021/06/27/go-tip/go-tip-4/"/>
    <id>http://example.com/2021/06/27/go-tip/go-tip-4/</id>
    <published>2021-06-27T04:00:00.000Z</published>
    <updated>2021-07-11T13:53:40.547Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg" alt="Go-Study"></p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>通过前面两讲，我们对错误的认知已经超过很多人了。让我们继续去看看常见项目中对错误的处理方式，探索背后的深意。</p><p>在介绍具体的处理方式前，我们先来模拟一个场景：我们要去动物园进行一次游玩，主要行为有</p><ul><li>进入动物园</li><li>参观熊猫</li><li>参观老虎</li><li>离开动物园</li></ul><h2 id="第一种风格-经典Go语言的处理模式"><a href="#第一种风格-经典Go语言的处理模式" class="headerlink" title="第一种风格 - 经典Go语言的处理模式"></a>第一种风格 - 经典Go语言的处理模式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次旅游</span></span><br><span class="line"><span class="keyword">type</span> ZooTour1 <span class="keyword">interface</span> &#123;</span><br><span class="line">Enter() error <span class="comment">// 进入</span></span><br><span class="line">VisitPanda(panda *Panda) error <span class="comment">// 看熊猫</span></span><br><span class="line">VisitTiger(tiger *Tiger) error <span class="comment">// 看老虎</span></span><br><span class="line">Leave() error <span class="comment">// 离开</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tour1</span><span class="params">(t ZooTour1, panda *Panda, tiger *Tiger)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := t.Enter(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;Enter failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := t.VisitPanda(panda); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessagef(err, <span class="string">&quot;VisitPanda failed, panda is %v&quot;</span>, panda)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := t.VisitTiger(tiger); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessagef(err, <span class="string">&quot;VisitTiger failed, tiger is %v&quot;</span>, tiger)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := t.Leave(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;Leave failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个处理风格非常经典。我们先不深入讨论，看完下一种后再做对比。</p><h2 id="第二种风格-类似Try-Catch的代码风格"><a href="#第二种风格-类似Try-Catch的代码风格" class="headerlink" title="第二种风格 - 类似Try-Catch的代码风格"></a>第二种风格 - 类似Try-Catch的代码风格</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ZooTour2 <span class="keyword">interface</span> &#123;</span><br><span class="line">Enter()</span><br><span class="line">VisitPanda(panda *Panda)</span><br><span class="line">VisitTiger(tiger *Tiger)</span><br><span class="line">Leave()</span><br><span class="line"></span><br><span class="line">Err() error <span class="comment">// 统一处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tour2</span><span class="params">(t ZooTour2, panda *Panda, tiger *Tiger)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">t.Enter()</span><br><span class="line">t.VisitPanda(panda)</span><br><span class="line">t.VisitTiger(tiger)</span><br><span class="line">t.Leave()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := t.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;ZooTour failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一整块的代码风格非常类似<strong>Try Catch</strong>，即先写业务逻辑，在最后对错误进行集中处理。</p><blockquote><p>标准库中的<code>bufio.Scanner</code>就是参考这种方式实现的。</p></blockquote><p>不过，由于Go语言对error的处理没有往外抛的机制，所以需要专门针对error做处理：</p><blockquote><p>新手千万不要把panic的机制和错误处理混为一谈。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZooTour的具体实现，需要保存一个error</span></span><br><span class="line"><span class="keyword">type</span> myZooTour <span class="keyword">struct</span> &#123;</span><br><span class="line">err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *myZooTour)</span> <span class="title">VisitPanda</span><span class="params">(panda *Panda)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 遇到错误就要直接返回，再处理其余逻辑</span></span><br><span class="line"><span class="keyword">if</span> t.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两种风格的对比"><a href="#两种风格的对比" class="headerlink" title="两种风格的对比"></a>两种风格的对比</h2><p>如果分别用一个词来形容前两种风格，我倾向于：</p><ol><li><strong>过程式的调用</strong></li><li><strong>集中处理错误</strong></li></ol><p>两种风格无法说清孰优孰劣，但有各自适宜的场景，我们来列举两种：</p><h3 id="不关注错误的发生，而关注错误发生后的统一处理"><a href="#不关注错误的发生，而关注错误发生后的统一处理" class="headerlink" title="不关注错误的发生，而关注错误发生后的统一处理"></a>不关注错误的发生，而关注错误发生后的统一处理</h3><p>内部存在大量的<code>VisitXXX</code>的函数，业务不关注发生错误的处理逻辑，而是关注整个流程完成后对error的处理。</p><p>例如，调用过程中如果出现了某个动物不在的问题，我们不关心，继续访问下一个，最后统一处理一下，看看有多少动物是不在的，打印一下即可。</p><p>这时，第二种处理方式明显会更简洁。</p><blockquote><p>一般推荐在工具类中采用这种方式，处理的内容比较直观，不会有太多异常case</p></blockquote><h3 id="错误有多种分类，会影响到程序的运行逻辑"><a href="#错误有多种分类，会影响到程序的运行逻辑" class="headerlink" title="错误有多种分类，会影响到程序的运行逻辑"></a>错误有多种分类，会影响到程序的运行逻辑</h3><p>例如<code>VisitPanda(panda *Panda)</code> 可能产生的错误分2类：</p><ul><li><p>不影响主流程：例如发现panda不见了，但还要接着继续参观其余动物</p></li><li><p>影响主流程：例如突然收到动物园闭园的通知，不能参观其余动物了</p></li></ul><p>这时，如果我们采用第二种风格，就得在每个函数内部加上很多特殊的业务逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *myZooTour)</span> <span class="title">VisitTiger</span><span class="params">(tiger *Tiger)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 要针对特定error进行处理</span></span><br><span class="line"><span class="keyword">if</span> t.err != <span class="literal">nil</span> &amp;&amp; t.err != ErrorPandaMissing &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很有可能出现一个问题：<strong>把Panda相关的error放到了Tiger里</strong>。</p><p>所以，<strong>当错误的类型会影响到代码的运行逻辑，更适合第一种方案</strong>。</p><blockquote><p>一般情况下，我们的业务代码都是复杂的，这时候更适合写过程性的代码。</p></blockquote><h2 id="第三种风格-函数式编程"><a href="#第三种风格-函数式编程" class="headerlink" title="第三种风格 - 函数式编程"></a>第三种风格 - 函数式编程</h2><p>借用1中的接口定义，我们将它改造成函数式的风格：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFunc <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEnterFunc</span><span class="params">()</span> <span class="title">MyFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> t.Enter()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewVisitPandaFunc</span><span class="params">(panda *Panda)</span> <span class="title">MyFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> t.VisitPanda(panda)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewVisitTigerFunc</span><span class="params">(tiger *Tiger)</span> <span class="title">MyFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> t.VisitTiger(tiger)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLeaveFunc</span><span class="params">()</span> <span class="title">MyFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> t.Leave()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用代码示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tour3</span><span class="params">(t ZooTour1, panda *Panda, tiger *Tiger)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> actions = []MyFunc&#123;</span><br><span class="line">NewEnterFunc(),</span><br><span class="line">NewVisitPandaFunc(panda),</span><br><span class="line">NewVisitTigerFunc(tiger),</span><br><span class="line">NewLeaveFunc(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ContinueOnError(t, actions)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContinueOnError</span><span class="params">(t ZooTour1, funcs []MyFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">    <span class="keyword">if</span> err := f(t);err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// continue</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BreakOnError</span><span class="params">(t ZooTour1, funcs []MyFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">    <span class="keyword">if</span> err := f(t);err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是</p><ul><li><code>ContinueOnError</code>表示遇到了error只记录下来，但整个流程继续往下跑</li><li><code>BreakOnError</code>表示遇到了error就直接break，不再跑接下来的<code>MyFunc</code></li></ul><h2 id="方案三背后的思想与延伸"><a href="#方案三背后的思想与延伸" class="headerlink" title="方案三背后的思想与延伸"></a>方案三背后的思想与延伸</h2><p>函数式编程最直观的一个特点是 <strong>延迟执行</strong>，也就是在引用<code>MyFunc</code>处不运行，在<code>ContinueOnError</code>或<code>BreakOnError</code>里才是真正执行的地方。</p><p>这个延迟执行的特性，在这里还能达到一个很有意思的效果 - <strong>分离关注点</strong>。</p><h3 id="关注点1-数据结构"><a href="#关注点1-数据结构" class="headerlink" title="关注点1 - 数据结构"></a>关注点1 - 数据结构</h3><p>样例中的<code>[]MyFunc</code>是一个切片，可以简单地理解为<strong>串行执行</strong>，也就是<code>MyFunc</code>执行完一个，再执行下一个。</p><p>我们可以引入更多的数据结构，例如<code>[][]MyFunc</code>，那就可以理解为增加了一层：</p><p>每一层中的<code>[]MyFunc</code>，代表这里面的所有<code>MyFunc</code>是平级的，也就可以采用一定的并发模式来加速执行。</p><h3 id="关注点2-执行逻辑"><a href="#关注点2-执行逻辑" class="headerlink" title="关注点2 - 执行逻辑"></a>关注点2 - 执行逻辑</h3><p>以<code>ContinueOnError</code>或<code>BreakOnError</code>为例，它们都是对各种<code>MyFunc</code>的处理逻辑。我们还可以引入更多的执行逻辑，比如：</p><ul><li>容忍特定错误的情况</li><li>对错误发生的数量有容忍上限</li><li>保证一定的并发模式</li></ul><h3 id="流水线的模式"><a href="#流水线的模式" class="headerlink" title="流水线的模式"></a>流水线的模式</h3><p>以我们常见的开发流水线为例，常见的包括：代码检查、单元测试、编译、CodeReview、自动化部署等。</p><p>这时，数据结构可以用来表示<strong>流水线的结构</strong>，执行逻辑可以用来表示<strong>流水线对异常的处置</strong>。</p><p>比如说，我们可以编排为一种串行执行的逻辑：</p><ol><li>代码检查</li><li>单元测试</li><li>编译</li><li>CodeReview</li><li>自动化部署</li></ol><p>我们想要加速整个流程，可以考虑修改为：</p><ol><li>检查<ol><li>代码检查</li><li>单元测试</li><li>编译</li></ol></li><li>CodeReview</li><li>自动化部署</li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文介绍了三种对error的处理方式，代码实现相对简单，大家更需要关注背后的适用场景。</p><p>其中，第三种方式是一个很有意思的设计模式，可以帮助大家理解函数式编程的价值。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习路线 - 5.基础篇:从一个web项目来谈Go语言的技能点</title>
    <link href="http://example.com/2021/05/13/go-study/go-study-5/"/>
    <id>http://example.com/2021/05/13/go-study/go-study-5/</id>
    <published>2021-05-13T04:00:00.000Z</published>
    <updated>2021-06-19T14:52:26.479Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p><h2 id="从一个Web项目开始"><a href="#从一个Web项目开始" class="headerlink" title="从一个Web项目开始"></a>从一个Web项目开始</h2><p>经过了 <strong>入门篇</strong> 的学习，大家已经初步了解Go语言的语法，也能写常见的代码了。接下来，我们就从一个Web项目入手，看看一些常见的技能与知识吧。</p><p>我们先简单地聊一下这个Web项目的背景：我们要做的是一个简单的web系统 ，有前端同学负责界面的开发，后端不会考虑高并发等复杂情况。</p><p>我们先从一个Web请求出发，看看会涉及到哪些模块。</p><h2 id="前端的请求生命周期"><a href="#前端的请求生命周期" class="headerlink" title="前端的请求生命周期"></a>前端的请求生命周期</h2><p>用户在web界面上点击了一个按钮，就由前端发起了一个请求。那这个请求的生命周期是怎么样的呢？</p><p>通常情况下，后端的工作是<strong>解析前端的数据，处理对应的业务逻辑，返回操作结果</strong>。</p><p>这里，离不开三层概念：</p><ul><li>API层：解析来自前端的数据，转化成go的数据结构</li><li>Service层：包含业务逻辑，是这个请求具体要做的事情</li><li>Dao层：数据持久化，也就是更新到数据库等，保证不丢失</li></ul><blockquote><p>不同框架有不同的命名方式，但我个人建议只关注这三层即可。</p></blockquote><p>当然，这三层逻辑并不绝对，会因为项目特点有所调整，但整体的<strong>分层思路</strong>是不会变化的。我认为，如果你能真正地理解web的分层，对项目的框架就能掌握得很棒了。</p><p>接下来，我们自顶向下逐层聊聊。</p><h2 id="第一层：API层"><a href="#第一层：API层" class="headerlink" title="第一层：API层"></a>第一层：API层</h2><p>通常来说，API层只做三件事：</p><ol><li><strong>根据路由规则，调用具体的处理函数</strong> ，常见的RESTful就是由<code>URL</code>+<code>Method</code>的作为路由规则；</li><li><strong>解析文本或二进制数据到Go结构体</strong>，常见的是用<code>json</code>反序列化；</li><li><strong>调用下一层Service的函数</strong></li></ol><p>抛开第三点暂且不谈，前两者比较容易理解，大家可以使用标准库里的<code>net/http</code>和<code>encoding/json</code>来完成。具体的代码我就不写了，网上示例非常多。</p><p>那么，API层这么简单，有什么学问嘛？这里，我建议大家看看两个开源库：</p><ul><li><a href="https://github.com/gin-gonic/gin">Gin</a></li><li><a href="https://github.com/gorilla/mux">Mux</a></li></ul><p>看看上面的示例，对比一下原生的<code>net/http</code>库写出来的代码，是否感觉可读性大大提高？没错，API层关键点之一的就是<strong>可读性</strong>。</p><p>不过Gin相对于Mux非常重量级，学习起来成本很大；而Mux虽然可读性提高，但在解析<code>http body</code>数据这块效果不佳，还是需要逐个手写结构体。</p><blockquote><p>所以，在我看来，这两个都并不是最佳方案，我非常建议有条件的项目能够直接引入 <strong>RPC级别的解决方案</strong>，例如gRPC。这块我会拿具体项目、花好几讲来好好说说。</p></blockquote><p>在开发的过程中，我对API层的开发会重点关注这几点：</p><ul><li>可读性：可以快速地根据命名了解功能，如<strong>RESTful</strong></li><li>高度复用：如引入<code>mux</code> 中的各种 middleware，比如 <strong>防止panic</strong> 、<strong>用户认证</strong> 、日志打印等</li><li>尽量薄：不做或少做业务逻辑处理，复杂处理都丢到service层</li><li>文档化：将接口的相关参数通过文档给到前端或第三方，尽量做到自动化或半自动化</li></ul><p>我再强调一下API层的重要性：<strong>API层是程序最关键的入口和出口，能很好地追踪到数据的前后变化情况。</strong> 一个优秀的API层实现，不仅能让我们少写很多重复性代码，也能大幅度地降低我们排查问题的效率。</p><h2 id="第二层：Service层"><a href="#第二层：Service层" class="headerlink" title="第二层：Service层"></a>第二层：Service层</h2><p>Service层可以理解为服务层，是整个项目中最复杂、也是代码比重往往是最多的。它是一个项目最核心的业务价值所在。</p><p>Service是最灵活、也是最考验设计能力的，虽说<strong>没有一套固定的模式</strong>，但还是会有一定的<strong>套路</strong>。</p><p>我分享一下个人的三个见解：</p><ol><li>单元测试覆盖率要尽量高，这是一个<strong>高频迭代与重构</strong>的模块，也是最容易出现问题的部分；</li><li>深入实践 <strong>面向对象与DDD</strong> ，最锻炼工程师抽象、解耦等能力的模块；</li><li>选择合适的 <strong>设计模式</strong> 可大幅度地提升研发效率；</li></ol><p>再提一句，请跃跃欲试的各位冷静一下，<strong>Service层是和业务一起成长的</strong>，前期没必要过度设计。我们把重点放在<strong>单元测试</strong>的编写上即可，适当地选用一些库来提高效率，如开源的<code>stretchr/testify</code>，内部的<code>reflect</code>等。</p><h2 id="第三层：Dao层"><a href="#第三层：Dao层" class="headerlink" title="第三层：Dao层"></a>第三层：Dao层</h2><p>Dao层常被理解为数据持久化层，但我们可以将它进行一定的延伸：<strong>将RPC调用也当做Dao层</strong>（不妨认为将数据持久化到了另一个服务），来适配微服务架构的场景。</p><blockquote><p>严格意义上，RPC调用和普通的Dao差异有不少，但为了收敛话题，我们暂且不细分。</p></blockquote><p>今天，我们不关注分布式场景下的各种数据问题，也不考虑各种存储中间件的特点，而是聚焦于一个问题：<strong>如何将内存中的对象持久化到数据库中</strong>。在编程领域，这部分的工具被称为<strong>ORM</strong>。</p><p>以Go语言对接MySQL为例，最常见的为<a href="https://github.com/go-gorm/gorm">gorm</a>，它能很便捷地将一个Go语言中的结构体，映射到MySQL数据库某个表中的一行数据。</p><blockquote><p>请自行对比一下，用go官方的sql库写增删改查，与用gorm写增删改查的工作量差异。</p></blockquote><p>关于Dao层，我认为有部分的实践是比较通用的：</p><ol><li><strong>选用官方或社区高频使用的库</strong>，避免后期出现功能缺失或性能瓶颈的问题；</li><li><strong>灵活性比易用性更重要</strong>，通过一层浅封装，往往能更适配项目，达到更棒的易用性；</li><li><strong>关注数据库的原理、而不是ORM工具的实现方式</strong>，数据库的原理是长期的积累，对技术选型和排查故障很有帮助。</li></ol><blockquote><p>至于不同的数据库ORM有不同的最佳实践，一一列举的工作量太大，我会在工程化的过程中选择性地讲解。</p></blockquote><h2 id="串联三层"><a href="#串联三层" class="headerlink" title="串联三层"></a>串联三层</h2><p>到这里，我们对这三层有了初步的了解，可以总结为**两边薄（API、Dao），中间厚（Service)**。</p><p>这里的实践需要大家不断打磨，比如说：</p><ul><li>API与Dao会随着个人编程能力的提升，不断地总结出更好的编程实践；</li><li>做性能优化时，优先考虑Dao，其次考虑API，这两部分的提效是最明显的；</li><li>排查问题时，先分析API的出入口，再分析Dao的出入口，实在解决不了再去看Service（此时已经是严重的业务逻辑问题了）；</li></ul><p>到最后，相信大家对这三层认知会进一步提升：</p><ul><li>API：服务对外的门面，通过一个接口定义就能了解大致实现原理；</li><li>Service：复杂的业务逻辑，非该服务的核心成员无需关注，而核心成员须重点维护；</li><li>Dao：无论是调用<strong>ORM</strong>还是<strong>SDK</strong>，都视为一种<strong>工具集</strong>，是一个技术人员沉淀通用能力的重点。</li></ul><h2 id="CRUD程序员"><a href="#CRUD程序员" class="headerlink" title="CRUD程序员"></a>CRUD程序员</h2><p>很多程序员都戏称自己是一个只会<strong>CRUD</strong>的码农。让我们换个视角，看看CRUD背后有没有一些的技术点。</p><ul><li>API层：遵循<strong>RESTful</strong>的原则，提高可读性（最好能在一行代码中看到，如<code>mux</code>）<ul><li>将操作（CRUD）对应到HTTP的Method</li><li>将资源对象对应到HTTP的URL</li></ul></li><li>Service层：<ul><li>对于只是简单的修改，Service不用做复杂处理，透传到Dao层即可</li><li>如果涉及到多个表的修改，进行事务处理（如mysql的transaction）</li><li>在Dao层出现错误时，适当封装错误信息，提高可读性</li></ul></li><li>Dao层：<ul><li>选择并熟练运用ORM，快速实现基本的CRUD</li><li>对复杂的ORM进行一层浅封装，方便Service层的调用</li></ul></li></ul><p>经过一段时间的磨练，CRUD的工作能大大提效，我们就能抽出更多的时间去学习其余技能了。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Web项目是我们日常开发最常见的项目类型，也是很多面试考察点的基点。</p><p>我建议大家从<strong>分层</strong>着手，明确各层职责，<strong>关注API与Dao层的提效工作，做好Service层的质量保障</strong>，更好地掌控全局。而在具体的开源库的使用过程中，<strong>选对比会用更重要</strong>，集中在<strong>API与Dao层</strong>。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;从一个Web项目开始&quot;&gt;&lt;a href=&quot;#从一个Web项目开始&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 3.【Error工程化】Go Error的工程化探索</title>
    <link href="http://example.com/2021/05/07/go-tip/go-tip-3/"/>
    <id>http://example.com/2021/05/07/go-tip/go-tip-3/</id>
    <published>2021-05-07T04:00:00.000Z</published>
    <updated>2021-06-19T14:52:26.500Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg" alt="Go-Study"></p><h2 id="Go-Error的工程化探索"><a href="#Go-Error的工程化探索" class="headerlink" title="Go Error的工程化探索"></a>Go Error的工程化探索</h2><p>在上一篇，我分享了对 <a href="https://go.googlesource.com/proposal/+/master/design/29934-error-values.md">官方Proposal</a> 的一些见解，偏向于理论层面。</p><p>本篇里，我会具体到代码层面，谈谈如何在一个工程化的项目中利用<code>github.com/pkg/errors</code>包，完整实现一套的错误处理机制。</p><h2 id="全局定义的error实现-MyError"><a href="#全局定义的error实现-MyError" class="headerlink" title="全局定义的error实现 - MyError"></a>全局定义的error实现 - MyError</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的 错误号 类型，用于API调用之间传递</span></span><br><span class="line"><span class="keyword">type</span> MyErrorCode <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的 错误号 的具体定义</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">ErrorBookNotFoundCode MyErrorCode = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">ErrorBookHasBeenBorrowedCode</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部的错误map，用来对应 错误号和错误信息</span></span><br><span class="line"><span class="keyword">var</span> errCodeMap = <span class="keyword">map</span>[MyErrorCode]<span class="keyword">string</span>&#123;</span><br><span class="line">ErrorBookNotFoundCode:        <span class="string">&quot;Book was not found&quot;</span>,</span><br><span class="line">ErrorBookHasBeenBorrowedCode: <span class="string">&quot;Book has been borrowed&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sentinel Error： 即全局定义的Static错误变量</span></span><br><span class="line"><span class="comment">// 注意，这里的全局error是没有保存堆栈信息的，所以需要在初始调用处使用 errors.Wrap</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ErrorBookNotFound        = NewMyError(ErrorBookNotFoundCode)</span><br><span class="line">ErrorBookHasBeenBorrowed = NewMyError(ErrorBookHasBeenBorrowedCode)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyError</span><span class="params">(code MyErrorCode)</span> *<span class="title">MyError</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">Code:    code,</span><br><span class="line">Message: errCodeMap[code],</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error的具体实现</span></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 对外使用 - 错误码</span></span><br><span class="line">Code MyErrorCode</span><br><span class="line"><span class="comment">// 对外使用 - 错误信息</span></span><br><span class="line">Message <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体示例-借书的三种场景"><a href="#具体示例-借书的三种场景" class="headerlink" title="具体示例 - 借书的三种场景"></a>具体示例 - 借书的三种场景</h2><p>我们来模拟一个场景：</p><p>我去图书馆借几本书，会存在三个场景，分别的处理逻辑如下</p><ol><li>找到书 - 不需要任何处理</li><li>发现书被借走了 - 打印一下即可，不认为是错误</li><li>发现图书馆不存在这本书 - 认为是错误，需要打印详细的错误信息</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">books := []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;Hamlet&quot;</span>,</span><br><span class="line"><span class="string">&quot;Jane Eyre&quot;</span>,</span><br><span class="line"><span class="string">&quot;War and Peace&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, bookName := <span class="keyword">range</span> books &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s start\n===\n&quot;</span>, bookName)</span><br><span class="line"></span><br><span class="line">err := borrowOne(bookName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;===\n%s end\n\n&quot;</span>, bookName)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">borrowOne</span><span class="params">(bookName <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Step1: 找书</span></span><br><span class="line">err := searchBook(bookName)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step2: 处理</span></span><br><span class="line"><span class="comment">// 特殊业务场景：如果发现书被借走了，下次再来就行了，不需要作为错误处理</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 提取error这个interface底层的错误码，一般在API的返回前才提取</span></span><br><span class="line"><span class="comment">// As - 获取错误的具体实现</span></span><br><span class="line"><span class="keyword">var</span> myError = <span class="built_in">new</span>(MyError)</span><br><span class="line"><span class="keyword">if</span> errors.As(err, &amp;myError) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;error code is %d, message is %s\n&quot;</span>, myError.Code, myError.Message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊逻辑: 对应场景2，指定错误(ErrorBookHasBeenBorrowed)时，打印即可，不返回错误</span></span><br><span class="line"><span class="comment">// Is - 判断错误是否为指定类型</span></span><br><span class="line"><span class="keyword">if</span> errors.Is(err, ErrorBookHasBeenBorrowed) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;book %s has been borrowed, I will come back later!\n&quot;</span>, bookName)</span><br><span class="line">err = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBook</span><span class="params">(bookName <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 下面两个 error 都是不带堆栈信息的，所以初次调用得用Wrap方法</span></span><br><span class="line"><span class="comment">// 如果已有堆栈信息，应调用WithMessage方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 发现图书馆不存在这本书 - 认为是错误，需要打印详细的错误信息</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(bookName) &gt; <span class="number">10</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrapf(ErrorBookNotFound, <span class="string">&quot;bookName is %s&quot;</span>, bookName)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(bookName) &gt; <span class="number">8</span> &#123;</span><br><span class="line"><span class="comment">// 2 发现书被借走了 - 打印一下被接走的提示即可，不认为是错误</span></span><br><span class="line"><span class="keyword">return</span> errors.Wrapf(ErrorBookHasBeenBorrowed, <span class="string">&quot;bookName is %s&quot;</span>, bookName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 找到书 - 不需要任何处理</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><h3 id="1-找到书-Helmet"><a href="#1-找到书-Helmet" class="headerlink" title="1. 找到书 - Helmet"></a>1. 找到书 - Helmet</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hamlet start</span><br><span class="line">===</span><br><span class="line">===</span><br><span class="line">Hamlet end</span><br></pre></td></tr></table></figure><p>没有任何错误信息</p><h3 id="2-发现书被借走了-Jane-Eyre"><a href="#2-发现书被借走了-Jane-Eyre" class="headerlink" title="2. 发现书被借走了 - Jane Eyre"></a>2. 发现书被借走了 - Jane Eyre</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Jane Eyre start</span><br><span class="line">===</span><br><span class="line">error code is 2, message is Book has been borrowed</span><br><span class="line">book Jane Eyre has been borrowed, I will come back later!</span><br><span class="line">===</span><br><span class="line">Jane Eyre end</span><br></pre></td></tr></table></figure><p><strong>打印被借走的提示</strong>，而错误被 <code>err = nil</code> 屏蔽。</p><h3 id="3-发现图书馆不存在这本书-War-and-Peace"><a href="#3-发现图书馆不存在这本书-War-and-Peace" class="headerlink" title="3. 发现图书馆不存在这本书 - War and Peace"></a>3. 发现图书馆不存在这本书 - War and Peace</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">War and Peace start</span><br><span class="line">===</span><br><span class="line">error code is 1, message is Book was not found</span><br><span class="line">Book was not found</span><br><span class="line">bookName is War and Peace</span><br><span class="line">main.searchBook</span><br><span class="line">        /GoProject/godemo/main.go:98</span><br><span class="line">main.borrowOne</span><br><span class="line">        /GoProject/godemo/main.go:71</span><br><span class="line">main.main</span><br><span class="line">        /GoProject/godemo/main.go:60</span><br><span class="line">runtime.main</span><br><span class="line">        /usr/local/go1.13.5/src/runtime/proc.go:203</span><br><span class="line">runtime.goexit</span><br><span class="line">        /usr/local/go1.13.5/src/runtime/asm_amd64.s:1357</span><br><span class="line">===</span><br><span class="line">War and Peace end</span><br></pre></td></tr></table></figure><p><strong>打印了错误的详细堆栈</strong>，在IDE中调试非常方便，可以直接跳转到对应代码位置。</p><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ol><li><code>MyError</code> 作为全局 <code>error</code> 的底层实现，保存具体的错误码和错误信息；</li><li><code>MyError</code>向上返回错误时，第一次先用<code>Wrap</code>初始化堆栈，后续用<code>WithMessage</code>增加堆栈信息；</li><li>从<code>error</code>中解析具体错误时，用<code>errors.As</code>提取出<code>MyError</code>，其中的错误码和错误信息可以传入到具体的API接口中；</li><li>要判断<code>error</code>是否为指定的错误时，用<code>errors.Is</code> + <code>Sentinel Error</code>的方法，处理一些特定情况下的逻辑；</li></ol><blockquote><p>Tips：</p><ol><li>不要一直用errors.Wrap来反复包装错误，堆栈信息会爆炸，具体情况可自行测试了解</li><li>利用go generate可以大量简化初始化Sentinel Error这块重复的工作</li><li><code>github.com/pkg/errors</code>和标准库的<code>error</code>完全兼容，可以先替换、后续改造历史遗留的代码</li><li>一定要注意打印<code>error</code>的堆栈需要用<code>%+v</code>，而原来的<code>%v</code>依旧为普通字符串方法；同时也要注意日志采集工具是否支持多行匹配</li></ol></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从现状来看，<code>Go</code> 语言的 <code>Error Handling</code> 已趋于共识，。</p><p>后续差异点就在底层 <code>MyError</code> 这块的实现，我个人认为会有如下三个方向：</p><ul><li>增加一些其余业务或系统的字段</li><li>对<code>Is</code>，<code>As</code> 等函数再进行一定的封装，使用起来更方便</li><li>区分不同的错误类型，来告诉调用方该如何处理，如 <strong>普通错误</strong>、<strong>重试错误</strong> 、<strong>服务降级错误</strong> 等</li></ul><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Go-Error的工程化探索&quot;&gt;&lt;a href=&quot;#Go-Error的工程化探索&quot; class=
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 2.【错误处理】谈谈Go Error的前世今生</title>
    <link href="http://example.com/2021/05/05/go-tip/go-tip-2/"/>
    <id>http://example.com/2021/05/05/go-tip/go-tip-2/</id>
    <published>2021-05-05T04:00:00.000Z</published>
    <updated>2021-06-19T14:51:46.443Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg" alt="Go-Study"></p><h2 id="从Go-2-Error-Proposal谈起"><a href="#从Go-2-Error-Proposal谈起" class="headerlink" title="从Go 2 Error Proposal谈起"></a>从Go 2 Error Proposal谈起</h2><p><code>Go</code>对<code>error</code>的处理一直都是很大的争议点，这点官方也已多次发文，并在2019年1月推出了一篇Proposal，有兴趣的可以点击链接细细品读。</p><p><a href="https://go.googlesource.com/proposal/+/master/design/29934-error-values.md">官方原文链接</a></p><p>下面，我会结合Proposal原文，发表一些自己的看法（会带上主观意见），欢迎讨论。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>这篇Proposal有一句话很好地解释了对<code>error</code>的期许：</p><p><strong>making errors more informative for both programs and people</strong></p><p>错误不仅是告诉机器怎么做的，也是告诉人发生了什么问题。</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>先让我们一起简单地回顾一下<code>error</code>的现状，来更好地理解这个 <strong>more informative</strong> 指的是什么。</p><p>原始的error定义为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">  Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的包含信息很少：一个Error() 的方法，即用字符串返回对应的错误信息。</p><p>最常用的<code>error</code>相关方法是2种：</p><ol><li>创建<code>error</code> - <code>fmt.Errorf</code>，它是针对<code>Error() </code>方法返回的字符串进行加工，如附带一些参数信息（暂不讨论%w这个wrap错误的实现）</li><li>使用<code>error</code> - 由于我们将<code>error</code>的输出结果定义为字符串，所以使用<code>error</code>时，一旦涉及到细节，就只能使用一些<code>string</code>的方法了</li></ol><p>举个具体的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 假设 readFile 存在于第三方或公用的库，我们没有权限修改、或者修改它的影响面很大</span></span><br><span class="line">_, err := readFile(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误中包含业务逻辑:</span></span><br><span class="line"><span class="comment">// 1. 文件不存在时，认为是 正常</span></span><br><span class="line"><span class="comment">// 2. 其余报错时，认为是 异常</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> strings.Index(err.Error(), <span class="string">&quot;no such file or directory&quot;</span>) &gt;= <span class="number">0</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;file not exist&quot;</span>)</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;open file error&quot;</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(fileName <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">b, err := ioutil.ReadFile(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;read file %s error %v&quot;</span>, fileName, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里存在3个明显的问题：</p><ol><li><strong>破坏性</strong> - <code>fmt.Errorf</code> 破坏了原有的error，将它从一个 <strong>具体对象</strong> 转化为 <strong>扁平的</strong> <code>string</code>，再填充到了新的<code>error</code>中。所以，通过<code>fmt.Errorf</code>处理后的error，都只传递了一个<code>string</code>的信息</li><li><strong>实现僵化</strong> - <strong>“no such file or directory”</strong> 这个错误信息用的是<strong>硬编码</strong>，对第三方<code>readFile</code>的内容有强依赖，不灵活</li><li><strong>排查问题效率低</strong> - 可以通过日志组件了解到error在<code>main</code>函数哪行发生，但无法知道错误从<code>readFile</code>中的哪行返回过来的</li></ol><blockquote><p>其中第一个破坏性的问题，其实就是破坏了error这个interface背后的具体实现，违背了面向对象的继承原则。</p></blockquote><h2 id="Handle-Errors-Only-Once"><a href="#Handle-Errors-Only-Once" class="headerlink" title="Handle Errors Only Once"></a>Handle Errors Only Once</h2><p>在工程中，为了解决 <strong>排查问题效率低</strong> 这个问题，有一个很常见的做法（以上面的readFile为例）:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(fileName <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">b, err := ioutil.ReadFile(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;read file %s error %v&quot;</span>, fileName, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;read file %s error %v&quot;</span>, fileName, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，就是 <strong>打印错误并返回</strong>。有大量排查问题经验的同学，对此肯定是深恶痛绝： <strong>一个错误能找到N处打印，看得人眼花缭乱</strong>。</p><p>这里违背了一个关键性的原则：<strong>对错误只进行一次处理，处理完之后就不要再往上抛了，而打印错误也是一种处理。</strong></p><p>结合三种具体的场景，我们分析一下：</p><ol><li>一个程序模块内，<code>error</code>不断往上抛，最上层处理；</li><li>一个公共的工具包中，<code>error</code>不记录，传给调用方处理；</li><li>一个RPC模块的调用中，<code>error</code>可以记录，作为<code>debug</code>信息，而具体的处理仍应交给调用方。</li></ol><p>示例参考文章</p><ul><li><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a></li><li><a href="https://www.orsolabs.com/post/go-errors-and-logs/">https://www.orsolabs.com/post/go-errors-and-logs/</a></li></ul><h2 id="理论实现"><a href="#理论实现" class="headerlink" title="理论实现"></a>理论实现</h2><p>那么，怎么样的<code>error</code>才是合适的呢？我们分两个角度来看这个<code>error</code>：</p><ol><li>对程序来说，<code>error</code>要包含<strong>错误细节</strong>：如错误类型、错误码等，方便在模块间传递；</li><li>对人来说，<code>error</code>要包含<strong>代码信息</strong>：如相关的调用参数、运行信息，方便查问题；</li></ol><p>用原文一句话来归纳：<strong>hide implementation details from programs while displaying them for diagnosis</strong></p><ul><li>Wrap - 隐藏实现，针对代码调用时的堆栈信息</li><li>Is/As - 展示细节，针对底层真正实现的数据结构</li></ul><h2 id="当前实现"><a href="#当前实现" class="headerlink" title="当前实现"></a>当前实现</h2><p><code>Go</code>语言发展多年，已经有了很多关于<code>error</code>的处理方法，但大多为过渡方案，我就不一一分析了。</p><p>这里我以 github.com/pkg/errors 为例，也是这个<strong>官方Proposal</strong>的重点参考对象，简单地分享一下大致实现思路。</p><p>代码量并不多，大家可以自行阅读源码：</p><h3 id="New-产生错误的堆栈信息"><a href="#New-产生错误的堆栈信息" class="headerlink" title="New 产生错误的堆栈信息"></a>New 产生错误的堆栈信息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(message <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;fundamental&#123;</span><br><span class="line">msg:   message,</span><br><span class="line">stack: callers(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fundamental <span class="keyword">struct</span> &#123;</span><br><span class="line">msg <span class="keyword">string</span></span><br><span class="line">*stack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong> stack保存了错误产生的堆栈信息，如函数名、代码行</p><h3 id="Wrap-包装错误"><a href="#Wrap-包装错误" class="headerlink" title="Wrap 包装错误"></a>Wrap 包装错误</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Wrap</span><span class="params">(err error, message <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">err = &amp;withMessage&#123;</span><br><span class="line">cause: err,</span><br><span class="line">msg:   message,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;withStack&#123;</span><br><span class="line">err,</span><br><span class="line">callers(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong> 将错误包装出一个全新的堆栈。一般只用于对外接口产生错误时，包括标准库、RPC。</p><h3 id="WithMessage-添加普通信息"><a href="#WithMessage-添加普通信息" class="headerlink" title="WithMessage 添加普通信息"></a>WithMessage 添加普通信息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithMessage</span><span class="params">(err error, message <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;withMessage&#123;</span><br><span class="line">cause: err,</span><br><span class="line">msg:   message,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong> 添加错误信息，增加一个普通的堆栈打印</p><h3 id="Is-解析Sentinel错误、即全局错误变量"><a href="#Is-解析Sentinel错误、即全局错误变量" class="headerlink" title="Is 解析Sentinel错误、即全局错误变量"></a>Is 解析Sentinel错误、即全局错误变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target error)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> stderrors.Is(err, target) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err == target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isComparable := reflectlite.TypeOf(target).Comparable()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> isComparable &amp;&amp; err == target &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; Is(error) <span class="keyword">bool</span> &#125;); ok &amp;&amp; x.Is(target) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> consider supporing target.Is(err). This would allow</span></span><br><span class="line"><span class="comment">// user-definable predicates, but also may allow for coping with sloppy</span></span><br><span class="line"><span class="comment">// APIs, thereby making it easier to get away with them.</span></span><br><span class="line"><span class="keyword">if</span> err = Unwrap(err); err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong> 反复Unwrap、提取错误，解析并对比错误类型</p><h2 id="As-提取出具体的错误数据结构"><a href="#As-提取出具体的错误数据结构" class="headerlink" title="As - 提取出具体的错误数据结构"></a>As - 提取出具体的错误数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">As</span><span class="params">(err error, target <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> stderrors.As(err, target) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">As</span><span class="params">(err error, target <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;errors: target cannot be nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">val := reflectlite.ValueOf(target)</span><br><span class="line">typ := val.Type()</span><br><span class="line"><span class="keyword">if</span> typ.Kind() != reflectlite.Ptr || val.IsNil() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;errors: target must be a non-nil pointer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> e := typ.Elem(); e.Kind() != reflectlite.Interface &amp;&amp; !e.Implements(errorType) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;errors: *target must be interface or implement error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">targetType := typ.Elem()</span><br><span class="line"><span class="keyword">for</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> reflectlite.TypeOf(err).AssignableTo(targetType) &#123;</span><br><span class="line">val.Elem().Set(reflectlite.ValueOf(err))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; As(<span class="keyword">interface</span>&#123;&#125;) <span class="keyword">bool</span> &#125;); ok &amp;&amp; x.As(target) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">err = Unwrap(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong> 反复Unwrap、提取错误，提取底层的实现类型</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Go</code>语言对<code>error</code>的定义很简单，虽然带来了灵活性，但也导致处理方式泛滥，一如当年的<strong>Go语言的版本管理</strong>。如今的<strong>go mod</strong>版本管理机制已经”一统江湖“，随着大家对<code>error</code>这块的不断深入，<code>Error Handling</code>也总会达成共识。</p><p>接下来，我会结合实际代码样例，写一个具体工程中 <strong>Error Handling</strong> 的操作方法，提供一定的参考。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;从Go-2-Error-Proposal谈起&quot;&gt;&lt;a href=&quot;#从Go-2-Error-Pr
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习路线 - 4.入门篇:快速体系化地入门Go语言</title>
    <link href="http://example.com/2021/04/17/go-study/go-study-4/"/>
    <id>http://example.com/2021/04/17/go-study/go-study-4/</id>
    <published>2021-04-17T04:00:00.000Z</published>
    <updated>2021-04-19T03:36:19.944Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p><h2 id="从一本书入门Go语言"><a href="#从一本书入门Go语言" class="headerlink" title="从一本书入门Go语言"></a>从一本书入门Go语言</h2><p>如今互联网资料泛滥，入门编程语言的途径有很多种选择，但如果要我推荐，只有一个建议 - <strong>研读一本该编程语言最优秀的基础书籍</strong>。 </p><p>对于Go语言，我推荐 《Go程序设计语言》(The Go Programming Language)，也被称为 <strong>Go语言圣经</strong>。参考链接:<a href="http://product.dangdang.com/25072202.html">当当链接</a> 和 <a href="https://docs.hacknode.org/gopl-zh/">网页版链接</a>。</p><blockquote><p>我认为，尽量避免只通过网上的博客或视频去学习基础。</p><p><strong>体系化</strong> 是建立知识体系最重要的一点。网上的资料最缺乏的就是 <strong>体系化</strong>，而经典书籍都经过了反复的精雕细琢。</p></blockquote><p>虽然这本书很经典，但在新手在学习的过程中还是会遇到三个经典的疑问：</p><ul><li>这本书出版已经有4年多，是否有些知识点已经 <strong>过时</strong>？</li><li>书籍中的知识点有深有浅，新手只想快速入门，该如何 <strong>权衡知识点</strong>？</li><li>书中的知识点虽然是体系化的，但新手很难 <strong>串联</strong> 起来。</li></ul><p>所以，本章的核心是为了解决上面三个问题的，也可以认为是我对于 <strong>Go语言圣经的导读</strong>。</p><blockquote><p>基础因人而异，根据自己的实际情况适当提高或降低预期。</p></blockquote><h2 id="1-了解背景"><a href="#1-了解背景" class="headerlink" title="1. 了解背景"></a>1. 了解背景</h2><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><ul><li><p>出版者的话、译者序、前言</p></li><li><p>第1章 入门 （不需要对着示例敲代码）</p></li></ul><h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>每门编程语言都有自己的背景和思想，了解这块对新手来说很有必要。如果上来就直接看一些基础语法，就会感觉是在 <strong>拼凑知识点</strong>。</p><p>所以，好好读一读这部分内容，<strong>建立自己在整体上对Go语言的认识</strong> 。</p><h2 id="2-基础语法点"><a href="#2-基础语法点" class="headerlink" title="2. 基础语法点"></a>2. 基础语法点</h2><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><ul><li>第2章 程序结构 （难点：指针、引用）</li><li>第3章 基本数据 （难点：字符串的编码UTF-8相关知识）</li><li>第4章 复合数据类型</li><li>第5章 函数（跳过：函数变量、匿名函数）</li></ul><h3 id="导读-1"><a href="#导读-1" class="headerlink" title="导读"></a>导读</h3><p>这块内容是最基础的，需要对着具体例子敲代码、并跑通。</p><p>上面指出的难点，如果不能快速掌握就跳过，<strong>入门学习没必要扣每个细节</strong> 。</p><p>至此，你已经掌握了最常见的Go语言用法了。</p><h2 id="3-面向对象编程"><a href="#3-面向对象编程" class="headerlink" title="3.面向对象编程"></a>3.面向对象编程</h2><h3 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h3><ul><li>第6章 方法</li><li>第7章 接口</li></ul><h3 id="导读-2"><a href="#导读-2" class="headerlink" title="导读"></a>导读</h3><p>这部分的语法并不难，关键点在于慢慢接触 <strong>学习面向对象编程的理念</strong>。</p><p><strong>面向对象</strong> 是一个博大精深的话题，这点需要长期的实践与体验，不用急于一时。</p><blockquote><p>如果对 <strong>面向对象</strong> 这个名词不熟悉的，先去搜搜科普贴，再回头理解这2章的内容。</p><p>建议Go语言入门后，跳出具体编程语言的视角，好好地理解一下面向对象的思想。</p></blockquote><h2 id="4-并发编程"><a href="#4-并发编程" class="headerlink" title="4. 并发编程"></a>4. 并发编程</h2><h2 id="范围-3"><a href="#范围-3" class="headerlink" title="范围"></a>范围</h2><ul><li>第8章 goroutine和通道</li><li>第9章 使用共享变量实现并发</li></ul><h3 id="导读-3"><a href="#导读-3" class="headerlink" title="导读"></a>导读</h3><p>并发编程一直都是各编程语言的一大难点，而Go语言将其语法设计得非常简洁，相对更容易学习。</p><p>学习并发这块，不仅仅需要大家去 <strong>扣每行代码的逻辑</strong> ，更要了解 <strong>这些并发语法是为了解决什么问题</strong>。</p><blockquote><p>纯编程新手对并发编程的理解需要一个过程，如果不能快速掌握也不用心浮气躁。</p><p>要真正地了解并发，那就得学习操作系统的相关知识。</p></blockquote><h2 id="5-函数式编程"><a href="#5-函数式编程" class="headerlink" title="5. 函数式编程"></a>5. 函数式编程</h2><h3 id="范围-4"><a href="#范围-4" class="headerlink" title="范围"></a>范围</h3><ul><li>第5章 函数（函数变量、匿名函数）</li></ul><h3 id="导读-4"><a href="#导读-4" class="headerlink" title="导读"></a>导读</h3><p>Go语言支持一定的函数式编程能力。函数式编程是对<strong>传统过程性编码思维的一种突破</strong>，新手了解基本使用方法即可。</p><p>匿名函数这块的玩法很有意思，也是面试的高频考点。</p><h2 id="6-Go语言的工程化"><a href="#6-Go语言的工程化" class="headerlink" title="6. Go语言的工程化"></a>6. Go语言的工程化</h2><h3 id="范围-5"><a href="#范围-5" class="headerlink" title="范围"></a>范围</h3><ul><li>第10章 包和go工具（简单通读里面的一些思想即可，最新的包管理已经完全采用<code>go mod</code>）</li><li>第11章 测试</li></ul><h3 id="导读-5"><a href="#导读-5" class="headerlink" title="导读"></a>导读</h3><p>Go的包管理工具几经波折，目前已经由<code>go mod</code>一统江湖了。<code>go mod</code>的资料可以参考 <a href="https://blog.golang.org/using-go-modules">官方博客</a>。但由于国内下载部分库有限制，可以参考搜索引擎进行配置。</p><p>而对于测试部分，我个人觉得 <em>官方提供的原始功能并不好用</em>，初学者写几个示例了解即可，后续在大型项目中还是需要一定的工具辅助。</p><h2 id="7-底层知识"><a href="#7-底层知识" class="headerlink" title="7. 底层知识"></a>7. 底层知识</h2><h3 id="范围-6"><a href="#范围-6" class="headerlink" title="范围"></a>范围</h3><ul><li>第12章 反射</li><li>第13章 低级编程（cgo直接忽略）</li></ul><h3 id="导读-6"><a href="#导读-6" class="headerlink" title="导读"></a>导读</h3><p>入门的新手<strong>浏览一遍即可，无需深入思考</strong>。大家需要了解的就是2点：</p><ol><li><strong>反射reflect</strong> 是将 <strong>数据和程序结构</strong> 互相转换的工具</li><li><strong>unsafe</strong> 是直接操作 <strong>计算机地址</strong> 的工具</li></ol><p>在实践中遇到具体问题时，再去针对性地学习。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>总体来看，入门Go语言的关键放在 2、3、4 三点即可，也就是 第2~9章，多敲代码、反复品读。</p><p>为了让大家更好地阅读书籍，我再补充三个建议：</p><ol><li><strong>结合上下文理解难点</strong> - 每个知识点都不是独立的，一定要了解上下文，切忌上来就敲代码；</li><li><strong>用文字背后的思想组织成体系化</strong> - 串联知识点的，并不是具体代码，而是相关的文字说明，多多琢磨背后的思想；</li><li><strong>对复杂知识点，暂时降低预期，做长期建设</strong> - 像面向对象、并发编程、函数式编程等 高阶内容，不可能只通过学习Go语言就能掌握；</li></ol><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;从一本书入门Go语言&quot;&gt;&lt;a href=&quot;#从一本书入门Go语言&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习路线 - 3.准备篇:打造个人专属的学习环境</title>
    <link href="http://example.com/2021/04/05/go-study/go-study-3/"/>
    <id>http://example.com/2021/04/05/go-study/go-study-3/</id>
    <published>2021-04-05T04:00:00.000Z</published>
    <updated>2021-04-19T03:36:19.943Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p><h2 id="为何我们需要持续学习"><a href="#为何我们需要持续学习" class="headerlink" title="为何我们需要持续学习"></a>为何我们需要持续学习</h2><p><strong>终身成长</strong> 一词已被广泛认可，意味着我们将比前人花费更多的时间在 <strong>学习成长</strong> 中，才能将个人的认知跟上社会的步伐。且不论是否应该放慢脚步，但我们大部分人不得不跟随社会的节奏，<strong>持续学习并提高自己</strong>。</p><p>相信有不少朋友跟我一样，在学习的过程中经常会 <strong>半途而废</strong>。那么我在这里分享一些方法和技巧（包括但不仅限于Go语言），希望能给大家带来一些启发。</p><p>这部分内容依旧会带有一些强烈的个人主观色彩，大家按需选用~</p><h2 id="心理建设"><a href="#心理建设" class="headerlink" title="心理建设"></a>心理建设</h2><p>在正式开始聊工具和方法前，我先聊聊自己学习前的心理建设。这一点看过去 <strong>很“软”</strong> ，但我吃过很多次亏：</p><p><strong>与其在学习的过程中，给自己找100个理由放弃，还不如在一开始就否定这些理由。</strong> </p><p>以Go语言为例，常见的放弃理由如下：</p><ul><li>Go真的能长期“火”下去吗？</li><li>Go的就业面不广，是否另选其它编程语言</li><li>学了基础的Go语法后，没有实践的机会</li><li>一段时间提升很不明显，感觉什么都懂、但什么都不精通</li></ul><p>我就是抱着这样的想法，走走停停，错过了很多快速提升的时期；不过也是由于这段经历，让我对许多朋友的想法有切身体会。今天我不会对着上面的问题一一回复，只强调一个重点：</p><p><strong>学技术带着功利心（跳槽、升职）是正常且必要的，毕竟只有解决问题的技术才是有价值的。Go语言是非常依赖“云原生”这一体系的：它实现了云原生的基石-Kubernetes及其余组件，也依赖云原生、提供了非常优雅的微服务解决方案。如今公有云和私有云的建设如火如荼，注定是一个不可逆的过程，所以Go语言是一个需求很大的方向。</strong></p><h2 id="学习环境的准备"><a href="#学习环境的准备" class="headerlink" title="学习环境的准备"></a>学习环境的准备</h2><p>下面，正式进入准备的细节：</p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>尽管Go语言支持跨操作系统，但我还是强烈建议大家使用Mac OS，关键在于 <strong>提效</strong>。</p><blockquote><p> 既然可以花7分力气做一件事，为什么需要10分呢？</p></blockquote><p>不排除后期Windows系统越来越完善，但目前来看，所有的大厂提供给开发者都是Macbook，这点就不言而喻了吧。如果你有在windows/Linux环境上高效开发的经验，欢迎与大家分享~</p><h3 id="Go语言版本"><a href="#Go语言版本" class="headerlink" title="Go语言版本"></a>Go语言版本</h3><p>在<a href="https://golang.google.cn/dl/">官网</a>任意挑选。</p><p>如果公司没有要求，那就直接上最新的版本吧~</p><blockquote><p>如果公司还在用1.13之前的版本，可以尝试着跟领导沟通，升级到较新的版本。</p><p>使用低版本会不断发现不兼容某些开源库的情况，比如有些依赖库引入了context的特性</p></blockquote><h3 id="代码编辑器"><a href="#代码编辑器" class="headerlink" title="代码编辑器"></a>代码编辑器</h3><p>强烈建议准备 VSCode + Goland ！对，不用二选一，而是两个都要！</p><ul><li><p>VSCode对各类语言、组件兼容都很好，面对<strong>轻量级</strong>的开发时完全可以胜任</p></li><li><p>Goland在面对<strong>重量级</strong>项目时效果很棒，尤其是对重构项目时，效率能提升一大截</p></li></ul><p>这里提供两个官网： <a href="https://code.visualstudio.com/">VSCode</a> / <a href="https://www.jetbrains.com/go/">Goland</a></p><blockquote><p>这两款软件的配置，前期尽量用默认的即可。</p><p>而如果有大量私人化的配置，记得将整个配置方案导出并保存。</p></blockquote><h3 id="其余提效工具"><a href="#其余提效工具" class="headerlink" title="其余提效工具"></a>其余提效工具</h3><ul><li><a href="https://git-scm.com/">git</a> 不要把git单纯地当作公司的版本管理工具，它更是你私人代码的管理工具</li><li><a href="https://segmentfault.com/a/1190000014992947">iTerm2 + Oh My Zsh</a> 这是在Mac下我非常喜欢的一套终端配置方案，大家可以借鉴</li><li>笔记类：这块大家按自己的习惯选用，常见的如 印象笔记、Microsoft TODO、typora、幕布、系统自带的笔记本等</li><li>上网助手：技术渠道有不少是在国外的网站上，不清楚具体访问方法的话，可以多和周围的开发者交流</li></ul><blockquote><p>欢迎大家留言谈谈自己最喜爱的工具，分享给我~</p></blockquote><h2 id="Markdown技术写作"><a href="#Markdown技术写作" class="headerlink" title="Markdown技术写作"></a>Markdown技术写作</h2><p>作为一个技术工作者，文档是一个必备技能。我们不应把写文档当作一个负担，大部分的时候它是一种沟通与协作上的提效工具。</p><p>这里不得不提一下Markdown，它的语法简单，产出的文档样式也满足基本的场景。大家可以根据<a href="https://www.markdown.xyz/basic-syntax/">这个链接</a>或者自行搜索教程。</p><blockquote><p>学习Markdown就是一个很小且价值很高的技术点，可以拿这个作为练手，先使用起来。</p><p>补充一句：Markdown在社区中的支持度不同，但基本大同小异。为了兼容性，少用html的相关特性。</p></blockquote><p>Markdown尽管简单，也有很多语法点，建议大家分阶段使用：</p><ol><li>标题、粗体、代码、链接、列表</li><li>图片、引用、分隔线、表格</li><li>其它</li></ol><p>第一阶段的5种语法已经可以满足日常的文档协作，第二阶段的特性可以让文档更具专业性，而其余特性完全可以在使用到时再去查询。</p><p><strong>切忌一次性想掌握全部，分阶段使用才是最有效的学习路径。</strong></p><p>这里推荐一个我常用的本地Markdown文档写作工具 - <a href="https://typora.io/">typora</a> 。尽管有Web文档工具支持在线编辑，但我更喜欢本地编辑后再复制过去，这样也方便留档。</p><h2 id="个人博客系统"><a href="#个人博客系统" class="headerlink" title="个人博客系统"></a>个人博客系统</h2><h3 id="为什么要玩博客"><a href="#为什么要玩博客" class="headerlink" title="为什么要玩博客"></a>为什么要玩博客</h3><ol><li><strong>根本价值</strong> - 作为个人的知识输出，沉淀到文档</li><li><strong>附带价值</strong> - 面试前后，让心仪的公司更好地了解你</li><li><strong>持续价值</strong> - 形成 <strong>正反馈</strong>，持续激励自我</li></ol><blockquote><p>有些人玩博客会将价值颠倒，比如将面试筹码作为根本价值，那么这个技术博客就会明显变味。</p></blockquote><h3 id="搭建教程"><a href="#搭建教程" class="headerlink" title="搭建教程"></a>搭建教程</h3><p>搭建博客系统的方法有很多，我这边推荐一个 <a href="https://segmentfault.com/a/1190000017986794">hexo + github pages</a> 的。</p><p>这种博客的优点在于2点：</p><ol><li>发布非常方便、非常方便、非常方便！</li><li>原始文档为Markdown，可在本地编辑、存档</li></ol><h3 id="写博客的Tips"><a href="#写博客的Tips" class="headerlink" title="写博客的Tips"></a>写博客的Tips</h3><ol><li><strong>降低“成本”</strong> - 让一篇博客从创作到发布变得简单，这点比较依赖博客系统，例如上面的 hexo+github pages</li><li><strong>分享作品</strong> - 分享个人的文章，有利于形成“正反馈”；对于比较腼腆的朋友，可以在小规模的圈子中先进行尝试</li><li><strong>多元化</strong> - 博客不仅仅停留在技术上，工作上的心得或者生活上的感悟，都可以写进来</li><li><strong>适当拆分</strong> - 不要过分追求长篇大作或者系列形式的文章，<em>小步快走</em> 在这里也适用</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>打造个人专属的学习环境，我认为主要包括三块：</p><ol><li>个人心态 - 坚持</li><li>开发环境 - 快速便捷</li><li>正反馈路线 - 文档博客</li></ol><p>当然，你可以根据实际情况，添加一些个人专属的内容：</p><ul><li>如果你是windows用户，你需要搞一套虚拟机</li><li>如果你已有一套成熟的文档系统，那就继续使用</li><li>如果你想快速地了解Go而不计划深入，那么没必要过于完善学习环境</li></ul><p>希望大家在 <strong>心理</strong> 和 <strong>环境</strong> 都做好充分的准备后，再去走这条长期的技术学习路线，并能坚持下来。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;为何我们需要持续学习&quot;&gt;&lt;a href=&quot;#为何我们需要持续学习&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习路线 - 2.方向篇:如何成为一名优秀的Go语言工程师</title>
    <link href="http://example.com/2021/03/28/go-study/go-study-2/"/>
    <id>http://example.com/2021/03/28/go-study/go-study-2/</id>
    <published>2021-03-28T04:00:00.000Z</published>
    <updated>2021-03-29T12:51:46.961Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p><h2 id="核心成长方向"><a href="#核心成长方向" class="headerlink" title="核心成长方向"></a>核心成长方向</h2><p>如何成为一名优秀的Go语言工程师，这是很多人都长期疑惑的问题。</p><p>我这边抛出自己的观点，希望能引起大家的思考：</p><p><strong>掌握基础，熟悉生态，集百家长，深耕领域</strong></p><p>接下来，我将围绕这四个词展开今天的分享。</p><h2 id="1-掌握基础"><a href="#1-掌握基础" class="headerlink" title="1. 掌握基础"></a>1. 掌握基础</h2><p>首先，我们来聊聊这个老生常谈的话题 - <strong>掌握基础</strong>。关于基础的学习路线我会在后面细讲，今天我们先来谈点别的。</p><p><strong>所谓基础，会根据工作的不同阶段而不断变化。</strong> 也就是要用 <strong>发展</strong> 的眼光来看问题。</p><p>举个例子，就以 <strong>编程语言</strong> 的作为切入点：</p><ul><li>一名合格的业务开发者，会熟练地应用<strong>编程语言</strong>去实现功能需求，熟练掌握常见的<strong>开源工具库</strong>；</li><li>进一步，如果作为一名模块的负责人，那就需要考虑<strong>设计模式</strong>来抽象复杂业务，熟悉编程语言底层的<strong>运行原理</strong>；</li><li>再进一步，作为一名架构师，就得思考如何用 <strong>工程化</strong> 来控制复杂度和约束规范性；</li><li>而如果是更高一层的角色，如CTO，就需要从编程语言或框架的 <strong>成熟度、前瞻性</strong> 的角度来决定路线。</li></ul><h2 id="2-熟悉生态"><a href="#2-熟悉生态" class="headerlink" title="2. 熟悉生态"></a>2. 熟悉生态</h2><p><strong>生态</strong> 这个词很微妙，社区里有不同的见解，我也无法抛出一个准确的定义，这块需要大家自行摸索。不过，我倒是可以分享几个踩坑经历：</p><ol><li><strong>语言生态</strong> ：编程语言都是有对应的应用领域的，我在上一讲已经说过，这里不再细谈；</li><li><strong>框架生态</strong> ：编程语言往往提供多种框架，不同框架的设计理念和使用场景不同，甚至会有一定的矛盾。例如有的框架提供了重量级的解决方案，可以快速生成一套代码，但对应的灵活性就大大降低；对应的，另一个框架能提供轻量级的插件化解决方案，需要你自行挑选、组装、调试，以提升复杂度的代价换来了灵活性；</li><li><strong>社区生态</strong> ：除了极少的探索性的工作，绝大部分的开发工作都能在社区中找到同路人，经常能发现很有价值的建议。但社区里的声音很杂，筛选信息是最大障碍，这一点很容易反复踩坑。</li></ol><blockquote><p>比起一些告诉你 <strong>该怎么做</strong> 的建议，我更倾向于那些 <strong>不该怎么做</strong> 的建议。</p><p>一次成功往往有大量的偶然因素，而从失败中分析出原因更有长期价值。</p></blockquote><h2 id="3-集百家长"><a href="#3-集百家长" class="headerlink" title="3.集百家长"></a>3.集百家长</h2><p>接下来的这点，是本章的重点，希望大家看完之后能重点思考。</p><p><strong>Go</strong> 语言是一个以简单著称的编程语言，又被号称是 <strong>云时代的编程语言</strong>。这背后蕴含了两层含义。</p><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><p>第一点，也就是 <strong>简单</strong> 带来的副作用。一种编程语言如果被冠以 <strong>简单</strong> 的头衔，那么它的设计核心就是 <strong>可读性</strong>。</p><p>但是，无论是模板、元编程、泛型这些语法上的高端特性，还是继承、多态、函数式等编程范式上的特性，虽然很复杂（或者说是学习曲线很陡峭），但不得不承认它们在特定的场景中，达到了很好的抽象效果，大幅度地提升了程序的效率。</p><p>所以，<strong>Go</strong> 语言决定了在单个程序中支持的复杂度有限，进一步则需要 <strong>JAVA、C++为代表的工业级编程语言</strong> 的一些特性。</p><h3 id="云时代的编程语言"><a href="#云时代的编程语言" class="headerlink" title="云时代的编程语言"></a>云时代的编程语言</h3><p>从上一点来看，<strong>Go</strong> 语言支持的单个程序复杂度有限，那就非常依赖 <strong>微服务</strong> 的核心理念 - 拆。通过拆解，可以将单个程序的复杂度转移到架构层面，也更好地契合了<strong>服务内聚</strong>的理念。</p><p>但是，即便进行了很好的设计与拆分，<strong>微服务</strong> 依然有两个比较重要的前置要求：<strong>服务间通信</strong> 和 <strong>微服务治理</strong>。前者相对容易解决，统一采用 <strong>RESTful</strong> 风格或 <strong>gRPC</strong> 等框架进行通信，就能满足基本要求；而微服务的治理问题就非常复杂了，很长一段时间都没有一套成熟的解决方案。近几年，随着 <strong>Docker容器化</strong> + <strong>Kubernetes调度平台</strong> 的出现与推广，已经成为了 <strong>微服务的Best Practice</strong> 。</p><p>以 <strong>K8s为核心的云原生生态</strong>，涵盖了<strong>监控、日志采集、链路追踪、Service Mesh</strong>等各类子领域的解决方案，均得到了快速迭代。其中，各种核心组件均是通过 <strong>Go</strong> 语言开发而成，像 <strong>Kubernetes、Prometheus、Etcd</strong> 等。</p><p>至此，我们开发的服务不再需要过分关注基础组件，而是更聚焦于业务领域。</p><h3 id="CNCF"><a href="#CNCF" class="headerlink" title="CNCF"></a>CNCF</h3><p>再回到这一个话题的核心 - <strong>集百家长</strong>。</p><p>云原生的社区<strong>CNCF</strong>提供了大量的组件，大家可以通过<a href="https://landscape.cncf.io/images/landscape.png">这个链接</a>看到对应的全景图。它提供了是一整套<strong>插件化</strong>的组合方案，需要开发人员按需组合（后面我也会给出一些建议）。</p><p>我非常不建议大家去自己从头开发一个模块，主要有两点（巨型互联网的基础团队除外）：</p><ol><li>自建轮子跟不上社区迭代，投入产出比价值低；</li><li>很多时候某些功能已经在某个组件中实现，或者正在实现，只是没正确使用。</li></ol><blockquote><p>如果真要新增某个重要功能，优先去找个现有CNCF项目的负责人聊聊，提交PR合入，或者自行fork开发。</p><p>相信我，在一个成熟产品中新增特性，比你重写一个轮子更有价值！无论是对技术的提升、还是投递简历时的效果，都更有意义。</p></blockquote><p>举一个场景，当我们发现需要在程序中用<code>map</code>保存大量结果时，用默认的数据结构效率很低：</p><ul><li>如果在<strong>JAVA</strong>生态里，那么内部就有丰富的容器库可供选择，放在一个服务中即可；</li><li>而在<strong>Go</strong>中，自然也可以借用<strong>github</strong>上面搜索的三方库来解决，但更建议根据场景选用开源的K-V组件，通过RPC调用来解决问题，也就是拆成了 <strong>业务功能</strong> 与 <strong>map数据存储</strong> 两个服务</li><li>专业的事交给专业的组件</li></ul><h2 id="4-深耕领域"><a href="#4-深耕领域" class="headerlink" title="4. 深耕领域"></a>4. 深耕领域</h2><p>在工作三年以上，我越来越感受到 <strong>领域</strong> 是一个很重要的概念，也是各公司考验高端人才的重要素质。</p><p>举几个例子：</p><ul><li><p>作为一名 <strong>电商支付领域</strong> 的开发专家，需要在编程语言的 <strong>如何保证数据一致性</strong> 的相关特性有深入研究；</p></li><li><p>如果是 <strong>物流订单领域</strong> 的专家，则要考虑 <strong>如何合理抽象各类物流类型</strong> 的问题，来支持复杂的场景；</p></li><li><p>当你负责的是一个 <strong>秒杀系统</strong>，那么需要对 <strong>高并发场景与异常兜底</strong> 有足够的经验。</p></li></ul><p>每一块 <strong>领域</strong> 都需要有大量的 <strong>专业技能</strong> 与 <strong>行业经验</strong> 沉淀，这是高端人才的核心竞争力。</p><p>虽说两者缺一不可，但还是具有一定的倾向性</p><ul><li>偏技术的领域更需要 <strong>专业技能</strong> ，瓶颈往往是某一个垂直领域的技术深度；</li><li>偏业务的领域更要求 <strong>行业经验</strong> ，要求负责人能 <strong>带领团队避开坑，走对路</strong> 。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾一下这四个点： <strong>掌握基础，熟悉生态，集百家长，深耕领域</strong> 。这一整个过程，也可以说是：<strong>修炼内功，学习并合理使用外部资源，沉淀于特定领域</strong> 。</p><p>纵观周围环境，我发现大部分的开发者都热衷于 <strong>修炼内功和领域沉淀</strong>，而过于轻视了 <strong>外部资源</strong> 的作用，就错失了一个快速提升个人能力的手段，技术视野也非常有限。这一块，将是我后续分享的重点，也是区别于其余教程的一大特点。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;核心成长方向&quot;&gt;&lt;a href=&quot;#核心成长方向&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 1.【惊艳亮相】如何写出一个优雅的main函数</title>
    <link href="http://example.com/2021/03/07/go-tip/go-tip-1/"/>
    <id>http://example.com/2021/03/07/go-tip/go-tip-1/</id>
    <published>2021-03-07T04:00:00.000Z</published>
    <updated>2021-05-08T09:31:04.082Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg" alt="Go-Study"></p><h2 id="一个简单的main函数"><a href="#一个简单的main函数" class="headerlink" title="一个简单的main函数"></a>一个简单的main函数</h2><p>我们先来看看一个最简单的<code>http服务端</code>的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的功能很简单：提供一个监听在<code>8080</code>端口的服务器，处理<code>URL</code>为<code>/hello</code>的请求，并打印出hello。</p><p>可以用一个简单的curl请求来打印结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/hello</span><br></pre></td></tr></table></figure><p>也可以用对应的<code>kill</code>杀死了对应的进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 &#123;pid&#125;</span><br></pre></td></tr></table></figure><p>但有一个问题：</p><p><strong>如果程序因为代码问题而意外退出（例如panic），无法和kill这种人为强制杀死的情况进行区分</strong></p><h2 id="引入signal"><a href="#引入signal" class="headerlink" title="引入signal"></a>引入signal</h2><p><code>kill</code>工具是<code>Linux</code>系统中，往进程发送一个信号。所以，我们的关键是去实现 <strong>捕获信号</strong> 的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个 sig 的 channel，捕获系统的信号，传递到sig中</span></span><br><span class="line">sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line"></span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello)</span><br><span class="line"><span class="comment">// http服务改造成异步</span></span><br><span class="line"><span class="keyword">go</span> http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, mux)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序阻塞在这里，除非收到了interrupt或者kill信号</span></span><br><span class="line">fmt.Println(&lt;-sig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们的主函数已经能区分正常的信号退出了。</p><h2 id="优雅退出的需求"><a href="#优雅退出的需求" class="headerlink" title="优雅退出的需求"></a>优雅退出的需求</h2><p>服务端程序经常会处理各种各样的逻辑，如操作数据库、读写文件、RPC调用等。根据其对 <strong>原子性</strong> 的要求，我将处理逻辑区分为两种：</p><ul><li>一种是<strong>无严格数据质量</strong>要求的，即程序直接崩溃也没有问题，比如一个普通查询；</li><li>另一种是有 <strong>原子性</strong> 要求的，即不希望运行到一半就退出，例如写文件、修改数据等，<strong>最好是程序提供一定的缓冲时间</strong>，等待这部分的逻辑处理完，优雅地退出。</li></ul><p>在复杂系统中，为了保证数据质量，<strong>优雅退出</strong> 是一个必要特性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟并发进行的处理业务逻辑</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 我们希望程序能等当前这个周期休眠完，再优雅退出</span></span><br><span class="line">time.Sleep(time.Duration(i) * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(&lt;-sig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是一个简单的示例，开启了10个<code>goroutine</code>并发处理，那么这时捕获信号后，这10个协程就立刻停止。而<strong>优雅退出</strong>，则是希望能执行完当前的<code>Sleep</code>再退出。</p><h2 id="一对一的解决方案"><a href="#一对一的解决方案" class="headerlink" title="一对一的解决方案"></a>一对一的解决方案</h2><p>我们先简化问题：主函数对应的是一个需要优雅关闭的协程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(&lt;-sig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体操作如下：</p><ul><li>父<code>goroutine</code>通知子<code>goroutine</code>准备优雅地关闭</li><li>子<code>goroutine</code>通知父<code>goroutine</code>已经关闭完成</li></ul><p>我们回忆下在<code>goroutine</code>传递消息的几个方案（排除共享的全局变量这种方式）。</p><h3 id="最直观的解决方案-2个channel"><a href="#最直观的解决方案-2个channel" class="headerlink" title="最直观的解决方案 - 2个channel"></a>最直观的解决方案 - 2个channel</h3><p>既然我们要在父子goroutine中传递消息，最直接的想法是启用2个 <code>channel</code> 用来通信，对应到代码：</p><ul><li><p>父<code>goroutine</code>通知子<code>goroutine</code>准备优雅地关闭，也就是<code>stopCh</code></p></li><li><p>子<code>goroutine</code>通知父<code>goroutine</code>已经关闭完成，也就是<code>finishedCh</code></p><p>具体代码实现如下</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">finishedCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(stopCh, finishedCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">fmt.Println(<span class="string">&quot;stopped&quot;</span>)</span><br><span class="line">finishedCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(stopCh, finishedCh)</span><br><span class="line"></span><br><span class="line">&lt;-sig</span><br><span class="line">stopCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&lt;-finishedCh</span><br><span class="line">fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="华丽的解决方案-channel嵌套channel"><a href="#华丽的解决方案-channel嵌套channel" class="headerlink" title="华丽的解决方案 - channel嵌套channel"></a>华丽的解决方案 - channel嵌套channel</h3><p>这个解决方案不太容易想到（看过Rob Pike的演讲视频除外，可在go官网看到）。</p><p>这个方案的核心结构为<code>chan chan</code>。</p><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(stopChh <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ch := &lt;-stopCh:</span><br><span class="line"><span class="comment">// 结束后，通过ch通知主goroutine</span></span><br><span class="line">fmt.Println(<span class="string">&quot;stopped&quot;</span>)</span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(stopCh)</span><br><span class="line"></span><br><span class="line">&lt;-sig</span><br><span class="line"><span class="comment">// ch作为一个channel，传递给子goroutine，待其结束后从中返回</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">stopCh &lt;- ch</span><br><span class="line">&lt;-ch</span><br><span class="line">fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个方案很酷，建议大家多思考思考，尤其是channel中传递的数据为error时，就能有更多信息了</p></blockquote><h3 id="标准解决方案-引入上下文context"><a href="#标准解决方案-引入上下文context" class="headerlink" title="标准解决方案 - 引入上下文context"></a>标准解决方案 - 引入上下文context</h3><p><code>go</code>语言里的上下文<code>context</code>不仅仅可以传递数值，也可以控制子<code>goroutine</code>的生命周期，很自然地有了如下解决方案。</p><p>实例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">finishedCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, finishedCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">// 结束后，通过ch通知主goroutine</span></span><br><span class="line">fmt.Println(<span class="string">&quot;stopped&quot;</span>)</span><br><span class="line">finishedCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(ctx, finishedCh)</span><br><span class="line"></span><br><span class="line">&lt;-sig</span><br><span class="line">cancel()</span><br><span class="line">&lt;-finishedCh</span><br><span class="line">fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有兴趣的朋友可以空闲时想一个问题：社区里有人认为context是一个很不好的实现：</p><p>context意思为上下文，最初的设计意为传递数值，也就是一个 <strong>数据流</strong> ；</p><p>而go中的context又延伸出了 控制goroutine生命周期的功能，也就成了 <strong>控制流</strong> 。</p><p>这么看下来，其实context就有 角色不清晰 的味道了。</p><p>但不可否认，context已经在go语言中大量被采用，这个问题可以作为大家自己设计模块时的参考。</p></blockquote><h2 id="一对多的解决方案"><a href="#一对多的解决方案" class="headerlink" title="一对多的解决方案"></a>一对多的解决方案</h2><p>一对多的解决方案可以复用 <strong>一对一解决方案</strong> 中的思想。我这边也给出另外一个 <code>context</code> + <code>sync.WaitGroup</code> 的解决方案。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">num := <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用wg来控制多个子goroutine的生命周期</span></span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">&quot;stopped&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">time.Sleep(time.Duration(i) * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-sig</span><br><span class="line">cancel()</span><br><span class="line"><span class="comment">// 等待所有的子goroutine都优雅退出</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家要注意一下，在追求 <strong>优雅退出</strong> 时要注意 <strong>控制细粒度</strong> 。</p><blockquote><p>比如一个<code>http</code>服务器，我们要控制整个<code>http server</code>的优雅退出。</p><p>千万不要去想着在主函数层面去控制每个<code>http handler</code>，也就是每个<code>http</code>请求的优雅退出，这样很难控制代码的复杂度。对于每个<code>http</code>请求的控制，应该交给<code>http server</code>这个框架去实现。</p><p>所以，在主函数中，其实需要优雅退出的选项其实很有限。</p></blockquote><h2 id="延伸思考"><a href="#延伸思考" class="headerlink" title="延伸思考"></a>延伸思考</h2><p>本次我们讲的是<code>main</code>函数控制其<code>goroutine</code>的优雅退出，其实我们延伸开来，就是 <strong>父Goroutine怎么保证子Goroutine优雅退出</strong> 这个问题。</p><p>虽然有解决方案，但我这是想泼一盆冷水，希望大家想想一个问题：<strong>既然这个子Goroutine是有价值的，不想轻易丢失，那么为什么不放到主Goroutine中呢？</strong> 其实，很多时候，我们都在 <strong>滥用Goroutine</strong> 。我希望大家更多地抛开语言特性，从整体思考以下三个问题：</p><ol><li><strong>明确调用链路</strong> - 梳理整个调用流程，区分关键和非关键的步骤，以及在对应步骤上发生错误时的处理方法</li><li><strong>用MQ解耦服务</strong> - 跨服务的调用如果比较费时，大部分时候更建议采用消息队列解耦</li><li><strong>面向错误编程</strong> - 关键业务的<code>Goroutine</code> 里代码要考虑所有可能发生错误的点，保证程序退出或<code>panic/recover</code>也不要出现 <strong>脏数据</strong>。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>main</code>函数是<code>go</code>程序的入口，如果在这里写出一段优雅的代码，很容易给阅读自己源码的朋友留下良好的印象。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一个简单的main函数&quot;&gt;&lt;a href=&quot;#一个简单的main函数&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习路线 - 1.方向篇:明确Go语言的成长方向</title>
    <link href="http://example.com/2021/03/05/go-study/go-study-1/"/>
    <id>http://example.com/2021/03/05/go-study/go-study-1/</id>
    <published>2021-03-05T03:27:15.000Z</published>
    <updated>2021-03-29T12:51:46.961Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p><h2 id="Go的就业方向"><a href="#Go的就业方向" class="headerlink" title="Go的就业方向"></a>Go的就业方向</h2><p>目前，后端开发语言的就业方向主要分为两块：<strong>业务系统开发</strong> 与 <strong>基础平台开发</strong> 。<code>Go</code>语言自然也不会例外。</p><p>也许有朋友不太了解这两块，那我简单地解释下：</p><p><strong>业务系统开发</strong> 主要指公司对外盈利的系统，包括 <code>toB</code> 与 <code>toC</code>。由于这个是公司安身立命的根本，所以开发者是必须跟着业务走的。</p><p><strong>基础平台开发</strong> 指的是公司为了提升工作效率（不仅仅是研发），搭建的一套内部体系，常常需要跨业务支持。</p><blockquote><p>目前主流的云平台，其实是包装成一套业务系统的基础平台，比如阿里云的ECS。</p><p>这类云平台是大型公司将自己的基础平台能力沉淀下来后，包装成一套业务系统对外销售，内部也是分成了两类开发人员：上层开发一些多语言接口、计费等业务系统；下层开发对应的基础平台。</p></blockquote><h2 id="Go语言的劣势"><a href="#Go语言的劣势" class="headerlink" title="Go语言的劣势"></a>Go语言的劣势</h2><p>很遗憾，我依然在这里不得不进行一些编程语言间的对比。毕竟，如果不清楚一些技术的优劣势，我们很难明确自己的定位和发展方向。</p><h3 id="并不是所有编程语言适合各个领域"><a href="#并不是所有编程语言适合各个领域" class="headerlink" title="并不是所有编程语言适合各个领域"></a>并不是所有编程语言适合各个领域</h3><p>我先简单地抛出几个例子：</p><ul><li>游戏、音视频领域主流是<code>C/C++</code></li><li>测试、人工智能的主流是<code>Python</code></li><li>大数据平台的主流是<code>Java</code></li><li>前端的主流是<code>JavaScript</code></li></ul><p>这里的说法并不是绝对的，但选对了语言，能大量地复用业界现有的资源，少走很多弯路。</p><h3 id="语言特点决定“轮子”不会太多"><a href="#语言特点决定“轮子”不会太多" class="headerlink" title="语言特点决定“轮子”不会太多"></a>语言特点决定“轮子”不会太多</h3><p><code>Go</code>的生命已有十年多，但新增的特性很少，主要是语言创建者的核心理念 - <strong>简洁</strong>。这个理念导致了现成可用的轮子少：以<code>map</code>容器来说，<code>Java</code>至少提供了数十种，可根据不同的场景选择不同的实现，达到性能极致化，而<code>Go</code>只提供了一种通用的基本数据结构。</p><blockquote><p>Go 的设计哲学可以类比为 Unix </p></blockquote><p>那么，我们是否可以采用开源社区中<code>Go</code>的现成库呢？当然可以！那我们来继续拿<code>Java</code>中的容器对比一下，看看改造的成本：</p><ul><li>在<code>Java</code>中，容器是一个对象类型，已定义对应的接口<code>interface</code><ul><li>新的容器类实现对应的接口</li><li>改造成本：在创建容器的地方(如<code>beans</code>)替换即可</li></ul></li><li>而<code>Go</code>里的容器是基本类型，它的操作是定义在基本语法中，并没有抽象出接口<code>interface</code><ul><li>改造成本：新的容器实现后，所有的增删改查代码都需要修改</li></ul></li><li>在复杂的嵌套数据结构中，<code>Go</code>的改造成本更大</li></ul><blockquote><p>我们自然可以在自己的项目中，对map/slice操作先封装成一个方法，这样后续改造成本也很低了，但这种思想就很偏向于Java体系了：</p><ol><li>Go 崇尚的是简洁，map/slice能满足99%以上的使用场景</li><li>无法在语言层面将 map/slice 封装成方法，就不能发展成一个语言层面的通用标准，很难推广</li></ol></blockquote><h3 id="没有一套成熟的复杂系统开发方法论"><a href="#没有一套成熟的复杂系统开发方法论" class="headerlink" title="没有一套成熟的复杂系统开发方法论"></a>没有一套成熟的复杂系统开发方法论</h3><p>细心的读者可以注意到我这边用到的两个关键词：<strong>成熟</strong> 和 <strong>复杂系统</strong> 。用 <code>Go</code> 语言开发的系统自然有不少，但我认为至今为止，业界还没有一套非常适配 <code>Go</code> 语言的系统开发方法论，包括大厂们也是在摸索的过程中（或者说没有公开）。</p><p>这里，我列举四个我比较关注的点：</p><ol><li>引入<code>DDD</code>设计思想拆分微服务后，如何保证实践与设计一致</li><li>如何借用 <strong>面向对象UML设计图</strong> 类似的实践，梳理复杂系统内的关系</li><li>如何组织代码的仓库、目录与分层，适配业务场景</li><li>一整套覆盖开发各模块的工具集和最佳实践：如监控埋点、日志链路追踪、测试套件</li></ol><blockquote><p>以上四点业界都有一定的实践，但没有如Spring那般形成一个生态圈，达到一致。</p><p>如果达不到一致认可，就无法用工具去强制约束，那么软件工程的复杂度就无法控制了。</p></blockquote><h2 id="明确Go语言的核心成长方向"><a href="#明确Go语言的核心成长方向" class="headerlink" title="明确Go语言的核心成长方向"></a>明确Go语言的核心成长方向</h2><ol><li><strong>掌握计算机基础</strong> <code>Go</code> 官方包覆盖了操作系统、网络、数据库等各类常用操作，我们不能停留在 <strong>使用</strong> 上，而是通过代码去了解它们的 <strong>底层实现</strong> ，为后续遇上相关瓶颈时做好基础的知识储备。由于 <code>Go</code> 的源码简洁，所以阅读起来相对其它语言轻松不少。</li><li><strong>常用工具库的储备</strong> <code>Go</code> 在开源上存在一些 <strong>优秀的轮子</strong>，常常能达到事半功倍的效果。我建议分三步走： <strong>会用</strong> 、 <strong>用好</strong> 、<strong>体系化</strong> 。其中体系化是指要将这些库串联起来，根据场景选择，形成一整套灵活的解决方案。</li><li><strong>项目/工程化</strong> 将<code>Go</code>的项目与公司的整个研发流程、甚至是产品周期结合起来：小到如何保证一个需求的准确实现，大到如何保证研发架构的合理落地，都是比较有挑战的内容。</li></ol><blockquote><p>也许不少人会认为第三点是一个远超编程语言的话题，在这里讲意义不大。确实，项目工程化更多地是看团队结构、工作流程等上层机制的约束，编程语言能做的不多。</p><p>然而，目前<code>Java</code>编程语言已经产生了一个成熟的生态圈，从单纯的代码实现功能，慢慢影响到了开发的各个流程，这样就或多或少地具备了 <strong>项目工程化</strong> 的一些特征。其它的编程语言如果希望能支持复杂的开发场景，必须得有一套初步的系统化方法论（成熟度暂且不论），才有可能分得一杯羹。当然，由于不同编程语言背后的编程范式、设计理念不同，方法论也各具特色，很有可能随着时间推移而变化。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天跟大家聊的话题挺广的，也结合了很多我的个人感受，希望能给大家带来启发。下一篇，我会继续 <strong>方向篇</strong> 的话题，细化到具体工作上，和大家谈谈具体工作上的内容。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Go的就业方向&quot;&gt;&lt;a href=&quot;#Go的就业方向&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习路线 - 0.总览</title>
    <link href="http://example.com/2021/02/21/go-study/go-study-0/"/>
    <id>http://example.com/2021/02/21/go-study/go-study-0/</id>
    <published>2021-02-21T03:27:15.000Z</published>
    <updated>2021-03-29T12:51:46.961Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p><p>大家好，我是六月天天。从今天开始，我将开启一个新的系列 - <strong>Go语言学习路线</strong>。</p><blockquote><p>大家可以从 <a href="https://space.bilibili.com/293775192">bilibili</a> 的视频分享中看到观点的延伸思考</p></blockquote><h2 id="以成长为核心"><a href="#以成长为核心" class="headerlink" title="以成长为核心"></a>以成长为核心</h2><p>目前网上已有很多Go相关的教程，包括基础讲解、源码解析、面试技巧等，但我依然下决心来做一个具有强烈个人主观观点色彩的<strong>Go语言学习路线</strong>：这个系列的目标只有一个 - <strong>成长</strong> 。我不求这个系列超越其它的教程，而是能做到<strong>去芜存菁</strong> ，引发一批朋友的共鸣。</p><p>整个系列中，我会输出大量的主观观点，大家不一定能全盘接受，我也不希望大家全盘接受。我坚信，<strong>没有碰撞的技术观点无法引起大家的深度思考</strong> ，犹如上课时老师对你进行单方面的内容输出；同时，<strong>主观观点会更具现实色彩与实践意义</strong> ，我经历的公司和方向都很丰富，或多或少会和大家的实际工作产生共鸣。</p><h2 id="学习路线概览"><a href="#学习路线概览" class="headerlink" title="学习路线概览"></a>学习路线概览</h2><ol><li>方向篇 - 明确学习的 <strong>短期目标</strong> 和 <strong>长期目标</strong> ，以及我的一些主观建议</li><li>准备篇 - <strong>工欲善其事，必先利其器</strong> ，一套好的工具和方法，不仅能让你更高效地学习，更能让你 <strong>坚持下来</strong></li><li>入门篇 - <strong>基础语法</strong> 的学习思路，提纲挈领，但不会细化到语法的讲解</li><li>基础篇 - <strong>简单web项目</strong> 的实现思路，介绍 <strong>项目布局</strong>、<strong>模块职责</strong>、<strong>业务特点</strong></li><li>提效篇 - <strong>提升开发效率</strong> ，常见思路是采用一些优秀的 <strong>编程实践</strong>、<strong>开源库</strong>、<strong>研发工具</strong>等</li><li>进阶篇 - 抛开日常的CRUD，根据自己的目标，找到适合自己的 <strong>进阶路线</strong></li><li>高级篇 - 根据互联网上相关信息，结合我的个人经验，谈谈<strong>Go语言的后续发展</strong></li></ol><blockquote><p>可能部分朋友会看重 <strong>入门、基础这些偏实践的模块</strong> ，但我花了大量心血在 <strong>方向及进阶相关的内容</strong> 上：</p><ul><li>入门的方式各有不同，快的一个月，慢的半年，但最终达到的效果差不了多少</li><li>方向错误会严重影响到个人的长远发展，拘泥于自己的舒适圈，越到后期，沉没成本越高</li></ul></blockquote><h2 id="自我简介"><a href="#自我简介" class="headerlink" title="自我简介"></a>自我简介</h2><p>我简单地介绍一下自己重要的编程经历，让大家更好地了解我：</p><ul><li>4年<code>C++</code> / 4年<code>Go</code> 开发，<code>Python</code>/<code>Java</code>/<code>Js</code>等也都有中小平台的研发经验</li><li>曾在某中型公司（已上市，1000+人）的运维开发团队中作为技术负责人，搭建研发效能平台</li><li>目前在某一线大厂任职，参与商用业务平台的开发</li><li>用<code>Go</code>语言研发过公司内部的 <strong>私有云平台</strong> 和已商用的 <strong>业务平台</strong></li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>最后，我再谈一谈自己对 <strong>Go语言学习路线</strong> 这个系列的期许，也是我希望能区别于其它教程的点：</p><ul><li><strong>可落地</strong> - 不停留于泛泛而谈，实践的具体路线清晰</li><li><strong>正反馈</strong> - 持续激励自己，避免半途而废</li><li><strong>阶梯式</strong> - 层层递进，有明确的进步目标</li><li><strong>通用性</strong> - 可延伸至各种技术的学习，形成自己的学习方法</li><li><strong>及时性</strong> - 定期更新，保证学习路线的内容不过时</li></ul><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;p&gt;大家好，我是六月天天。从今天开始，我将开启一个新的系列 - &lt;strong&gt;Go语言学习路线&lt;/stron
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>gRPC源码分析(四)：剖析Proto序列化</title>
    <link href="http://example.com/2021/02/20/grpc/grpc-4/"/>
    <id>http://example.com/2021/02/20/grpc/grpc-4/</id>
    <published>2021-02-20T11:34:49.000Z</published>
    <updated>2021-03-29T12:51:46.963Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的分析中，我们已经知道了使用proto序列化的代码在<a href="https://github.com/grpc/grpc-go/tree/v1.29.x/encoding/proto">encoding目录</a>中，路径中只有三个文件，其中2个还是测试文件，看起来这次的工作量并不大。</p><p>首先，针对读源码是先看源代码还是测试代码，因人而异。个人建议在对源码毫无头绪时，先从测试入手，了解大致功能；如果有一定基础，那么也可以直接入手源代码。我认为优秀的Go源码可读性是非常高的，所以一般情况下，我都直接从源文件入手，遇到问题才会去对应的测试里阅读。</p><h2 id="Marshal"><a href="#Marshal" class="headerlink" title="Marshal"></a>Marshal</h2><p>Marshal的代码不多，关键在于传入参数的类型，有2个分支路线：</p><ol><li><a href="https://github.com/grpc/grpc-go/blob/v1.29.x/encoding/proto/proto.go#L68">proto.Marshaler类型</a>，实现了<code>Marshal() ([]byte, error)</code>方法</li><li><a href="https://github.com/grpc/grpc-go/blob/v1.29.x/encoding/proto/proto.go#L54">proto.Message类型</a>，实现了<code>Reset()</code>、<code>String() string</code> 和<code>ProtoMessage()</code>三个方法</li></ol><p>我们回头看看proto生成的<a href="https://github.com/grpc/grpc-go/blob/v1.29.x/examples/helloworld/helloworld/helloworld.pb.go#L35">go文件</a>，发现对应的是第二个接口。那我们接着看：</p><ol><li>调用了protoBufferPool，是一个sync.Pool，是为了加速proto对象的分配</li><li>内部采用的是 <code>marshalAppend</code>，字面来看就是 序列化并追加，对应了 <code> wire-format</code>这个概念，并不需要将整个结构加载完毕、再进行序列化</li><li>接下来调用的是<code>protoV2.MarshalOptions</code>，需要关注的是protoV2是另一个package，<code>protoV2 &quot;google.golang.org/protobuf/proto&quot;</code></li><li>在正式marshal前，调用<code>m.ProtoReflect()</code>方法，根据名字可以猜测是对Message做反射，详细内容不妨后面再看</li><li>最后就是正式的marshal了，分两个分支：<code>out, err = methods.Marshal(in)</code>和<code>out.Buf, err = o.marshalMessageSlow(b, m)</code>。后者是慢速的，一般情况下是不会用到，我们重点关注前者，这时就需要回头看4中的实现了</li><li>逐个往前搜索，<code>接口protoreflect.Message =&gt; </code> <code>接口Message</code> =&gt;<code>函数MessageV2</code>  =&gt; <code>函数ProtoMessageV2Of</code>  =&gt; <code>函数legacyWrapMessage</code> =&gt; <code>函数MessageOf</code> =&gt; <code>类型messageReflectWrapper</code>，终于，在这里找到了目标函数 <code>ProtoMethods</code></li><li>因为我们取的是<code>methods</code>，所以很快将代码定位到 <code>makeCoderMethods</code> =&gt; <code>marshal</code> =&gt; <code>marshalAppendPointer</code> ，最后找到一行核心代码 <code>b, err = f.funcs.marshal(b, fptr, f, opts)</code></li><li>那这个marshal什么时候被赋值的呢？在步骤7中，我们查看了methods被赋值的地方，其实旁边就有一个函数 <code>makeReflectFuncs</code> ，最后定位到了 <code>/google.golang.org/protobuf/internal/impl/codec_gen.go</code> 文件中。每种变量的序列化，都是按照特定规则来执行的。</li></ol><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>那么 protobuf 实际是如何对每种类型进行Encoding的呢？有兴趣的朋友可以点击<a href="https://developers.google.com/protocol-buffers/docs/encoding">这个链接</a>，阅读原文。这里，我直接拿出一个实例进行讲解。</p><h4 id="定义proto"><a href="#定义proto" class="headerlink" title="定义proto"></a>定义proto</h4><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"><span class="built_in">bool</span> male = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int32</span> age = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">string</span> address = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生成对应文件后，编写测试用例"><a href="#生成对应文件后，编写测试用例" class="headerlink" title="生成对应文件后，编写测试用例"></a>生成对应文件后，编写测试用例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">people := &amp;pbmsg.People&#123;</span><br><span class="line">Male:    <span class="literal">true</span>,</span><br><span class="line">Age:     <span class="number">80</span>,</span><br><span class="line">Address: <span class="string">&quot;China Town&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">b, _ := proto.Marshal(people)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行生成结果"><a href="#运行生成结果" class="headerlink" title="运行生成结果"></a>运行生成结果</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1000 1 10000 1010000 11010 1010 1000011 1101000 1101001 1101110 1100001 100000 1010100 1101111 1110111 1101110]</span><br></pre></td></tr></table></figure><h4 id="分析第一个字段Bool"><a href="#分析第一个字段Bool" class="headerlink" title="分析第一个字段Bool"></a>分析第一个字段Bool</h4><p>首先，Male是一个bool字段，序号为1。</p><p>根据Google上的文档，bool是Varint，所以计算</p><p>(field_number &lt;&lt; 3) | wire_type = (1&lt;&lt;3)|0 = 8，对应第一个字节： <code>1000</code></p><p>然后，它的值true对应第二个字节<code>1</code></p><h4 id="分析第二个字段Int"><a href="#分析第二个字段Int" class="headerlink" title="分析第二个字段Int"></a>分析第二个字段Int</h4><p>同样的，(field_number &lt;&lt; 3) | wire_type = (2&lt;&lt;3)|0 = 16，对应第三个字节<code>10000</code></p><p>值80对应<code>1010000</code></p><h4 id="分析第三个字段String"><a href="#分析第三个字段String" class="headerlink" title="分析第三个字段String"></a>分析第三个字段String</h4><p>因为string是不定长的，所以需要一个额外的长度字段</p><p>(field_number &lt;&lt; 3) | wire_type = (3&lt;&lt;3)|2=26，对应<code>11010</code></p><p>接下来是长度字段，我们有10个英文单词，所以长度为10，对应 <code>1010</code></p><p>然后就是10个Byte表示”China Town”了</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次的分析到这里就暂时告一段落了，阅读protobuf的相关代码还是非常耗时耗力的。其实这块最主要的复杂度在于为了兼容新老版本，采用了大量的Interface实现。Interface带有面向对象特色，在重构代码时很有意义，不过也给阅读代码时，查找方法对应实现时带来了复杂度。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号：golangcoding</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前面的分析中，我们已经知道了使用proto序列化的代码在&lt;a href=&quot;https://github.com/grpc/grpc-go/tree/v1.29.x/encoding/proto&quot;&gt;encoding目录&lt;/a&gt;中，路径中只有三个文件，其中2个还是测试文件，看
      
    
    </summary>
    
      <category term="源码阅读" scheme="http://example.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="gRPC" scheme="http://example.com/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>gRPC源码分析(三)：从Github文档了解gRPC的项目细节</title>
    <link href="http://example.com/2021/02/20/grpc/grpc-3/"/>
    <id>http://example.com/2021/02/20/grpc/grpc-3/</id>
    <published>2021-02-20T11:34:47.000Z</published>
    <updated>2021-03-29T12:51:46.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="官方Git总览"><a href="#官方Git总览" class="headerlink" title="官方Git总览"></a><a href="https://github.com/grpc">官方Git总览</a></h2><p>我们先看看GRPC这个项目的总览，主要分三种：</p><ul><li>基于C实现，包括了 C++, Python, Ruby, Objective-C, PHP, C#</li><li>其余语言实现的，最主要是go，java，node</li><li>proposal，即grpc的RFC，关于实现、讨论的文档汇总</li></ul><p>从这里可以看出，gRPC虽然是支持多语言，但原生的实现并不多。如果想在一些小众语言里引入gRPC，还是有很大风险的，有兴趣的可以搜索下TiDB在探索rust的gRPC的经验分享。</p><h2 id="gRPC-Go"><a href="#gRPC-Go" class="headerlink" title="gRPC-Go"></a><a href="https://github.com/grpc/grpc-go">gRPC-Go</a></h2><p>作为一名Go语言开发者，我自然选择从最熟悉的语言入手。同时，值得注意的是，grpc-go是除了<code>C家族系列</code>以外使用量最大的repo，加上Go语言优秀的可读性，是一个很好的入门gRPC的阅读材料。</p><p>进入项目，整个README.md文档也不长。通常情况下，如果你能啃完这个文档及相关链接，你对这个开源项目就已经超过99%的人了。</p><p>对Repo的相关注意事项，大家逐行阅读即可，整体比较简单，我简单列举下关键点：</p><ol><li>建议阅读官网文档（恭喜你，上次我们已经读完了官方文档）</li><li>在项目中的引入，建议用go mod</li><li>优先支持3个Go语言最新发布的版本</li><li>FAQ中的常见问题，主要关注<a href="https://github.com/grpc/grpc-go#io-timeout-errors">package下载问题</a>和<a href="https://github.com/grpc/grpc-go#how-to-turn-on-logging">如何开启追踪日志</a></li></ol><p>通读完成，我们再深入看看<a href="https://github.com/grpc/grpc-go#documentation">文档细节</a>，Example这块我们在官网的测试中已经看过，我们的接下来重点是godoc和具体细节的文档。</p><h2 id="go-doc"><a href="#go-doc" class="headerlink" title="go doc"></a><a href="https://godoc.org/google.golang.org/grpc">go doc</a></h2><h4 id="DefaultBackoffConfig"><a href="#DefaultBackoffConfig" class="headerlink" title="DefaultBackoffConfig"></a>DefaultBackoffConfig</h4><p>注意，这个变量被弃用，被挪到 <code>ConnectParams</code>里了(<a href="https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md">详情链接</a>)。那这个所谓的连接参数是什么用呢？代码不长，我们选择几个比较重要的内容来阅读下，原链接可以<a href="https://github.com/grpc/grpc-go/blob/v1.29.x/internal/backoff/backoff.go#L54">点击这里</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Backoff returns the amount of time to wait before the next retry given the</span></span><br><span class="line"><span class="comment">// number of retries.</span></span><br><span class="line"><span class="comment">// 根据retries返回等待时间，可以认为是一种退避策略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc Exponential)</span> <span class="title">Backoff</span><span class="params">(retries <span class="keyword">int</span>)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> retries == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 之前没有retries过，就返回BaseDelay</span></span><br><span class="line"><span class="keyword">return</span> bc.Config.BaseDelay</span><br><span class="line">&#125;</span><br><span class="line">backoff, max := <span class="keyword">float64</span>(bc.Config.BaseDelay), <span class="keyword">float64</span>(bc.Config.MaxDelay)</span><br><span class="line">  <span class="comment">// 等待时间不能超过max，等待时间 = BaseDelay * Multiplier的retries次方</span></span><br><span class="line">  <span class="comment">// Multiplier默认1.6，并不是官方http包中的2</span></span><br><span class="line"><span class="keyword">for</span> backoff &lt; max &amp;&amp; retries &gt; <span class="number">0</span> &#123;</span><br><span class="line">backoff *= bc.Config.Multiplier</span><br><span class="line">retries--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> backoff &gt; max &#123;</span><br><span class="line">backoff = max</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Randomize backoff delays so that if a cluster of requests start at</span></span><br><span class="line"><span class="comment">// the same time, they won&#x27;t operate in lockstep.</span></span><br><span class="line">  <span class="comment">// 乘以一个随机因子，数值为(1-Jitter,1+Jitter)，默认为(0.8,1.2)，防止同一时刻有大量请求发出，引起锁的问题</span></span><br><span class="line">backoff *= <span class="number">1</span> + bc.Config.Jitter*(grpcrand.Float64()*<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> backoff &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> time.Duration(backoff)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EnableTracing"><a href="#EnableTracing" class="headerlink" title="EnableTracing"></a>EnableTracing</h4><p>用来设置是否开启 trace，追踪日志</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>gRPC的错误码，原代码见<a href="https://github.com/grpc/grpc-go/blob/v1.29.x/codes/codes.go#L29">链接</a>，我们大概了解其原因即可：</p><ul><li><strong>OK</strong> 正常</li><li><strong>Canceled</strong> 客户端取消</li><li><strong>Unknown</strong> 未知</li><li><strong>InvalidArgument</strong> 未知参数</li><li><strong>DeadlineExceeded</strong> 超时</li><li><strong>NotFound</strong> 未找到资源</li><li><strong>AlreadyExists</strong> 资源已经创建</li><li><strong>PermissionDenied</strong> 权限不足</li><li><strong>ResourceExhausted</strong> 资源耗尽</li><li><strong>FailedPrecondition</strong> 前置条件不满足</li><li><strong>Aborted</strong> 异常退出</li><li><strong>OutOfRange</strong> 超出范围</li><li><strong>Unimplemented</strong> 未实现方法</li><li><strong>Internal</strong> 内部问题</li><li><strong>Unavailable</strong> 不可用状态</li><li><strong>DataLoss</strong> 数据丢失</li><li><strong>Unauthenticated</strong> 未认证</li></ul><p>读完上面的内容，发现跟HTTP/1.1的Status Code非常相似。</p><h4 id="CallOption"><a href="#CallOption" class="headerlink" title="CallOption"></a>CallOption</h4><p>调用在客户端 <code>Invoke</code> 方法中，包括before发送前，after为接收后。</p><p>官方提供了几个常用的CallOption，按场景调用。</p><h4 id="ClientConn"><a href="#ClientConn" class="headerlink" title="ClientConn"></a>ClientConn</h4><p>抽象的客户端连接。</p><p>值得注意的是，conns是一个map，所以实际可能有多个tcp连接。</p><h4 id="CodeC"><a href="#CodeC" class="headerlink" title="CodeC"></a>CodeC</h4><p>定义了Marshal和Unmarshal的接口，在grpc底层实现是proto，详细可见 <a href="https://github.com/grpc/grpc-go/blob/v1.29.x/encoding/proto/proto.go#L39">codec</a></p><h4 id="Compressor"><a href="#Compressor" class="headerlink" title="Compressor"></a>Compressor</h4><p>压缩相关的定义</p><h4 id="MetaData"><a href="#MetaData" class="headerlink" title="MetaData"></a>MetaData</h4><p>元数据，也就是key-value，可以类比到http的header</p><h4 id="DialOption"><a href="#DialOption" class="headerlink" title="DialOption"></a>DialOption</h4><p>客户端新建连接时的选项，按场景调用。</p><h4 id="ServerOption"><a href="#ServerOption" class="headerlink" title="ServerOption"></a>ServerOption</h4><p>服务端监听时的选项，按场景调用。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://github.com/grpc/grpc-go/tree/master/Documentation">文档链接</a></p><h4 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/benchmark.md">benchmark</a></h4><p>性能测试，有兴趣的可以细看gRPC是从哪几个维度做RPC性能测试的。</p><h4 id="Compression"><a href="#Compression" class="headerlink" title="Compression"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/compression.md">Compression</a></h4><p>可用<a href="https://github.com/grpc/grpc-go/blob/v1.29.x/encoding/encoding.go#L66">encoding.RegisterCompressor</a>实现自定义的压缩方法。</p><p>注意，压缩算法应用于客户端和服务端两侧。</p><h4 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/concurrency.md">Concurrency</a></h4><p>支持并发，从三个角度分析：</p><ul><li><code>ClientConn</code>支持多个Goroutine</li><li><code>Steams</code>中，<code>SendMsg</code>/<code>RecvMsg</code>可分别在两个Goroutine中运行，但任何一个方法运行在多个Goroutine上是不安全的</li><li><code>Server</code>每个客户端的invoke会对应一个Server端的Goroutine</li></ul><h4 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/encoding.md">Encoding</a></h4><p>类似Compression，可用<a href="https://github.com/grpc/grpc-go/blob/v1.29.x/encoding/encoding.go#L105">encoding.RegisterCodec</a>实现自定义的序列化方法。</p><h4 id="go-mock"><a href="#go-mock" class="headerlink" title="go mock"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/gomock-example.md">go mock</a></h4><p>用mock生成测试代码，详细可细看。</p><h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-auth-support.md">Authentication</a></h4><p>认证的相关选项，包括 TLS/OAuth2/GCE/JWT ，一般用前两者即可。</p><h4 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md">Metadata</a></h4><p>介绍了Metadata的使用，类比于HTTP/1.1的Header。</p><h4 id="Keepalive"><a href="#Keepalive" class="headerlink" title="Keepalive"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/keepalive.md">Keepalive</a></h4><p>长连接的参数分为3类：</p><ul><li>ClientParameters 客户端侧参数，主要用来探活</li><li>SeverParameters 服务端参数，控制连接时间</li><li>EnforcementPolicy 服务端加强型参数</li></ul><h4 id="log-level"><a href="#log-level" class="headerlink" title="log level"></a><a href="zhttps://github.com/grpc/grpc-go/blob/master/Documentation/log_levels.md">log level</a></h4><p>四个级别的log level，针对不同场景：</p><ul><li><code>Info</code> 用于debug问题</li><li><code>Warning</code> 排查非关键性的问题</li><li><code>Error</code> gRPC调用出现无法返回到客户端的问题</li><li><code>Fatal</code>  导致程序无法恢复的致命问题</li></ul><h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/proxy.md">proxy</a></h4><p>使用默认的HTTP或HTTPS代理。</p><h4 id="rpc-error"><a href="#rpc-error" class="headerlink" title="rpc error"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/rpc-errors.md">rpc error</a></h4><p>结合官方提供的错误码，用 <code>status.New</code> 或者 <code>status.Error</code> 创建错误。</p><h4 id="server-reflection"><a href="#server-reflection" class="headerlink" title="server reflection"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md">server reflection</a></h4><p>服务端方法映射，跟着教程走即可。</p><p>值得一提的是，采用c++中的grpc_cli模块，可以查看指定端口暴露出来的服务详情。</p><h4 id="versioning"><a href="#versioning" class="headerlink" title="versioning"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/versioning.md">versioning</a></h4><p>版本演进，一般情况下每6周一个小版本，紧急修复会打补丁号。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号：golangcoding</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;官方Git总览&quot;&gt;&lt;a href=&quot;#官方Git总览&quot; class=&quot;headerlink&quot; title=&quot;官方Git总览&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/grpc&quot;&gt;官方Git总览&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;我们先看看GRPC这个项
      
    
    </summary>
    
      <category term="源码阅读" scheme="http://example.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="gRPC" scheme="http://example.com/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>gRPC源码分析(二)：从官网文档看gRPC的特性</title>
    <link href="http://example.com/2021/02/20/grpc/grpc-2/"/>
    <id>http://example.com/2021/02/20/grpc/grpc-2/</id>
    <published>2021-02-20T11:34:45.000Z</published>
    <updated>2021-03-29T12:51:46.962Z</updated>
    
    <content type="html"><![CDATA[<p>在第一部分，我们学习了gRPC的基本调用过程，这样我们对全局层面有了一定了解。接下来，我们将结合官方文档，继续深入学习、探索下去。</p><h2 id="1-Authentication-认证的实现"><a href="#1-Authentication-认证的实现" class="headerlink" title="1. Authentication 认证的实现"></a>1. Authentication 认证的实现</h2><p><a href="https://grpc.io/docs/guides/auth/#with-server-authentication-ssltls">官方示例</a></p><p>示例很简单，客户端和服务端都大致分为两步：</p><ol><li>生成对应的认证信息 <code>creds</code></li><li>将认证信息作为 <code>DialOption</code> 传入信息</li></ol><p>认证方法的底层实现并不在我们今天的讨论范围内。这里值得一提的是，由于请求会存在大量的输入参数，这里提供的方法是 <code>opts ...DialOption</code>，也就是可变长度的参数，这一点很值得我们思考和学习。</p><h4 id="客户端的认证实现"><a href="#客户端的认证实现" class="headerlink" title="客户端的认证实现"></a>客户端的认证实现</h4><p>第一步：将认证信息放入连接中</p><ul><li><code>grpc.WithTransportCredentials</code> 中，将<code>creds</code> 保存到<code>copts.TransportCredentials</code></li><li>调用<code>Dial</code>，在内部用 <code>opt.apply(&amp;cc.dopts)</code>将认证信息传递到结构中</li><li><code>credsClone = creds.Clone()</code> 使用了一份复制，放到了Balancer中，估计是用于负载均衡的，暂时不用考虑</li></ul><p>第二步：将认证信息请求中发出</p><ul><li>首先我们先找到 <code>Invoke</code>函数，这里是发送请求的入口（对这一块有疑问的，查看上一篇）</li><li>分析一下函数 <code>invoke</code> ，调用了<code>newClientStream</code>，一大段代码都没有用到<code>copts.TransportCredentials</code>中的参数，大致猜测是在<code>clientStream</code>中</li><li>接下来这块，只通过阅读代码，要找到对应使用到<code>copts.TransportCredentials</code>很麻烦，建议第一次可以先通过反向查找，调用到这个参数的地方</li><li><code>newHTTP2Client</code> =&gt; <code>NewClientTransport</code> =&gt; <code>createTransport</code> =&gt; <code>tryAllAddrs</code> =&gt; <code>resetTransport</code> =&gt; <code>connect</code> =&gt; <code>getReadyTransport</code> =&gt;<code>pick</code> =&gt; <code>getTransport</code> =&gt;<code>newAttemptLocked</code> =&gt; <code>newAttemptLocked</code> =&gt; <code>newClientStream</code></li><li>这时，我们再正向梳理一下其调用逻辑，大致是查找连接情况，对传输层进行初始化。如果你了解认证是基于传输层<code>Transport</code>的，那下次正向查找时，会有一条比较明确的方向了</li></ul><h4 id="服务端的认证实现"><a href="#服务端的认证实现" class="headerlink" title="服务端的认证实现"></a>服务端的认证实现</h4><p>第一步：将认证信息放入Server结构中</p><ul><li>将<code>creds</code>包装成<code>ServerOption</code>，传入<code>NewServer</code>中</li><li>类似Client中的操作，被存至 <code>opts.creds</code> 里</li></ul><p>第二步：在连接中进行认证</p><ul><li>参考之前一讲的分析，我们进入函数 <code>handleRawConn</code></li><li>这次，我们的进展很顺利，一下子就看到了关键函数名<code>useTransportAuthenticator</code></li><li>在这里，调用了<code>creds</code>实现的<code>ServerHandshake</code>实现了认证。到这里，认证已经完成，不过我们可以再看看，认证信息是怎么传递的</li><li>接着，认证信息传入了 <code>newHTTP2Transport</code>，保存到结构体<code>http2Server</code>中的<code>authInfo</code>，最后返回了一个Interface <code>ServerTransport</code></li><li>在进行连接时，调用了<code>serveStreams</code>，然后调用了 <code>http2Server</code>的<code>HandleStreams</code>方法，这时，我们大致可以猜测，auth在这里被用到了</li><li>往下看，发现有个对header帧的处理<code>operateHeaders</code>，在这里被赋值到 <code>pr.AuthInfo</code>里，并被保存到s的Context中</li><li>一般情况下，Context的调用是十分隐蔽的，我们可以通过反向查找，哪里调用了<code>peer.FromContext</code>，然而并没有地方应用，那认证的分析，就告一段落了</li></ul><h2 id="2-四类gRPC调用的实现"><a href="#2-四类gRPC调用的实现" class="headerlink" title="2. 四类gRPC调用的实现"></a>2. 四类gRPC调用的实现</h2><p>这一块我们暂不深入源码，先了解使用时的特性</p><h4 id="2-1-简单RPC"><a href="#2-1-简单RPC" class="headerlink" title="2.1 简单RPC"></a>2.1 简单RPC</h4><p><a href="https://grpc.io/docs/tutorials/basic/go/#simple-rpc">代码链接</a></p><p>代码逻辑很直观，即处理后返回</p><h4 id="2-2-服务端流式RPC"><a href="#2-2-服务端流式RPC" class="headerlink" title="2.2 服务端流式RPC"></a>2.2 服务端流式RPC</h4><p><a href="https://grpc.io/docs/tutorials/basic/go/#server-side-streaming-rpc">代码链接</a></p><p>代码的关键在于两个函数<code>inRange</code>和 <code>stream.Send</code></p><h4 id="2-3-客户端流式RPC"><a href="#2-3-客户端流式RPC" class="headerlink" title="2.3 客户端流式RPC"></a>2.3 客户端流式RPC</h4><p><a href="https://grpc.io/docs/tutorials/basic/go/#client-side-streaming-rpc">代码链接</a></p><p>用一个for循环进行多次发送，<code>stream.Recv()</code>实现了从服务端获取数据，当EOF时，才调用<code>stream.SendAndClose</code>结束发送</p><h4 id="2-4-双向流式RPC"><a href="#2-4-双向流式RPC" class="headerlink" title="2.4 双向流式RPC"></a>2.4 双向流式RPC</h4><p><a href="https://grpc.io/docs/tutorials/basic/go/#bidirectional-streaming-rpc">代码链接</a></p><p>将 <code>SendAndClose</code> 变为 <code>Send</code>，其余基本不变。从这里可以看到，正常的关闭都是由服务端发起的。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号：golangcoding</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在第一部分，我们学习了gRPC的基本调用过程，这样我们对全局层面有了一定了解。接下来，我们将结合官方文档，继续深入学习、探索下去。&lt;/p&gt;
&lt;h2 id=&quot;1-Authentication-认证的实现&quot;&gt;&lt;a href=&quot;#1-Authentication-认证的实现&quot; c
      
    
    </summary>
    
      <category term="源码阅读" scheme="http://example.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="gRPC" scheme="http://example.com/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>gRPC源码分析（一）：gRPC的系统调用过程</title>
    <link href="http://example.com/2021/02/20/grpc/grpc-1/"/>
    <id>http://example.com/2021/02/20/grpc/grpc-1/</id>
    <published>2021-02-20T11:34:41.000Z</published>
    <updated>2021-03-29T12:51:46.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>参考<a href="https://grpc.io/docs/quickstart/go/">官方文档</a>，进行部署并运行成功</p><h2 id="分析思路：GRPC是怎么实现方法调用的"><a href="#分析思路：GRPC是怎么实现方法调用的" class="headerlink" title="分析思路：GRPC是怎么实现方法调用的"></a>分析思路：GRPC是怎么实现方法调用的</h2><ol><li>分析PB生成的对应文件</li><li>运行server</li><li>运行client</li></ol><h2 id="1-分析PB生成的对应文件"><a href="#1-分析PB生成的对应文件" class="headerlink" title="1. 分析PB生成的对应文件"></a>1. 分析PB生成的对应文件</h2><h3 id="HelloRequest-HelloReply-结构分析"><a href="#HelloRequest-HelloReply-结构分析" class="headerlink" title="HelloRequest/HelloReply 结构分析"></a>HelloRequest/HelloReply 结构分析</h3><p>存在三个冗余字段 <code>XXX_NoUnkeyedLiteral</code> <code>XXX_unrecognized</code> <code>XXX_sizecache</code></p><p>这部分主要是兼容proto2的，我们暂时不用细究</p><h3 id="GreeterClient客户端"><a href="#GreeterClient客户端" class="headerlink" title="GreeterClient客户端"></a>GreeterClient客户端</h3><p>传入一个 cc grpc.ClientConnInterface 客户端连接</p><p>可调用的方法为SayHello，其内部的method为”/helloworld.Greeter/SayHello”，也就是<code>/&#123;package&#125;.&#123;service&#125;/&#123;method&#125;</code> ，作为一个唯一的URI</p><h3 id="GreeterServer服务端"><a href="#GreeterServer服务端" class="headerlink" title="GreeterServer服务端"></a>GreeterServer服务端</h3><p>需要自己实现一个SayHello的方法</p><p>其中有个 UnimplementedGreeterServer 的接口，可以嵌入到对应的server结构体中（有方法未实现时，会返回codes.Unimplemented）</p><h2 id="2-运行server"><a href="#2-运行server" class="headerlink" title="2. 运行server"></a>2. 运行server</h2><h3 id="定义server"><a href="#定义server" class="headerlink" title="定义server"></a>定义server</h3><p>这里pb.UnimplementedGreeterServer被嵌入了server结构，所以即使没有实现SayHello方法，编译也能通过。</p><p>但是，我们通常要强制server在编译期就必须实现对应的方法，所以生产中建议不嵌入。</p><h3 id="实现自己的业务逻辑"><a href="#实现自己的业务逻辑" class="headerlink" title="实现自己的业务逻辑"></a>实现自己的业务逻辑</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span>&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册TCP监听端口"><a href="#注册TCP监听端口" class="headerlink" title="注册TCP监听端口"></a>注册TCP监听端口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)</span><br></pre></td></tr></table></figure><p>因为gRPC的应用层是基于HTTP2的，所以这里不出意外，监听的是tcp端口</p><h3 id="grpc-NewServer"><a href="#grpc-NewServer" class="headerlink" title="grpc.NewServer()"></a>grpc.NewServer()</h3><ol><li>入参为选项参数options</li><li>自带一组defaultServerOptions，最大发送size、最大接收size、连接超时、发送缓冲、接收缓冲</li><li><code>s.cv = sync.NewCond(&amp;s.mu)</code> 条件锁，用于关闭连接</li><li>全局参数 <code>EnableTraciing</code> ，会调用golang.org/x/net/trace 这个包</li></ol><h3 id="pb-RegisterGreeterServer-s-amp-server"><a href="#pb-RegisterGreeterServer-s-amp-server" class="headerlink" title="pb.RegisterGreeterServer(s, &amp;server{})"></a>pb.RegisterGreeterServer(s, &amp;server{})</h3><p>对比自己创建的server和pb中定义的server，确定每个方法都已经实现</p><p>service放在 <code>m map[string]*service</code> 中，所以一个server可以放多个proto定义的服务</p><p>内部的method和stream放在 service 中的两个map中</p><h3 id="s-Serve-lis"><a href="#s-Serve-lis" class="headerlink" title="s.Serve(lis)"></a>s.Serve(lis)</h3><ol><li>listener 放到内部的map中</li><li>for循环，进行tcp连接，这一部分和http源码中的ListenAndServe极其类似</li><li>在协程中进行handleRawConn</li><li>将tcp连接封装对应的creds认证信息</li><li>新建newHTTP2Transport传输层连接</li><li>在协程中进行serveStreams，而http1这里为阻塞的</li><li>函数HandleStreams中参数为2个函数，前者为处理请求，后者用于trace</li><li>进入handleStream，前半段被拆为service，后者为method，通过map查找</li><li>method在processUnaryRPC处理，stream在processStreamingRPC处理，这两块内部就比较复杂了，涉及到具体的算法，以后有时间细读</li></ol><h2 id="3-运行client"><a href="#3-运行client" class="headerlink" title="3. 运行client"></a>3. 运行client</h2><h3 id="grpc-Dial"><a href="#grpc-Dial" class="headerlink" title="grpc.Dial"></a>grpc.Dial</h3><p>新建一个conn连接，这里是一个支持HTTP2.0的客户端，暂不细讲</p><h3 id="pb-NewGreeterClient-conn"><a href="#pb-NewGreeterClient-conn" class="headerlink" title="pb.NewGreeterClient(conn)"></a>pb.NewGreeterClient(conn)</h3><p>新建一个client，包装对应的method，方便调用SayHello</p><h3 id="调用SayHello"><a href="#调用SayHello" class="headerlink" title="调用SayHello"></a>调用SayHello</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: name&#125;)</span><br></pre></td></tr></table></figure><ol><li>核心调用的是 Invoke 方法，具体实现要看grpc.ClientConn中</li><li>grpc.ClientConn中实现了Invoke方法，在call.go文件中，详情都在invoke中</li></ol><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号：golangcoding</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;参考&lt;a href=&quot;https://grpc.io/docs/quickstart/go/&quot;&gt;官方文档&lt;/a&gt;，进行部署并
      
    
    </summary>
    
      <category term="源码阅读" scheme="http://example.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="gRPC" scheme="http://example.com/tags/gRPC/"/>
    
  </entry>
  
</feed>
