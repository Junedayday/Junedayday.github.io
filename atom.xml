<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Junedayday Blog</title>
  
  <subtitle>六月天天的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-28T13:56:23.906Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Junedayday</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言技巧 - 4.【错误的三种处理】探索不同代码风格背后的哲学</title>
    <link href="http://example.com/2021/06/27/go-tip/go-tip-4/"/>
    <id>http://example.com/2021/06/27/go-tip/go-tip-4/</id>
    <published>2021-06-27T04:00:00.000Z</published>
    <updated>2021-06-28T13:56:23.906Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg" alt="Go-Study"></p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>先来模拟一个背景故事：</p><p>我们要去动物园进行一次游玩，主要行为有：</p><ul><li>进入动物园</li><li>参观熊猫</li><li>参观老虎</li><li>离开动物园</li></ul><h2 id="第一种风格-经典Go语言的处理模式"><a href="#第一种风格-经典Go语言的处理模式" class="headerlink" title="第一种风格 - 经典Go语言的处理模式"></a>第一种风格 - 经典Go语言的处理模式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次旅游</span></span><br><span class="line"><span class="keyword">type</span> ZooTour1 <span class="keyword">interface</span> &#123;</span><br><span class="line">Enter() error <span class="comment">// 进入</span></span><br><span class="line">VisitPanda(panda *Panda) error <span class="comment">// 看熊猫</span></span><br><span class="line">VisitTiger(tiger *Tiger) error <span class="comment">// 看老虎</span></span><br><span class="line">Leave() error <span class="comment">// 离开</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tour1</span><span class="params">(t ZooTour1, panda *Panda, tiger *Tiger)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := t.Enter(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;Enter failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := t.VisitPanda(panda); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessagef(err, <span class="string">&quot;VisitPanda failed, panda is %v&quot;</span>, panda)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := t.VisitTiger(tiger); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessagef(err, <span class="string">&quot;VisitTiger failed, tiger is %v&quot;</span>, tiger)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := t.Leave(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;Leave failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个处理风格非常经典。我们先不深入讨论，看完下一种后再做对比。</p><h2 id="第二种风格-类似Try-Exception的代码风格"><a href="#第二种风格-类似Try-Exception的代码风格" class="headerlink" title="第二种风格 - 类似Try-Exception的代码风格"></a>第二种风格 - 类似Try-Exception的代码风格</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ZooTour2 <span class="keyword">interface</span> &#123;</span><br><span class="line">Enter()</span><br><span class="line">VisitPanda(panda *Panda)</span><br><span class="line">VisitTiger(tiger *Tiger)</span><br><span class="line">Leave()</span><br><span class="line"></span><br><span class="line">Err() error <span class="comment">// 统一处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tour2</span><span class="params">(t ZooTour2, panda *Panda, tiger *Tiger)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">t.Enter()</span><br><span class="line">t.VisitPanda(panda)</span><br><span class="line">t.VisitTiger(tiger)</span><br><span class="line">t.Leave()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := t.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;ZooTour failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一整块的代码风格非常类似<strong>Try Exception</strong>，即先写业务逻辑，在最后对错误进行集中处理。</p><blockquote><p>标准库中的<code>bufio.Scanner</code>就是参考这种方式实现的。</p></blockquote><p>不过，由于Go语言对error的处理没有往外抛的机制，所以需要专门针对error做处理：</p><blockquote><p>新手千万不要把panic的机制和错误处理混为一谈。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZooTour的具体实现，需要保存一个error</span></span><br><span class="line"><span class="keyword">type</span> myZooTour <span class="keyword">struct</span> &#123;</span><br><span class="line">err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *myZooTour)</span> <span class="title">VisitPanda</span><span class="params">(panda *Panda)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 遇到错误就要直接返回，再处理其余逻辑</span></span><br><span class="line"><span class="keyword">if</span> t.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两种风格的对比"><a href="#两种风格的对比" class="headerlink" title="两种风格的对比"></a>两种风格的对比</h2><p>如果分别用一个词来形容前两种风格，我倾向于：</p><ol><li><strong>过程式的调用</strong></li><li><strong>集中处理错误</strong></li></ol><p>两种风格无法说清孰优孰劣，但有各自适宜的场景，我们来列举两种：</p><h3 id="不关注错误的发生，而关注错误发生后的统一处理"><a href="#不关注错误的发生，而关注错误发生后的统一处理" class="headerlink" title="不关注错误的发生，而关注错误发生后的统一处理"></a>不关注错误的发生，而关注错误发生后的统一处理</h3><p>内部存在大量的<code>VisitXXX</code>的函数，业务不关注发生错误的处理逻辑，而是关注整个流程完成后对error的处理。</p><p>例如，调用过程中如果出现了某个动物不在的问题，我们不关心，继续访问下一个，最后统一处理一下，看看有多少动物是不在的，打印一下即可。</p><p>这时，第二种处理方式明显会更简洁。</p><blockquote><p>一般推荐在工具类是采用这种方式，处理的内容比较直观，不会有太多异常case</p></blockquote><h3 id="错误有多种分类，会影响到程序的运行逻辑"><a href="#错误有多种分类，会影响到程序的运行逻辑" class="headerlink" title="错误有多种分类，会影响到程序的运行逻辑"></a>错误有多种分类，会影响到程序的运行逻辑</h3><p>例如<code>VisitPanda(panda *Panda)</code> 可能产生的错误分2类：</p><ul><li><p>不影响主流程：例如发现panda不见了，但还要接着继续参观其余动物</p></li><li><p>影响主流程：例如突然收到动物园闭园的通知，不能参观其余动物了</p></li></ul><p>这时，如果我们采用第二种风格，就得在每个函数内部加上很多特殊的业务逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *myZooTour)</span> <span class="title">VisitTiger</span><span class="params">(tiger *Tiger)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 要针对特定error进行处理</span></span><br><span class="line"><span class="keyword">if</span> t.err != <span class="literal">nil</span> &amp;&amp; t.err != ErrorPandaMissing &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很有可能出现一个问题：<strong>把Panda相关的error放到了Tiger里</strong>。</p><p>所以，<strong>当错误的类型会影响到代码的运行逻辑，更适合第一种方案</strong>。</p><blockquote><p>一般情况下，我们的业务代码都是复杂的，这时候更适合写过程性的代码。</p></blockquote><h2 id="第三种风格-函数式编程"><a href="#第三种风格-函数式编程" class="headerlink" title="第三种风格 - 函数式编程"></a>第三种风格 - 函数式编程</h2><p>借用1中的接口定义，我们将它改造成函数式的风格：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFunc <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEnterFunc</span><span class="params">()</span> <span class="title">MyFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> t.Enter()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewVisitPandaFunc</span><span class="params">(panda *Panda)</span> <span class="title">MyFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> t.VisitPanda(panda)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewVisitTigerFunc</span><span class="params">(tiger *Tiger)</span> <span class="title">MyFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> t.VisitTiger(tiger)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLeaveFunc</span><span class="params">()</span> <span class="title">MyFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t ZooTour1)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> t.Leave()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用代码示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tour3</span><span class="params">(t ZooTour1, panda *Panda, tiger *Tiger)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> actions = []MyFunc&#123;</span><br><span class="line">NewEnterFunc(),</span><br><span class="line">NewVisitPandaFunc(panda),</span><br><span class="line">NewVisitTigerFunc(tiger),</span><br><span class="line">NewLeaveFunc(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ContinueOnError(t, actions)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContinueOnError</span><span class="params">(t ZooTour1, funcs []MyFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">    <span class="keyword">if</span> err := f(t);err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// continue</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BreakOnError</span><span class="params">(t ZooTour1, funcs []MyFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line"><span class="keyword">if</span> err := f(t);err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是</p><ul><li><code>ContinueOnError</code>表示遇到了error有只记录下来，但整个流程继续往下跑</li><li><code>BreakOnError</code>表示遇到了error就直接break，不再跑接下来的<code>MyFunc</code></li></ul><h2 id="方案三背后的思想与延伸"><a href="#方案三背后的思想与延伸" class="headerlink" title="方案三背后的思想与延伸"></a>方案三背后的思想与延伸</h2><p>函数式编程最直观的一个特点是 <strong>延迟执行</strong>，也就是在引用<code>MyFunc</code>处不运行，在<code>ContinueOnError</code>或<code>BreakOnError</code>里才是真正执行的地方。</p><p>这个延迟执行的特性，在这里还能达到一个很有意思的效果 - <strong>分离关注点</strong>。</p><h3 id="关注点1-数据结构"><a href="#关注点1-数据结构" class="headerlink" title="关注点1 - 数据结构"></a>关注点1 - 数据结构</h3><p>样例中的<code>[]MyFunc</code>是一个切片，可以简单地理解为<strong>串行执行</strong>，也就是<code>MyFunc</code>执行完一个，再执行下一个。</p><p>我们可以引入更多的数据结构，例如<code>[][]MyFunc</code>，那就可以理解为增加了一层：</p><p>每一层中的<code>[]MyFunc</code>，代表这里面的所有<code>MyFunc</code>是平级的，也就可以采用一定的并发模式来加速执行。</p><h3 id="关注点2-执行逻辑"><a href="#关注点2-执行逻辑" class="headerlink" title="关注点2 - 执行逻辑"></a>关注点2 - 执行逻辑</h3><p>以<code>ContinueOnError</code>或<code>BreakOnError</code>为例，它们都是对各种<code>MyFunc</code>的处理逻辑。我们还可以引入更多的执行逻辑，比如：</p><ul><li>容忍特定错误的情况</li><li>对错误发生的数量有容忍上限</li><li>保证一定的并发模式</li></ul><h3 id="流水线的模式"><a href="#流水线的模式" class="headerlink" title="流水线的模式"></a>流水线的模式</h3><p>以我们常见的开发流水线为例，常见的包括：代码检查、单元测试、编译、CodeReview、自动化部署等。</p><p>这时，数据结构可以用来表示<strong>流水线的结构</strong>，执行逻辑可以用来表示<strong>流水线对异常的处置</strong>。</p><p>比如说，我们可以编排为一种串行执行的逻辑：</p><ol><li>代码检查</li><li>单元测试</li><li>编译</li><li>CodeReview</li><li>自动化部署</li></ol><p>我们想要加速整个流程，可以考虑修改为：</p><ol><li>检查<ol><li>代码检查</li><li>单元测试</li><li>编译</li></ol></li><li>CodeReview</li><li>自动化部署</li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文介绍了三种对error的处理方式，代码实现相对简单，大家更需要关注背后的适用场景。</p><p>其中，第三种方式是一个很有意思的设计模式，可以帮助大家理解函数式编程的价值。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习路线 - 5.基础篇:从一个web项目来谈Go语言的技能点</title>
    <link href="http://example.com/2021/05/13/go-study/go-study-5/"/>
    <id>http://example.com/2021/05/13/go-study/go-study-5/</id>
    <published>2021-05-13T04:00:00.000Z</published>
    <updated>2021-06-19T14:52:26.479Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p><h2 id="从一个Web项目开始"><a href="#从一个Web项目开始" class="headerlink" title="从一个Web项目开始"></a>从一个Web项目开始</h2><p>经过了 <strong>入门篇</strong> 的学习，大家已经初步了解Go语言的语法，也能写常见的代码了。接下来，我们就从一个Web项目入手，看看一些常见的技能与知识吧。</p><p>我们先简单地聊一下这个Web项目的背景：我们要做的是一个简单的web系统 ，有前端同学负责界面的开发，后端不会考虑高并发等复杂情况。</p><p>我们先从一个Web请求出发，看看会涉及到哪些模块。</p><h2 id="前端的请求生命周期"><a href="#前端的请求生命周期" class="headerlink" title="前端的请求生命周期"></a>前端的请求生命周期</h2><p>用户在web界面上点击了一个按钮，就由前端发起了一个请求。那这个请求的生命周期是怎么样的呢？</p><p>通常情况下，后端的工作是<strong>解析前端的数据，处理对应的业务逻辑，返回操作结果</strong>。</p><p>这里，离不开三层概念：</p><ul><li>API层：解析来自前端的数据，转化成go的数据结构</li><li>Service层：包含业务逻辑，是这个请求具体要做的事情</li><li>Dao层：数据持久化，也就是更新到数据库等，保证不丢失</li></ul><blockquote><p>不同框架有不同的命名方式，但我个人建议只关注这三层即可。</p></blockquote><p>当然，这三层逻辑并不绝对，会因为项目特点有所调整，但整体的<strong>分层思路</strong>是不会变化的。我认为，如果你能真正地理解web的分层，对项目的框架就能掌握得很棒了。</p><p>接下来，我们自顶向下逐层聊聊。</p><h2 id="第一层：API层"><a href="#第一层：API层" class="headerlink" title="第一层：API层"></a>第一层：API层</h2><p>通常来说，API层只做三件事：</p><ol><li><strong>根据路由规则，调用具体的处理函数</strong> ，常见的RESTful就是由<code>URL</code>+<code>Method</code>的作为路由规则；</li><li><strong>解析文本或二进制数据到Go结构体</strong>，常见的是用<code>json</code>反序列化；</li><li><strong>调用下一层Service的函数</strong></li></ol><p>抛开第三点暂且不谈，前两者比较容易理解，大家可以使用标准库里的<code>net/http</code>和<code>encoding/json</code>来完成。具体的代码我就不写了，网上示例非常多。</p><p>那么，API层这么简单，有什么学问嘛？这里，我建议大家看看两个开源库：</p><ul><li><a href="https://github.com/gin-gonic/gin">Gin</a></li><li><a href="https://github.com/gorilla/mux">Mux</a></li></ul><p>看看上面的示例，对比一下原生的<code>net/http</code>库写出来的代码，是否感觉可读性大大提高？没错，API层关键点之一的就是<strong>可读性</strong>。</p><p>不过Gin相对于Mux非常重量级，学习起来成本很大；而Mux虽然可读性提高，但在解析<code>http body</code>数据这块效果不佳，还是需要逐个手写结构体。</p><blockquote><p>所以，在我看来，这两个都并不是最佳方案，我非常建议有条件的项目能够直接引入 <strong>RPC级别的解决方案</strong>，例如gRPC。这块我会拿具体项目、花好几讲来好好说说。</p></blockquote><p>在开发的过程中，我对API层的开发会重点关注这几点：</p><ul><li>可读性：可以快速地根据命名了解功能，如<strong>RESTful</strong></li><li>高度复用：如引入<code>mux</code> 中的各种 middleware，比如 <strong>防止panic</strong> 、<strong>用户认证</strong> 、日志打印等</li><li>尽量薄：不做或少做业务逻辑处理，复杂处理都丢到service层</li><li>文档化：将接口的相关参数通过文档给到前端或第三方，尽量做到自动化或半自动化</li></ul><p>我再强调一下API层的重要性：<strong>API层是程序最关键的入口和出口，能很好地追踪到数据的前后变化情况。</strong> 一个优秀的API层实现，不仅能让我们少写很多重复性代码，也能大幅度地降低我们排查问题的效率。</p><h2 id="第二层：Service层"><a href="#第二层：Service层" class="headerlink" title="第二层：Service层"></a>第二层：Service层</h2><p>Service层可以理解为服务层，是整个项目中最复杂、也是代码比重往往是最多的。它是一个项目最核心的业务价值所在。</p><p>Service是最灵活、也是最考验设计能力的，虽说<strong>没有一套固定的模式</strong>，但还是会有一定的<strong>套路</strong>。</p><p>我分享一下个人的三个见解：</p><ol><li>单元测试覆盖率要尽量高，这是一个<strong>高频迭代与重构</strong>的模块，也是最容易出现问题的部分；</li><li>深入实践 <strong>面向对象与DDD</strong> ，最锻炼工程师抽象、解耦等能力的模块；</li><li>选择合适的 <strong>设计模式</strong> 可大幅度地提升研发效率；</li></ol><p>再提一句，请跃跃欲试的各位冷静一下，<strong>Service层是和业务一起成长的</strong>，前期没必要过度设计。我们把重点放在<strong>单元测试</strong>的编写上即可，适当地选用一些库来提高效率，如开源的<code>stretchr/testify</code>，内部的<code>reflect</code>等。</p><h2 id="第三层：Dao层"><a href="#第三层：Dao层" class="headerlink" title="第三层：Dao层"></a>第三层：Dao层</h2><p>Dao层常被理解为数据持久化层，但我们可以将它进行一定的延伸：<strong>将RPC调用也当做Dao层</strong>（不妨认为将数据持久化到了另一个服务），来适配微服务架构的场景。</p><blockquote><p>严格意义上，RPC调用和普通的Dao差异有不少，但为了收敛话题，我们暂且不细分。</p></blockquote><p>今天，我们不关注分布式场景下的各种数据问题，也不考虑各种存储中间件的特点，而是聚焦于一个问题：<strong>如何将内存中的对象持久化到数据库中</strong>。在编程领域，这部分的工具被称为<strong>ORM</strong>。</p><p>以Go语言对接MySQL为例，最常见的为<a href="https://github.com/go-gorm/gorm">gorm</a>，它能很便捷地将一个Go语言中的结构体，映射到MySQL数据库某个表中的一行数据。</p><blockquote><p>请自行对比一下，用go官方的sql库写增删改查，与用gorm写增删改查的工作量差异。</p></blockquote><p>关于Dao层，我认为有部分的实践是比较通用的：</p><ol><li><strong>选用官方或社区高频使用的库</strong>，避免后期出现功能缺失或性能瓶颈的问题；</li><li><strong>灵活性比易用性更重要</strong>，通过一层浅封装，往往能更适配项目，达到更棒的易用性；</li><li><strong>关注数据库的原理、而不是ORM工具的实现方式</strong>，数据库的原理是长期的积累，对技术选型和排查故障很有帮助。</li></ol><blockquote><p>至于不同的数据库ORM有不同的最佳实践，一一列举的工作量太大，我会在工程化的过程中选择性地讲解。</p></blockquote><h2 id="串联三层"><a href="#串联三层" class="headerlink" title="串联三层"></a>串联三层</h2><p>到这里，我们对这三层有了初步的了解，可以总结为**两边薄（API、Dao），中间厚（Service)**。</p><p>这里的实践需要大家不断打磨，比如说：</p><ul><li>API与Dao会随着个人编程能力的提升，不断地总结出更好的编程实践；</li><li>做性能优化时，优先考虑Dao，其次考虑API，这两部分的提效是最明显的；</li><li>排查问题时，先分析API的出入口，再分析Dao的出入口，实在解决不了再去看Service（此时已经是严重的业务逻辑问题了）；</li></ul><p>到最后，相信大家对这三层认知会进一步提升：</p><ul><li>API：服务对外的门面，通过一个接口定义就能了解大致实现原理；</li><li>Service：复杂的业务逻辑，非该服务的核心成员无需关注，而核心成员须重点维护；</li><li>Dao：无论是调用<strong>ORM</strong>还是<strong>SDK</strong>，都视为一种<strong>工具集</strong>，是一个技术人员沉淀通用能力的重点。</li></ul><h2 id="CRUD程序员"><a href="#CRUD程序员" class="headerlink" title="CRUD程序员"></a>CRUD程序员</h2><p>很多程序员都戏称自己是一个只会<strong>CRUD</strong>的码农。让我们换个视角，看看CRUD背后有没有一些的技术点。</p><ul><li>API层：遵循<strong>RESTful</strong>的原则，提高可读性（最好能在一行代码中看到，如<code>mux</code>）<ul><li>将操作（CRUD）对应到HTTP的Method</li><li>将资源对象对应到HTTP的URL</li></ul></li><li>Service层：<ul><li>对于只是简单的修改，Service不用做复杂处理，透传到Dao层即可</li><li>如果涉及到多个表的修改，进行事务处理（如mysql的transaction）</li><li>在Dao层出现错误时，适当封装错误信息，提高可读性</li></ul></li><li>Dao层：<ul><li>选择并熟练运用ORM，快速实现基本的CRUD</li><li>对复杂的ORM进行一层浅封装，方便Service层的调用</li></ul></li></ul><p>经过一段时间的磨练，CRUD的工作能大大提效，我们就能抽出更多的时间去学习其余技能了。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Web项目是我们日常开发最常见的项目类型，也是很多面试考察点的基点。</p><p>我建议大家从<strong>分层</strong>着手，明确各层职责，<strong>关注API与Dao层的提效工作，做好Service层的质量保障</strong>，更好地掌控全局。而在具体的开源库的使用过程中，<strong>选对比会用更重要</strong>，集中在<strong>API与Dao层</strong>。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;从一个Web项目开始&quot;&gt;&lt;a href=&quot;#从一个Web项目开始&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 3.【Error工程化】Go Error的工程化探索</title>
    <link href="http://example.com/2021/05/07/go-tip/go-tip-3/"/>
    <id>http://example.com/2021/05/07/go-tip/go-tip-3/</id>
    <published>2021-05-07T04:00:00.000Z</published>
    <updated>2021-06-19T14:52:26.500Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg" alt="Go-Study"></p><h2 id="Go-Error的工程化探索"><a href="#Go-Error的工程化探索" class="headerlink" title="Go Error的工程化探索"></a>Go Error的工程化探索</h2><p>在上一篇，我分享了对 <a href="https://go.googlesource.com/proposal/+/master/design/29934-error-values.md">官方Proposal</a> 的一些见解，偏向于理论层面。</p><p>本篇里，我会具体到代码层面，谈谈如何在一个工程化的项目中利用<code>github.com/pkg/errors</code>包，完整实现一套的错误处理机制。</p><h2 id="全局定义的error实现-MyError"><a href="#全局定义的error实现-MyError" class="headerlink" title="全局定义的error实现 - MyError"></a>全局定义的error实现 - MyError</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的 错误号 类型，用于API调用之间传递</span></span><br><span class="line"><span class="keyword">type</span> MyErrorCode <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的 错误号 的具体定义</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">ErrorBookNotFoundCode MyErrorCode = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">ErrorBookHasBeenBorrowedCode</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部的错误map，用来对应 错误号和错误信息</span></span><br><span class="line"><span class="keyword">var</span> errCodeMap = <span class="keyword">map</span>[MyErrorCode]<span class="keyword">string</span>&#123;</span><br><span class="line">ErrorBookNotFoundCode:        <span class="string">&quot;Book was not found&quot;</span>,</span><br><span class="line">ErrorBookHasBeenBorrowedCode: <span class="string">&quot;Book has been borrowed&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sentinel Error： 即全局定义的Static错误变量</span></span><br><span class="line"><span class="comment">// 注意，这里的全局error是没有保存堆栈信息的，所以需要在初始调用处使用 errors.Wrap</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ErrorBookNotFound        = NewMyError(ErrorBookNotFoundCode)</span><br><span class="line">ErrorBookHasBeenBorrowed = NewMyError(ErrorBookHasBeenBorrowedCode)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyError</span><span class="params">(code MyErrorCode)</span> *<span class="title">MyError</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">Code:    code,</span><br><span class="line">Message: errCodeMap[code],</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error的具体实现</span></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 对外使用 - 错误码</span></span><br><span class="line">Code MyErrorCode</span><br><span class="line"><span class="comment">// 对外使用 - 错误信息</span></span><br><span class="line">Message <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体示例-借书的三种场景"><a href="#具体示例-借书的三种场景" class="headerlink" title="具体示例 - 借书的三种场景"></a>具体示例 - 借书的三种场景</h2><p>我们来模拟一个场景：</p><p>我去图书馆借几本书，会存在三个场景，分别的处理逻辑如下</p><ol><li>找到书 - 不需要任何处理</li><li>发现书被借走了 - 打印一下即可，不认为是错误</li><li>发现图书馆不存在这本书 - 认为是错误，需要打印详细的错误信息</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">books := []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;Hamlet&quot;</span>,</span><br><span class="line"><span class="string">&quot;Jane Eyre&quot;</span>,</span><br><span class="line"><span class="string">&quot;War and Peace&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, bookName := <span class="keyword">range</span> books &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s start\n===\n&quot;</span>, bookName)</span><br><span class="line"></span><br><span class="line">err := borrowOne(bookName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;===\n%s end\n\n&quot;</span>, bookName)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">borrowOne</span><span class="params">(bookName <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Step1: 找书</span></span><br><span class="line">err := searchBook(bookName)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step2: 处理</span></span><br><span class="line"><span class="comment">// 特殊业务场景：如果发现书被借走了，下次再来就行了，不需要作为错误处理</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 提取error这个interface底层的错误码，一般在API的返回前才提取</span></span><br><span class="line"><span class="comment">// As - 获取错误的具体实现</span></span><br><span class="line"><span class="keyword">var</span> myError = <span class="built_in">new</span>(MyError)</span><br><span class="line"><span class="keyword">if</span> errors.As(err, &amp;myError) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;error code is %d, message is %s\n&quot;</span>, myError.Code, myError.Message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊逻辑: 对应场景2，指定错误(ErrorBookHasBeenBorrowed)时，打印即可，不返回错误</span></span><br><span class="line"><span class="comment">// Is - 判断错误是否为指定类型</span></span><br><span class="line"><span class="keyword">if</span> errors.Is(err, ErrorBookHasBeenBorrowed) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;book %s has been borrowed, I will come back later!\n&quot;</span>, bookName)</span><br><span class="line">err = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBook</span><span class="params">(bookName <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 下面两个 error 都是不带堆栈信息的，所以初次调用得用Wrap方法</span></span><br><span class="line"><span class="comment">// 如果已有堆栈信息，应调用WithMessage方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 发现图书馆不存在这本书 - 认为是错误，需要打印详细的错误信息</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(bookName) &gt; <span class="number">10</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrapf(ErrorBookNotFound, <span class="string">&quot;bookName is %s&quot;</span>, bookName)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(bookName) &gt; <span class="number">8</span> &#123;</span><br><span class="line"><span class="comment">// 2 发现书被借走了 - 打印一下被接走的提示即可，不认为是错误</span></span><br><span class="line"><span class="keyword">return</span> errors.Wrapf(ErrorBookHasBeenBorrowed, <span class="string">&quot;bookName is %s&quot;</span>, bookName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 找到书 - 不需要任何处理</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><h3 id="1-找到书-Helmet"><a href="#1-找到书-Helmet" class="headerlink" title="1. 找到书 - Helmet"></a>1. 找到书 - Helmet</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hamlet start</span><br><span class="line">===</span><br><span class="line">===</span><br><span class="line">Hamlet end</span><br></pre></td></tr></table></figure><p>没有任何错误信息</p><h3 id="2-发现书被借走了-Jane-Eyre"><a href="#2-发现书被借走了-Jane-Eyre" class="headerlink" title="2. 发现书被借走了 - Jane Eyre"></a>2. 发现书被借走了 - Jane Eyre</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Jane Eyre start</span><br><span class="line">===</span><br><span class="line">error code is 2, message is Book has been borrowed</span><br><span class="line">book Jane Eyre has been borrowed, I will come back later!</span><br><span class="line">===</span><br><span class="line">Jane Eyre end</span><br></pre></td></tr></table></figure><p><strong>打印被借走的提示</strong>，而错误被 <code>err = nil</code> 屏蔽。</p><h3 id="3-发现图书馆不存在这本书-War-and-Peace"><a href="#3-发现图书馆不存在这本书-War-and-Peace" class="headerlink" title="3. 发现图书馆不存在这本书 - War and Peace"></a>3. 发现图书馆不存在这本书 - War and Peace</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">War and Peace start</span><br><span class="line">===</span><br><span class="line">error code is 1, message is Book was not found</span><br><span class="line">Book was not found</span><br><span class="line">bookName is War and Peace</span><br><span class="line">main.searchBook</span><br><span class="line">        /GoProject/godemo/main.go:98</span><br><span class="line">main.borrowOne</span><br><span class="line">        /GoProject/godemo/main.go:71</span><br><span class="line">main.main</span><br><span class="line">        /GoProject/godemo/main.go:60</span><br><span class="line">runtime.main</span><br><span class="line">        /usr/local/go1.13.5/src/runtime/proc.go:203</span><br><span class="line">runtime.goexit</span><br><span class="line">        /usr/local/go1.13.5/src/runtime/asm_amd64.s:1357</span><br><span class="line">===</span><br><span class="line">War and Peace end</span><br></pre></td></tr></table></figure><p><strong>打印了错误的详细堆栈</strong>，在IDE中调试非常方便，可以直接跳转到对应代码位置。</p><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ol><li><code>MyError</code> 作为全局 <code>error</code> 的底层实现，保存具体的错误码和错误信息；</li><li><code>MyError</code>向上返回错误时，第一次先用<code>Wrap</code>初始化堆栈，后续用<code>WithMessage</code>增加堆栈信息；</li><li>从<code>error</code>中解析具体错误时，用<code>errors.As</code>提取出<code>MyError</code>，其中的错误码和错误信息可以传入到具体的API接口中；</li><li>要判断<code>error</code>是否为指定的错误时，用<code>errors.Is</code> + <code>Sentinel Error</code>的方法，处理一些特定情况下的逻辑；</li></ol><blockquote><p>Tips：</p><ol><li>不要一直用errors.Wrap来反复包装错误，堆栈信息会爆炸，具体情况可自行测试了解</li><li>利用go generate可以大量简化初始化Sentinel Error这块重复的工作</li><li><code>github.com/pkg/errors</code>和标准库的<code>error</code>完全兼容，可以先替换、后续改造历史遗留的代码</li><li>一定要注意打印<code>error</code>的堆栈需要用<code>%+v</code>，而原来的<code>%v</code>依旧为普通字符串方法；同时也要注意日志采集工具是否支持多行匹配</li></ol></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从现状来看，<code>Go</code> 语言的 <code>Error Handling</code> 已趋于共识，。</p><p>后续差异点就在底层 <code>MyError</code> 这块的实现，我个人认为会有如下三个方向：</p><ul><li>增加一些其余业务或系统的字段</li><li>对<code>Is</code>，<code>As</code> 等函数再进行一定的封装，使用起来更方便</li><li>区分不同的错误类型，来告诉调用方该如何处理，如 <strong>普通错误</strong>、<strong>重试错误</strong> 、<strong>服务降级错误</strong> 等</li></ul><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Go-Error的工程化探索&quot;&gt;&lt;a href=&quot;#Go-Error的工程化探索&quot; class=
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 2.【错误处理】谈谈Go Error的前世今生</title>
    <link href="http://example.com/2021/05/05/go-tip/go-tip-2/"/>
    <id>http://example.com/2021/05/05/go-tip/go-tip-2/</id>
    <published>2021-05-05T04:00:00.000Z</published>
    <updated>2021-06-19T14:51:46.443Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg" alt="Go-Study"></p><h2 id="从Go-2-Error-Proposal谈起"><a href="#从Go-2-Error-Proposal谈起" class="headerlink" title="从Go 2 Error Proposal谈起"></a>从Go 2 Error Proposal谈起</h2><p><code>Go</code>对<code>error</code>的处理一直都是很大的争议点，这点官方也已多次发文，并在2019年1月推出了一篇Proposal，有兴趣的可以点击链接细细品读。</p><p><a href="https://go.googlesource.com/proposal/+/master/design/29934-error-values.md">官方原文链接</a></p><p>下面，我会结合Proposal原文，发表一些自己的看法（会带上主观意见），欢迎讨论。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>这篇Proposal有一句话很好地解释了对<code>error</code>的期许：</p><p><strong>making errors more informative for both programs and people</strong></p><p>错误不仅是告诉机器怎么做的，也是告诉人发生了什么问题。</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>先让我们一起简单地回顾一下<code>error</code>的现状，来更好地理解这个 <strong>more informative</strong> 指的是什么。</p><p>原始的error定义为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">  Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的包含信息很少：一个Error() 的方法，即用字符串返回对应的错误信息。</p><p>最常用的<code>error</code>相关方法是2种：</p><ol><li>创建<code>error</code> - <code>fmt.Errorf</code>，它是针对<code>Error() </code>方法返回的字符串进行加工，如附带一些参数信息（暂不讨论%w这个wrap错误的实现）</li><li>使用<code>error</code> - 由于我们将<code>error</code>的输出结果定义为字符串，所以使用<code>error</code>时，一旦涉及到细节，就只能使用一些<code>string</code>的方法了</li></ol><p>举个具体的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 假设 readFile 存在于第三方或公用的库，我们没有权限修改、或者修改它的影响面很大</span></span><br><span class="line">_, err := readFile(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误中包含业务逻辑:</span></span><br><span class="line"><span class="comment">// 1. 文件不存在时，认为是 正常</span></span><br><span class="line"><span class="comment">// 2. 其余报错时，认为是 异常</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> strings.Index(err.Error(), <span class="string">&quot;no such file or directory&quot;</span>) &gt;= <span class="number">0</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;file not exist&quot;</span>)</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;open file error&quot;</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(fileName <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">b, err := ioutil.ReadFile(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;read file %s error %v&quot;</span>, fileName, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里存在3个明显的问题：</p><ol><li><strong>破坏性</strong> - <code>fmt.Errorf</code> 破坏了原有的error，将它从一个 <strong>具体对象</strong> 转化为 <strong>扁平的</strong> <code>string</code>，再填充到了新的<code>error</code>中。所以，通过<code>fmt.Errorf</code>处理后的error，都只传递了一个<code>string</code>的信息</li><li><strong>实现僵化</strong> - <strong>“no such file or directory”</strong> 这个错误信息用的是<strong>硬编码</strong>，对第三方<code>readFile</code>的内容有强依赖，不灵活</li><li><strong>排查问题效率低</strong> - 可以通过日志组件了解到error在<code>main</code>函数哪行发生，但无法知道错误从<code>readFile</code>中的哪行返回过来的</li></ol><blockquote><p>其中第一个破坏性的问题，其实就是破坏了error这个interface背后的具体实现，违背了面向对象的继承原则。</p></blockquote><h2 id="Handle-Errors-Only-Once"><a href="#Handle-Errors-Only-Once" class="headerlink" title="Handle Errors Only Once"></a>Handle Errors Only Once</h2><p>在工程中，为了解决 <strong>排查问题效率低</strong> 这个问题，有一个很常见的做法（以上面的readFile为例）:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(fileName <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">b, err := ioutil.ReadFile(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;read file %s error %v&quot;</span>, fileName, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;read file %s error %v&quot;</span>, fileName, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，就是 <strong>打印错误并返回</strong>。有大量排查问题经验的同学，对此肯定是深恶痛绝： <strong>一个错误能找到N处打印，看得人眼花缭乱</strong>。</p><p>这里违背了一个关键性的原则：<strong>对错误只进行一次处理，处理完之后就不要再往上抛了，而打印错误也是一种处理。</strong></p><p>结合三种具体的场景，我们分析一下：</p><ol><li>一个程序模块内，<code>error</code>不断往上抛，最上层处理；</li><li>一个公共的工具包中，<code>error</code>不记录，传给调用方处理；</li><li>一个RPC模块的调用中，<code>error</code>可以记录，作为<code>debug</code>信息，而具体的处理仍应交给调用方。</li></ol><p>示例参考文章</p><ul><li><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a></li><li><a href="https://www.orsolabs.com/post/go-errors-and-logs/">https://www.orsolabs.com/post/go-errors-and-logs/</a></li></ul><h2 id="理论实现"><a href="#理论实现" class="headerlink" title="理论实现"></a>理论实现</h2><p>那么，怎么样的<code>error</code>才是合适的呢？我们分两个角度来看这个<code>error</code>：</p><ol><li>对程序来说，<code>error</code>要包含<strong>错误细节</strong>：如错误类型、错误码等，方便在模块间传递；</li><li>对人来说，<code>error</code>要包含<strong>代码信息</strong>：如相关的调用参数、运行信息，方便查问题；</li></ol><p>用原文一句话来归纳：<strong>hide implementation details from programs while displaying them for diagnosis</strong></p><ul><li>Wrap - 隐藏实现，针对代码调用时的堆栈信息</li><li>Is/As - 展示细节，针对底层真正实现的数据结构</li></ul><h2 id="当前实现"><a href="#当前实现" class="headerlink" title="当前实现"></a>当前实现</h2><p><code>Go</code>语言发展多年，已经有了很多关于<code>error</code>的处理方法，但大多为过渡方案，我就不一一分析了。</p><p>这里我以 github.com/pkg/errors 为例，也是这个<strong>官方Proposal</strong>的重点参考对象，简单地分享一下大致实现思路。</p><p>代码量并不多，大家可以自行阅读源码：</p><h3 id="New-产生错误的堆栈信息"><a href="#New-产生错误的堆栈信息" class="headerlink" title="New 产生错误的堆栈信息"></a>New 产生错误的堆栈信息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(message <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;fundamental&#123;</span><br><span class="line">msg:   message,</span><br><span class="line">stack: callers(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fundamental <span class="keyword">struct</span> &#123;</span><br><span class="line">msg <span class="keyword">string</span></span><br><span class="line">*stack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong> stack保存了错误产生的堆栈信息，如函数名、代码行</p><h3 id="Wrap-包装错误"><a href="#Wrap-包装错误" class="headerlink" title="Wrap 包装错误"></a>Wrap 包装错误</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Wrap</span><span class="params">(err error, message <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">err = &amp;withMessage&#123;</span><br><span class="line">cause: err,</span><br><span class="line">msg:   message,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;withStack&#123;</span><br><span class="line">err,</span><br><span class="line">callers(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong> 将错误包装出一个全新的堆栈。一般只用于对外接口产生错误时，包括标准库、RPC。</p><h3 id="WithMessage-添加普通信息"><a href="#WithMessage-添加普通信息" class="headerlink" title="WithMessage 添加普通信息"></a>WithMessage 添加普通信息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithMessage</span><span class="params">(err error, message <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;withMessage&#123;</span><br><span class="line">cause: err,</span><br><span class="line">msg:   message,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong> 添加错误信息，增加一个普通的堆栈打印</p><h3 id="Is-解析Sentinel错误、即全局错误变量"><a href="#Is-解析Sentinel错误、即全局错误变量" class="headerlink" title="Is 解析Sentinel错误、即全局错误变量"></a>Is 解析Sentinel错误、即全局错误变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target error)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> stderrors.Is(err, target) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err == target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isComparable := reflectlite.TypeOf(target).Comparable()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> isComparable &amp;&amp; err == target &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; Is(error) <span class="keyword">bool</span> &#125;); ok &amp;&amp; x.Is(target) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> consider supporing target.Is(err). This would allow</span></span><br><span class="line"><span class="comment">// user-definable predicates, but also may allow for coping with sloppy</span></span><br><span class="line"><span class="comment">// APIs, thereby making it easier to get away with them.</span></span><br><span class="line"><span class="keyword">if</span> err = Unwrap(err); err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong> 反复Unwrap、提取错误，解析并对比错误类型</p><h2 id="As-提取出具体的错误数据结构"><a href="#As-提取出具体的错误数据结构" class="headerlink" title="As - 提取出具体的错误数据结构"></a>As - 提取出具体的错误数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">As</span><span class="params">(err error, target <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> stderrors.As(err, target) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">As</span><span class="params">(err error, target <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;errors: target cannot be nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">val := reflectlite.ValueOf(target)</span><br><span class="line">typ := val.Type()</span><br><span class="line"><span class="keyword">if</span> typ.Kind() != reflectlite.Ptr || val.IsNil() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;errors: target must be a non-nil pointer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> e := typ.Elem(); e.Kind() != reflectlite.Interface &amp;&amp; !e.Implements(errorType) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;errors: *target must be interface or implement error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">targetType := typ.Elem()</span><br><span class="line"><span class="keyword">for</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> reflectlite.TypeOf(err).AssignableTo(targetType) &#123;</span><br><span class="line">val.Elem().Set(reflectlite.ValueOf(err))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; As(<span class="keyword">interface</span>&#123;&#125;) <span class="keyword">bool</span> &#125;); ok &amp;&amp; x.As(target) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">err = Unwrap(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong> 反复Unwrap、提取错误，提取底层的实现类型</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Go</code>语言对<code>error</code>的定义很简单，虽然带来了灵活性，但也导致处理方式泛滥，一如当年的<strong>Go语言的版本管理</strong>。如今的<strong>go mod</strong>版本管理机制已经”一统江湖“，随着大家对<code>error</code>这块的不断深入，<code>Error Handling</code>也总会达成共识。</p><p>接下来，我会结合实际代码样例，写一个具体工程中 <strong>Error Handling</strong> 的操作方法，提供一定的参考。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;从Go-2-Error-Proposal谈起&quot;&gt;&lt;a href=&quot;#从Go-2-Error-Pr
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习路线 - 4.入门篇:快速体系化地入门Go语言</title>
    <link href="http://example.com/2021/04/17/go-study/go-study-4/"/>
    <id>http://example.com/2021/04/17/go-study/go-study-4/</id>
    <published>2021-04-17T04:00:00.000Z</published>
    <updated>2021-04-19T03:36:19.944Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p><h2 id="从一本书入门Go语言"><a href="#从一本书入门Go语言" class="headerlink" title="从一本书入门Go语言"></a>从一本书入门Go语言</h2><p>如今互联网资料泛滥，入门编程语言的途径有很多种选择，但如果要我推荐，只有一个建议 - <strong>研读一本该编程语言最优秀的基础书籍</strong>。 </p><p>对于Go语言，我推荐 《Go程序设计语言》(The Go Programming Language)，也被称为 <strong>Go语言圣经</strong>。参考链接:<a href="http://product.dangdang.com/25072202.html">当当链接</a> 和 <a href="https://docs.hacknode.org/gopl-zh/">网页版链接</a>。</p><blockquote><p>我认为，尽量避免只通过网上的博客或视频去学习基础。</p><p><strong>体系化</strong> 是建立知识体系最重要的一点。网上的资料最缺乏的就是 <strong>体系化</strong>，而经典书籍都经过了反复的精雕细琢。</p></blockquote><p>虽然这本书很经典，但在新手在学习的过程中还是会遇到三个经典的疑问：</p><ul><li>这本书出版已经有4年多，是否有些知识点已经 <strong>过时</strong>？</li><li>书籍中的知识点有深有浅，新手只想快速入门，该如何 <strong>权衡知识点</strong>？</li><li>书中的知识点虽然是体系化的，但新手很难 <strong>串联</strong> 起来。</li></ul><p>所以，本章的核心是为了解决上面三个问题的，也可以认为是我对于 <strong>Go语言圣经的导读</strong>。</p><blockquote><p>基础因人而异，根据自己的实际情况适当提高或降低预期。</p></blockquote><h2 id="1-了解背景"><a href="#1-了解背景" class="headerlink" title="1. 了解背景"></a>1. 了解背景</h2><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><ul><li><p>出版者的话、译者序、前言</p></li><li><p>第1章 入门 （不需要对着示例敲代码）</p></li></ul><h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>每门编程语言都有自己的背景和思想，了解这块对新手来说很有必要。如果上来就直接看一些基础语法，就会感觉是在 <strong>拼凑知识点</strong>。</p><p>所以，好好读一读这部分内容，<strong>建立自己在整体上对Go语言的认识</strong> 。</p><h2 id="2-基础语法点"><a href="#2-基础语法点" class="headerlink" title="2. 基础语法点"></a>2. 基础语法点</h2><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><ul><li>第2章 程序结构 （难点：指针、引用）</li><li>第3章 基本数据 （难点：字符串的编码UTF-8相关知识）</li><li>第4章 复合数据类型</li><li>第5章 函数（跳过：函数变量、匿名函数）</li></ul><h3 id="导读-1"><a href="#导读-1" class="headerlink" title="导读"></a>导读</h3><p>这块内容是最基础的，需要对着具体例子敲代码、并跑通。</p><p>上面指出的难点，如果不能快速掌握就跳过，<strong>入门学习没必要扣每个细节</strong> 。</p><p>至此，你已经掌握了最常见的Go语言用法了。</p><h2 id="3-面向对象编程"><a href="#3-面向对象编程" class="headerlink" title="3.面向对象编程"></a>3.面向对象编程</h2><h3 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h3><ul><li>第6章 方法</li><li>第7章 接口</li></ul><h3 id="导读-2"><a href="#导读-2" class="headerlink" title="导读"></a>导读</h3><p>这部分的语法并不难，关键点在于慢慢接触 <strong>学习面向对象编程的理念</strong>。</p><p><strong>面向对象</strong> 是一个博大精深的话题，这点需要长期的实践与体验，不用急于一时。</p><blockquote><p>如果对 <strong>面向对象</strong> 这个名词不熟悉的，先去搜搜科普贴，再回头理解这2章的内容。</p><p>建议Go语言入门后，跳出具体编程语言的视角，好好地理解一下面向对象的思想。</p></blockquote><h2 id="4-并发编程"><a href="#4-并发编程" class="headerlink" title="4. 并发编程"></a>4. 并发编程</h2><h2 id="范围-3"><a href="#范围-3" class="headerlink" title="范围"></a>范围</h2><ul><li>第8章 goroutine和通道</li><li>第9章 使用共享变量实现并发</li></ul><h3 id="导读-3"><a href="#导读-3" class="headerlink" title="导读"></a>导读</h3><p>并发编程一直都是各编程语言的一大难点，而Go语言将其语法设计得非常简洁，相对更容易学习。</p><p>学习并发这块，不仅仅需要大家去 <strong>扣每行代码的逻辑</strong> ，更要了解 <strong>这些并发语法是为了解决什么问题</strong>。</p><blockquote><p>纯编程新手对并发编程的理解需要一个过程，如果不能快速掌握也不用心浮气躁。</p><p>要真正地了解并发，那就得学习操作系统的相关知识。</p></blockquote><h2 id="5-函数式编程"><a href="#5-函数式编程" class="headerlink" title="5. 函数式编程"></a>5. 函数式编程</h2><h3 id="范围-4"><a href="#范围-4" class="headerlink" title="范围"></a>范围</h3><ul><li>第5章 函数（函数变量、匿名函数）</li></ul><h3 id="导读-4"><a href="#导读-4" class="headerlink" title="导读"></a>导读</h3><p>Go语言支持一定的函数式编程能力。函数式编程是对<strong>传统过程性编码思维的一种突破</strong>，新手了解基本使用方法即可。</p><p>匿名函数这块的玩法很有意思，也是面试的高频考点。</p><h2 id="6-Go语言的工程化"><a href="#6-Go语言的工程化" class="headerlink" title="6. Go语言的工程化"></a>6. Go语言的工程化</h2><h3 id="范围-5"><a href="#范围-5" class="headerlink" title="范围"></a>范围</h3><ul><li>第10章 包和go工具（简单通读里面的一些思想即可，最新的包管理已经完全采用<code>go mod</code>）</li><li>第11章 测试</li></ul><h3 id="导读-5"><a href="#导读-5" class="headerlink" title="导读"></a>导读</h3><p>Go的包管理工具几经波折，目前已经由<code>go mod</code>一统江湖了。<code>go mod</code>的资料可以参考 <a href="https://blog.golang.org/using-go-modules">官方博客</a>。但由于国内下载部分库有限制，可以参考搜索引擎进行配置。</p><p>而对于测试部分，我个人觉得 <em>官方提供的原始功能并不好用</em>，初学者写几个示例了解即可，后续在大型项目中还是需要一定的工具辅助。</p><h2 id="7-底层知识"><a href="#7-底层知识" class="headerlink" title="7. 底层知识"></a>7. 底层知识</h2><h3 id="范围-6"><a href="#范围-6" class="headerlink" title="范围"></a>范围</h3><ul><li>第12章 反射</li><li>第13章 低级编程（cgo直接忽略）</li></ul><h3 id="导读-6"><a href="#导读-6" class="headerlink" title="导读"></a>导读</h3><p>入门的新手<strong>浏览一遍即可，无需深入思考</strong>。大家需要了解的就是2点：</p><ol><li><strong>反射reflect</strong> 是将 <strong>数据和程序结构</strong> 互相转换的工具</li><li><strong>unsafe</strong> 是直接操作 <strong>计算机地址</strong> 的工具</li></ol><p>在实践中遇到具体问题时，再去针对性地学习。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>总体来看，入门Go语言的关键放在 2、3、4 三点即可，也就是 第2~9章，多敲代码、反复品读。</p><p>为了让大家更好地阅读书籍，我再补充三个建议：</p><ol><li><strong>结合上下文理解难点</strong> - 每个知识点都不是独立的，一定要了解上下文，切忌上来就敲代码；</li><li><strong>用文字背后的思想组织成体系化</strong> - 串联知识点的，并不是具体代码，而是相关的文字说明，多多琢磨背后的思想；</li><li><strong>对复杂知识点，暂时降低预期，做长期建设</strong> - 像面向对象、并发编程、函数式编程等 高阶内容，不可能只通过学习Go语言就能掌握；</li></ol><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;从一本书入门Go语言&quot;&gt;&lt;a href=&quot;#从一本书入门Go语言&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习路线 - 3.准备篇:打造个人专属的学习环境</title>
    <link href="http://example.com/2021/04/05/go-study/go-study-3/"/>
    <id>http://example.com/2021/04/05/go-study/go-study-3/</id>
    <published>2021-04-05T04:00:00.000Z</published>
    <updated>2021-04-19T03:36:19.943Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p><h2 id="为何我们需要持续学习"><a href="#为何我们需要持续学习" class="headerlink" title="为何我们需要持续学习"></a>为何我们需要持续学习</h2><p><strong>终身成长</strong> 一词已被广泛认可，意味着我们将比前人花费更多的时间在 <strong>学习成长</strong> 中，才能将个人的认知跟上社会的步伐。且不论是否应该放慢脚步，但我们大部分人不得不跟随社会的节奏，<strong>持续学习并提高自己</strong>。</p><p>相信有不少朋友跟我一样，在学习的过程中经常会 <strong>半途而废</strong>。那么我在这里分享一些方法和技巧（包括但不仅限于Go语言），希望能给大家带来一些启发。</p><p>这部分内容依旧会带有一些强烈的个人主观色彩，大家按需选用~</p><h2 id="心理建设"><a href="#心理建设" class="headerlink" title="心理建设"></a>心理建设</h2><p>在正式开始聊工具和方法前，我先聊聊自己学习前的心理建设。这一点看过去 <strong>很“软”</strong> ，但我吃过很多次亏：</p><p><strong>与其在学习的过程中，给自己找100个理由放弃，还不如在一开始就否定这些理由。</strong> </p><p>以Go语言为例，常见的放弃理由如下：</p><ul><li>Go真的能长期“火”下去吗？</li><li>Go的就业面不广，是否另选其它编程语言</li><li>学了基础的Go语法后，没有实践的机会</li><li>一段时间提升很不明显，感觉什么都懂、但什么都不精通</li></ul><p>我就是抱着这样的想法，走走停停，错过了很多快速提升的时期；不过也是由于这段经历，让我对许多朋友的想法有切身体会。今天我不会对着上面的问题一一回复，只强调一个重点：</p><p><strong>学技术带着功利心（跳槽、升职）是正常且必要的，毕竟只有解决问题的技术才是有价值的。Go语言是非常依赖“云原生”这一体系的：它实现了云原生的基石-Kubernetes及其余组件，也依赖云原生、提供了非常优雅的微服务解决方案。如今公有云和私有云的建设如火如荼，注定是一个不可逆的过程，所以Go语言是一个需求很大的方向。</strong></p><h2 id="学习环境的准备"><a href="#学习环境的准备" class="headerlink" title="学习环境的准备"></a>学习环境的准备</h2><p>下面，正式进入准备的细节：</p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>尽管Go语言支持跨操作系统，但我还是强烈建议大家使用Mac OS，关键在于 <strong>提效</strong>。</p><blockquote><p> 既然可以花7分力气做一件事，为什么需要10分呢？</p></blockquote><p>不排除后期Windows系统越来越完善，但目前来看，所有的大厂提供给开发者都是Macbook，这点就不言而喻了吧。如果你有在windows/Linux环境上高效开发的经验，欢迎与大家分享~</p><h3 id="Go语言版本"><a href="#Go语言版本" class="headerlink" title="Go语言版本"></a>Go语言版本</h3><p>在<a href="https://golang.google.cn/dl/">官网</a>任意挑选。</p><p>如果公司没有要求，那就直接上最新的版本吧~</p><blockquote><p>如果公司还在用1.13之前的版本，可以尝试着跟领导沟通，升级到较新的版本。</p><p>使用低版本会不断发现不兼容某些开源库的情况，比如有些依赖库引入了context的特性</p></blockquote><h3 id="代码编辑器"><a href="#代码编辑器" class="headerlink" title="代码编辑器"></a>代码编辑器</h3><p>强烈建议准备 VSCode + Goland ！对，不用二选一，而是两个都要！</p><ul><li><p>VSCode对各类语言、组件兼容都很好，面对<strong>轻量级</strong>的开发时完全可以胜任</p></li><li><p>Goland在面对<strong>重量级</strong>项目时效果很棒，尤其是对重构项目时，效率能提升一大截</p></li></ul><p>这里提供两个官网： <a href="https://code.visualstudio.com/">VSCode</a> / <a href="https://www.jetbrains.com/go/">Goland</a></p><blockquote><p>这两款软件的配置，前期尽量用默认的即可。</p><p>而如果有大量私人化的配置，记得将整个配置方案导出并保存。</p></blockquote><h3 id="其余提效工具"><a href="#其余提效工具" class="headerlink" title="其余提效工具"></a>其余提效工具</h3><ul><li><a href="https://git-scm.com/">git</a> 不要把git单纯地当作公司的版本管理工具，它更是你私人代码的管理工具</li><li><a href="https://segmentfault.com/a/1190000014992947">iTerm2 + Oh My Zsh</a> 这是在Mac下我非常喜欢的一套终端配置方案，大家可以借鉴</li><li>笔记类：这块大家按自己的习惯选用，常见的如 印象笔记、Microsoft TODO、typora、幕布、系统自带的笔记本等</li><li>上网助手：技术渠道有不少是在国外的网站上，不清楚具体访问方法的话，可以多和周围的开发者交流</li></ul><blockquote><p>欢迎大家留言谈谈自己最喜爱的工具，分享给我~</p></blockquote><h2 id="Markdown技术写作"><a href="#Markdown技术写作" class="headerlink" title="Markdown技术写作"></a>Markdown技术写作</h2><p>作为一个技术工作者，文档是一个必备技能。我们不应把写文档当作一个负担，大部分的时候它是一种沟通与协作上的提效工具。</p><p>这里不得不提一下Markdown，它的语法简单，产出的文档样式也满足基本的场景。大家可以根据<a href="https://www.markdown.xyz/basic-syntax/">这个链接</a>或者自行搜索教程。</p><blockquote><p>学习Markdown就是一个很小且价值很高的技术点，可以拿这个作为练手，先使用起来。</p><p>补充一句：Markdown在社区中的支持度不同，但基本大同小异。为了兼容性，少用html的相关特性。</p></blockquote><p>Markdown尽管简单，也有很多语法点，建议大家分阶段使用：</p><ol><li>标题、粗体、代码、链接、列表</li><li>图片、引用、分隔线、表格</li><li>其它</li></ol><p>第一阶段的5种语法已经可以满足日常的文档协作，第二阶段的特性可以让文档更具专业性，而其余特性完全可以在使用到时再去查询。</p><p><strong>切忌一次性想掌握全部，分阶段使用才是最有效的学习路径。</strong></p><p>这里推荐一个我常用的本地Markdown文档写作工具 - <a href="https://typora.io/">typora</a> 。尽管有Web文档工具支持在线编辑，但我更喜欢本地编辑后再复制过去，这样也方便留档。</p><h2 id="个人博客系统"><a href="#个人博客系统" class="headerlink" title="个人博客系统"></a>个人博客系统</h2><h3 id="为什么要玩博客"><a href="#为什么要玩博客" class="headerlink" title="为什么要玩博客"></a>为什么要玩博客</h3><ol><li><strong>根本价值</strong> - 作为个人的知识输出，沉淀到文档</li><li><strong>附带价值</strong> - 面试前后，让心仪的公司更好地了解你</li><li><strong>持续价值</strong> - 形成 <strong>正反馈</strong>，持续激励自我</li></ol><blockquote><p>有些人玩博客会将价值颠倒，比如将面试筹码作为根本价值，那么这个技术博客就会明显变味。</p></blockquote><h3 id="搭建教程"><a href="#搭建教程" class="headerlink" title="搭建教程"></a>搭建教程</h3><p>搭建博客系统的方法有很多，我这边推荐一个 <a href="https://segmentfault.com/a/1190000017986794">hexo + github pages</a> 的。</p><p>这种博客的优点在于2点：</p><ol><li>发布非常方便、非常方便、非常方便！</li><li>原始文档为Markdown，可在本地编辑、存档</li></ol><h3 id="写博客的Tips"><a href="#写博客的Tips" class="headerlink" title="写博客的Tips"></a>写博客的Tips</h3><ol><li><strong>降低“成本”</strong> - 让一篇博客从创作到发布变得简单，这点比较依赖博客系统，例如上面的 hexo+github pages</li><li><strong>分享作品</strong> - 分享个人的文章，有利于形成“正反馈”；对于比较腼腆的朋友，可以在小规模的圈子中先进行尝试</li><li><strong>多元化</strong> - 博客不仅仅停留在技术上，工作上的心得或者生活上的感悟，都可以写进来</li><li><strong>适当拆分</strong> - 不要过分追求长篇大作或者系列形式的文章，<em>小步快走</em> 在这里也适用</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>打造个人专属的学习环境，我认为主要包括三块：</p><ol><li>个人心态 - 坚持</li><li>开发环境 - 快速便捷</li><li>正反馈路线 - 文档博客</li></ol><p>当然，你可以根据实际情况，添加一些个人专属的内容：</p><ul><li>如果你是windows用户，你需要搞一套虚拟机</li><li>如果你已有一套成熟的文档系统，那就继续使用</li><li>如果你想快速地了解Go而不计划深入，那么没必要过于完善学习环境</li></ul><p>希望大家在 <strong>心理</strong> 和 <strong>环境</strong> 都做好充分的准备后，再去走这条长期的技术学习路线，并能坚持下来。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;为何我们需要持续学习&quot;&gt;&lt;a href=&quot;#为何我们需要持续学习&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习路线 - 2.方向篇:如何成为一名优秀的Go语言工程师</title>
    <link href="http://example.com/2021/03/28/go-study/go-study-2/"/>
    <id>http://example.com/2021/03/28/go-study/go-study-2/</id>
    <published>2021-03-28T04:00:00.000Z</published>
    <updated>2021-03-29T12:51:46.961Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p><h2 id="核心成长方向"><a href="#核心成长方向" class="headerlink" title="核心成长方向"></a>核心成长方向</h2><p>如何成为一名优秀的Go语言工程师，这是很多人都长期疑惑的问题。</p><p>我这边抛出自己的观点，希望能引起大家的思考：</p><p><strong>掌握基础，熟悉生态，集百家长，深耕领域</strong></p><p>接下来，我将围绕这四个词展开今天的分享。</p><h2 id="1-掌握基础"><a href="#1-掌握基础" class="headerlink" title="1. 掌握基础"></a>1. 掌握基础</h2><p>首先，我们来聊聊这个老生常谈的话题 - <strong>掌握基础</strong>。关于基础的学习路线我会在后面细讲，今天我们先来谈点别的。</p><p><strong>所谓基础，会根据工作的不同阶段而不断变化。</strong> 也就是要用 <strong>发展</strong> 的眼光来看问题。</p><p>举个例子，就以 <strong>编程语言</strong> 的作为切入点：</p><ul><li>一名合格的业务开发者，会熟练地应用<strong>编程语言</strong>去实现功能需求，熟练掌握常见的<strong>开源工具库</strong>；</li><li>进一步，如果作为一名模块的负责人，那就需要考虑<strong>设计模式</strong>来抽象复杂业务，熟悉编程语言底层的<strong>运行原理</strong>；</li><li>再进一步，作为一名架构师，就得思考如何用 <strong>工程化</strong> 来控制复杂度和约束规范性；</li><li>而如果是更高一层的角色，如CTO，就需要从编程语言或框架的 <strong>成熟度、前瞻性</strong> 的角度来决定路线。</li></ul><h2 id="2-熟悉生态"><a href="#2-熟悉生态" class="headerlink" title="2. 熟悉生态"></a>2. 熟悉生态</h2><p><strong>生态</strong> 这个词很微妙，社区里有不同的见解，我也无法抛出一个准确的定义，这块需要大家自行摸索。不过，我倒是可以分享几个踩坑经历：</p><ol><li><strong>语言生态</strong> ：编程语言都是有对应的应用领域的，我在上一讲已经说过，这里不再细谈；</li><li><strong>框架生态</strong> ：编程语言往往提供多种框架，不同框架的设计理念和使用场景不同，甚至会有一定的矛盾。例如有的框架提供了重量级的解决方案，可以快速生成一套代码，但对应的灵活性就大大降低；对应的，另一个框架能提供轻量级的插件化解决方案，需要你自行挑选、组装、调试，以提升复杂度的代价换来了灵活性；</li><li><strong>社区生态</strong> ：除了极少的探索性的工作，绝大部分的开发工作都能在社区中找到同路人，经常能发现很有价值的建议。但社区里的声音很杂，筛选信息是最大障碍，这一点很容易反复踩坑。</li></ol><blockquote><p>比起一些告诉你 <strong>该怎么做</strong> 的建议，我更倾向于那些 <strong>不该怎么做</strong> 的建议。</p><p>一次成功往往有大量的偶然因素，而从失败中分析出原因更有长期价值。</p></blockquote><h2 id="3-集百家长"><a href="#3-集百家长" class="headerlink" title="3.集百家长"></a>3.集百家长</h2><p>接下来的这点，是本章的重点，希望大家看完之后能重点思考。</p><p><strong>Go</strong> 语言是一个以简单著称的编程语言，又被号称是 <strong>云时代的编程语言</strong>。这背后蕴含了两层含义。</p><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><p>第一点，也就是 <strong>简单</strong> 带来的副作用。一种编程语言如果被冠以 <strong>简单</strong> 的头衔，那么它的设计核心就是 <strong>可读性</strong>。</p><p>但是，无论是模板、元编程、泛型这些语法上的高端特性，还是继承、多态、函数式等编程范式上的特性，虽然很复杂（或者说是学习曲线很陡峭），但不得不承认它们在特定的场景中，达到了很好的抽象效果，大幅度地提升了程序的效率。</p><p>所以，<strong>Go</strong> 语言决定了在单个程序中支持的复杂度有限，进一步则需要 <strong>JAVA、C++为代表的工业级编程语言</strong> 的一些特性。</p><h3 id="云时代的编程语言"><a href="#云时代的编程语言" class="headerlink" title="云时代的编程语言"></a>云时代的编程语言</h3><p>从上一点来看，<strong>Go</strong> 语言支持的单个程序复杂度有限，那就非常依赖 <strong>微服务</strong> 的核心理念 - 拆。通过拆解，可以将单个程序的复杂度转移到架构层面，也更好地契合了<strong>服务内聚</strong>的理念。</p><p>但是，即便进行了很好的设计与拆分，<strong>微服务</strong> 依然有两个比较重要的前置要求：<strong>服务间通信</strong> 和 <strong>微服务治理</strong>。前者相对容易解决，统一采用 <strong>RESTful</strong> 风格或 <strong>gRPC</strong> 等框架进行通信，就能满足基本要求；而微服务的治理问题就非常复杂了，很长一段时间都没有一套成熟的解决方案。近几年，随着 <strong>Docker容器化</strong> + <strong>Kubernetes调度平台</strong> 的出现与推广，已经成为了 <strong>微服务的Best Practice</strong> 。</p><p>以 <strong>K8s为核心的云原生生态</strong>，涵盖了<strong>监控、日志采集、链路追踪、Service Mesh</strong>等各类子领域的解决方案，均得到了快速迭代。其中，各种核心组件均是通过 <strong>Go</strong> 语言开发而成，像 <strong>Kubernetes、Prometheus、Etcd</strong> 等。</p><p>至此，我们开发的服务不再需要过分关注基础组件，而是更聚焦于业务领域。</p><h3 id="CNCF"><a href="#CNCF" class="headerlink" title="CNCF"></a>CNCF</h3><p>再回到这一个话题的核心 - <strong>集百家长</strong>。</p><p>云原生的社区<strong>CNCF</strong>提供了大量的组件，大家可以通过<a href="https://landscape.cncf.io/images/landscape.png">这个链接</a>看到对应的全景图。它提供了是一整套<strong>插件化</strong>的组合方案，需要开发人员按需组合（后面我也会给出一些建议）。</p><p>我非常不建议大家去自己从头开发一个模块，主要有两点（巨型互联网的基础团队除外）：</p><ol><li>自建轮子跟不上社区迭代，投入产出比价值低；</li><li>很多时候某些功能已经在某个组件中实现，或者正在实现，只是没正确使用。</li></ol><blockquote><p>如果真要新增某个重要功能，优先去找个现有CNCF项目的负责人聊聊，提交PR合入，或者自行fork开发。</p><p>相信我，在一个成熟产品中新增特性，比你重写一个轮子更有价值！无论是对技术的提升、还是投递简历时的效果，都更有意义。</p></blockquote><p>举一个场景，当我们发现需要在程序中用<code>map</code>保存大量结果时，用默认的数据结构效率很低：</p><ul><li>如果在<strong>JAVA</strong>生态里，那么内部就有丰富的容器库可供选择，放在一个服务中即可；</li><li>而在<strong>Go</strong>中，自然也可以借用<strong>github</strong>上面搜索的三方库来解决，但更建议根据场景选用开源的K-V组件，通过RPC调用来解决问题，也就是拆成了 <strong>业务功能</strong> 与 <strong>map数据存储</strong> 两个服务</li><li>专业的事交给专业的组件</li></ul><h2 id="4-深耕领域"><a href="#4-深耕领域" class="headerlink" title="4. 深耕领域"></a>4. 深耕领域</h2><p>在工作三年以上，我越来越感受到 <strong>领域</strong> 是一个很重要的概念，也是各公司考验高端人才的重要素质。</p><p>举几个例子：</p><ul><li><p>作为一名 <strong>电商支付领域</strong> 的开发专家，需要在编程语言的 <strong>如何保证数据一致性</strong> 的相关特性有深入研究；</p></li><li><p>如果是 <strong>物流订单领域</strong> 的专家，则要考虑 <strong>如何合理抽象各类物流类型</strong> 的问题，来支持复杂的场景；</p></li><li><p>当你负责的是一个 <strong>秒杀系统</strong>，那么需要对 <strong>高并发场景与异常兜底</strong> 有足够的经验。</p></li></ul><p>每一块 <strong>领域</strong> 都需要有大量的 <strong>专业技能</strong> 与 <strong>行业经验</strong> 沉淀，这是高端人才的核心竞争力。</p><p>虽说两者缺一不可，但还是具有一定的倾向性</p><ul><li>偏技术的领域更需要 <strong>专业技能</strong> ，瓶颈往往是某一个垂直领域的技术深度；</li><li>偏业务的领域更要求 <strong>行业经验</strong> ，要求负责人能 <strong>带领团队避开坑，走对路</strong> 。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾一下这四个点： <strong>掌握基础，熟悉生态，集百家长，深耕领域</strong> 。这一整个过程，也可以说是：<strong>修炼内功，学习并合理使用外部资源，沉淀于特定领域</strong> 。</p><p>纵观周围环境，我发现大部分的开发者都热衷于 <strong>修炼内功和领域沉淀</strong>，而过于轻视了 <strong>外部资源</strong> 的作用，就错失了一个快速提升个人能力的手段，技术视野也非常有限。这一块，将是我后续分享的重点，也是区别于其余教程的一大特点。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;核心成长方向&quot;&gt;&lt;a href=&quot;#核心成长方向&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 1.【惊艳亮相】如何写出一个优雅的main函数</title>
    <link href="http://example.com/2021/03/07/go-tip/go-tip-1/"/>
    <id>http://example.com/2021/03/07/go-tip/go-tip-1/</id>
    <published>2021-03-07T04:00:00.000Z</published>
    <updated>2021-05-08T09:31:04.082Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg" alt="Go-Study"></p><h2 id="一个简单的main函数"><a href="#一个简单的main函数" class="headerlink" title="一个简单的main函数"></a>一个简单的main函数</h2><p>我们先来看看一个最简单的<code>http服务端</code>的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的功能很简单：提供一个监听在<code>8080</code>端口的服务器，处理<code>URL</code>为<code>/hello</code>的请求，并打印出hello。</p><p>可以用一个简单的curl请求来打印结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/hello</span><br></pre></td></tr></table></figure><p>也可以用对应的<code>kill</code>杀死了对应的进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 &#123;pid&#125;</span><br></pre></td></tr></table></figure><p>但有一个问题：</p><p><strong>如果程序因为代码问题而意外退出（例如panic），无法和kill这种人为强制杀死的情况进行区分</strong></p><h2 id="引入signal"><a href="#引入signal" class="headerlink" title="引入signal"></a>引入signal</h2><p><code>kill</code>工具是<code>Linux</code>系统中，往进程发送一个信号。所以，我们的关键是去实现 <strong>捕获信号</strong> 的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个 sig 的 channel，捕获系统的信号，传递到sig中</span></span><br><span class="line">sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line"></span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello)</span><br><span class="line"><span class="comment">// http服务改造成异步</span></span><br><span class="line"><span class="keyword">go</span> http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, mux)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序阻塞在这里，除非收到了interrupt或者kill信号</span></span><br><span class="line">fmt.Println(&lt;-sig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们的主函数已经能区分正常的信号退出了。</p><h2 id="优雅退出的需求"><a href="#优雅退出的需求" class="headerlink" title="优雅退出的需求"></a>优雅退出的需求</h2><p>服务端程序经常会处理各种各样的逻辑，如操作数据库、读写文件、RPC调用等。根据其对 <strong>原子性</strong> 的要求，我将处理逻辑区分为两种：</p><ul><li>一种是<strong>无严格数据质量</strong>要求的，即程序直接崩溃也没有问题，比如一个普通查询；</li><li>另一种是有 <strong>原子性</strong> 要求的，即不希望运行到一半就退出，例如写文件、修改数据等，<strong>最好是程序提供一定的缓冲时间</strong>，等待这部分的逻辑处理完，优雅地退出。</li></ul><p>在复杂系统中，为了保证数据质量，<strong>优雅退出</strong> 是一个必要特性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟并发进行的处理业务逻辑</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 我们希望程序能等当前这个周期休眠完，再优雅退出</span></span><br><span class="line">time.Sleep(time.Duration(i) * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(&lt;-sig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是一个简单的示例，开启了10个<code>goroutine</code>并发处理，那么这时捕获信号后，这10个协程就立刻停止。而<strong>优雅退出</strong>，则是希望能执行完当前的<code>Sleep</code>再退出。</p><h2 id="一对一的解决方案"><a href="#一对一的解决方案" class="headerlink" title="一对一的解决方案"></a>一对一的解决方案</h2><p>我们先简化问题：主函数对应的是一个需要优雅关闭的协程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(&lt;-sig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体操作如下：</p><ul><li>父<code>goroutine</code>通知子<code>goroutine</code>准备优雅地关闭</li><li>子<code>goroutine</code>通知父<code>goroutine</code>已经关闭完成</li></ul><p>我们回忆下在<code>goroutine</code>传递消息的几个方案（排除共享的全局变量这种方式）。</p><h3 id="最直观的解决方案-2个channel"><a href="#最直观的解决方案-2个channel" class="headerlink" title="最直观的解决方案 - 2个channel"></a>最直观的解决方案 - 2个channel</h3><p>既然我们要在父子goroutine中传递消息，最直接的想法是启用2个 <code>channel</code> 用来通信，对应到代码：</p><ul><li><p>父<code>goroutine</code>通知子<code>goroutine</code>准备优雅地关闭，也就是<code>stopCh</code></p></li><li><p>子<code>goroutine</code>通知父<code>goroutine</code>已经关闭完成，也就是<code>finishedCh</code></p><p>具体代码实现如下</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">finishedCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(stopCh, finishedCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">fmt.Println(<span class="string">&quot;stopped&quot;</span>)</span><br><span class="line">finishedCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(stopCh, finishedCh)</span><br><span class="line"></span><br><span class="line">&lt;-sig</span><br><span class="line">stopCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&lt;-finishedCh</span><br><span class="line">fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="华丽的解决方案-channel嵌套channel"><a href="#华丽的解决方案-channel嵌套channel" class="headerlink" title="华丽的解决方案 - channel嵌套channel"></a>华丽的解决方案 - channel嵌套channel</h3><p>这个解决方案不太容易想到（看过Rob Pike的演讲视频除外，可在go官网看到）。</p><p>这个方案的核心结构为<code>chan chan</code>。</p><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(stopChh <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ch := &lt;-stopCh:</span><br><span class="line"><span class="comment">// 结束后，通过ch通知主goroutine</span></span><br><span class="line">fmt.Println(<span class="string">&quot;stopped&quot;</span>)</span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(stopCh)</span><br><span class="line"></span><br><span class="line">&lt;-sig</span><br><span class="line"><span class="comment">// ch作为一个channel，传递给子goroutine，待其结束后从中返回</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">stopCh &lt;- ch</span><br><span class="line">&lt;-ch</span><br><span class="line">fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个方案很酷，建议大家多思考思考，尤其是channel中传递的数据为error时，就能有更多信息了</p></blockquote><h3 id="标准解决方案-引入上下文context"><a href="#标准解决方案-引入上下文context" class="headerlink" title="标准解决方案 - 引入上下文context"></a>标准解决方案 - 引入上下文context</h3><p><code>go</code>语言里的上下文<code>context</code>不仅仅可以传递数值，也可以控制子<code>goroutine</code>的生命周期，很自然地有了如下解决方案。</p><p>实例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">finishedCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, finishedCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">// 结束后，通过ch通知主goroutine</span></span><br><span class="line">fmt.Println(<span class="string">&quot;stopped&quot;</span>)</span><br><span class="line">finishedCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(ctx, finishedCh)</span><br><span class="line"></span><br><span class="line">&lt;-sig</span><br><span class="line">cancel()</span><br><span class="line">&lt;-finishedCh</span><br><span class="line">fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有兴趣的朋友可以空闲时想一个问题：社区里有人认为context是一个很不好的实现：</p><p>context意思为上下文，最初的设计意为传递数值，也就是一个 <strong>数据流</strong> ；</p><p>而go中的context又延伸出了 控制goroutine生命周期的功能，也就成了 <strong>控制流</strong> 。</p><p>这么看下来，其实context就有 角色不清晰 的味道了。</p><p>但不可否认，context已经在go语言中大量被采用，这个问题可以作为大家自己设计模块时的参考。</p></blockquote><h2 id="一对多的解决方案"><a href="#一对多的解决方案" class="headerlink" title="一对多的解决方案"></a>一对多的解决方案</h2><p>一对多的解决方案可以复用 <strong>一对一解决方案</strong> 中的思想。我这边也给出另外一个 <code>context</code> + <code>sync.WaitGroup</code> 的解决方案。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL)</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">num := <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用wg来控制多个子goroutine的生命周期</span></span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">&quot;stopped&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">time.Sleep(time.Duration(i) * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-sig</span><br><span class="line">cancel()</span><br><span class="line"><span class="comment">// 等待所有的子goroutine都优雅退出</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家要注意一下，在追求 <strong>优雅退出</strong> 时要注意 <strong>控制细粒度</strong> 。</p><blockquote><p>比如一个<code>http</code>服务器，我们要控制整个<code>http server</code>的优雅退出。</p><p>千万不要去想着在主函数层面去控制每个<code>http handler</code>，也就是每个<code>http</code>请求的优雅退出，这样很难控制代码的复杂度。对于每个<code>http</code>请求的控制，应该交给<code>http server</code>这个框架去实现。</p><p>所以，在主函数中，其实需要优雅退出的选项其实很有限。</p></blockquote><h2 id="延伸思考"><a href="#延伸思考" class="headerlink" title="延伸思考"></a>延伸思考</h2><p>本次我们讲的是<code>main</code>函数控制其<code>goroutine</code>的优雅退出，其实我们延伸开来，就是 <strong>父Goroutine怎么保证子Goroutine优雅退出</strong> 这个问题。</p><p>虽然有解决方案，但我这是想泼一盆冷水，希望大家想想一个问题：<strong>既然这个子Goroutine是有价值的，不想轻易丢失，那么为什么不放到主Goroutine中呢？</strong> 其实，很多时候，我们都在 <strong>滥用Goroutine</strong> 。我希望大家更多地抛开语言特性，从整体思考以下三个问题：</p><ol><li><strong>明确调用链路</strong> - 梳理整个调用流程，区分关键和非关键的步骤，以及在对应步骤上发生错误时的处理方法</li><li><strong>用MQ解耦服务</strong> - 跨服务的调用如果比较费时，大部分时候更建议采用消息队列解耦</li><li><strong>面向错误编程</strong> - 关键业务的<code>Goroutine</code> 里代码要考虑所有可能发生错误的点，保证程序退出或<code>panic/recover</code>也不要出现 <strong>脏数据</strong>。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>main</code>函数是<code>go</code>程序的入口，如果在这里写出一段优雅的代码，很容易给阅读自己源码的朋友留下良好的印象。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一个简单的main函数&quot;&gt;&lt;a href=&quot;#一个简单的main函数&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习路线 - 1.方向篇:明确Go语言的成长方向</title>
    <link href="http://example.com/2021/03/05/go-study/go-study-1/"/>
    <id>http://example.com/2021/03/05/go-study/go-study-1/</id>
    <published>2021-03-05T03:27:15.000Z</published>
    <updated>2021-03-29T12:51:46.961Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p><h2 id="Go的就业方向"><a href="#Go的就业方向" class="headerlink" title="Go的就业方向"></a>Go的就业方向</h2><p>目前，后端开发语言的就业方向主要分为两块：<strong>业务系统开发</strong> 与 <strong>基础平台开发</strong> 。<code>Go</code>语言自然也不会例外。</p><p>也许有朋友不太了解这两块，那我简单地解释下：</p><p><strong>业务系统开发</strong> 主要指公司对外盈利的系统，包括 <code>toB</code> 与 <code>toC</code>。由于这个是公司安身立命的根本，所以开发者是必须跟着业务走的。</p><p><strong>基础平台开发</strong> 指的是公司为了提升工作效率（不仅仅是研发），搭建的一套内部体系，常常需要跨业务支持。</p><blockquote><p>目前主流的云平台，其实是包装成一套业务系统的基础平台，比如阿里云的ECS。</p><p>这类云平台是大型公司将自己的基础平台能力沉淀下来后，包装成一套业务系统对外销售，内部也是分成了两类开发人员：上层开发一些多语言接口、计费等业务系统；下层开发对应的基础平台。</p></blockquote><h2 id="Go语言的劣势"><a href="#Go语言的劣势" class="headerlink" title="Go语言的劣势"></a>Go语言的劣势</h2><p>很遗憾，我依然在这里不得不进行一些编程语言间的对比。毕竟，如果不清楚一些技术的优劣势，我们很难明确自己的定位和发展方向。</p><h3 id="并不是所有编程语言适合各个领域"><a href="#并不是所有编程语言适合各个领域" class="headerlink" title="并不是所有编程语言适合各个领域"></a>并不是所有编程语言适合各个领域</h3><p>我先简单地抛出几个例子：</p><ul><li>游戏、音视频领域主流是<code>C/C++</code></li><li>测试、人工智能的主流是<code>Python</code></li><li>大数据平台的主流是<code>Java</code></li><li>前端的主流是<code>JavaScript</code></li></ul><p>这里的说法并不是绝对的，但选对了语言，能大量地复用业界现有的资源，少走很多弯路。</p><h3 id="语言特点决定“轮子”不会太多"><a href="#语言特点决定“轮子”不会太多" class="headerlink" title="语言特点决定“轮子”不会太多"></a>语言特点决定“轮子”不会太多</h3><p><code>Go</code>的生命已有十年多，但新增的特性很少，主要是语言创建者的核心理念 - <strong>简洁</strong>。这个理念导致了现成可用的轮子少：以<code>map</code>容器来说，<code>Java</code>至少提供了数十种，可根据不同的场景选择不同的实现，达到性能极致化，而<code>Go</code>只提供了一种通用的基本数据结构。</p><blockquote><p>Go 的设计哲学可以类比为 Unix </p></blockquote><p>那么，我们是否可以采用开源社区中<code>Go</code>的现成库呢？当然可以！那我们来继续拿<code>Java</code>中的容器对比一下，看看改造的成本：</p><ul><li>在<code>Java</code>中，容器是一个对象类型，已定义对应的接口<code>interface</code><ul><li>新的容器类实现对应的接口</li><li>改造成本：在创建容器的地方(如<code>beans</code>)替换即可</li></ul></li><li>而<code>Go</code>里的容器是基本类型，它的操作是定义在基本语法中，并没有抽象出接口<code>interface</code><ul><li>改造成本：新的容器实现后，所有的增删改查代码都需要修改</li></ul></li><li>在复杂的嵌套数据结构中，<code>Go</code>的改造成本更大</li></ul><blockquote><p>我们自然可以在自己的项目中，对map/slice操作先封装成一个方法，这样后续改造成本也很低了，但这种思想就很偏向于Java体系了：</p><ol><li>Go 崇尚的是简洁，map/slice能满足99%以上的使用场景</li><li>无法在语言层面将 map/slice 封装成方法，就不能发展成一个语言层面的通用标准，很难推广</li></ol></blockquote><h3 id="没有一套成熟的复杂系统开发方法论"><a href="#没有一套成熟的复杂系统开发方法论" class="headerlink" title="没有一套成熟的复杂系统开发方法论"></a>没有一套成熟的复杂系统开发方法论</h3><p>细心的读者可以注意到我这边用到的两个关键词：<strong>成熟</strong> 和 <strong>复杂系统</strong> 。用 <code>Go</code> 语言开发的系统自然有不少，但我认为至今为止，业界还没有一套非常适配 <code>Go</code> 语言的系统开发方法论，包括大厂们也是在摸索的过程中（或者说没有公开）。</p><p>这里，我列举四个我比较关注的点：</p><ol><li>引入<code>DDD</code>设计思想拆分微服务后，如何保证实践与设计一致</li><li>如何借用 <strong>面向对象UML设计图</strong> 类似的实践，梳理复杂系统内的关系</li><li>如何组织代码的仓库、目录与分层，适配业务场景</li><li>一整套覆盖开发各模块的工具集和最佳实践：如监控埋点、日志链路追踪、测试套件</li></ol><blockquote><p>以上四点业界都有一定的实践，但没有如Spring那般形成一个生态圈，达到一致。</p><p>如果达不到一致认可，就无法用工具去强制约束，那么软件工程的复杂度就无法控制了。</p></blockquote><h2 id="明确Go语言的核心成长方向"><a href="#明确Go语言的核心成长方向" class="headerlink" title="明确Go语言的核心成长方向"></a>明确Go语言的核心成长方向</h2><ol><li><strong>掌握计算机基础</strong> <code>Go</code> 官方包覆盖了操作系统、网络、数据库等各类常用操作，我们不能停留在 <strong>使用</strong> 上，而是通过代码去了解它们的 <strong>底层实现</strong> ，为后续遇上相关瓶颈时做好基础的知识储备。由于 <code>Go</code> 的源码简洁，所以阅读起来相对其它语言轻松不少。</li><li><strong>常用工具库的储备</strong> <code>Go</code> 在开源上存在一些 <strong>优秀的轮子</strong>，常常能达到事半功倍的效果。我建议分三步走： <strong>会用</strong> 、 <strong>用好</strong> 、<strong>体系化</strong> 。其中体系化是指要将这些库串联起来，根据场景选择，形成一整套灵活的解决方案。</li><li><strong>项目/工程化</strong> 将<code>Go</code>的项目与公司的整个研发流程、甚至是产品周期结合起来：小到如何保证一个需求的准确实现，大到如何保证研发架构的合理落地，都是比较有挑战的内容。</li></ol><blockquote><p>也许不少人会认为第三点是一个远超编程语言的话题，在这里讲意义不大。确实，项目工程化更多地是看团队结构、工作流程等上层机制的约束，编程语言能做的不多。</p><p>然而，目前<code>Java</code>编程语言已经产生了一个成熟的生态圈，从单纯的代码实现功能，慢慢影响到了开发的各个流程，这样就或多或少地具备了 <strong>项目工程化</strong> 的一些特征。其它的编程语言如果希望能支持复杂的开发场景，必须得有一套初步的系统化方法论（成熟度暂且不论），才有可能分得一杯羹。当然，由于不同编程语言背后的编程范式、设计理念不同，方法论也各具特色，很有可能随着时间推移而变化。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天跟大家聊的话题挺广的，也结合了很多我的个人感受，希望能给大家带来启发。下一篇，我会继续 <strong>方向篇</strong> 的话题，细化到具体工作上，和大家谈谈具体工作上的内容。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Go的就业方向&quot;&gt;&lt;a href=&quot;#Go的就业方向&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习路线 - 0.总览</title>
    <link href="http://example.com/2021/02/21/go-study/go-study-0/"/>
    <id>http://example.com/2021/02/21/go-study/go-study-0/</id>
    <published>2021-02-21T03:27:15.000Z</published>
    <updated>2021-03-29T12:51:46.961Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p><p>大家好，我是六月天天。从今天开始，我将开启一个新的系列 - <strong>Go语言学习路线</strong>。</p><blockquote><p>大家可以从 <a href="https://space.bilibili.com/293775192">bilibili</a> 的视频分享中看到观点的延伸思考</p></blockquote><h2 id="以成长为核心"><a href="#以成长为核心" class="headerlink" title="以成长为核心"></a>以成长为核心</h2><p>目前网上已有很多Go相关的教程，包括基础讲解、源码解析、面试技巧等，但我依然下决心来做一个具有强烈个人主观观点色彩的<strong>Go语言学习路线</strong>：这个系列的目标只有一个 - <strong>成长</strong> 。我不求这个系列超越其它的教程，而是能做到<strong>去芜存菁</strong> ，引发一批朋友的共鸣。</p><p>整个系列中，我会输出大量的主观观点，大家不一定能全盘接受，我也不希望大家全盘接受。我坚信，<strong>没有碰撞的技术观点无法引起大家的深度思考</strong> ，犹如上课时老师对你进行单方面的内容输出；同时，<strong>主观观点会更具现实色彩与实践意义</strong> ，我经历的公司和方向都很丰富，或多或少会和大家的实际工作产生共鸣。</p><h2 id="学习路线概览"><a href="#学习路线概览" class="headerlink" title="学习路线概览"></a>学习路线概览</h2><ol><li>方向篇 - 明确学习的 <strong>短期目标</strong> 和 <strong>长期目标</strong> ，以及我的一些主观建议</li><li>准备篇 - <strong>工欲善其事，必先利其器</strong> ，一套好的工具和方法，不仅能让你更高效地学习，更能让你 <strong>坚持下来</strong></li><li>入门篇 - <strong>基础语法</strong> 的学习思路，提纲挈领，但不会细化到语法的讲解</li><li>基础篇 - <strong>简单web项目</strong> 的实现思路，介绍 <strong>项目布局</strong>、<strong>模块职责</strong>、<strong>业务特点</strong></li><li>提效篇 - <strong>提升开发效率</strong> ，常见思路是采用一些优秀的 <strong>编程实践</strong>、<strong>开源库</strong>、<strong>研发工具</strong>等</li><li>进阶篇 - 抛开日常的CRUD，根据自己的目标，找到适合自己的 <strong>进阶路线</strong></li><li>高级篇 - 根据互联网上相关信息，结合我的个人经验，谈谈<strong>Go语言的后续发展</strong></li></ol><blockquote><p>可能部分朋友会看重 <strong>入门、基础这些偏实践的模块</strong> ，但我花了大量心血在 <strong>方向及进阶相关的内容</strong> 上：</p><ul><li>入门的方式各有不同，快的一个月，慢的半年，但最终达到的效果差不了多少</li><li>方向错误会严重影响到个人的长远发展，拘泥于自己的舒适圈，越到后期，沉没成本越高</li></ul></blockquote><h2 id="自我简介"><a href="#自我简介" class="headerlink" title="自我简介"></a>自我简介</h2><p>我简单地介绍一下自己重要的编程经历，让大家更好地了解我：</p><ul><li>4年<code>C++</code> / 4年<code>Go</code> 开发，<code>Python</code>/<code>Java</code>/<code>Js</code>等也都有中小平台的研发经验</li><li>曾在某中型公司（已上市，1000+人）的运维开发团队中作为技术负责人，搭建研发效能平台</li><li>目前在某一线大厂任职，参与商用业务平台的开发</li><li>用<code>Go</code>语言研发过公司内部的 <strong>私有云平台</strong> 和已商用的 <strong>业务平台</strong></li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>最后，我再谈一谈自己对 <strong>Go语言学习路线</strong> 这个系列的期许，也是我希望能区别于其它教程的点：</p><ul><li><strong>可落地</strong> - 不停留于泛泛而谈，实践的具体路线清晰</li><li><strong>正反馈</strong> - 持续激励自己，避免半途而废</li><li><strong>阶梯式</strong> - 层层递进，有明确的进步目标</li><li><strong>通用性</strong> - 可延伸至各种技术的学习，形成自己的学习方法</li><li><strong>及时性</strong> - 定期更新，保证学习路线的内容不过时</li></ul><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;p&gt;大家好，我是六月天天。从今天开始，我将开启一个新的系列 - &lt;strong&gt;Go语言学习路线&lt;/stron
      
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>gRPC源码分析(四)：剖析Proto序列化</title>
    <link href="http://example.com/2021/02/20/grpc/grpc-4/"/>
    <id>http://example.com/2021/02/20/grpc/grpc-4/</id>
    <published>2021-02-20T11:34:49.000Z</published>
    <updated>2021-03-29T12:51:46.963Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的分析中，我们已经知道了使用proto序列化的代码在<a href="https://github.com/grpc/grpc-go/tree/v1.29.x/encoding/proto">encoding目录</a>中，路径中只有三个文件，其中2个还是测试文件，看起来这次的工作量并不大。</p><p>首先，针对读源码是先看源代码还是测试代码，因人而异。个人建议在对源码毫无头绪时，先从测试入手，了解大致功能；如果有一定基础，那么也可以直接入手源代码。我认为优秀的Go源码可读性是非常高的，所以一般情况下，我都直接从源文件入手，遇到问题才会去对应的测试里阅读。</p><h2 id="Marshal"><a href="#Marshal" class="headerlink" title="Marshal"></a>Marshal</h2><p>Marshal的代码不多，关键在于传入参数的类型，有2个分支路线：</p><ol><li><a href="https://github.com/grpc/grpc-go/blob/v1.29.x/encoding/proto/proto.go#L68">proto.Marshaler类型</a>，实现了<code>Marshal() ([]byte, error)</code>方法</li><li><a href="https://github.com/grpc/grpc-go/blob/v1.29.x/encoding/proto/proto.go#L54">proto.Message类型</a>，实现了<code>Reset()</code>、<code>String() string</code> 和<code>ProtoMessage()</code>三个方法</li></ol><p>我们回头看看proto生成的<a href="https://github.com/grpc/grpc-go/blob/v1.29.x/examples/helloworld/helloworld/helloworld.pb.go#L35">go文件</a>，发现对应的是第二个接口。那我们接着看：</p><ol><li>调用了protoBufferPool，是一个sync.Pool，是为了加速proto对象的分配</li><li>内部采用的是 <code>marshalAppend</code>，字面来看就是 序列化并追加，对应了 <code> wire-format</code>这个概念，并不需要将整个结构加载完毕、再进行序列化</li><li>接下来调用的是<code>protoV2.MarshalOptions</code>，需要关注的是protoV2是另一个package，<code>protoV2 &quot;google.golang.org/protobuf/proto&quot;</code></li><li>在正式marshal前，调用<code>m.ProtoReflect()</code>方法，根据名字可以猜测是对Message做反射，详细内容不妨后面再看</li><li>最后就是正式的marshal了，分两个分支：<code>out, err = methods.Marshal(in)</code>和<code>out.Buf, err = o.marshalMessageSlow(b, m)</code>。后者是慢速的，一般情况下是不会用到，我们重点关注前者，这时就需要回头看4中的实现了</li><li>逐个往前搜索，<code>接口protoreflect.Message =&gt; </code> <code>接口Message</code> =&gt;<code>函数MessageV2</code>  =&gt; <code>函数ProtoMessageV2Of</code>  =&gt; <code>函数legacyWrapMessage</code> =&gt; <code>函数MessageOf</code> =&gt; <code>类型messageReflectWrapper</code>，终于，在这里找到了目标函数 <code>ProtoMethods</code></li><li>因为我们取的是<code>methods</code>，所以很快将代码定位到 <code>makeCoderMethods</code> =&gt; <code>marshal</code> =&gt; <code>marshalAppendPointer</code> ，最后找到一行核心代码 <code>b, err = f.funcs.marshal(b, fptr, f, opts)</code></li><li>那这个marshal什么时候被赋值的呢？在步骤7中，我们查看了methods被赋值的地方，其实旁边就有一个函数 <code>makeReflectFuncs</code> ，最后定位到了 <code>/google.golang.org/protobuf/internal/impl/codec_gen.go</code> 文件中。每种变量的序列化，都是按照特定规则来执行的。</li></ol><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>那么 protobuf 实际是如何对每种类型进行Encoding的呢？有兴趣的朋友可以点击<a href="https://developers.google.com/protocol-buffers/docs/encoding">这个链接</a>，阅读原文。这里，我直接拿出一个实例进行讲解。</p><h4 id="定义proto"><a href="#定义proto" class="headerlink" title="定义proto"></a>定义proto</h4><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"><span class="built_in">bool</span> male = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int32</span> age = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">string</span> address = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生成对应文件后，编写测试用例"><a href="#生成对应文件后，编写测试用例" class="headerlink" title="生成对应文件后，编写测试用例"></a>生成对应文件后，编写测试用例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">people := &amp;pbmsg.People&#123;</span><br><span class="line">Male:    <span class="literal">true</span>,</span><br><span class="line">Age:     <span class="number">80</span>,</span><br><span class="line">Address: <span class="string">&quot;China Town&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">b, _ := proto.Marshal(people)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行生成结果"><a href="#运行生成结果" class="headerlink" title="运行生成结果"></a>运行生成结果</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1000 1 10000 1010000 11010 1010 1000011 1101000 1101001 1101110 1100001 100000 1010100 1101111 1110111 1101110]</span><br></pre></td></tr></table></figure><h4 id="分析第一个字段Bool"><a href="#分析第一个字段Bool" class="headerlink" title="分析第一个字段Bool"></a>分析第一个字段Bool</h4><p>首先，Male是一个bool字段，序号为1。</p><p>根据Google上的文档，bool是Varint，所以计算</p><p>(field_number &lt;&lt; 3) | wire_type = (1&lt;&lt;3)|0 = 8，对应第一个字节： <code>1000</code></p><p>然后，它的值true对应第二个字节<code>1</code></p><h4 id="分析第二个字段Int"><a href="#分析第二个字段Int" class="headerlink" title="分析第二个字段Int"></a>分析第二个字段Int</h4><p>同样的，(field_number &lt;&lt; 3) | wire_type = (2&lt;&lt;3)|0 = 16，对应第三个字节<code>10000</code></p><p>值80对应<code>1010000</code></p><h4 id="分析第三个字段String"><a href="#分析第三个字段String" class="headerlink" title="分析第三个字段String"></a>分析第三个字段String</h4><p>因为string是不定长的，所以需要一个额外的长度字段</p><p>(field_number &lt;&lt; 3) | wire_type = (3&lt;&lt;3)|2=26，对应<code>11010</code></p><p>接下来是长度字段，我们有10个英文单词，所以长度为10，对应 <code>1010</code></p><p>然后就是10个Byte表示”China Town”了</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次的分析到这里就暂时告一段落了，阅读protobuf的相关代码还是非常耗时耗力的。其实这块最主要的复杂度在于为了兼容新老版本，采用了大量的Interface实现。Interface带有面向对象特色，在重构代码时很有意义，不过也给阅读代码时，查找方法对应实现时带来了复杂度。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号：golangcoding</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前面的分析中，我们已经知道了使用proto序列化的代码在&lt;a href=&quot;https://github.com/grpc/grpc-go/tree/v1.29.x/encoding/proto&quot;&gt;encoding目录&lt;/a&gt;中，路径中只有三个文件，其中2个还是测试文件，看
      
    
    </summary>
    
      <category term="源码阅读" scheme="http://example.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="gRPC" scheme="http://example.com/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>gRPC源码分析(三)：从Github文档了解gRPC的项目细节</title>
    <link href="http://example.com/2021/02/20/grpc/grpc-3/"/>
    <id>http://example.com/2021/02/20/grpc/grpc-3/</id>
    <published>2021-02-20T11:34:47.000Z</published>
    <updated>2021-03-29T12:51:46.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="官方Git总览"><a href="#官方Git总览" class="headerlink" title="官方Git总览"></a><a href="https://github.com/grpc">官方Git总览</a></h2><p>我们先看看GRPC这个项目的总览，主要分三种：</p><ul><li>基于C实现，包括了 C++, Python, Ruby, Objective-C, PHP, C#</li><li>其余语言实现的，最主要是go，java，node</li><li>proposal，即grpc的RFC，关于实现、讨论的文档汇总</li></ul><p>从这里可以看出，gRPC虽然是支持多语言，但原生的实现并不多。如果想在一些小众语言里引入gRPC，还是有很大风险的，有兴趣的可以搜索下TiDB在探索rust的gRPC的经验分享。</p><h2 id="gRPC-Go"><a href="#gRPC-Go" class="headerlink" title="gRPC-Go"></a><a href="https://github.com/grpc/grpc-go">gRPC-Go</a></h2><p>作为一名Go语言开发者，我自然选择从最熟悉的语言入手。同时，值得注意的是，grpc-go是除了<code>C家族系列</code>以外使用量最大的repo，加上Go语言优秀的可读性，是一个很好的入门gRPC的阅读材料。</p><p>进入项目，整个README.md文档也不长。通常情况下，如果你能啃完这个文档及相关链接，你对这个开源项目就已经超过99%的人了。</p><p>对Repo的相关注意事项，大家逐行阅读即可，整体比较简单，我简单列举下关键点：</p><ol><li>建议阅读官网文档（恭喜你，上次我们已经读完了官方文档）</li><li>在项目中的引入，建议用go mod</li><li>优先支持3个Go语言最新发布的版本</li><li>FAQ中的常见问题，主要关注<a href="https://github.com/grpc/grpc-go#io-timeout-errors">package下载问题</a>和<a href="https://github.com/grpc/grpc-go#how-to-turn-on-logging">如何开启追踪日志</a></li></ol><p>通读完成，我们再深入看看<a href="https://github.com/grpc/grpc-go#documentation">文档细节</a>，Example这块我们在官网的测试中已经看过，我们的接下来重点是godoc和具体细节的文档。</p><h2 id="go-doc"><a href="#go-doc" class="headerlink" title="go doc"></a><a href="https://godoc.org/google.golang.org/grpc">go doc</a></h2><h4 id="DefaultBackoffConfig"><a href="#DefaultBackoffConfig" class="headerlink" title="DefaultBackoffConfig"></a>DefaultBackoffConfig</h4><p>注意，这个变量被弃用，被挪到 <code>ConnectParams</code>里了(<a href="https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md">详情链接</a>)。那这个所谓的连接参数是什么用呢？代码不长，我们选择几个比较重要的内容来阅读下，原链接可以<a href="https://github.com/grpc/grpc-go/blob/v1.29.x/internal/backoff/backoff.go#L54">点击这里</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Backoff returns the amount of time to wait before the next retry given the</span></span><br><span class="line"><span class="comment">// number of retries.</span></span><br><span class="line"><span class="comment">// 根据retries返回等待时间，可以认为是一种退避策略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc Exponential)</span> <span class="title">Backoff</span><span class="params">(retries <span class="keyword">int</span>)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> retries == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 之前没有retries过，就返回BaseDelay</span></span><br><span class="line"><span class="keyword">return</span> bc.Config.BaseDelay</span><br><span class="line">&#125;</span><br><span class="line">backoff, max := <span class="keyword">float64</span>(bc.Config.BaseDelay), <span class="keyword">float64</span>(bc.Config.MaxDelay)</span><br><span class="line">  <span class="comment">// 等待时间不能超过max，等待时间 = BaseDelay * Multiplier的retries次方</span></span><br><span class="line">  <span class="comment">// Multiplier默认1.6，并不是官方http包中的2</span></span><br><span class="line"><span class="keyword">for</span> backoff &lt; max &amp;&amp; retries &gt; <span class="number">0</span> &#123;</span><br><span class="line">backoff *= bc.Config.Multiplier</span><br><span class="line">retries--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> backoff &gt; max &#123;</span><br><span class="line">backoff = max</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Randomize backoff delays so that if a cluster of requests start at</span></span><br><span class="line"><span class="comment">// the same time, they won&#x27;t operate in lockstep.</span></span><br><span class="line">  <span class="comment">// 乘以一个随机因子，数值为(1-Jitter,1+Jitter)，默认为(0.8,1.2)，防止同一时刻有大量请求发出，引起锁的问题</span></span><br><span class="line">backoff *= <span class="number">1</span> + bc.Config.Jitter*(grpcrand.Float64()*<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> backoff &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> time.Duration(backoff)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EnableTracing"><a href="#EnableTracing" class="headerlink" title="EnableTracing"></a>EnableTracing</h4><p>用来设置是否开启 trace，追踪日志</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>gRPC的错误码，原代码见<a href="https://github.com/grpc/grpc-go/blob/v1.29.x/codes/codes.go#L29">链接</a>，我们大概了解其原因即可：</p><ul><li><strong>OK</strong> 正常</li><li><strong>Canceled</strong> 客户端取消</li><li><strong>Unknown</strong> 未知</li><li><strong>InvalidArgument</strong> 未知参数</li><li><strong>DeadlineExceeded</strong> 超时</li><li><strong>NotFound</strong> 未找到资源</li><li><strong>AlreadyExists</strong> 资源已经创建</li><li><strong>PermissionDenied</strong> 权限不足</li><li><strong>ResourceExhausted</strong> 资源耗尽</li><li><strong>FailedPrecondition</strong> 前置条件不满足</li><li><strong>Aborted</strong> 异常退出</li><li><strong>OutOfRange</strong> 超出范围</li><li><strong>Unimplemented</strong> 未实现方法</li><li><strong>Internal</strong> 内部问题</li><li><strong>Unavailable</strong> 不可用状态</li><li><strong>DataLoss</strong> 数据丢失</li><li><strong>Unauthenticated</strong> 未认证</li></ul><p>读完上面的内容，发现跟HTTP/1.1的Status Code非常相似。</p><h4 id="CallOption"><a href="#CallOption" class="headerlink" title="CallOption"></a>CallOption</h4><p>调用在客户端 <code>Invoke</code> 方法中，包括before发送前，after为接收后。</p><p>官方提供了几个常用的CallOption，按场景调用。</p><h4 id="ClientConn"><a href="#ClientConn" class="headerlink" title="ClientConn"></a>ClientConn</h4><p>抽象的客户端连接。</p><p>值得注意的是，conns是一个map，所以实际可能有多个tcp连接。</p><h4 id="CodeC"><a href="#CodeC" class="headerlink" title="CodeC"></a>CodeC</h4><p>定义了Marshal和Unmarshal的接口，在grpc底层实现是proto，详细可见 <a href="https://github.com/grpc/grpc-go/blob/v1.29.x/encoding/proto/proto.go#L39">codec</a></p><h4 id="Compressor"><a href="#Compressor" class="headerlink" title="Compressor"></a>Compressor</h4><p>压缩相关的定义</p><h4 id="MetaData"><a href="#MetaData" class="headerlink" title="MetaData"></a>MetaData</h4><p>元数据，也就是key-value，可以类比到http的header</p><h4 id="DialOption"><a href="#DialOption" class="headerlink" title="DialOption"></a>DialOption</h4><p>客户端新建连接时的选项，按场景调用。</p><h4 id="ServerOption"><a href="#ServerOption" class="headerlink" title="ServerOption"></a>ServerOption</h4><p>服务端监听时的选项，按场景调用。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://github.com/grpc/grpc-go/tree/master/Documentation">文档链接</a></p><h4 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/benchmark.md">benchmark</a></h4><p>性能测试，有兴趣的可以细看gRPC是从哪几个维度做RPC性能测试的。</p><h4 id="Compression"><a href="#Compression" class="headerlink" title="Compression"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/compression.md">Compression</a></h4><p>可用<a href="https://github.com/grpc/grpc-go/blob/v1.29.x/encoding/encoding.go#L66">encoding.RegisterCompressor</a>实现自定义的压缩方法。</p><p>注意，压缩算法应用于客户端和服务端两侧。</p><h4 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/concurrency.md">Concurrency</a></h4><p>支持并发，从三个角度分析：</p><ul><li><code>ClientConn</code>支持多个Goroutine</li><li><code>Steams</code>中，<code>SendMsg</code>/<code>RecvMsg</code>可分别在两个Goroutine中运行，但任何一个方法运行在多个Goroutine上是不安全的</li><li><code>Server</code>每个客户端的invoke会对应一个Server端的Goroutine</li></ul><h4 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/encoding.md">Encoding</a></h4><p>类似Compression，可用<a href="https://github.com/grpc/grpc-go/blob/v1.29.x/encoding/encoding.go#L105">encoding.RegisterCodec</a>实现自定义的序列化方法。</p><h4 id="go-mock"><a href="#go-mock" class="headerlink" title="go mock"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/gomock-example.md">go mock</a></h4><p>用mock生成测试代码，详细可细看。</p><h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-auth-support.md">Authentication</a></h4><p>认证的相关选项，包括 TLS/OAuth2/GCE/JWT ，一般用前两者即可。</p><h4 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md">Metadata</a></h4><p>介绍了Metadata的使用，类比于HTTP/1.1的Header。</p><h4 id="Keepalive"><a href="#Keepalive" class="headerlink" title="Keepalive"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/keepalive.md">Keepalive</a></h4><p>长连接的参数分为3类：</p><ul><li>ClientParameters 客户端侧参数，主要用来探活</li><li>SeverParameters 服务端参数，控制连接时间</li><li>EnforcementPolicy 服务端加强型参数</li></ul><h4 id="log-level"><a href="#log-level" class="headerlink" title="log level"></a><a href="zhttps://github.com/grpc/grpc-go/blob/master/Documentation/log_levels.md">log level</a></h4><p>四个级别的log level，针对不同场景：</p><ul><li><code>Info</code> 用于debug问题</li><li><code>Warning</code> 排查非关键性的问题</li><li><code>Error</code> gRPC调用出现无法返回到客户端的问题</li><li><code>Fatal</code>  导致程序无法恢复的致命问题</li></ul><h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/proxy.md">proxy</a></h4><p>使用默认的HTTP或HTTPS代理。</p><h4 id="rpc-error"><a href="#rpc-error" class="headerlink" title="rpc error"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/rpc-errors.md">rpc error</a></h4><p>结合官方提供的错误码，用 <code>status.New</code> 或者 <code>status.Error</code> 创建错误。</p><h4 id="server-reflection"><a href="#server-reflection" class="headerlink" title="server reflection"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md">server reflection</a></h4><p>服务端方法映射，跟着教程走即可。</p><p>值得一提的是，采用c++中的grpc_cli模块，可以查看指定端口暴露出来的服务详情。</p><h4 id="versioning"><a href="#versioning" class="headerlink" title="versioning"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/versioning.md">versioning</a></h4><p>版本演进，一般情况下每6周一个小版本，紧急修复会打补丁号。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号：golangcoding</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;官方Git总览&quot;&gt;&lt;a href=&quot;#官方Git总览&quot; class=&quot;headerlink&quot; title=&quot;官方Git总览&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/grpc&quot;&gt;官方Git总览&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;我们先看看GRPC这个项
      
    
    </summary>
    
      <category term="源码阅读" scheme="http://example.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="gRPC" scheme="http://example.com/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>gRPC源码分析(二)：从官网文档看gRPC的特性</title>
    <link href="http://example.com/2021/02/20/grpc/grpc-2/"/>
    <id>http://example.com/2021/02/20/grpc/grpc-2/</id>
    <published>2021-02-20T11:34:45.000Z</published>
    <updated>2021-03-29T12:51:46.962Z</updated>
    
    <content type="html"><![CDATA[<p>在第一部分，我们学习了gRPC的基本调用过程，这样我们对全局层面有了一定了解。接下来，我们将结合官方文档，继续深入学习、探索下去。</p><h2 id="1-Authentication-认证的实现"><a href="#1-Authentication-认证的实现" class="headerlink" title="1. Authentication 认证的实现"></a>1. Authentication 认证的实现</h2><p><a href="https://grpc.io/docs/guides/auth/#with-server-authentication-ssltls">官方示例</a></p><p>示例很简单，客户端和服务端都大致分为两步：</p><ol><li>生成对应的认证信息 <code>creds</code></li><li>将认证信息作为 <code>DialOption</code> 传入信息</li></ol><p>认证方法的底层实现并不在我们今天的讨论范围内。这里值得一提的是，由于请求会存在大量的输入参数，这里提供的方法是 <code>opts ...DialOption</code>，也就是可变长度的参数，这一点很值得我们思考和学习。</p><h4 id="客户端的认证实现"><a href="#客户端的认证实现" class="headerlink" title="客户端的认证实现"></a>客户端的认证实现</h4><p>第一步：将认证信息放入连接中</p><ul><li><code>grpc.WithTransportCredentials</code> 中，将<code>creds</code> 保存到<code>copts.TransportCredentials</code></li><li>调用<code>Dial</code>，在内部用 <code>opt.apply(&amp;cc.dopts)</code>将认证信息传递到结构中</li><li><code>credsClone = creds.Clone()</code> 使用了一份复制，放到了Balancer中，估计是用于负载均衡的，暂时不用考虑</li></ul><p>第二步：将认证信息请求中发出</p><ul><li>首先我们先找到 <code>Invoke</code>函数，这里是发送请求的入口（对这一块有疑问的，查看上一篇）</li><li>分析一下函数 <code>invoke</code> ，调用了<code>newClientStream</code>，一大段代码都没有用到<code>copts.TransportCredentials</code>中的参数，大致猜测是在<code>clientStream</code>中</li><li>接下来这块，只通过阅读代码，要找到对应使用到<code>copts.TransportCredentials</code>很麻烦，建议第一次可以先通过反向查找，调用到这个参数的地方</li><li><code>newHTTP2Client</code> =&gt; <code>NewClientTransport</code> =&gt; <code>createTransport</code> =&gt; <code>tryAllAddrs</code> =&gt; <code>resetTransport</code> =&gt; <code>connect</code> =&gt; <code>getReadyTransport</code> =&gt;<code>pick</code> =&gt; <code>getTransport</code> =&gt;<code>newAttemptLocked</code> =&gt; <code>newAttemptLocked</code> =&gt; <code>newClientStream</code></li><li>这时，我们再正向梳理一下其调用逻辑，大致是查找连接情况，对传输层进行初始化。如果你了解认证是基于传输层<code>Transport</code>的，那下次正向查找时，会有一条比较明确的方向了</li></ul><h4 id="服务端的认证实现"><a href="#服务端的认证实现" class="headerlink" title="服务端的认证实现"></a>服务端的认证实现</h4><p>第一步：将认证信息放入Server结构中</p><ul><li>将<code>creds</code>包装成<code>ServerOption</code>，传入<code>NewServer</code>中</li><li>类似Client中的操作，被存至 <code>opts.creds</code> 里</li></ul><p>第二步：在连接中进行认证</p><ul><li>参考之前一讲的分析，我们进入函数 <code>handleRawConn</code></li><li>这次，我们的进展很顺利，一下子就看到了关键函数名<code>useTransportAuthenticator</code></li><li>在这里，调用了<code>creds</code>实现的<code>ServerHandshake</code>实现了认证。到这里，认证已经完成，不过我们可以再看看，认证信息是怎么传递的</li><li>接着，认证信息传入了 <code>newHTTP2Transport</code>，保存到结构体<code>http2Server</code>中的<code>authInfo</code>，最后返回了一个Interface <code>ServerTransport</code></li><li>在进行连接时，调用了<code>serveStreams</code>，然后调用了 <code>http2Server</code>的<code>HandleStreams</code>方法，这时，我们大致可以猜测，auth在这里被用到了</li><li>往下看，发现有个对header帧的处理<code>operateHeaders</code>，在这里被赋值到 <code>pr.AuthInfo</code>里，并被保存到s的Context中</li><li>一般情况下，Context的调用是十分隐蔽的，我们可以通过反向查找，哪里调用了<code>peer.FromContext</code>，然而并没有地方应用，那认证的分析，就告一段落了</li></ul><h2 id="2-四类gRPC调用的实现"><a href="#2-四类gRPC调用的实现" class="headerlink" title="2. 四类gRPC调用的实现"></a>2. 四类gRPC调用的实现</h2><p>这一块我们暂不深入源码，先了解使用时的特性</p><h4 id="2-1-简单RPC"><a href="#2-1-简单RPC" class="headerlink" title="2.1 简单RPC"></a>2.1 简单RPC</h4><p><a href="https://grpc.io/docs/tutorials/basic/go/#simple-rpc">代码链接</a></p><p>代码逻辑很直观，即处理后返回</p><h4 id="2-2-服务端流式RPC"><a href="#2-2-服务端流式RPC" class="headerlink" title="2.2 服务端流式RPC"></a>2.2 服务端流式RPC</h4><p><a href="https://grpc.io/docs/tutorials/basic/go/#server-side-streaming-rpc">代码链接</a></p><p>代码的关键在于两个函数<code>inRange</code>和 <code>stream.Send</code></p><h4 id="2-3-客户端流式RPC"><a href="#2-3-客户端流式RPC" class="headerlink" title="2.3 客户端流式RPC"></a>2.3 客户端流式RPC</h4><p><a href="https://grpc.io/docs/tutorials/basic/go/#client-side-streaming-rpc">代码链接</a></p><p>用一个for循环进行多次发送，<code>stream.Recv()</code>实现了从服务端获取数据，当EOF时，才调用<code>stream.SendAndClose</code>结束发送</p><h4 id="2-4-双向流式RPC"><a href="#2-4-双向流式RPC" class="headerlink" title="2.4 双向流式RPC"></a>2.4 双向流式RPC</h4><p><a href="https://grpc.io/docs/tutorials/basic/go/#bidirectional-streaming-rpc">代码链接</a></p><p>将 <code>SendAndClose</code> 变为 <code>Send</code>，其余基本不变。从这里可以看到，正常的关闭都是由服务端发起的。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号：golangcoding</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在第一部分，我们学习了gRPC的基本调用过程，这样我们对全局层面有了一定了解。接下来，我们将结合官方文档，继续深入学习、探索下去。&lt;/p&gt;
&lt;h2 id=&quot;1-Authentication-认证的实现&quot;&gt;&lt;a href=&quot;#1-Authentication-认证的实现&quot; c
      
    
    </summary>
    
      <category term="源码阅读" scheme="http://example.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="gRPC" scheme="http://example.com/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>gRPC源码分析（一）：gRPC的系统调用过程</title>
    <link href="http://example.com/2021/02/20/grpc/grpc-1/"/>
    <id>http://example.com/2021/02/20/grpc/grpc-1/</id>
    <published>2021-02-20T11:34:41.000Z</published>
    <updated>2021-03-29T12:51:46.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>参考<a href="https://grpc.io/docs/quickstart/go/">官方文档</a>，进行部署并运行成功</p><h2 id="分析思路：GRPC是怎么实现方法调用的"><a href="#分析思路：GRPC是怎么实现方法调用的" class="headerlink" title="分析思路：GRPC是怎么实现方法调用的"></a>分析思路：GRPC是怎么实现方法调用的</h2><ol><li>分析PB生成的对应文件</li><li>运行server</li><li>运行client</li></ol><h2 id="1-分析PB生成的对应文件"><a href="#1-分析PB生成的对应文件" class="headerlink" title="1. 分析PB生成的对应文件"></a>1. 分析PB生成的对应文件</h2><h3 id="HelloRequest-HelloReply-结构分析"><a href="#HelloRequest-HelloReply-结构分析" class="headerlink" title="HelloRequest/HelloReply 结构分析"></a>HelloRequest/HelloReply 结构分析</h3><p>存在三个冗余字段 <code>XXX_NoUnkeyedLiteral</code> <code>XXX_unrecognized</code> <code>XXX_sizecache</code></p><p>这部分主要是兼容proto2的，我们暂时不用细究</p><h3 id="GreeterClient客户端"><a href="#GreeterClient客户端" class="headerlink" title="GreeterClient客户端"></a>GreeterClient客户端</h3><p>传入一个 cc grpc.ClientConnInterface 客户端连接</p><p>可调用的方法为SayHello，其内部的method为”/helloworld.Greeter/SayHello”，也就是<code>/&#123;package&#125;.&#123;service&#125;/&#123;method&#125;</code> ，作为一个唯一的URI</p><h3 id="GreeterServer服务端"><a href="#GreeterServer服务端" class="headerlink" title="GreeterServer服务端"></a>GreeterServer服务端</h3><p>需要自己实现一个SayHello的方法</p><p>其中有个 UnimplementedGreeterServer 的接口，可以嵌入到对应的server结构体中（有方法未实现时，会返回codes.Unimplemented）</p><h2 id="2-运行server"><a href="#2-运行server" class="headerlink" title="2. 运行server"></a>2. 运行server</h2><h3 id="定义server"><a href="#定义server" class="headerlink" title="定义server"></a>定义server</h3><p>这里pb.UnimplementedGreeterServer被嵌入了server结构，所以即使没有实现SayHello方法，编译也能通过。</p><p>但是，我们通常要强制server在编译期就必须实现对应的方法，所以生产中建议不嵌入。</p><h3 id="实现自己的业务逻辑"><a href="#实现自己的业务逻辑" class="headerlink" title="实现自己的业务逻辑"></a>实现自己的业务逻辑</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span>&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册TCP监听端口"><a href="#注册TCP监听端口" class="headerlink" title="注册TCP监听端口"></a>注册TCP监听端口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)</span><br></pre></td></tr></table></figure><p>因为gRPC的应用层是基于HTTP2的，所以这里不出意外，监听的是tcp端口</p><h3 id="grpc-NewServer"><a href="#grpc-NewServer" class="headerlink" title="grpc.NewServer()"></a>grpc.NewServer()</h3><ol><li>入参为选项参数options</li><li>自带一组defaultServerOptions，最大发送size、最大接收size、连接超时、发送缓冲、接收缓冲</li><li><code>s.cv = sync.NewCond(&amp;s.mu)</code> 条件锁，用于关闭连接</li><li>全局参数 <code>EnableTraciing</code> ，会调用golang.org/x/net/trace 这个包</li></ol><h3 id="pb-RegisterGreeterServer-s-amp-server"><a href="#pb-RegisterGreeterServer-s-amp-server" class="headerlink" title="pb.RegisterGreeterServer(s, &amp;server{})"></a>pb.RegisterGreeterServer(s, &amp;server{})</h3><p>对比自己创建的server和pb中定义的server，确定每个方法都已经实现</p><p>service放在 <code>m map[string]*service</code> 中，所以一个server可以放多个proto定义的服务</p><p>内部的method和stream放在 service 中的两个map中</p><h3 id="s-Serve-lis"><a href="#s-Serve-lis" class="headerlink" title="s.Serve(lis)"></a>s.Serve(lis)</h3><ol><li>listener 放到内部的map中</li><li>for循环，进行tcp连接，这一部分和http源码中的ListenAndServe极其类似</li><li>在协程中进行handleRawConn</li><li>将tcp连接封装对应的creds认证信息</li><li>新建newHTTP2Transport传输层连接</li><li>在协程中进行serveStreams，而http1这里为阻塞的</li><li>函数HandleStreams中参数为2个函数，前者为处理请求，后者用于trace</li><li>进入handleStream，前半段被拆为service，后者为method，通过map查找</li><li>method在processUnaryRPC处理，stream在processStreamingRPC处理，这两块内部就比较复杂了，涉及到具体的算法，以后有时间细读</li></ol><h2 id="3-运行client"><a href="#3-运行client" class="headerlink" title="3. 运行client"></a>3. 运行client</h2><h3 id="grpc-Dial"><a href="#grpc-Dial" class="headerlink" title="grpc.Dial"></a>grpc.Dial</h3><p>新建一个conn连接，这里是一个支持HTTP2.0的客户端，暂不细讲</p><h3 id="pb-NewGreeterClient-conn"><a href="#pb-NewGreeterClient-conn" class="headerlink" title="pb.NewGreeterClient(conn)"></a>pb.NewGreeterClient(conn)</h3><p>新建一个client，包装对应的method，方便调用SayHello</p><h3 id="调用SayHello"><a href="#调用SayHello" class="headerlink" title="调用SayHello"></a>调用SayHello</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: name&#125;)</span><br></pre></td></tr></table></figure><ol><li>核心调用的是 Invoke 方法，具体实现要看grpc.ClientConn中</li><li>grpc.ClientConn中实现了Invoke方法，在call.go文件中，详情都在invoke中</li></ol><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号：golangcoding</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;参考&lt;a href=&quot;https://grpc.io/docs/quickstart/go/&quot;&gt;官方文档&lt;/a&gt;，进行部署并
      
    
    </summary>
    
      <category term="源码阅读" scheme="http://example.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="gRPC" scheme="http://example.com/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>Go编程模式 - 8-装饰、管道和访问者模式</title>
    <link href="http://example.com/2021/02/20/go-patterns/go-patterns-8/"/>
    <id>http://example.com/2021/02/20/go-patterns/go-patterns-8/</id>
    <published>2021-02-20T10:32:09.000Z</published>
    <updated>2021-03-29T12:51:46.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的<a href="https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save">链接</a>可能并不方便获取，所以我下载了一份<a href="https://github.com/Junedayday/code_reading/tree/master/doc/Go_Programming_Patterns.pdf">PDF</a>到git仓，方便大家阅读。我将结合自己的实际项目经历，与大家一起细品这份文档。</p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#Decoration">装饰模式</a></li><li><a href="#Pipeline">管道模式</a></li><li><a href="#Visitorl">访问者模式</a></li></ul><p>今天，我会抛开官方的定义，简单介绍一下三种设计模式。</p><blockquote><p> 后续会有介绍Go语言设计模式Design Patterns的系列，会更具理论性。</p></blockquote><h2 id="Decoration"><a href="#Decoration" class="headerlink" title="Decoration"></a>Decoration</h2><p>代码实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decorator</span><span class="params">(f <span class="keyword">func</span>(s <span class="keyword">string</span>)</span>) <span class="title">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Started&quot;</span>)</span><br><span class="line">f(s)</span><br><span class="line">fmt.Println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一句话解释：<strong>在函数f前后，添加装饰性的功能函数，但不改变函数本身的行为</strong>。</p><p>这种设计模式，对一些被高频率调用的代码非常有用：</p><ol><li>HTTP Server被调用的handler</li><li>HTTP Client发送请求</li><li>对MySQL的操作</li></ol><p>而装饰性的功能，常见的有：</p><ol><li>打印相关的日志信息（Debug中非常有用！）</li><li>耗时相关的计算</li><li>监控埋点</li></ol><h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>代码示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HttpHandlerDecorator <span class="function"><span class="keyword">func</span><span class="params">(http.HandlerFunc)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handler</span><span class="params">(h http.HandlerFunc, decors ...HttpHandlerDecorator)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> decors &#123;</span><br><span class="line">        d := decors[<span class="built_in">len</span>(decors)<span class="number">-1</span>-i] <span class="comment">// iterate in reverse</span></span><br><span class="line">        h = d(h)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一句话解释：<strong>用不定参数的特性，将入参中的函数，逐个应用到对象上</strong></p><blockquote><p>看到这里，如果你能想起之前 <code>Functional Option</code> 那篇，会发现有这块的影子。</p></blockquote><p>主要应用于： 有多种可选择的配置（对应Field）或处理（对应方法）的复杂对象。</p><p>耗子叔在后面又增加了一些用Goroutine+Channel的方式，其实就是讲Channel作为一个管道的承载体。</p><h2 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor"></a>Visitor</h2><p>关于访问者设计者模式，我之前在Kubernetes源码分析中专门分析了源码。今天，我们也简单地过一下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义访问的函数类型</span></span><br><span class="line"><span class="keyword">type</span> VisitorFunc <span class="function"><span class="keyword">func</span><span class="params">(*Info, error)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Visitor接口设计</span></span><br><span class="line"><span class="keyword">type</span> Visitor <span class="keyword">interface</span> &#123;</span><br><span class="line">Visit(VisitorFunc) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源对象</span></span><br><span class="line"><span class="keyword">type</span> Info <span class="keyword">struct</span> &#123;</span><br><span class="line">Namespace   <span class="keyword">string</span></span><br><span class="line">Name        <span class="keyword">string</span></span><br><span class="line">OtherThings <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Visitor函数应用到资源对象上</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(info *Info)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fn(info, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看其中一个实现：NameVisitor，其余的也类似，这样就能注入对应的Visitor</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NameVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">visitor Visitor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v NameVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> v.visitor.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 这里是运行入参中的VisitorFunc，这一块的逻辑有点像pipeline</span></span><br><span class="line">err = fn(info, err)</span><br><span class="line"><span class="comment">// NameVisitor自己实现的Visit逻辑</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，Kubernetes中的Visitor还有进一步的封装，包括遇到错误时的处理，这里不细讲，有兴趣的朋友可以看看我对那一篇的分析。</p><p>Visitor模式最大的优点就是 <code>解耦了数据和程序</code>。回头看Kubernetes的Visitor应用场景，主要是从各种输入源中解析出资源<code>Info</code>。这个过程中Info是数据，各类解析方法是资源。</p><p>所以，我认为Visitor模式比较适合的是：<strong>目标数据明确，但获取数据的方法多样且复杂</strong>。但由于多层Visitor调用复杂，建议大家可以在外面再简单地封一层，提供常用的几种Visitor组合后的接口，供使用方调用。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号：golangcoding</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的&lt;a href=&quot;https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save&quot;&gt;链接&lt;
      
    
    </summary>
    
      <category term="经典品读" scheme="http://example.com/categories/%E7%BB%8F%E5%85%B8%E5%93%81%E8%AF%BB/"/>
    
    
      <category term="Go-Programming-Patterns" scheme="http://example.com/tags/Go-Programming-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>Go编程模式 - 7-代码生成</title>
    <link href="http://example.com/2021/02/20/go-patterns/go-patterns-7/"/>
    <id>http://example.com/2021/02/20/go-patterns/go-patterns-7/</id>
    <published>2021-02-20T10:32:05.000Z</published>
    <updated>2021-03-29T12:51:46.960Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的<a href="https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save">链接</a>可能并不方便获取，所以我下载了一份<a href="https://github.com/Junedayday/code_reading/tree/master/doc/Go_Programming_Patterns.pdf">PDF</a>到git仓，方便大家阅读。我将结合自己的实际项目经历，与大家一起细品这份文档。</p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#Simple-Script">简单脚本准备</a><ul><li><a href="#Template">模板文件</a></li><li><a href="#Shell">运行脚本</a></li><li><a href="#Generate-File">入口文件</a></li><li><a href="#Generation">运行原理</a></li></ul></li><li><a href="#genny">类型替换工具genny</a></li><li><a href="#go-bindata">任意文件转Go</a></li><li><a href="#stringer">字符串生成工具stringer</a></li></ul><h2 id="Simple-Script"><a href="#Simple-Script" class="headerlink" title="Simple Script"></a>Simple Script</h2><p>为了让大家快速了解这块，我们从一个最简单的例子入手。</p><h3 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h3><p>首先创建一个模板Go文件，即容器模板：container.tmp.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> PACKAGE_NAME</span><br><span class="line"><span class="keyword">type</span> GENERIC_NAMEContainer <span class="keyword">struct</span> &#123;</span><br><span class="line">    s []GENERIC_TYPE</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGENERIC_NAMEContainer</span><span class="params">()</span> *<span class="title">GENERIC_NAMEContainer</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;GENERIC_NAMEContainer&#123;s: []GENERIC_TYPE&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *GENERIC_NAMEContainer)</span> <span class="title">Put</span><span class="params">(val GENERIC_TYPE)</span></span> &#123;</span><br><span class="line">    c.s = <span class="built_in">append</span>(c.s, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *GENERIC_NAMEContainer)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">GENERIC_TYPE</span></span> &#123;</span><br><span class="line">    r := c.s[<span class="number">0</span>]</span><br><span class="line">    c.s = c.s[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>生成的shell脚本，gen.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">SRC_FILE=$&#123;1&#125;</span><br><span class="line">PACKAGE=$&#123;2&#125;</span><br><span class="line">TYPE=$&#123;3&#125;</span><br><span class="line">DES=$&#123;4&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">uppcase the first char</span></span><br><span class="line">PREFIX=&quot;$(tr &#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27; &lt;&lt;&lt; $&#123;TYPE:0:1&#125;)$&#123;TYPE:1&#125;&quot;</span><br><span class="line"></span><br><span class="line">DES_FILE=$(echo $&#123;TYPE&#125;| tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)_$&#123;DES&#125;.go</span><br><span class="line"></span><br><span class="line">sed &#x27;s/PACKAGE_NAME/&#x27;&quot;$&#123;PACKAGE&#125;&quot;&#x27;/g&#x27; $&#123;SRC_FILE&#125; | \</span><br><span class="line">    sed &#x27;s/GENERIC_TYPE/&#x27;&quot;$&#123;TYPE&#125;&quot;&#x27;/g&#x27; | \</span><br><span class="line">    sed &#x27;s/GENERIC_NAME/&#x27;&quot;$&#123;PREFIX&#125;&quot;&#x27;/g&#x27; &gt; $&#123;DES_FILE&#125;</span><br></pre></td></tr></table></figure><p>四个参数分别为</p><ul><li>源文件名</li><li>包名</li><li>类型</li><li>文件后缀名</li></ul><h3 id="Generate-File"><a href="#Generate-File" class="headerlink" title="Generate File"></a>Generate File</h3><p>最后，增加一个创建代码的go文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:generate ./gen.sh ./template/container.tmp.go gen uint32 container</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateUint32Example</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> u <span class="keyword">uint32</span> = <span class="number">42</span></span><br><span class="line">    c := NewUint32Container()</span><br><span class="line">    c.Put(u)</span><br><span class="line">    v := c.Get()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;generateExample: %d (%T)\n&quot;</span>, v, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate ./gen.sh ./template/container.tmp.go gen string container</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateStringExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    c := NewStringContainer()</span><br><span class="line">    c.Put(s)</span><br><span class="line">    v := c.Get()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;generateExample: %s (%T)\n&quot;</span>, v, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h3><p>我们运行一下 <code>go generate</code>，就能产生对应的文件。</p><ol><li>运行go generate，工具会扫描所有的文件</li><li>如果发现注释有带 go:generate的，会自动运行后面的命令</li><li>通过命令生成的代码，会在源文件添加提示，告诉他人这是自动生成的代码，不要编辑</li></ol><p>因此，我们不仅仅可以用<code>shell</code>脚本，也可以用各种二进制工具来生成代码。值得一提的是，像Kubernetes这种重量级的项目，大量地应用了这种特性。后面我也会和大家分享在开发web项目中的应用。</p><p>下面，我也来介绍几个个人认为比较有用的工具。</p><h2 id="genny"><a href="#genny" class="headerlink" title="genny"></a>genny</h2><p>源项目链接：<a href="https://github.com/cheekybits/genny">https://github.com/cheekybits/genny</a></p><h3 id="Go文件示例"><a href="#Go文件示例" class="headerlink" title="Go文件示例"></a>Go文件示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/cheekybits/genny/generic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> this is how easy it is to define a generic type</span></span><br><span class="line"><span class="keyword">type</span> Something generic.Type</span><br><span class="line"></span><br><span class="line"><span class="comment">// SomethingQueue is a queue of Somethings.</span></span><br><span class="line"><span class="keyword">type</span> SomethingQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">  items []Something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSomethingQueue</span><span class="params">()</span> *<span class="title">SomethingQueue</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;SomethingQueue&#123;items: <span class="built_in">make</span>([]Something, <span class="number">0</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *SomethingQueue)</span> <span class="title">Push</span><span class="params">(item Something)</span></span> &#123;</span><br><span class="line">  q.items = <span class="built_in">append</span>(q.items, item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *SomethingQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">Something</span></span> &#123;</span><br><span class="line">  item := q.items[<span class="number">0</span>]</span><br><span class="line">  q.items = q.items[<span class="number">1</span>:]</span><br><span class="line">  <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat source.go | genny gen &quot;Something=string&quot;</span><br></pre></td></tr></table></figure><p>官方示例还是采用的是shell脚本，建议替换到 go:generate 中，这样的代码更统一</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>可以简单地理解成一个类型替换的工具（PS：擅长用sed脚本的朋友也可直接通过shell脚本实现）</p><h2 id="go-bindata"><a href="#go-bindata" class="headerlink" title="go-bindata"></a>go-bindata</h2><p>源网站链接：<a href="https://github.com/go-bindata/go-bindata">https://github.com/go-bindata/go-bindata</a></p><p>go-bindata的功能是将任意格式的源文件，转化为Go代码，使我们无需再去打开文件读取了。</p><p>这个工具多用在静态网页转化为Go代码（不符合前后端分离的实践），所以具体的使用方式我就不细讲了，大家有兴趣的可以自行阅读教程。</p><p>但它有两个优点值得我们关注：无需再进行文件读取操作、压缩。</p><h2 id="stringer"><a href="#stringer" class="headerlink" title="stringer"></a>stringer</h2><p>stringer是官方提供一个字符串工具，我个人非常推荐大家使用</p><p>文档链接：<a href="https://pkg.go.dev/golang.org/x/tools/cmd/stringer">https://pkg.go.dev/golang.org/x/tools/cmd/stringer</a> </p><h3 id="Go文件"><a href="#Go文件" class="headerlink" title="Go文件"></a>Go文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> painkiller</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pill <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Placebo Pill = <span class="literal">iota</span></span><br><span class="line">Aspirin</span><br><span class="line">Ibuprofen</span><br><span class="line">Paracetamol</span><br><span class="line">Acetaminophen = Paracetamol</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:generate stringer -type=Pill</span></span><br></pre></td></tr></table></figure><p>于是，就会生成对应的方法<code>func (Pill) String() string</code>，也就是直接转化成了其命名。</p><h3 id="价值"><a href="#价值" class="headerlink" title="价值"></a>价值</h3><p>Go语言在调用 <code>fmt</code> 等相关包时，如果要将某个变量转化为字符串，默认会寻找它的<code>String()</code>方法。</p><p>这时，<strong>良好的命名</strong> 能体现出其价值。尤其是在错误码的处理上，无需再去查询错误码对应的错误内容，直接可以通过命名了解。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号：golangcoding</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的&lt;a href=&quot;https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save&quot;&gt;链接&lt;
      
    
    </summary>
    
      <category term="经典品读" scheme="http://example.com/categories/%E7%BB%8F%E5%85%B8%E5%93%81%E8%AF%BB/"/>
    
    
      <category term="Go-Programming-Patterns" scheme="http://example.com/tags/Go-Programming-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>Go编程模式 - 6-映射、归约与过滤</title>
    <link href="http://example.com/2021/02/20/go-patterns/go-patterns-6/"/>
    <id>http://example.com/2021/02/20/go-patterns/go-patterns-6/</id>
    <published>2021-02-20T10:32:02.000Z</published>
    <updated>2021-03-29T12:51:46.960Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的<a href="https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save">链接</a>可能并不方便获取，所以我下载了一份<a href="https://github.com/Junedayday/code_reading/tree/master/doc/Go_Programming_Patterns.pdf">PDF</a>到git仓，方便大家阅读。我将结合自己的实际项目经历，与大家一起细品这份文档。</p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#Map/Reduce/Filter">映射、规约与过滤</a></li><li><a href="#Scenarios">应用场景探索</a></li><li><a href="#Generic">泛型</a></li></ul><h2 id="Map-Reduce-Filter"><a href="#Map-Reduce-Filter" class="headerlink" title="Map/Reduce/Filter"></a>Map/Reduce/Filter</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapUpCase</span><span class="params">(arr []<span class="keyword">string</span>, fn <span class="keyword">func</span>(s <span class="keyword">string</span>)</span> <span class="title">string</span>) []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> newArray = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, it := <span class="keyword">range</span> arr &#123;</span><br><span class="line">newArray = <span class="built_in">append</span>(newArray, fn(it))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapLen</span><span class="params">(arr []<span class="keyword">string</span>, fn <span class="keyword">func</span>(s <span class="keyword">string</span>)</span> <span class="title">int</span>) []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> newArray = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, it := <span class="keyword">range</span> arr &#123;</span><br><span class="line">newArray = <span class="built_in">append</span>(newArray, fn(it))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reduce</span><span class="params">(arr []<span class="keyword">string</span>, fn <span class="keyword">func</span>(s <span class="keyword">string</span>)</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, it := <span class="keyword">range</span> arr &#123;</span><br><span class="line">sum += fn(it)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Filter</span><span class="params">(arr []<span class="keyword">string</span>, fn <span class="keyword">func</span>(n <span class="keyword">string</span>)</span> <span class="title">bool</span>) []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> newArray = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, it := <span class="keyword">range</span> arr &#123;</span><br><span class="line"><span class="keyword">if</span> fn(it) &#123;</span><br><span class="line">newArray = <span class="built_in">append</span>(newArray, it)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> list = []<span class="keyword">string</span>&#123;<span class="string">&quot;Hao&quot;</span>, <span class="string">&quot;Chen&quot;</span>, <span class="string">&quot;MegaEase&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素一对一映射 string-&gt;string</span></span><br><span class="line">x := MapUpCase(list, <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> strings.ToUpper(s)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, x)</span><br><span class="line"><span class="comment">// [HAO CHEN MEGAEASE]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素一对一映射 string-&gt;int</span></span><br><span class="line">y := MapLen(list, <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, y)</span><br><span class="line"><span class="comment">// [3 4 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 归约：多个元素-&gt;一个元素</span></span><br><span class="line">z := Reduce(list, <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, z)</span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤：过滤不满足条件的元素</span></span><br><span class="line">f := Filter(list, <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s) &gt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, f)</span><br><span class="line"><span class="comment">// [Chen MegaEase]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Scenarios"><a href="#Scenarios" class="headerlink" title="Scenarios"></a>Scenarios</h2><ul><li><code>Map</code> 是一对一的场景，是 <strong>循环中对数据加工处理</strong> </li><li><code>Reduce</code> 是多对一，是 <strong>数据聚合处理</strong></li><li><code>Filter</code>是过滤的处理，是 <strong>数据有效性</strong></li></ul><p>我们以常见的账单统计相关的功能，我们会遇上大量的此类情况：</p><ol><li>统计消费总额 - Reduce</li><li>统计用户A - Filter</li><li>统计本月 - Filter</li><li>费用转化为美金 - Map</li></ol><p>在综合各个因素后，就是大量复杂的、管道式的Map/Reduce/Filter操作。</p><blockquote><p>延伸思考一下，这块和SQL语句非常类似</p></blockquote><h2 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h2><p>耗子叔在接下来的部分，展示了用<code>reflect</code>处理泛型情况。我这边简单地截取Map部分解析一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TransformInPlace</span><span class="params">(slice, function <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> transform(slice, function, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map的转换函数，slice为切片，function为对应的函数，inPlace表示是否原地处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transform</span><span class="params">(slice, function <span class="keyword">interface</span>&#123;&#125;, inPlace <span class="keyword">bool</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="comment">// 类型判断，必须为切片</span></span><br><span class="line">sliceInType := reflect.ValueOf(slice)</span><br><span class="line"><span class="keyword">if</span> sliceInType.Kind() != reflect.Slice &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;transform: not slice&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的签名判断，即函数的入参必须和slice里的元素一致</span></span><br><span class="line">fn := reflect.ValueOf(function)</span><br><span class="line">elemType := sliceInType.Type().Elem()</span><br><span class="line"><span class="keyword">if</span> !verifyFuncSignature(fn, elemType, <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;trasform: function must be of type func(&quot;</span> + sliceInType.Type().Elem().String() + <span class="string">&quot;) outputElemType&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是原地，则直接处理函数，结果会保存到入参中（这时入参一般为指针）</span></span><br><span class="line"><span class="comment">// 如果非原地，那就需要新建一个切片，用来保存结果</span></span><br><span class="line">sliceOutType := sliceInType</span><br><span class="line"><span class="keyword">if</span> !inPlace &#123;</span><br><span class="line">sliceOutType = reflect.MakeSlice(reflect.SliceOf(fn.Type().Out(<span class="number">0</span>)), sliceInType.Len(), sliceInType.Len())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; sliceInType.Len(); i++ &#123;</span><br><span class="line">sliceOutType.Index(i).Set(fn.Call([]reflect.Value&#123;sliceInType.Index(i)&#125;)[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sliceOutType.Interface()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">verifyFuncSignature</span><span class="params">(fn reflect.Value, types ...reflect.Type)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// 类型判断</span></span><br><span class="line"><span class="keyword">if</span> fn.Kind() != reflect.Func &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入参数量和函数签名一致，出参必须只有一个</span></span><br><span class="line"><span class="keyword">if</span> (fn.Type().NumIn() != <span class="built_in">len</span>(types)<span class="number">-1</span>) || (fn.Type().NumOut() != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个函数入参的类型校验</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(types)<span class="number">-1</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> fn.Type().In(i) != types[i] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出参类型的校验</span></span><br><span class="line">outType := types[<span class="built_in">len</span>(types)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> outType != <span class="literal">nil</span> &amp;&amp; fn.Type().Out(<span class="number">0</span>) != outType &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细阅读这一块代码，我们能学到很多反射方面的知识，尤其是并不常用的函数相关的。</p><p>但是，我不建议大家在实际项目中直接使用这一块代码，毕竟其中大量的反射操作是比较耗时的，尤其是在延迟非常敏感的web服务器中。</p><p>如果我们多花点时间、直接编写指定类型的代码，那么就能在编译期发现错误，运行时也可以跳过反射的耗时。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号：golangcoding</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的&lt;a href=&quot;https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save&quot;&gt;链接&lt;
      
    
    </summary>
    
      <category term="经典品读" scheme="http://example.com/categories/%E7%BB%8F%E5%85%B8%E5%93%81%E8%AF%BB/"/>
    
    
      <category term="Go-Programming-Patterns" scheme="http://example.com/tags/Go-Programming-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>Go编程模式 - 5.函数式选项</title>
    <link href="http://example.com/2021/02/20/go-patterns/go-patterns-5/"/>
    <id>http://example.com/2021/02/20/go-patterns/go-patterns-5/</id>
    <published>2021-02-20T10:31:59.000Z</published>
    <updated>2021-03-29T12:51:46.960Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的<a href="https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save">链接</a>可能并不方便获取，所以我下载了一份<a href="https://github.com/Junedayday/code_reading/tree/master/doc/Go_Programming_Patterns.pdf">PDF</a>到git仓，方便大家阅读。我将结合自己的实际项目经历，与大家一起细品这份文档。</p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#ServerConfig">一个常见的HTTP服务器</a></li><li><a href="#SplitConfig">拆分可选配置</a></li><li><a href="#Functional-Option">函数式选项</a></li><li><a href="#Further">更进一步</a></li></ul><h2 id="ServerConfig"><a href="#ServerConfig" class="headerlink" title="ServerConfig"></a>ServerConfig</h2><p>我们先来看看一个常见的HTTP服务器的配置，它区分了2个必填参数与4个非必填参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServerCfg <span class="keyword">struct</span> &#123;</span><br><span class="line">Addr     <span class="keyword">string</span>        <span class="comment">// 必填</span></span><br><span class="line">Port     <span class="keyword">int</span>           <span class="comment">// 必填</span></span><br><span class="line">Protocol <span class="keyword">string</span>        <span class="comment">// 非必填</span></span><br><span class="line">Timeout  time.Duration <span class="comment">// 非必填</span></span><br><span class="line">MaxConns <span class="keyword">int</span>           <span class="comment">// 非必填</span></span><br><span class="line">TLS      *tls.Config   <span class="comment">// 非必填</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们要实现非常多种方法，来支持各种非必填的情况，示例如下</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>)</span> <span class="params">(*Server, error)</span></span>                                   &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTLSServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, tls *tls.Config)</span> <span class="params">(*Server, error)</span></span>               &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServerWithTimeout</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, timeout time.Duration)</span> <span class="params">(*Server, error)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTLSServerWithMaxConnAndTimeout</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, maxconns <span class="keyword">int</span>, timeout time.Duration, tls *tls.Config)</span> <span class="params">(*Server, error)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="SplitConfig"><a href="#SplitConfig" class="headerlink" title="SplitConfig"></a>SplitConfig</h2><p>编程的一大重点，就是要 <code>分离变化点和不变点</code>。这里，我们可以将必填项认为是不变点，而非必填则是变化点。</p><p>我们将非必填的选项拆分出来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">Protocol <span class="keyword">string</span></span><br><span class="line">Timeout  time.Duration</span><br><span class="line">MaxConns <span class="keyword">int</span></span><br><span class="line">TLS      *tls.Config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">Addr <span class="keyword">string</span></span><br><span class="line">Port <span class="keyword">int</span></span><br><span class="line">Conf *Config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, conf *Config)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Server&#123;</span><br><span class="line">Addr: addr,</span><br><span class="line">Port: port,</span><br><span class="line">Conf: conf,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">srv1, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">9000</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">conf := Config&#123;Protocol: <span class="string">&quot;tcp&quot;</span>, Timeout: <span class="number">60</span> * time.Second&#125;</span><br><span class="line">srv2, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">9000</span>, &amp;conf)</span><br><span class="line"></span><br><span class="line">fmt.Println(srv1, srv2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，其实已经满足大部分的开发需求了。那么，我们将进入今天的重点。</p><h2 id="Functional-Option"><a href="#Functional-Option" class="headerlink" title="Functional Option"></a>Functional Option</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">Addr     <span class="keyword">string</span></span><br><span class="line">Port     <span class="keyword">int</span></span><br><span class="line">Protocol <span class="keyword">string</span></span><br><span class="line">Timeout  time.Duration</span><br><span class="line">MaxConns <span class="keyword">int</span></span><br><span class="line">TLS      *tls.Config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个Option类型的函数，它操作了Server这个对象</span></span><br><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*Server)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是对四个可选参数的配置函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Protocol</span><span class="params">(p <span class="keyword">string</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">s.Protocol = p</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Timeout</span><span class="params">(timeout time.Duration)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">s.Timeout = timeout</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxConns</span><span class="params">(maxconns <span class="keyword">int</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">s.MaxConns = maxconns</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TLS</span><span class="params">(tls *tls.Config)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">s.TLS = tls</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用到了不定参数的特性，将任意个option应用到Server上</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, options ...Option)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 先填写默认值</span></span><br><span class="line">srv := Server&#123;</span><br><span class="line">Addr:     addr,</span><br><span class="line">Port:     port,</span><br><span class="line">Protocol: <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">Timeout:  <span class="number">30</span> * time.Second,</span><br><span class="line">MaxConns: <span class="number">1000</span>,</span><br><span class="line">TLS:      <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 应用任意个option</span></span><br><span class="line"><span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">option(&amp;srv)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;srv, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">1024</span>)</span><br><span class="line">s2, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">2048</span>, Protocol(<span class="string">&quot;udp&quot;</span>))</span><br><span class="line">s3, _ := NewServer(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8080</span>, Timeout(<span class="number">300</span>*time.Second), MaxConns(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">fmt.Println(s1, s2, s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>耗子哥给出了6个点，但我感受最深的是以下两点：</p><ol><li>可读性强，将配置都转化成了对应的函数项option</li><li>扩展性好，新增参数只需要增加一个对应的方法</li></ol><p>那么对应的代价呢？就是需要编写多个Option函数，代码量会有所增加。</p><p>如果大家对这个感兴趣，可以去看一下Rob Pike的<a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html">这篇blog</a> 。</p><h2 id="Further"><a href="#Further" class="headerlink" title="Further"></a>Further</h2><p>顺着耗子叔的例子，我们再思考一下，如果配置的过程中有参数限制，那么我们该怎么办呢？</p><p>首先，我们改造一下函数Option</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回错误</span></span><br><span class="line"><span class="keyword">type</span> OptionWithError <span class="function"><span class="keyword">func</span><span class="params">(*Server)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>然后，我们改造一下其中两个函数作为示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Protocol</span><span class="params">(p <span class="keyword">string</span>)</span> <span class="title">OptionWithError</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> p == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;empty protocol&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">s.Protocol = p</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Timeout</span><span class="params">(timeout time.Duration)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> timeout.Seconds() &lt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;time out should not less than 1s&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">s.Timeout = timeout</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再做一次改造</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, options ...OptionWithError)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line">srv := Server&#123;</span><br><span class="line">Addr:     addr,</span><br><span class="line">Port:     port,</span><br><span class="line">Protocol: <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">Timeout:  <span class="number">30</span> * time.Second,</span><br><span class="line">MaxConns: <span class="number">1000</span>,</span><br><span class="line">TLS:      <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 增加了一个参数验证的步骤</span></span><br><span class="line"><span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line"><span class="keyword">if</span> err := option(&amp;srv); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;srv, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造基本到此完成，希望能给大家带来一定的帮助。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号：golangcoding</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的&lt;a href=&quot;https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save&quot;&gt;链接&lt;
      
    
    </summary>
    
      <category term="经典品读" scheme="http://example.com/categories/%E7%BB%8F%E5%85%B8%E5%93%81%E8%AF%BB/"/>
    
    
      <category term="Go-Programming-Patterns" scheme="http://example.com/tags/Go-Programming-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>Go编程模式 - 4.错误处理</title>
    <link href="http://example.com/2021/02/20/go-patterns/go-patterns-4/"/>
    <id>http://example.com/2021/02/20/go-patterns/go-patterns-4/</id>
    <published>2021-02-20T10:31:57.000Z</published>
    <updated>2021-03-29T12:51:46.960Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的<a href="https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save">链接</a>可能并不方便获取，所以我下载了一份<a href="https://github.com/Junedayday/code_reading/tree/master/doc/Go_Programming_Patterns.pdf">PDF</a>到git仓，方便大家阅读。我将结合自己的实际项目经历，与大家一起细品这份文档。</p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#Functional">函数式处理</a></li><li><a href="#ErrorObject">对象嵌入错误</a></li><li><a href="#Wrap">错误包装</a></li></ul><h2 id="Functional"><a href="#Functional" class="headerlink" title="Functional"></a>Functional</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Number <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">int</span></span><br><span class="line">b <span class="keyword">string</span></span><br><span class="line">c <span class="keyword">bool</span></span><br><span class="line">d []<span class="keyword">int32</span></span><br><span class="line">e error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Number)</span> <span class="title">parse</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := binary.Read(r, binary.BigEndian, &amp;n.a); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := binary.Read(r, binary.BigEndian, &amp;n.b); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := binary.Read(r, binary.BigEndian, &amp;n.c); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := binary.Read(r, binary.BigEndian, &amp;n.d); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := binary.Read(r, binary.BigEndian, &amp;n.e); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入了函数式编程的方式，我们看看有什么改变</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Number)</span> <span class="title">parse</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 先定义一个error</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数，注意这里的err的作用域是来自上面定义的</span></span><br><span class="line">read := <span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 先检查error，如果已经有错误则不检查</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = binary.Read(r, binary.BigEndian, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，这个函数的调用逻辑和之前的差别在于一点：</span></span><br><span class="line"><span class="comment">// 即使前面的发生了error，下面的函数也会被调用</span></span><br><span class="line">read(&amp;n.a)</span><br><span class="line">read(&amp;n.b)</span><br><span class="line">read(&amp;n.c)</span><br><span class="line">read(&amp;n.d)</span><br><span class="line">read(&amp;n.e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ErrorObject"><a href="#ErrorObject" class="headerlink" title="ErrorObject"></a>ErrorObject</h2><p>先看一个标准库中的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">input := bytes.NewReader([]<span class="keyword">byte</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描数据，这里不会直接返回错误</span></span><br><span class="line">scanner := bufio.NewScanner(input)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">token := scanner.Text()</span><br><span class="line">fmt.Println(token)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从Err()方法中获取错误</span></span><br><span class="line"><span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的根本思想，是将<code>error</code>嵌入到了对象中。那我们借鉴一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">r   io.Reader</span><br><span class="line">err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">read</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.err == <span class="literal">nil</span> &#123;</span><br><span class="line">r.err = binary.Read(r.r, binary.BigEndian, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Number)</span> <span class="title">parse</span><span class="params">(reader io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">r := Reader&#123;r: reader&#125;</span><br><span class="line"></span><br><span class="line">r.read(&amp;n.a)</span><br><span class="line">r.read(&amp;n.b)</span><br><span class="line">r.read(&amp;n.c)</span><br><span class="line">r.read(&amp;n.d)</span><br><span class="line">r.read(&amp;n.e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捎带提一句：个人不太喜欢上面<code>scanner</code>的错误处理方式，这个要求使用方对这个包很熟悉，否则很容易忘掉后面的错误处理逻辑。但后面处理错误的逻辑，就很直接地将错误返回，可读性很强。</p><h2 id="Wrap"><a href="#Wrap" class="headerlink" title="Wrap"></a>Wrap</h2><p>耗子叔给的例子是调用了<code>github.com/pkg/errors</code>下的wrap包，不过我更倾向于直接用原生的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 原始 error</span></span><br><span class="line">err := errors.New(<span class="string">&quot;level 1&quot;</span>)</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="comment">// level 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wrap一下error，注意error的占位符是%w</span></span><br><span class="line">wraped := fmt.Errorf(<span class="string">&quot;%v: %w&quot;</span>, <span class="string">&quot;level 2&quot;</span>, err)</span><br><span class="line">fmt.Println(wraped)</span><br><span class="line"><span class="comment">// level 2: level 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unwrap 后获得原来的错误</span></span><br><span class="line">unwraped := errors.Unwrap(wraped)</span><br><span class="line">fmt.Println(unwraped)</span><br><span class="line"><span class="comment">// level 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 过度unwrap会导致错误变成nil</span></span><br><span class="line">unwraped2 := errors.Unwrap(unwraped)</span><br><span class="line">fmt.Println(unwraped2)</span><br><span class="line"><span class="comment">// nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在实际项目实践中，<code>Wrap</code>的这个特性并不好用：</p><p>如何Wrap Error，在多人协同开发、多模块开发过程中，很难统一。而一旦不统一，容易出现示例中的过度Unwrap的情况。</p><p>所以，我认为与其花大精力在制定错误的标准上，还不如利用<code>fmt.Errorf</code>将错误信息直观地表述出来。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号：golangcoding</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的&lt;a href=&quot;https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save&quot;&gt;链接&lt;
      
    
    </summary>
    
      <category term="经典品读" scheme="http://example.com/categories/%E7%BB%8F%E5%85%B8%E5%93%81%E8%AF%BB/"/>
    
    
      <category term="Go-Programming-Patterns" scheme="http://example.com/tags/Go-Programming-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>Go编程模式 - 3.继承与嵌入</title>
    <link href="http://example.com/2021/02/20/go-patterns/go-patterns-3/"/>
    <id>http://example.com/2021/02/20/go-patterns/go-patterns-3/</id>
    <published>2021-02-20T10:31:54.000Z</published>
    <updated>2021-03-29T12:51:46.960Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的<a href="https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save">链接</a>可能并不方便获取，所以我下载了一份<a href="https://github.com/Junedayday/code_reading/tree/master/doc/Go_Programming_Patterns.pdf">PDF</a>到git仓，方便大家阅读。我将结合自己的实际项目经历，与大家一起细品这份文档。</p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#Embedded">嵌入和委托</a></li><li><a href="#IoC">反转控制</a></li></ul><h2 id="Embedded"><a href="#Embedded" class="headerlink" title="Embedded"></a>Embedded</h2><p>接口定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了两种interface</span></span><br><span class="line"><span class="keyword">type</span> Painter <span class="keyword">interface</span> &#123;</span><br><span class="line">Paint()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Clicker <span class="keyword">interface</span> &#123;</span><br><span class="line">Click()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Label 实现了 Painter</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准组件，用于嵌入</span></span><br><span class="line"><span class="keyword">type</span> Widget <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Label 实现了 Painter</span></span><br><span class="line"><span class="keyword">type</span> Label <span class="keyword">struct</span> &#123;</span><br><span class="line">Widget        <span class="comment">// Embedding (delegation)</span></span><br><span class="line">Text   <span class="keyword">string</span> <span class="comment">// Aggregation</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(label Label)</span> <span class="title">Paint</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p:Label.Paint(%q)\n&quot;</span>, &amp;label, label.Text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ListBox实现了Painter和Clicker</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListBox声明了Paint和Click，所以实现了Painter和Clicker</span></span><br><span class="line"><span class="keyword">type</span> ListBox <span class="keyword">struct</span> &#123;</span><br><span class="line">Widget          <span class="comment">// Embedding (delegation)</span></span><br><span class="line">Texts  []<span class="keyword">string</span> <span class="comment">// Aggregation</span></span><br><span class="line">Index  <span class="keyword">int</span>      <span class="comment">// Aggregation</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(listBox ListBox)</span> <span class="title">Paint</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;ListBox.Paint(%q)\n&quot;</span>, listBox.Texts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(listBox ListBox)</span> <span class="title">Click</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;ListBox.Click(%q)\n&quot;</span>, listBox.Texts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Button也实现了Painter和Clicker</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Button 继承了Label，所以直接实现了Painter</span></span><br><span class="line"><span class="comment">// 接下来，Button又声明了Paint和Click，所以实现了Painter和Clicker，其中Paint方法被覆</span></span><br><span class="line"><span class="keyword">type</span> Button <span class="keyword">struct</span> &#123;</span><br><span class="line">Label <span class="comment">// Embedding (delegation)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(button Button)</span> <span class="title">Paint</span><span class="params">()</span></span> &#123; <span class="comment">// Override</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Button.Paint(%s)\n&quot;</span>, button.Text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(button Button)</span> <span class="title">Click</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Button.Click(%s)\n&quot;</span>, button.Text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">label := Label&#123;Widget&#123;<span class="number">10</span>, <span class="number">70</span>&#125;, <span class="string">&quot;Label&quot;</span>&#125;</span><br><span class="line">button1 := Button&#123;Label&#123;Widget&#123;<span class="number">10</span>, <span class="number">70</span>&#125;, <span class="string">&quot;OK&quot;</span>&#125;&#125;</span><br><span class="line">button2 := Button&#123;Label&#123;Widget&#123;<span class="number">50</span>, <span class="number">70</span>&#125;, <span class="string">&quot;Cancel&quot;</span>&#125;&#125;</span><br><span class="line">listBox := ListBox&#123;Widget&#123;<span class="number">10</span>, <span class="number">40</span>&#125;,</span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">&quot;AL&quot;</span>, <span class="string">&quot;AK&quot;</span>, <span class="string">&quot;AZ&quot;</span>, <span class="string">&quot;AR&quot;</span>&#125;, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, painter := <span class="keyword">range</span> []Painter&#123;label, listBox, button1, button2&#125; &#123;</span><br><span class="line">painter.Paint()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, widget := <span class="keyword">range</span> []<span class="keyword">interface</span>&#123;&#125;&#123;label, listBox, button1, button2&#125; &#123;</span><br><span class="line"><span class="comment">// 默认都实现了Painter接口，可以直接调用</span></span><br><span class="line">widget.(Painter).Paint()</span><br><span class="line"><span class="keyword">if</span> clicker, ok := widget.(Clicker); ok &#123;</span><br><span class="line">clicker.Click()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子代码很多，我个人认为重点可以归纳为一句话：</p><p><strong>用嵌入实现方法的继承，减少代码的冗余度</strong></p><p>耗子叔的例子很精彩，不过我个人不太喜欢<code>interface</code>这个数据类型（main函数中），有没有什么优化的空间呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义两种方法的组合</span></span><br><span class="line"><span class="keyword">type</span> PaintClicker <span class="keyword">interface</span> &#123;</span><br><span class="line">Painter</span><br><span class="line">Clicker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 在上面的例子中，interface传参其实不太优雅，有没有更优雅的实现呢？那就用组合的interface</span></span><br><span class="line"><span class="keyword">for</span> _, widget := <span class="keyword">range</span> []PaintClicker&#123;listBox, button1, button2&#125; &#123;</span><br><span class="line">widget.Paint()</span><br><span class="line">widget.Click()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p>先看一个Int集合的最基本实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Int集合，用于最基础的增删查</span></span><br><span class="line"><span class="keyword">type</span> IntSet <span class="keyword">struct</span> &#123;</span><br><span class="line">data <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIntSet</span><span class="params">()</span> <span class="title">IntSet</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> IntSet&#123;<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *IntSet)</span> <span class="title">Add</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123; set.data[x] = <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *IntSet)</span> <span class="title">Delete</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123; <span class="built_in">delete</span>(set.data, x) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *IntSet)</span> <span class="title">Contains</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> set.data[x] &#125;</span><br></pre></td></tr></table></figure><p>现在，需求来了，我们希望对这个Int集合的操作是可撤销的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可撤销的Int集合，依赖于IntSet，我们看看基本实现</span></span><br><span class="line"><span class="keyword">type</span> UndoableIntSet <span class="keyword">struct</span> &#123; <span class="comment">// Poor style</span></span><br><span class="line">IntSet    <span class="comment">// Embedding (delegation)</span></span><br><span class="line">functions []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUndoableIntSet</span><span class="params">()</span> <span class="title">UndoableIntSet</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> UndoableIntSet&#123;NewIntSet(), <span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增</span></span><br><span class="line"><span class="comment">// 不存在元素时：添加元素，并新增撤销函数：删除</span></span><br><span class="line"><span class="comment">// 存在元素时：不做任何操作，并新增撤销函数：空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *UndoableIntSet)</span> <span class="title">Add</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// Override</span></span><br><span class="line"><span class="keyword">if</span> !set.Contains(x) &#123;</span><br><span class="line">set.data[x] = <span class="literal">true</span></span><br><span class="line">set.functions = <span class="built_in">append</span>(set.functions, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; set.Delete(x) &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">set.functions = <span class="built_in">append</span>(set.functions, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除，与新增相反</span></span><br><span class="line"><span class="comment">// 存在元素时：删除元素，并新增撤销函数：新增</span></span><br><span class="line"><span class="comment">// 不存在元素时：不做任何操作，并新增撤销函数：空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *UndoableIntSet)</span> <span class="title">Delete</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// Override</span></span><br><span class="line"><span class="keyword">if</span> set.Contains(x) &#123;</span><br><span class="line"><span class="built_in">delete</span>(set.data, x)</span><br><span class="line">set.functions = <span class="built_in">append</span>(set.functions, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; set.Add(x) &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">set.functions = <span class="built_in">append</span>(set.functions, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 撤销：执行最后一个撤销函数function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *UndoableIntSet)</span> <span class="title">Undo</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(set.functions) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;No functions to undo&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">index := <span class="built_in">len</span>(set.functions) - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> function := set.functions[index]; function != <span class="literal">nil</span> &#123;</span><br><span class="line">function()</span><br><span class="line">set.functions[index] = <span class="literal">nil</span> <span class="comment">// For garbage collection</span></span><br><span class="line">&#125;</span><br><span class="line">set.functions = set.functions[:index]</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实现是一种顺序逻辑的思路，整体还是挺麻烦的。有没有优化思路呢？</p><p>定义一下Undo这个结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Undo []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(undo *Undo)</span> <span class="title">Add</span><span class="params">(function <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">*undo = <span class="built_in">append</span>(*undo, function)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(undo *Undo)</span> <span class="title">Undo</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">functions := *undo</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(functions) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;No functions to undo&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">index := <span class="built_in">len</span>(functions) - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> function := functions[index]; function != <span class="literal">nil</span> &#123;</span><br><span class="line">function()</span><br><span class="line">functions[index] = <span class="literal">nil</span> <span class="comment">// For garbage collection</span></span><br><span class="line">&#125;</span><br><span class="line">*undo = functions[:index]</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细品一下这里的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSet2 <span class="keyword">struct</span> &#123;</span><br><span class="line">data <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span></span><br><span class="line">undo Undo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIntSet2</span><span class="params">()</span> <span class="title">IntSet2</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> IntSet2&#123;data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *IntSet2)</span> <span class="title">Undo</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> set.undo.Undo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *IntSet2)</span> <span class="title">Contains</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> set.data[x]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *IntSet2)</span> <span class="title">Add</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !set.Contains(x) &#123;</span><br><span class="line">set.data[x] = <span class="literal">true</span></span><br><span class="line">set.undo.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; set.Delete(x) &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">set.undo.Add(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *IntSet2)</span> <span class="title">Delete</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> set.Contains(x) &#123;</span><br><span class="line"><span class="built_in">delete</span>(set.data, x)</span><br><span class="line">set.undo.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; set.Add(x) &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">set.undo.Add(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一下，这块代码的前后逻辑有了啥变化：</p><ol><li>之前，撤销函数是在Add/Delete时添加的，函数中包含了IntSet的操作，也就是 <strong>Undo依赖IntSet</strong></li><li>而修改之后，撤销函数被抽象为Undo，撤销相关的工作直接调用Undo相关的工作即可，也就是 <strong>IntSet依赖Undo</strong></li></ol><p>我们再来分析一下</p><ul><li>Undo是控制逻辑 - 撤销动作</li><li>IntSet是业务逻辑 - 保存数据的功能。</li></ul><p><strong>业务逻辑依赖控制逻辑，才能保证在复杂业务逻辑变化场景下，代码更健壮！</strong></p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili：<a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号：golangcoding</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 注：本文的灵感来源于GOPHER 2020年大会陈皓的分享，原PPT的&lt;a href=&quot;https://www2.slideshare.net/haoel/go-programming-patterns?from_action=save&quot;&gt;链接&lt;
      
    
    </summary>
    
      <category term="经典品读" scheme="http://example.com/categories/%E7%BB%8F%E5%85%B8%E5%93%81%E8%AF%BB/"/>
    
    
      <category term="Go-Programming-Patterns" scheme="http://example.com/tags/Go-Programming-Patterns/"/>
    
  </entry>
  
</feed>
