<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Junedayday Blog</title>
  
  <subtitle>六月天天的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-02-27T14:05:47.825Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Junedayday</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【每周小结】2023-Week9</title>
    <link href="http://example.com/2023/02/26/weekly/weekly-2023-9/"/>
    <id>http://example.com/2023/02/26/weekly/weekly-2023-9/</id>
    <published>2023-02-26T10:00:00.000Z</published>
    <updated>2023-02-27T14:05:47.825Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><span id="more"></span><h2 id="Go技巧-快速学习官方库ast"><a href="#Go技巧-快速学习官方库ast" class="headerlink" title="Go技巧 - 快速学习官方库ast"></a>Go技巧 - 快速学习官方库<code>ast</code></h2><p>当我们谈及<code>Go</code>语言底层时，往往会聊<code>GMP</code>相关的并发原理，或者是以<code>reflect</code>为代表的反射处理，它们也是面试中的常客。</p><p>而我今天想推荐的一个底层库 - <code>ast</code>，全名抽象语法树（abstract syntax tree），不仅能让我们进一步掌握<code>Go</code>的基础语法，更是一个开发<strong>标准化</strong>和<strong>提效</strong>工具的关键技能。</p><h3 id="AST的基本概念"><a href="#AST的基本概念" class="headerlink" title="AST的基本概念"></a>AST的基本概念</h3><p><code>ast</code>的官方概念理解起来比较复杂，有兴趣的可以参考<a href="https://zhuanlan.zhihu.com/p/28516587">这篇知乎</a>，或者阅读更专业的资料。</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/20230224211609.png"></p><p>对初学者来说，抓住上图中的两个关键因素：</p><ol><li>树 - 了解树相关的深度遍历算法</li><li>节点 - 各语法特征，如变量、条件语句等</li></ol><h3 id="Go的AST节点类型"><a href="#Go的AST节点类型" class="headerlink" title="Go的AST节点类型"></a>Go的AST节点类型</h3><p>学习<code>ast</code>，从它底层的数据定义入手会让我们事半功倍。</p><p><code>ast</code>语法的核心抽象是<code>Node</code>，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">interface</span> &#123;</span><br><span class="line">Pos() token.Pos <span class="comment">// 起始定义的位置</span></span><br><span class="line">End() token.Pos <span class="comment">// 结束定义的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用就是解析出对应语法的位置。整个<code>Node</code>相关的接口与实现比较复杂，我以网上的一个版本为例：</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/ast-tree.jpeg"></p><p>整个语法树很庞杂，每个接口与结构体都有自己的一些特点。为了方便大家加深这部分的理解，我们从一个具体的case入手</p><h3 id="AST的示例代码"><a href="#AST的示例代码" class="headerlink" title="AST的示例代码"></a>AST的示例代码</h3><p>示例代码如下，即解析本身main.go文件，打印出import的库与类型定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go/ast&quot;</span></span><br><span class="line"><span class="string">&quot;go/parser&quot;</span></span><br><span class="line"><span class="string">&quot;go/token&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义解析的具体文件</span></span><br><span class="line">fSet := token.NewFileSet()</span><br><span class="line">f, err := parser.ParseFile(fSet, <span class="string">&quot;main.go&quot;</span>, <span class="literal">nil</span>, parser.ParseComments)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 怎么解析 - 用visit对象去Walk(遍历)对应文件</span></span><br><span class="line">visit := &amp;MyVisitor&#123;&#125;</span><br><span class="line">ast.Walk(visit, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyVisitor <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vi *MyVisitor)</span> <span class="title">Visit</span><span class="params">(node ast.Node)</span> <span class="title">ast</span>.<span class="title">Visitor</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> node.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *ast.ImportSpec:</span><br><span class="line"><span class="comment">// import库</span></span><br><span class="line">fmt.Println(node.(*ast.ImportSpec).Path.Value)</span><br><span class="line"><span class="keyword">case</span> *ast.TypeSpec:</span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line">fmt.Println(node.(*ast.TypeSpec).Name.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余语法的使用，大家可以参考前面图中的<code>Node</code>接口与实现的定义，对照着实现。</p><p>为了加深大家对<code>ast</code>这棵树的理解，我们再细化一下上面的例子。</p><h3 id="AST的两种处理思路"><a href="#AST的两种处理思路" class="headerlink" title="AST的两种处理思路"></a>AST的两种处理思路</h3><p>示例中的<code>import</code>代码，即</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go/ast&quot;</span></span><br><span class="line"><span class="string">&quot;go/parser&quot;</span></span><br><span class="line"><span class="string">&quot;go/token&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>它对应的<code>ast</code>中的结构体是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GenDecl <span class="keyword">struct</span> &#123;</span><br><span class="line">Doc    *CommentGroup <span class="comment">// associated documentation; or nil</span></span><br><span class="line">TokPos token.Pos     <span class="comment">// position of Tok</span></span><br><span class="line">Tok    token.Token   <span class="comment">// IMPORT, CONST, TYPE, or VAR</span></span><br><span class="line">Lparen token.Pos     <span class="comment">// position of &#x27;(&#x27;, if any</span></span><br><span class="line">Specs  []Spec</span><br><span class="line">Rparen token.Pos <span class="comment">// position of &#x27;)&#x27;, if any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而每个import选项，则是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象</span></span><br><span class="line"><span class="keyword">type</span> Spec <span class="keyword">interface</span> &#123;</span><br><span class="line">Node</span><br><span class="line">specNode()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">type</span> ImportSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">Doc     *CommentGroup <span class="comment">// associated documentation; or nil</span></span><br><span class="line">Name    *Ident        <span class="comment">// local package name (including &quot;.&quot;); or nil</span></span><br><span class="line">Path    *BasicLit     <span class="comment">// import path</span></span><br><span class="line">Comment *CommentGroup <span class="comment">// line comments; or nil</span></span><br><span class="line">EndPos  token.Pos     <span class="comment">// end of spec (overrides Path.Pos if nonzero)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，我们可以有两种方式来访问到每个<code>ImportSpec</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vi *MyVisitor)</span> <span class="title">Visit</span><span class="params">(node ast.Node)</span> <span class="title">ast</span>.<span class="title">Visitor</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> node.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="comment">// 方法1 - 直接处理下层的叶子节点</span></span><br><span class="line"><span class="keyword">case</span> *ast.ImportSpec:</span><br><span class="line"><span class="comment">// import库</span></span><br><span class="line">fmt.Println(node.(*ast.ImportSpec).Path.Value)</span><br><span class="line"><span class="comment">// 方法2 - 先解析出上层节点，再处理下层节点</span></span><br><span class="line"><span class="keyword">case</span> *ast.GenDecl:</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> node.(*ast.GenDecl).Specs &#123;</span><br><span class="line"><span class="keyword">switch</span> v.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *ast.ImportSpec:</span><br><span class="line">fmt.Println(v.(*ast.ImportSpec).Path.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在用<code>ast</code>编写相关工具时，我建议优先按思路2去编写代码，它的优势在于两点：</p><ol><li><strong>扩大上下文信息</strong> - 除了基本的<code>ImportSpec</code>，还可以使用父节点<code>GenDecl</code>中的共用信息</li><li><strong>代码可读性高</strong> - 先处理父节点，解析到具体的结构体，再进行各个子节点的处理，思路很自然</li></ol><p>当整个<code>Visit</code>处理的内容比较多时，就需要进行一定的拆分，用<strong>递归</strong>来减少复杂度。</p><h3 id="AST在日常工作中的使用示例"><a href="#AST在日常工作中的使用示例" class="headerlink" title="AST在日常工作中的使用示例"></a>AST在日常工作中的使用示例</h3><p><code>ast</code>的特性看起来很酷，但很少会直接应用在项目的代码里。</p><p>不过，作为官方支持、可用来分析<code>Go</code>代码的库，它常用于制作二进制工具，在不同的场景使用：</p><ol><li><strong>进阶性的代码规范性检查</strong> - 如检查某层代码的import情况，保证分层规范</li><li><strong>自定义的代码生成</strong> - 如根据注释自动生成定义，根据方法生成mock接口</li><li><strong>编译前统一对库或方法的替换</strong> - 在编译前，对某些特定的库或方法进行替换，修改原<code>go</code>文件</li></ol><p>在优秀的框架中，<code>ast</code>往往与标准化相辅相成，形成正反馈：<strong>代码标准化的程度越高，<code>ast</code>就越能提升自动化、保障质量；<code>ast</code>应用得越广泛，代码的标准化程度自然就越高</strong>。</p><h2 id="编程思考-业务也是技术人员的核心能力"><a href="#编程思考-业务也是技术人员的核心能力" class="headerlink" title="编程思考 - 业务也是技术人员的核心能力"></a>编程思考 - 业务也是技术人员的核心能力</h2><p>最近，为了项目的推进，我和大量的开发人员进行了沟通，发现部分新人对“业务”的认知有明显偏差。</p><p>技术有两个极致的方向：</p><ol><li>底层理论性的研究</li><li>面向业务的trade-off</li></ol><p>前者是为技术领域开辟新的领域，只有极少的研究员会参与这类工作；而面向业务的trade-off则是大多数开发者能接触到的终极目标，难点往往在于：</p><ol><li>技术储备广 - 有多样的解决方案，各有利弊</li><li>业务认知深 - 洞察业务的核心价值</li><li>技术 ✖️ 业务 - 两者结合时的决策能力</li></ol><p><strong>技术是开发者的立身之本，而业务是公司的立身之本。</strong> 优秀的开发者并不在于能想出100个技术方案，而是能提出3个各有利弊的关键技术方案、并且能根据业务情况给出自己的意见。</p><h2 id="工作生活-如果无法理解，也请包容他人"><a href="#工作生活-如果无法理解，也请包容他人" class="headerlink" title="工作生活 - 如果无法理解，也请包容他人"></a>工作生活 - 如果无法理解，也请包容他人</h2><p>我有段时间心理洁癖非常严重：我会尝试各种方法、各种角度去理解一些人，但如果用尽方法、仍无法理解对方的所作所为，我就会对其非常反感（当然，这样的人是极少数的）。</p><p>理解是一个很理想的方式，能让我更深刻地了解对方，也更适合深度、长期的关系。但在现实生活中，我们很难投入那么多的时间与情绪去熟悉每个人，也因不可避免的个人认知偏差导致误会。</p><p>所以，在和大部分人相处时，包容是一种让自己更轻松的方式。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>【每周小结】2023-Week8</title>
    <link href="http://example.com/2023/02/19/weekly/weekly-2023-8/"/>
    <id>http://example.com/2023/02/19/weekly/weekly-2023-8/</id>
    <published>2023-02-19T10:00:00.000Z</published>
    <updated>2023-02-21T13:16:52.242Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><p>这段时间，我在尝试着远离抖音、B站、头条等消息媒介。</p><p>这些平台承载了过多大数据推荐算法，反复向人们推送着高度重复性的内容，脱离了获取信息的初衷 - <strong>扩大自己的认知面</strong>。如果你关注的内容包括了失业等负面内容，还容易加强你的焦虑感。</p><span id="more"></span><h2 id="Go技巧-结构体的赋值小技巧"><a href="#Go技巧-结构体的赋值小技巧" class="headerlink" title="Go技巧 - 结构体的赋值小技巧"></a>Go技巧 - 结构体的赋值小技巧</h2><p>在日常的CRUD开发过程中，我们往往会用到一些结构体：它们只是一些简单的数据的组合，很难用对象来封装。比如说，有一个订单表，里面包括20+个field。当我们创建时，就需要对这些field赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 包括近20个字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们来看三种常见的方法，并分析各自的利弊：</p><h3 id="方案1-全量透传结构体"><a href="#方案1-全量透传结构体" class="headerlink" title="方案1-全量透传结构体"></a>方案1-全量透传结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据从http body中解析出来</span></span><br><span class="line"><span class="keyword">var</span> b []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析到order</span></span><br><span class="line"><span class="keyword">var</span> order = <span class="built_in">new</span>(Order)</span><br><span class="line">json.Unmarshal(b, &amp;order)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建到数据库</span></span><br><span class="line">db.Insert(order)</span><br></pre></td></tr></table></figure><p>这种思路确实非常方便，但仅限于轻量级项目。</p><p>如果业务逻辑稍微复杂点，就会出现无法支持的情况。问题的根本在于：<strong>在程序的不同层面，结构体各有各的使用场景，像传输效率、安全、性能等</strong>。</p><blockquote><p>最经典的莫过于时间类型的参数：在数据库保存为<code>timestamp</code>格式，而在接口层往往是<code>YYYY-MM-DD hh:mm:ss</code>或<code>int64</code>类型，无法用透传实现。</p></blockquote><h3 id="方案2-用一个通用库解决问题"><a href="#方案2-用一个通用库解决问题" class="headerlink" title="方案2-用一个通用库解决问题"></a>方案2-用一个通用库解决问题</h3><p>既然我们要从一个结构体转成另一个结构体，就自然产生了一个想法 - 写个通用库。</p><p>常见的实现思路有2种：序列化工具或发射。这里以序列化工具为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源结构体，来自http</span></span><br><span class="line"><span class="keyword">type</span> OrderDTO <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 目标结构体，保存到MySQL</span></span><br><span class="line"><span class="keyword">type</span> OrderDao <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> order *orderDTO</span><br><span class="line">b, err := json.Marshal(order)</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">new</span>(OrderDao)</span><br><span class="line">err = json.Unmarshal(b, target)</span><br></pre></td></tr></table></figure><p>这种思路在编写代码时确实方便，但是，长期来看有两大隐患：</p><ol><li>中间操作的性能可能成为性能瓶颈</li><li>两个结构体不一定能保证一致，如数据库里叫<code>name</code>，但接口则叫<code>order_name</code></li></ol><p>尤其是第二点，使得通用库变得不再通用，就会出现一些tricky的实现，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`json:&quot;order_name&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式很容易在未来成为一个埋雷点。随着通用库的封装，埋雷越来越多，往往就变得不可维护了。</p><h3 id="方案3-傻瓜式赋值"><a href="#方案3-傻瓜式赋值" class="headerlink" title="方案3-傻瓜式赋值"></a>方案3-傻瓜式赋值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transfer</span><span class="params">(from *orderDTO)</span> <span class="params">(to *OrderDao)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> OrderDao &#123;</span><br><span class="line">  Id:          from.Id,</span><br><span class="line">  Name:        from.OrderName,</span><br><span class="line">  CreateTime:  from.CreateTime.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>),</span><br><span class="line">  Cost:        from.EndTime.Sub(from.StartTime).Seconds(),</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样的代码写起来很累，但对阅读者来说是非常方便的（往往封装成一个函数，放在文件末尾即可）。在开发与排查问题的过程中，它有三个优点无可比拟：</p><ol><li><strong>填充逻辑清晰</strong>：数据源来自哪个字段，又被填充到了哪个字段，一目了然</li><li><strong>灵活自定义加工</strong>：如代码中时间<code>CreateTime</code>的格式化，以及耗时<code>Cost</code>的逻辑计算</li><li><strong>兼容性与安全性高</strong>：两个结构体的变更，要么不影响这个转换逻辑（兼容性高，如新增字段），要么就会编译报错（安全性高，如修改相关字段的名称或类型）</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在我开发<code>Go</code>语言的近六年时间里，看到相关的代码风格远不止这3种。通过反反复复倒腾，我认为代码可维护性最为重要，所以更倾向于 <strong>傻瓜式赋值</strong> 这个方法，哪怕牺牲一部分效率也是值得的（在IDE的帮助下，其实效率几乎没有影响）。</p><p>你的想法又是怎么样呢？欢迎与我交流沟通。</p><h2 id="编程思考-重视技术评审的过程性价值"><a href="#编程思考-重视技术评审的过程性价值" class="headerlink" title="编程思考 - 重视技术评审的过程性价值"></a>编程思考 - 重视技术评审的过程性价值</h2><p>我们模拟个场景：你写了一个自认为 <strong>当下最优解的技术方案</strong>，信心满满地拿出来评审，结果遭到各方的挑战，无法回答清楚很多问题，心里忿忿不平；评审后仍按你的方案执行，结果出来也很不错，你就觉得当时提问的那些评委都不如你。</p><p>相信很多人都有这样的经历，我也相当一段时间处于这种状态。不过，现在的我更愿意静下心，去关注过程里的一些内容：</p><ul><li>评委提出的“无意义”问题，是否有一部分来源于我叙述的不清楚？尤其是背景</li><li>评委们关心的角度是否与我的视角有差异？比如我更关心代码实现，而评委关注的是业务、稳定性、安全等</li><li>你获得的成果，是否仍有改进空间？适当地收集一些评委意见，弥补个人视角的盲区</li></ul><p>技术评审的主要价值是 <strong>优化方案</strong>。作为评审方，大部分的评委在多方面的能力都是高于本人的。如果你抱着“评委就是跟我过不去、就是乱挑刺”的想法去面对他们，那么对你来说就是浪费时间。</p><p>如果真有这么一个瞎挑刺的评委、他又是你工作中绕不过的领导，那该怎么办呢？退而求其次，技术评审还提供了一个交流的机会，你可以尝试着摸清他的一些思路，想想如何与其相处，<strong>为自己营造更轻松的工作环境</strong>。</p><h2 id="工作生活-主动创造美好瞬间"><a href="#工作生活-主动创造美好瞬间" class="headerlink" title="工作生活 - 主动创造美好瞬间"></a>工作生活 - 主动创造美好瞬间</h2><p>这个小标题起得有点煽情。</p><p>我想表达的是：在年轻时，我们可以肆意地享受人生的美好。但随着时间推移，我们往往会被家庭琐事、工作压力、身体健康等问题困扰，这就需要我们从被动的享受、慢慢地转变为主动创造，这样就能大幅提高生活的幸福感。</p><p>而且，我们创造的美好瞬间能让家人与朋友同样感受到快乐，提高整个圈子的幸福感；而整体氛围的提升，往往能形成正反馈，收益人也包括了你。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这段时间，我在尝试着远离抖音、B站、头条等消息媒介。&lt;/p&gt;
&lt;p&gt;这些平台承载了过多大数据推荐算法，反复向人们推送着高度重复性的内容，脱离了获取信息的初衷 - &lt;strong&gt;扩大自己的认知面&lt;/strong&gt;。如果你关注的内容包括了失业等负面内容，还容易加强你的焦虑感。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>【每周小结】2023-Week7</title>
    <link href="http://example.com/2023/02/12/weekly/weekly-2023-7/"/>
    <id>http://example.com/2023/02/12/weekly/weekly-2023-7/</id>
    <published>2023-02-12T10:00:00.000Z</published>
    <updated>2023-02-15T04:51:58.773Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><p>本周的总结发得比较晚，花在打磨编程思考部分的时间比较多。</p><p>虽然最终版本也不是很满意，不过也算达到了阶段性交付的水平。</p><span id="more"></span><h2 id="Go技巧-并发代码的单元测试"><a href="#Go技巧-并发代码的单元测试" class="headerlink" title="Go技巧 - 并发代码的单元测试"></a>Go技巧 - 并发代码的单元测试</h2><p>在<code>Go</code>语言开发的过程中，我们或多或少会引入并发模式，常见的如<code>go</code>、<code>channel</code>、<code>sync.WaitGroup</code>等。这些并发原语使用起来很方便，但常常会阻碍相关代码的单元测试，如依赖的<code>channel</code>发生阻塞，<code>mutex</code>被锁等，导致想验证的重要代码根本跑不到。</p><p>这里，我介绍一下自己的三个心得，用一句话概括，<strong>合理利用分层进行拆分，屏蔽并发逻辑</strong>。</p><blockquote><p>没有分层的基础或工具库不在本次的讨论范围内，但也可以借鉴这里的思想。</p></blockquote><h3 id="多协程的逻辑交由上层控制"><a href="#多协程的逻辑交由上层控制" class="headerlink" title="多协程的逻辑交由上层控制"></a>多协程的逻辑交由上层控制</h3><p>如下，原先的业务逻辑代码包括了两块处理逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 逻辑A</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑B</span></span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于逻辑B相关的代码无法验证，所以这个单元测试能做的很有限。这时，通过分层，我们将代码拆分为两部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上层代码 - 使用基础的并发特性，没有必要做单元测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  FooA()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">go</span> FooB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下层代码 - 做严格的单元测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FooA</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FooB</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的单元测试就变得直观了。</p><h3 id="锁类逻辑由下层对象封装"><a href="#锁类逻辑由下层对象封装" class="headerlink" title="锁类逻辑由下层对象封装"></a>锁类逻辑由下层对象封装</h3><p>业务代码常常会包含锁，这就导致很多函数中有大量的<code>Lock</code>、<code>UnLock</code>操作，容易在单元测试里验证一些逻辑时发生死锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// do a</span></span><br><span class="line">  m.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.UnLock()</span><br><span class="line">  <span class="comment">// do b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从抽象层面来说，业务逻辑的核心代码尽量减少锁这种 <strong>底层的并发原语</strong>，把它们放在业务逻辑里也很影响阅读体验。这时，将锁划分到下层会让代码逻辑更清晰：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下层对象</span></span><br><span class="line"><span class="keyword">type</span> FooA <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FooB <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 锁</span></span><br><span class="line">  sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 这里不包含锁逻辑</span></span><br><span class="line">  fooA.Do()</span><br><span class="line">  <span class="comment">// 这里包含锁逻辑</span></span><br><span class="line">  fooB.DO()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从使用锁的角度来说，<code>Lock</code>与<code>UnLock</code>之间的逻辑应尽量短，所以很适合放在底层对象、交由它自行控制，也能缩短锁的影响范围。</p><h3 id="同层抽离出核心控制函数"><a href="#同层抽离出核心控制函数" class="headerlink" title="同层抽离出核心控制函数"></a>同层抽离出核心控制函数</h3><p>在<code>Go</code>语言中，有一些并发特性、尤其以<code>channel</code>为代表，很难通过分层解决。例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">  <span class="comment">// 发送消息</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// send to c</span></span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 接收消息</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// receive from c</span></span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>channel</code>更多的是一种具有业务特性的并发控制，单独抽出一个 <strong>核心控制函数</strong> 就能提升整体的可读性与可测试性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心控制函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送逻辑</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := logicA()</span><br><span class="line">    c &lt;- a</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 接收逻辑</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := &lt;- c</span><br><span class="line">    logicB(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下逻辑均不包含channel，方便单元测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logicA</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logicB</span><span class="params">(a <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心控制函数很难通过单元测试完整验证，更考验的是开发人员对<code>Go</code>并发编程的基本功。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上三点是我在工作过程中的经验心得，帮助我解决了很多并发代码中的单元测试问题。它们不一定是最佳实践，但希望能对各位遇到相关问题时有一些启发。</p><h2 id="编程思考-平台开发的三个阶段"><a href="#编程思考-平台开发的三个阶段" class="headerlink" title="编程思考 - 平台开发的三个阶段"></a>编程思考 - 平台开发的三个阶段</h2><p>如今， <strong>平台开发</strong> 这个词已经广泛应用在程序员圈子内。在我看来，相关的开发者可以分为三个阶段：</p><ol><li><strong>初级阶段</strong>：根据用户的需求明细写过程性的CRUD，实现功能</li><li><strong>中级阶段</strong>：以<code>OpenAPI</code>的方式向多业务、多用户提供能力</li><li><strong>高级阶段</strong>：定制核心能力+复用通用能力</li></ol><p>其中，很多人往往走到中级阶段后就阻塞不前了，并且心得意满、认为平台的已经处于最终形态。但是，平台如果长期处于中级阶段，相关弊端会随着时间推移越发凸显，例如：</p><ul><li>没有技术壁垒 - 越是通用，越是普通，很容易被开源产品取代</li><li>调用方的使用成本高 - 开放接口往往透传各类参数，使用方成本高</li><li>无法贴合一线业务创造价值 - 平台以甲方自居，不去理解业务的使用场景</li></ul><p>我见过许多工作了近10年仍处于中级阶段的工程师，他们的技术能力十分高超，但很难在职业发展的道路上再进一步，关键就是在于对平台的认知 - <strong>平台的核心价值是靠 为业务创造的价值 来间接体现的，而不是靠 平台自身的能力 来直接评价</strong>。</p><h2 id="工作生活-少给自己找借口的机会"><a href="#工作生活-少给自己找借口的机会" class="headerlink" title="工作生活 - 少给自己找借口的机会"></a>工作生活 - 少给自己找借口的机会</h2><p>年后，我完整地跑了2次十公里，过程中也有近10次跑了不到一半就放弃。我的跑步配速不快，理应每次都能达成目标，那为什么还有这么多次半途而废呢？</p><p>我回顾了这几次的经历，总结如下：<strong>一旦我想要中途放弃，借口总是能找到的；所以，在整个跑步的过程中，保持一个稳定、平和的心态，不要让放弃的想法有可趁之机。</strong> </p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;本周的总结发得比较晚，花在打磨编程思考部分的时间比较多。&lt;/p&gt;
&lt;p&gt;虽然最终版本也不是很满意，不过也算达到了阶段性交付的水平。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>【每周小结】2023-Week6</title>
    <link href="http://example.com/2023/02/05/weekly/weekly-2023-6/"/>
    <id>http://example.com/2023/02/05/weekly/weekly-2023-6/</id>
    <published>2023-02-05T10:00:00.000Z</published>
    <updated>2023-02-07T02:10:36.455Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><p>本周开始，绝大多数人的工作与生活步入了常规模式。</p><p>希望大家的身体与心理都能尽快地适应工作或学习节奏，保持一颗愉悦的心情。</p><span id="more"></span><h2 id="Go技巧-浅谈1-20版本特性"><a href="#Go技巧-浅谈1-20版本特性" class="headerlink" title="Go技巧 - 浅谈1.20版本特性"></a>Go技巧 - 浅谈1.20版本特性</h2><p>本周<code>Go</code>语言<a href="https://tip.golang.org/doc/go1.20">1.20版本正式发布</a>，我们对其重要特性进行简单分析，为后续掌握<code>Go</code>的发展脉络做好铺垫。</p><h3 id="切片转数组"><a href="#切片转数组" class="headerlink" title="切片转数组"></a>切片转数组</h3><p>在1.17版本时，切换转数组的<a href="https://tip.golang.org/ref/spec#Conversions_from_slice_to_array_or_array_pointer">语法</a>已经支持，只是写起来比较冗余。在这次1.20版本进行了优化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更早版本 - 手工填充</span></span><br><span class="line"><span class="keyword">var</span> s = [<span class="number">4</span>]<span class="keyword">byte</span>&#123;x[<span class="number">0</span>],x[<span class="number">1</span>],x[<span class="number">2</span>],x[<span class="number">3</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go1.17 - 指针操作</span></span><br><span class="line"><span class="keyword">var</span> s = *(*[<span class="number">4</span>]<span class="keyword">byte</span>)(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go1.20 - 直接类型转换</span></span><br><span class="line"><span class="keyword">var</span> s = [<span class="number">4</span>]<span class="keyword">byte</span>(x)</span><br></pre></td></tr></table></figure><p>这个语法本身没有太多的学习成本，但官方在此时才完全支持，这就导致：<strong>在1.17版本前的绝大多数开发场景下，<code>Go</code>开发者都更愿意用更灵活的切片来代替数组</strong>。但相较于切片，固定长度的数组对节约内存更为友好。</p><p>而随着1.20版本的推出，使用数组的语法便利性大幅提高，相信会有更多追求极致性能的人开始引入数组。</p><h3 id="unsafe三个新函数"><a href="#unsafe三个新函数" class="headerlink" title="unsafe三个新函数"></a>unsafe三个新函数</h3><p>unsafe中提供了三个新函数：<code>SliceData</code>、<code>String</code>和<code>StringData</code>。</p><p>这三个函数是低频使用的，我们按需阅读<a href="https://pkg.go.dev/unsafe">官方文档</a>即可。如果你对<strong>指针</strong>的相关知识基础扎实，很容易理解这三个函数。</p><h3 id="时间常量的定义"><a href="#时间常量的定义" class="headerlink" title="时间常量的定义"></a>时间常量的定义</h3><p>终于，在1.20版本引入了开发者最常用的<a href="https://pkg.go.dev/time#pkg-constants">时间戳格式</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DateTime   = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br></pre></td></tr></table></figure><p>经历了多少次手写时间，查找了多少个相关的低级bug，官方终于把这个时间格式放到了标准库中。强烈建议升级到1.20版本的项目，先做一次变量的全局替换。</p><p>这里分享一个小tip：如何记忆这个时间戳？记住1~6：</p><ul><li>1月</li><li>2日</li><li>下午3点</li><li>4分</li><li>5秒</li><li>06年</li></ul><h3 id="error的组合"><a href="#error的组合" class="headerlink" title="error的组合"></a>error的组合</h3><p>标准库中的<code>error</code>支持了组合的能力，扩展了错误的使用场景。</p><p>例如，程序发生了错误，从开发者来看，既有属于数据库的错误A，又有属于业务逻辑的错误B。在上层用<code>errors.Is</code>判定时，只能在A与B中二选一。而1.20则引入了<code>Join</code>类型，则可以将两个错误组合起来，上层判断时两个都成立。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errA error</span><br><span class="line"><span class="keyword">var</span> errB error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合错误</span></span><br><span class="line"><span class="keyword">var</span> err = errors.Join(errA, errB)</span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>更新<strong>结构体比较</strong>的规范的说明（严格来说是修正了不严谨的说明，代码已经实现）</li><li>泛型类型对<code>Comparable</code>更多的支持</li><li><code>Go</code>后续支持各操作系统的计划</li><li>相关工具链的优化</li><li>编译速度提升，达到差不多引入泛型前的水平</li><li>运行时提升CPU效率约2%</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从近几个版本的迭代来看，<code>Go</code>官方一直关注前后版本兼容性，这对开发者来说体验是很棒的。官方把主要精力花在了两个方面：</p><ol><li>相关工具与库的建设，完善基本开发的生态</li><li>底层能力（如编译）的建设</li></ol><p>可见，<code>Go</code>团队通过前期的设计，帮助我们屏蔽了下层的细节，是一个很棒的编程体验。</p><h2 id="编程思考-对成长来说，划分边界是为了扩大边界"><a href="#编程思考-对成长来说，划分边界是为了扩大边界" class="headerlink" title="编程思考 - 对成长来说，划分边界是为了扩大边界"></a>编程思考 - 对成长来说，划分边界是为了扩大边界</h2><p>在编程开发中，有许多划分边界的事情，如：</p><ol><li>代码的模块划分</li><li>微服务的划分</li><li>业务领域的划分</li><li>网络的分层</li></ol><p>划分边界后就有了分工，优秀的分工协作可以带来组织效率的提升。但是，随着日复一日的重复性工作，很容易就只专注于自己职责范围内的部分，而忽略了相关方。近几年，许多公司倡导的 “跳出当前角色”、“共赢思想”、“FT-Feature Team” 等词汇，都是一种跨出当前工作内容、与周边其余组织团队合作的思想。</p><p>我们要从更高的视角来理解： 划分边界是为了整体实现更高价值的一种方法，而不是成为一种阻碍。所以，我们要不断地跨出当前职责，比如：</p><ul><li>了解某个模块的依赖方 - 如学习ORM库时，顺便了解一下数据库的基本知识</li><li>主动了解周边服务 - 如做支付系统时，了解订单系统的设计与交互</li></ul><p>从许多大厂的职级定义来看，职级的提升往往就是边界的扩大 - 从单个服务、一个系统、整套业务，最后甚至要有跳出技术的视角。</p><h2 id="工作生活-学习一些营养学知识"><a href="#工作生活-学习一些营养学知识" class="headerlink" title="工作生活 - 学习一些营养学知识"></a>工作生活 - 学习一些营养学知识</h2><p>最近看了<a href="https://book.douban.com/subject/27590675/">《你是你吃出来的》</a>和<a href="https://book.douban.com/subject/35340053/">《你是你吃出来的2》</a>两本书。书的内容涉及到许多健康、医学相关的内容，作者的文笔已经很通俗易懂了，有兴趣的朋友可以自己去看看。</p><blockquote><p>对书中的例子要保持理性：</p><p>比如某患者听了作者的说法，换了食谱，三个月后就恢复了。但是，三个月内其余因素是否有变化？比如吃了药、加强锻炼、心态变化等。</p></blockquote><p>读完本书，我有个观点一直萦绕心头：高血压、糖尿病等这种亚健康的情况，是很难定义边界的。虽然业内有参考值，但很容易因人种、环境等因素而变化，颇为个性化。而我们称它们为“病”，往往是已经严重到远超临界值了。对于这些情况，吃药就像是亡羊补牢 - 虽然有效果，但很难根治。我相信，大众更需要的是营养学知识的普及。</p><p>目前，绝大多数人很难有专属的家庭医生，这就要求每个人都拥有基础的营养学知识储备。相关的理论知识已经很完善了，但当前社会缺少一个权威的宣传路径，把这块知识普及到大众。</p><p>个人觉得像公众号、抖音视频等，由于整个传播路径上干扰信息过多，但很难具有公众说服力。而类似于 <strong>国家反诈中心</strong> 这种独立app更具有权威效应。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;本周开始，绝大多数人的工作与生活步入了常规模式。&lt;/p&gt;
&lt;p&gt;希望大家的身体与心理都能尽快地适应工作或学习节奏，保持一颗愉悦的心情。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>【每周小结】2023-Week5</title>
    <link href="http://example.com/2023/01/29/weekly/weekly-2023-5/"/>
    <id>http://example.com/2023/01/29/weekly/weekly-2023-5/</id>
    <published>2023-01-29T10:00:00.000Z</published>
    <updated>2023-02-07T01:47:49.755Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><p>本周过后，绝大多数打工人就需要从休假模式切换到工作模式。</p><p>趁着春节假期的尾巴，我们聊三个轻松的话题。</p><span id="more"></span><h2 id="Go技巧-从官方问卷谈谈未来发展"><a href="#Go技巧-从官方问卷谈谈未来发展" class="headerlink" title="Go技巧 - 从官方问卷谈谈未来发展"></a>Go技巧 - 从官方问卷谈谈未来发展</h2><p><code>Go</code>官方最近开放了一个<a href="https://google.qualtrics.com/jfe/form/SV_bNnbAtFZ0vfRTH8?s=b">问卷</a>，里面收集了用户的相关意见。整个问卷是全英文的，全部填完需要15min左右，有很多是收集用户背景与满意度的常规问题。</p><p>这里，我对其中的关键信息做一下提炼。</p><h3 id="配套工具的两个开发方向-Module与IDE"><a href="#配套工具的两个开发方向-Module与IDE" class="headerlink" title="配套工具的两个开发方向 - Module与IDE"></a>配套工具的两个开发方向 - Module与IDE</h3><p>官方在工具侧的两大投入方向在 <strong>模块化</strong> 与 <strong>IDE配套</strong> 。</p><p>先说说模块化。自<code>Go Module</code>推出之后，已成为一套官方标准，但仍有不少缺憾：如多模块化管理、互相依赖问题，需要官方给出明确的指导意见。而IDE配套，最常见的包括<code>Goland</code>、<code>VsCode</code>、<code>Vim</code>，需要有更多的插件进行支持，如接口与实现的跳转、重构相关工具等。</p><p>在我看来，IDE配套工具比模块化更为重要。尽管<code>Goland</code>已支撑了不少能力，但是其高收费、吃内存的特性，对开发者很不友好，而相对轻量级的<code>VsCode</code>面对复杂项目时，各项能力很难支撑。而模块化的问题虽然重要，但目前已有临时的解决方案，只要关注官方推出的方案即可。</p><h3 id="用Go语言开发的领域"><a href="#用Go语言开发的领域" class="headerlink" title="用Go语言开发的领域"></a>用Go语言开发的领域</h3><p>问卷中的领域方向罗列如下：</p><ul><li>Games</li><li>Mobile apps</li><li>Libraries or frameworks</li><li>Agents and daemons (e.g., monitoring)</li><li>Automation/scripts (e.g., deployment, configuration management)</li><li>A runnable/interactive program (CLI)</li><li>Desktop / GUI applications</li><li>Embedded devices / Internet of Things</li><li>Websites / web services (returning HTML)</li><li>Machine learning / Artificial intelligence</li><li>API/RPC services (returning non-HTML)</li><li>Data processing (e.g., pipelines, aggregation)</li></ul><p>我们不妨思考一下，<strong>Go语言适合哪些方向</strong>？（官方在问卷后面征询了用户意见，希望<code>Go</code>语言支持哪些方向）</p><p>这里，其实大部分的方向都具有 <strong>门槛</strong>，并不适合<code>Go</code>语言，例如：</p><ul><li>游戏方向需要引擎基础，主流是<code>C++</code></li><li>移动设备上的应用注重体验，要用原生的语言</li><li>嵌入设备很吃性能，主流是<code>C/C++</code></li><li>机器学习有TensorFlow/PyTorch等框架，主流是<code>Python</code></li><li>大数据生态基本定型，主流是<code>Java</code></li></ul><p>所以，目前用到<code>Go</code>语言的场景主要是三块：</p><ul><li>基础库与框架</li><li>命令行工具（采集agent、交互CLI）</li><li>后端服务（包括返回HTML与普通RPC）</li></ul><p>对这三个领域，我有如下建议，希望能引起思考：</p><ol><li>基础库与框架<ol><li>入门：基础库与框架的最重要目标是提效，那么如何量化到具体指标呢？</li><li>进阶：<code>Go</code>开源社区有不少库与框架，该如何取长补短、又能形成自己的技术壁垒呢？</li></ol></li><li>命令行工具<ol><li>入门：<code>Go</code>语言工具与脚本（<code>Shell</code>/<code>Python</code>）等的优劣比较，如何选型？</li><li>进阶：云原生技术生态结合，找准工具的切入角度与定位</li></ol></li><li>后端服务<ol><li>入门：与主流编程语言（<code>Java</code>）、框架（<code>Spring</code>）的优劣比较，如何选型？</li><li>进阶：沉淀一整套用<code>Go</code>语言开发的方法论（基建、迭代流程、技术价值等）</li></ol></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从目前来看，<code>Go</code>语言自身的迭代频率不高，整个生态也没有具有突破性的新产品诞生（如<code>Kubernetes</code>），接下来很难有井喷式的增长。而另一方面，<code>Go</code>语言入门的门槛较低，很难形成一定的壁垒（如果希望单靠编程语言就能具有技术壁垒的，建议走C++的路）。</p><p>所以，想要有足够的市场竞争力，除了<code>Go</code>语言，我们还需要 <strong>综合培养多方面的技能</strong>：如计算机基础、业务理解、项目管理等，而不要固守一项技能，被市场慢慢淘汰。</p><h2 id="编程思考-不要陷入过程性的编码"><a href="#编程思考-不要陷入过程性的编码" class="headerlink" title="编程思考 - 不要陷入过程性的编码"></a>编程思考 - 不要陷入过程性的编码</h2><p>这个子标题包含两层意思。</p><p>第一层比较直观：<strong>不要单纯面向过程地编码，而是学会抽象、面向对象</strong>。这是一个老生常谈的话题，我举一个例子：</p><p>现在，要开发一个管理书本的功能。在面向过程时，我们思路是增删改查，很容易写出对应的代码；而如果要抽象，我们需要钻研 - <strong>书</strong> 这个对象，就冒出各种问题：</p><ul><li>书需要哪些属性？</li><li>书的管理有权限吗？</li><li>书与书之间有关联吗？</li></ul><p>这些问题也许最终并没有对代码开发有所帮助，但能帮助开发者锻炼抽象思维与理解业务场景。</p><p>第二层则是一种工作状态：<strong>不要闷头写代码，而应时不时确认方向的正确性。</strong></p><p>在Coding时，有些人会陷入 <strong>心流</strong> 的状态，感觉如有神助，一下子写出几千行代码，但回过头却发现这些代码是无效的 - 不满足需求。要解决这个问题，需要突破两个舒适区：</p><ol><li><strong>高频沟通</strong>：以文档或demo的方式与需求方沟通，而不要闷头“自嗨式”地闭门造车</li><li><strong>放弃沉没成本</strong>：在软件行业高频迭代的场景下，很容易出现某项工作中途叫停的情况。如果有足够的自信支撑，那么继续坚持是一种勇气；而如果判断最终大概率失败，那么选择中途放弃也是很大的勇气。</li></ol><p>用一个词来总结以上两点的话，就是常谈的 <strong>以终为始</strong> 。</p><h2 id="工作生活-更多维的视角"><a href="#工作生活-更多维的视角" class="headerlink" title="工作生活 - 更多维的视角"></a>工作生活 - 更多维的视角</h2><p>在春节的尾巴，我和朋友去吃了个自助餐。</p><p>入座后，我发现隔壁座有个小哥哥，穿着一身睡衣，一个人不紧不慢地吃着，时不时地和服务员闲聊两句，整个就餐过程表现得非常轻松；而到我这边，则一心想着“吃回本”，填鸭式地往嘴里塞，就餐过程非常仓促，最后挺着撑饱的肚子才离开。</p><p>我的这种情况在网上非常常见，尤其是那些大胃王的短视频，给观众带来价值观是一种 <strong>零和博弈</strong> - 吃得少就是商家赚、食客亏，吃得多就是食客赚、商家亏。这种观点没有问题，却扭曲了很多人吃自助餐的初衷 - 吃自助只是为了不受拘束地点餐或者享受某个美食。如果顾客只是为了吃亏商家，那么商家要么降低服务品质，要么只能倒闭。</p><p>世界并不是非黑即白的，我们要从更多维的视角来看问题：单维度的视角（如金钱的得失）很容易发生冲突，而多维度的视角（比如那位小哥哥享受了就餐的过程）可以让我们更享受生活。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;本周过后，绝大多数打工人就需要从休假模式切换到工作模式。&lt;/p&gt;
&lt;p&gt;趁着春节假期的尾巴，我们聊三个轻松的话题。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>【每周小结】2023-Week4</title>
    <link href="http://example.com/2023/01/22/weekly/weekly-2023-4/"/>
    <id>http://example.com/2023/01/22/weekly/weekly-2023-4/</id>
    <published>2023-01-22T12:00:00.000Z</published>
    <updated>2023-01-24T15:03:30.620Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><p>新的一年已经到来，祝各位读者2023年身体健康、家庭美满。</p><p>回到本篇的主题，我继续来聊聊本周的一些心得。</p><span id="more"></span><h2 id="Go技巧-接口实现下的三个代码复用技巧"><a href="#Go技巧-接口实现下的三个代码复用技巧" class="headerlink" title="Go技巧 - 接口实现下的三个代码复用技巧"></a>Go技巧 - 接口实现下的三个代码复用技巧</h2><p>在面向对象开发的场景下，我们经常会写高度重复的<code>Go</code>代码。为了帮助大家形成一定的方法论，这里以一个具体场景为例，分享我的三个技巧。</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/interface-3-way.png"></p><h3 id="示例：一个接口-三个实现"><a href="#示例：一个接口-三个实现" class="headerlink" title="示例：一个接口 + 三个实现"></a>示例：一个接口 + 三个实现</h3><p>我们以上图为例，看看示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义 - 订单</span></span><br><span class="line"><span class="comment">// 方法定义：创建订单Create与关闭订单Close</span></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">interface</span> &#123;</span><br><span class="line">  Create() error</span><br><span class="line">  Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三种具体的订单类型 Order1 Order2 Order3</span></span><br><span class="line"><span class="comment">// 为了实现接口Order，这三个结构都需要实现 Create与Close 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Order1部分</span></span><br><span class="line"><span class="keyword">type</span> Order1 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order1)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order1)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order2部分</span></span><br><span class="line"><span class="keyword">type</span> Order2 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order2)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order2)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order3部分</span></span><br><span class="line"><span class="keyword">type</span> Order3 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order3)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order3)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际场景中，<code>Order1</code>/<code>Order2</code>/<code>Order3</code>的逻辑、数据高度相似，出现大量的重复性代码。如何提升这部分代码的开发效率呢？下面给出三个途径：</p><h3 id="方法1：快刀斩乱麻-函数复用"><a href="#方法1：快刀斩乱麻-函数复用" class="headerlink" title="方法1：快刀斩乱麻 - 函数复用"></a>方法1：快刀斩乱麻 - 函数复用</h3><p>最直接的方法就是抛开面向对象的一堆概念，单纯地用函数复用来解决问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createOrder</span><span class="params">(ctx context.Context, data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closeOrder</span><span class="params">(ctx context.Context, data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以Order1为例，Order2/Order3类似</span></span><br><span class="line"><span class="keyword">type</span> Order1 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order1)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 调用 createOrder</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order1)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123; </span><br><span class="line">  <span class="comment">// 调用 closeOrder</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种编程思维是面向过程的，虽然不够抽象，但它确实是 <strong>最便捷的代码复用方式</strong>。而且，在很多情况下，我们不会对这块代码有大更新，函数复用是一个 <strong>高性价比</strong> 的选择。</p><p>但我们的追求不仅限于此：如果这块代码涉及业务核心，高频迭代，会出现什么样的现象呢？举3个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1 - 入参不断增加</span></span><br><span class="line"><span class="comment">// 某些订单的需要一些额外的数据，那么就必须增加入参（并且这个参数很难通用！）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createOrder</span><span class="params">(ctx context.Context, data <span class="keyword">interface</span>&#123;&#125;, other, more <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2 - 大量的if-else</span></span><br><span class="line"><span class="comment">// 一个函数适配多种逻辑，只能增加判断逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createOrder</span><span class="params">(ctx context.Context, data <span class="keyword">interface</span>&#123;&#125;, otherData <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> orderType == <span class="number">1</span> &#123;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> price &gt; <span class="number">1000</span> &#123;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例3 - 创建多个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createOrder2</span><span class="params">()</span> <span class="title">error</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createOrder3</span><span class="params">()</span> <span class="title">error</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>以上这些代码是不整洁的，相信大部分人不愿在自己开发过程中看到。这种过程性代码复用的思路，见效虽快，但在复杂场景下弊端愈发明显。下面，我们引入第二个方法：</p><h3 id="方法2：对象抽象的妙用-嵌套-Overwrite"><a href="#方法2：对象抽象的妙用-嵌套-Overwrite" class="headerlink" title="方法2：对象抽象的妙用 - 嵌套+Overwrite"></a>方法2：对象抽象的妙用 - 嵌套+Overwrite</h3><p><code>Go</code>并不是一门完全面向对象的语言，但对于复杂场景，会用嵌套来支持一定的代码复用。代码示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个基础对象，实现了接口 Order</span></span><br><span class="line"><span class="keyword">type</span> CommonOrder <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *CommonOrder)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *CommonOrder)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order1 利用嵌套，直接实现了Create和Close两个方法</span></span><br><span class="line"><span class="keyword">type</span> Order1 <span class="keyword">struct</span> &#123;</span><br><span class="line">  *CommonOrder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order2 也利用了嵌套，Close方法会复用，但Create方法会被覆盖</span></span><br><span class="line"><span class="keyword">type</span> Order2 <span class="keyword">struct</span> &#123;</span><br><span class="line">  *CommonOrder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overwrite</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order2)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order3 两个方法都会被覆盖</span></span><br><span class="line"><span class="keyword">type</span> Order3 <span class="keyword">struct</span> &#123;</span><br><span class="line">  *CommonOrder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overwrite</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order3)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overwrite</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order3)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套+<code>Overwrite</code>的组合能力，支撑了<code>Go</code>语言面向对象的很多特性。与之前的函数复用对比，这种方法的可读性会更棒（这也非常依赖开发者面向对象的抽象能力）。</p><p>到这一阶段，维护绝大多数的项目已经足够。但如果你是一个苛求细节的人，在继续开发的过程中会发现一个问题：<strong>即便代码的逻辑一致，我们却常常因为数据结构不同，而编写出高度重复性的代码。</strong>那么，我们再看第三个方法：</p><h3 id="方法3：剥离数据结构的差异-泛型"><a href="#方法3：剥离数据结构的差异-泛型" class="headerlink" title="方法3：剥离数据结构的差异 - 泛型"></a>方法3：剥离数据结构的差异 - 泛型</h3><p>我们先看如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OrderInfo1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order1)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 数据结构 OrderInfo1 保存的是 Order1 订单信息</span></span><br><span class="line">  <span class="keyword">var</span> order *OrderInfo1</span><br><span class="line">  <span class="comment">// 插入msyql</span></span><br><span class="line">  err := mysql.Insert(order)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 序列化后打印</span></span><br><span class="line">  b,err := json.Marshal(order)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderInfo2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order2)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 数据结构 OrderInfo2 保存的是 Order2 订单信息</span></span><br><span class="line">  <span class="keyword">var</span> order *OrderInfo2</span><br><span class="line">  <span class="comment">// 后面操作同Order1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderInfo3 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order3)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 数据结构 OrderInfo3 保存的是 Order3 订单信息</span></span><br><span class="line">  <span class="keyword">var</span> order *OrderInfo3</span><br><span class="line">  <span class="comment">// 后面操作同Order1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码很难通过上述两个方法解决。而如果利用泛型，会变得非常巧妙：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将公共逻辑抽象到这个泛型函数中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span>[<span class="title">OrderInfo</span> <span class="title">interface</span></span>&#123;&#125;](order OrderInfo) error &#123;</span><br><span class="line">  err := mysql.Insert(order)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  b,err := json.Marshal(order)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个Order的Create方法就非常清晰了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order1)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> order *OrderInfo1</span><br><span class="line">  <span class="keyword">return</span> Create[OrderInfo1](order)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order2)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> order *OrderInfo2</span><br><span class="line">  <span class="keyword">return</span> Create[OrderInfo2](order)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order3)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> order *OrderInfo3</span><br><span class="line">  <span class="keyword">return</span> Create[OrderInfo3](order)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型特性的引入，往往出现在数据处理层，即和基础库、工具库相关的地方，而在业务层很少出现。我们可以从如下两点进行分析：</p><ul><li>业务层主要的特点在与 <strong>逻辑差异大</strong>，对数据结构也有各种校验等，不适用泛型；</li><li>数据处理层则往往逻辑一致，仅仅只有数据结构的差异，泛型非常适配。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>函数复用、嵌套+<code>Overwrite</code>、泛型，是三种非常有效的代码复用技巧。希望大家能够循序渐进，在工程中找到属于自己的最佳实践。</p><h2 id="编程思考-开发前的三个文档"><a href="#编程思考-开发前的三个文档" class="headerlink" title="编程思考 - 开发前的三个文档"></a>编程思考 - 开发前的三个文档</h2><p>在开发一个项目前，有三个文档是必备的，我们称为 - <strong>BRD</strong>、<strong>PRD</strong>、<strong>技术方案</strong>，它们在项目流程中依次编写。</p><ol><li>BRD（商业需求文档）：这个文档有一个关键词 - 商业价值，不仅要了解用户痛点，更要结合市场，发掘价值</li><li>PRD（产品需求文档）：与产品经理角色相关，设计功能交互，体现出两种重要的思维：产品思维与用户思维</li><li>技术方案：开发者最熟悉的文档，最主要的是设计，但更重要的是评估能力，如排期、风险</li></ol><p>编写技术方案不难，普通开发者工作两三年就能有一个很棒的呈现；而PRD则须要 <strong>视野转换</strong>，从用户与产品的角度来思考功能的开发；BRD则最为复杂，往往要多年行业经验积累以及深刻的用户洞察。</p><p>大家可以在日常开发中多主动地接触优秀的PRD、BRD，不仅能拓宽视野，更能提升个人认知。</p><h2 id="工作生活-学会聚焦，才能做好取舍"><a href="#工作生活-学会聚焦，才能做好取舍" class="headerlink" title="工作生活 - 学会聚焦，才能做好取舍"></a>工作生活 - 学会聚焦，才能做好取舍</h2><p>不同人、在不同的阶段，对工作和生活的平衡点都有不同的理解。所以，我认为没有必要去过多地从他人经验里去探求 <strong>最佳平衡点</strong>，也没有必要把工作和生活当作对立面，而是在日常反复问自己：<strong>我究竟想要什么？</strong></p><p>有取，往往就需要舍弃，这时就会犹豫代价是否过大。我总是过多地担忧所失去的，就扭曲了原问题：<strong>不再关注自己最想要的，而转过头去关注可能失去的，情绪上出现焦虑，甚至恐慌</strong>。简而言之，就是要认清自己，学会聚焦。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;新的一年已经到来，祝各位读者2023年身体健康、家庭美满。&lt;/p&gt;
&lt;p&gt;回到本篇的主题，我继续来聊聊本周的一些心得。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>【每周小结】2023-Week3</title>
    <link href="http://example.com/2023/01/15/weekly/weekly-2023-3/"/>
    <id>http://example.com/2023/01/15/weekly/weekly-2023-3/</id>
    <published>2023-01-15T12:00:00.000Z</published>
    <updated>2023-01-16T02:52:25.866Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><p>本周，我的工作模式正式从远程办公回到了现场办公。恰逢过年，整体工作节奏放缓，切换的过程很顺畅。</p><p>虽然我十分期待远程办公成为常态，但不得不承认，这种模式在中国落地，还有一段路要走。</p><span id="more"></span><h2 id="Go技巧-提高ORM使用体验的三个要点"><a href="#Go技巧-提高ORM使用体验的三个要点" class="headerlink" title="Go技巧 - 提高ORM使用体验的三个要点"></a>Go技巧 - 提高ORM使用体验的三个要点</h2><p>ORM是一个非常高频使用的开发工具。以下图为例，<strong>Go程序内与MySQL中，数据存储是异构的</strong> ，这就导致传统开发方式会分成两步：</p><ol><li>将Go程序中的数据转换成MySQL的 <code>SQL</code> 语句</li><li>解析MySQL 返回的数据到具体结构体中</li></ol><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/ORM.png"></p><p>这部分的开发有大量重复性的代码，如拼接SQL、数据解析，所以就有了ORM这个概念 - <strong>将内存中的数据结构（对象）与数据库中的表对应起来</strong>。一旦映射关系建立，那就可以调用ORM里的CRUD完成日常开发。在Go语言程序中，最常见的就是<a href="https://gorm.io/zh_CN/docs/">gorm</a>。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们以Book作为对象为例，它在Go程序中的定义是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id         <span class="keyword">int64</span>     <span class="string">`gorm:&quot;column:id&quot;`</span></span><br><span class="line">    BookName   <span class="keyword">string</span>    <span class="string">`gorm:&quot;column:book_name&quot;`</span></span><br><span class="line">    UpdateTime time.Time <span class="string">`gorm:&quot;column:update_time&quot;`</span></span><br><span class="line">    Status     <span class="keyword">int</span>       <span class="string">`gorm:&quot;column:status&quot;`</span>     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应MySQL中的建表语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `books`</span><br><span class="line">(</span><br><span class="line">    `id`          <span class="type">bigint</span>(<span class="number">20</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    `book_name`   <span class="type">varchar</span>(<span class="number">255</span>)        <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;书名&#x27;</span>,</span><br><span class="line">    `update_time` datetime            <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> NOW() COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    `status`      tinyint(<span class="number">3</span>)          <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">  CHARSET <span class="operator">=</span> utf8mb4</span><br><span class="line">  <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_bin COMMENT <span class="string">&#x27;书&#x27;</span>;</span><br></pre></td></tr></table></figure><p>完成定义后，我们可以使用<code>gorm</code>库实现CRUD了。但基于ORM库，开发中还是会高频出现一些奇怪的问题：<strong>明明程序没有bug，ORM的操作结果却没有达到预期</strong>。例如插入时<code>status</code>字段是0，没有报错，但查询时缺变成了100。</p><p>这类问题，往往是开发者在设计时没有注重 <strong>用户认知</strong> 导致的，也就是说 现象反直觉、所见非所得。我们今天的话题，将基于此展开：</p><h3 id="要点一：程序侧-节制地使用ORM能力"><a href="#要点一：程序侧-节制地使用ORM能力" class="headerlink" title="要点一：程序侧 - 节制地使用ORM能力"></a>要点一：程序侧 - 节制地使用ORM能力</h3><p>ORM往往扩展了很多能力，但大幅度地增加了用户的学习成本与排查问题时的成本。以<a href="https://gorm.io/zh_CN/docs/models.html#%E5%AD%97%E6%AE%B5%E7%BA%A7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6">GORM字段权限控制</a>为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;&lt;-:create&quot;`</span> <span class="comment">// 允许读和创建</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;&lt;-:update&quot;`</span> <span class="comment">// 允许读和更新</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;&lt;-&quot;`</span>        <span class="comment">// 允许读和写（创建和更新）</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;&lt;-:false&quot;`</span>  <span class="comment">// 允许读，禁止写</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;-&gt;&quot;`</span>        <span class="comment">// 只读（除非有自定义配置，否则禁止写）</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;-&gt;;&lt;-:create&quot;`</span> <span class="comment">// 允许读和写</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;-&gt;:false;&lt;-:create&quot;`</span> <span class="comment">// 仅创建（禁止从 db 读）</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;-&quot;`</span>  <span class="comment">// 通过 struct 读写会忽略该字段</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;-:all&quot;`</span>        <span class="comment">// 通过 struct 读写、迁移会忽略该字段</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;-:migration&quot;`</span>  <span class="comment">// 通过 struct 迁移会忽略该字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来特性很酷，但如果你作为读代码的人，你愿意去读一个结构体中每个Field的<code>tag</code>详情吗？而且，这种限制藏得很隐蔽，发生问题后排查起来很累。</p><p>因此，程序侧的ORM定义，最重要的是能<strong>保证程序数据结构与数据库存储结构一一映射，其余特性需要慎用</strong>。</p><blockquote><p>慎用不代表不用。</p><p>如果能在团队内部形成规范，一方面这个规范能落地到代码里，另一方面也能宣传到各个成员、让大家形成共识，那就能用这些特性提升开发效率。</p></blockquote><h3 id="要点二：数据库侧-最简化设计"><a href="#要点二：数据库侧-最简化设计" class="headerlink" title="要点二：数据库侧 - 最简化设计"></a>要点二：数据库侧 - 最简化设计</h3><p>程序侧的代码对开发者可见，排查问题相对清晰。而如果问题最终是在数据库侧导致的，那么就变得复杂了：</p><ul><li>技术领域不同 - 数据库存在一定的专业性，经验尚浅的开发者需要一定的经验积累</li><li>访问权限 - 角色、环境等问题，可能导致排查困难</li><li>滞后性 - 出现问题的优先排查对象往往是代码，数据库往往会被我们“默认”认为没问题</li></ul><p>所以，我们在前期设计数据库侧的内容时，要尽可能地保证简单。我个人的评判标准是：<strong>让Go结构体的数据，和MySQL表中的一行数据完全对应</strong>，不做额外的工作。</p><p>我举两个反例：</p><ol><li>字段默认值有特殊的含义，如建表时<code>status</code>的默认值设置为100<ol><li>改进方案：如果100这个值有业务含义，应在Go程序中设置</li></ol></li><li>表中增加Trigger，如<code>status</code>字段修改为某个值后，自动触发另一个字段的修改<ol><li>改进方案：在Go程序中实现这块逻辑</li></ol></li></ol><h3 id="要点三：ORM能力与数据库特性的综合考量"><a href="#要点三：ORM能力与数据库特性的综合考量" class="headerlink" title="要点三：ORM能力与数据库特性的综合考量"></a>要点三：ORM能力与数据库特性的综合考量</h3><p>第三个要点最为复杂，它需要结合ORM库的具体能力以及数据库的自身特性来综合考量：ORM的有些特性并不完善，具体在哪实现？</p><p>依旧以gorm为例，在用<code>Book</code>结构体进行<a href="https://gorm.io/zh_CN/docs/update.html#%E6%9B%B4%E6%96%B0%E5%A4%9A%E5%88%97">多列更新</a>时，无法更新其中的默认值，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 官方示例</span></span><br><span class="line"><span class="comment">// 代码原理：Active字段是默认值false，所以不会更新</span></span><br><span class="line"><span class="comment">// 用户认知：因为惯性思维，往往认为这个值会被设置为false</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>, Active: <span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure><p>我们先不考虑具体解决方案，而是希望大家能认识到ORM的局限性 - 想用一个结构体完全覆盖所有的增删改查场景，是不现实的。选择方案，其实是<code>trade-off</code>，选择一个团队更能快速理解的策略。</p><blockquote><p>想了解方案的同学，可以参考我之前的<a href="https://junes.tech/2022/11/03/go-study/go-rpc-4/">博客</a>。</p></blockquote><p>第三点是进阶性质的能力，需要大量ORM与数据库侧的开发经验，今天不作展开。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>ORM的使用体验会大幅提升CRUD的开发与维护效率。我比较提倡 <strong>在设计时，最简化ORM与数据库侧的特性</strong>，只采用其核心的映射能力。</p><p>而当简化到一定程度后，我们可以打通两侧的数据结构，如示例中的<code>Book</code>结构体与<code>books</code>建表语句。由于MySQL中的数据类型更为复杂，可以维护一个从 <strong>解析建表语句，自动生成Go中ORM结构体</strong> 的代码生成工具。</p><blockquote><p>实现可以参考<a href="https://junes.tech/2021/09/27/go-framework/go-framework-7/">博客</a> </p></blockquote><h2 id="编程思考-开发者的coding经验"><a href="#编程思考-开发者的coding经验" class="headerlink" title="编程思考 - 开发者的coding经验"></a>编程思考 - 开发者的coding经验</h2><p>如今的应届生在校或实习时就具备了颇为深厚的编程经验，参加工作后能快速地胜任日常需求，这就引起了老一批工程师的焦虑，不禁怀疑：我们的coding经验究竟有什么价值？</p><p>下面，我分享一下个人的思考，会从低到高三个维度进行讲述：</p><ol><li><strong>代码维度 - 写得好，读得懂</strong>：看过、写过的代码多，一方面让自己写代码时可读性提高，另一方面也能适应五花八门的项目风格。</li><li><strong>功能维度 - 懂需求，善取舍</strong>：代码所实现的功能，往往和最终预期有出入，如沟通损耗、认知差异等；而功能实现的过程中往往需要取舍，要理清主次先后。</li><li><strong>系统维度 - 识风险，促迭代</strong>：开发的代码从来就不是孤立的，需要识别出它对系统其余功能是否会产生风险；同时，本次开发也是一个迭代的机会，例如建设更通用的模块、修复一些历史包袱等。</li></ol><p>以上三点维度不同，但很难从价值维度区分高低。从这三点来看，一个资深coder对团队的价值非常重要。</p><h2 id="工作生活-焦虑感的缓解"><a href="#工作生活-焦虑感的缓解" class="headerlink" title="工作生活 - 焦虑感的缓解"></a>工作生活 - 焦虑感的缓解</h2><p>这几年，我的焦虑感与日俱增，尤其是近两年的行业低谷。面对焦虑，专家们有很多思路，这里分享三个对我帮助最大的方法：</p><ul><li>多锻炼，既能保证身体能量充沛，又可以释放很多负能量</li><li>多读书（尤其是心理学），提升心智成熟，坦然地面对不确定性</li><li>多沟通，与同事、领导、朋友等多种角色，进行真诚的交流</li></ul><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;本周，我的工作模式正式从远程办公回到了现场办公。恰逢过年，整体工作节奏放缓，切换的过程很顺畅。&lt;/p&gt;
&lt;p&gt;虽然我十分期待远程办公成为常态，但不得不承认，这种模式在中国落地，还有一段路要走。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>【每周小结】2023-Week2</title>
    <link href="http://example.com/2023/01/08/weekly/weekly-2023-2/"/>
    <id>http://example.com/2023/01/08/weekly/weekly-2023-2/</id>
    <published>2023-01-08T12:00:00.000Z</published>
    <updated>2023-01-08T13:10:10.874Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><p>作为一名年龄30+程序员，随着2023年的到来，我的工作和生活正在逐步变化。</p><p>本系列会以周维度为周期，记录我对如下三块内容的思考，大家挑选各自感兴趣的内容阅读即可：</p><ul><li><strong>Go技巧</strong> - Go开发者作为重点阅读的群体，不忘初心</li><li><strong>编程思考</strong> - 面向所有开发者，从系统设计等高层维度进行分享</li><li><strong>工作生活</strong> - 以更贴近生活的视角，分享时间管理、职业发展、焦虑感的一些心得</li></ul><span id="more"></span><h2 id="Go技巧-用接口interface提高模块间协作效率"><a href="#Go技巧-用接口interface提高模块间协作效率" class="headerlink" title="Go技巧 - 用接口interface提高模块间协作效率"></a>Go技巧 - 用接口<code>interface</code>提高模块间协作效率</h2><p>本周要分享的一个技巧是 - <strong>用接口<code>interface</code>提高模块间协作效率</strong>。</p><p>我们在协作开发时，在划分清边界后，就需要协同开发。而这个边界，如果能结合<code>interface</code>特性，就会大幅提升效率。从边界功能的角色来看，主要包括2个：<strong>提供方</strong>与<strong>调用方</strong>。</p><p>从下图来看：</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1.png"></p><p>我们以一个具体工作内容为例：我们要开发一个Book的CRUD的工作，但时间紧迫，所以计划分为两块：</p><ul><li>A同学 - HTTP API部分</li><li>B同学 - MySQL数据库部分</li></ul><p>而由于数据库部分的工作比较少，所以计划让B同学来主导接口这块工作，即B是提供方，A是使用方。接下来的三块工作内容如下：</p><h3 id="1-设计接口"><a href="#1-设计接口" class="headerlink" title="1 - 设计接口"></a>1 - 设计接口</h3><p>B同学给出一版接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心接口定义</span></span><br><span class="line"><span class="keyword">type</span> BookDao <span class="keyword">interface</span> &#123;</span><br><span class="line">  Create(book *Book) error</span><br><span class="line">  Delete(bookId <span class="keyword">int64</span>) error</span><br><span class="line">  List(pageNumber,pageSize <span class="keyword">int</span>) ([]*Book, error)</span><br><span class="line">  Update(bookId <span class="keyword">int64</span>, bookName <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化，新建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBookDao</span><span class="params">()</span> <span class="title">BookDao</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里并没有真正的代码实现。代码重点包括3个部分：</p><ul><li><code>interface</code>的定义：核心内容，方便使用者阅读</li><li>实例化：<code>interface</code>怎么创建</li><li>数据结构：<code>interface</code>涉及的结构体</li></ul><p>这一块，非常考验B同学的代码设计能力：怎么样让使用者快速了解你的设计？注释固然是一个不错的方式，但更好的方式是通过函数名、参数名等，详情可参考《 Effective Go》、《代码整洁之道》等资料。</p><h3 id="2-审核接口"><a href="#2-审核接口" class="headerlink" title="2 - 审核接口"></a>2 - 审核接口</h3><p>在B同学完成初步设计后，就需要A同学进行审核。审核主要的目标：<strong>发掘信息差，保证最终功能的正确性</strong>。</p><p>信息差来源于不同模块的上下文差异。比如说，数据库同学更关注底层的数据存储，而API层的同学更关注用户的使用场景。所以，通过评审，A同学可以发现与B同学的信息差，并对接口提出意见、希望B同学加以改进。</p><p>从上面的示例来看，可能存在如下问题，我用注释的方式加以说明（往往结合Code Review）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BookDao <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 需求点1：提供批量创建的能力</span></span><br><span class="line">  Create(book *Book) error</span><br><span class="line">  <span class="comment">// 需求点2：能否支持软删除</span></span><br><span class="line">  Delete(bookId <span class="keyword">int64</span>) error</span><br><span class="line">  <span class="comment">// 需求点3：查询能否支持一些字段的模糊查询，如bookName</span></span><br><span class="line">  <span class="comment">// 需求点4：需要查询满足条件的Book总数，支持分页功能</span></span><br><span class="line">  List(pageNumber,pageSize <span class="keyword">int</span>) ([]*Book, error)</span><br><span class="line">  <span class="comment">// 需求点5：需要修改其余字段，如作者author</span></span><br><span class="line">  Update(bookId <span class="keyword">int64</span>, bookName <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需求点6：字段缺失：如出版商、出版时间</span></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，就是A与B的不断沟通、不断修改<code>interface</code>的过程，直到双方基本达成一致。</p><h3 id="3-实现与使用接口"><a href="#3-实现与使用接口" class="headerlink" title="3 - 实现与使用接口"></a>3 - 实现与使用接口</h3><p>随着接口的敲定，接下来的工作就可以兵分两路了:</p><ul><li>B - 提供方去编写这个接口的具体实现，也就是MySQL相关的部分</li><li>A - 使用方调用代码，完成上层业务部分的开发</li></ul><p>可以看到，<code>interface</code>的定义有利于将工作进行拆分，定义关键边界，然后各自完成独立开发。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从两个角色来看，他们侧重的能力点会有差异：</p><ul><li>提供者：偏向基础能力，主要在于代码的可读性与能力的通用性（不仅仅对接一个使用方）</li><li>使用者：偏向业务能力，需要结合用户使用场景来思考程序设计</li></ul><p>这个情况不仅仅存在于模块间设计，在更大的系统设计时也有非常重要的体现。所以，这是一个很好的提升能力的机会。</p><h2 id="编程思考-提高个人的市场竞争力"><a href="#编程思考-提高个人的市场竞争力" class="headerlink" title="编程思考 - 提高个人的市场竞争力"></a>编程思考 - 提高个人的市场竞争力</h2><p>最近，我经常看到一个问题：<strong>我该学习什么编程能力？</strong> 我会先关心提问者的初衷，常见分为两种：</p><ul><li>提升编程能力</li><li>提高个人的市场竞争力</li></ul><p>相信绝大多数的人都是为了后者。单纯为了提升编程能力的话，自己去啃那些经典教材即可。</p><p>认清并承认自己的目标很重要。关于<strong>程序员的市场竞争力</strong>这个问题，我分享个人的三点看法：</p><ul><li>从ROI的角度分析个人的能力成长方向，把自己当作一个商品（想不清楚的话，多搜搜各大公司的招聘要求）</li><li>多和“高阶人士”交流，扩展视野：可以是职位比你高的领导，也可以是某个方向的资深人员</li><li>为机遇创造条件（能力储备、人脉），但不要一心追求机遇，而是逐步成长</li></ul><h2 id="工作生活-记录生活作息"><a href="#工作生活-记录生活作息" class="headerlink" title="工作生活 - 记录生活作息"></a>工作生活 - 记录生活作息</h2><p>我从本周开始，记录了自己的每日生活作息，分为7类：</p><ul><li>睡眠</li><li>吃饭</li><li>工作</li><li>娱乐</li><li>学习</li><li>运动</li><li>家庭</li></ul><p>记录的动作很简单，拿纸笔就能快速完成，但我在今年才开始真正地做这件事。这背后，我长期存在的一个性格问题：<strong>我清楚自己浪费时间的问题所在，但不敢真正地去面对它，更羞于看到具体的浪费时长。</strong></p><p>我的最终目标也不是为了成为一个时间管理领域的达人，而是 <strong>让自己时间更可控</strong>，减少来自浪费时间的焦虑感。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;作为一名年龄30+程序员，随着2023年的到来，我的工作和生活正在逐步变化。&lt;/p&gt;
&lt;p&gt;本系列会以周维度为周期，记录我对如下三块内容的思考，大家挑选各自感兴趣的内容阅读即可：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Go技巧&lt;/strong&gt; - Go开发者作为重点阅读的群体，不忘初心&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编程思考&lt;/strong&gt; - 面向所有开发者，从系统设计等高层维度进行分享&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作生活&lt;/strong&gt; - 以更贴近生活的视角，分享时间管理、职业发展、焦虑感的一些心得&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>Go-Buf教程 - 2.【背景篇】Buf生态概览</title>
    <link href="http://example.com/2022/12/30/go-buf/go-buf-2/"/>
    <id>http://example.com/2022/12/30/go-buf/go-buf-2/</id>
    <published>2022-12-30T04:00:00.000Z</published>
    <updated>2023-01-09T11:47:52.828Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-buf.jpg"></p><p>在上一讲，我们明确了<code>Buf</code>套件的定位 - <strong><code>Buf</code>重点是通过对<code>Protobuf Schema</code>的规范化，提供代码生成、依赖管理等一站式的API接口管理方案，来保证开发效率与团队协作的收益最大化。</strong></p><p>那么，<code>Buf</code>生态究竟提供了哪些具体的工具与平台，来支撑其能力呢？通过本篇的分析，你将不仅仅了解<code>Buf</code>项目的设计，更能窥一斑而见全豹，熟悉一个中型开源项目的构成，为后续在自己项目中的落地提供理论支撑。</p><span id="more"></span><h2 id="两大组件-Schema-Registry与CLI"><a href="#两大组件-Schema-Registry与CLI" class="headerlink" title="两大组件 - Schema Registry与CLI"></a>两大组件 - Schema Registry与CLI</h2><p>作为<code>buf</code>主推的两大产品，<code>Schema Registry</code> 和 <code>CLI</code> 的定位非常清晰：</p><ul><li><a href="https://buf.build/product/bsr/">Schema Registry</a> 是一个远端管理<code>buf schema</code>的解决方案，可以类比<code>github</code></li><li><a href="https://docs.buf.build/tour/introduction/">CLI</a> 是一个在本地终端运行的二进制工具，也是与<code>Schema Registry</code>交互的工具</li></ul><p><img src="https://buf.build/static/buf-graph-f73585cb2ce571190da213de0af6e198.svg" alt="Buf"></p><p>对照上面的设计图，这两个产品的功能不难猜测。这里，我换一个角度和大家聊聊这两个产品 - 收费pricing。如果你作为负责人，你会想要怎么收费呢？没错，收费的重点放在<code>Schema Registry</code>上：</p><ul><li><code>CLI</code>作为一个和各终端交互的工具，如果作为收费点，一来很难控制，二来很影响用户的直接体验；</li><li><code>Schema Registry</code>作为一个集中式的、远端的服务，对官方来说容易升级维护，也是协作能力的卖点所在；</li></ul><p>到这里，我们对这两个产品有了一定的理解，而且明确了学习的重点 - <code>CLI</code>的使用。</p><blockquote><p>关于<code>Schema Registry</code>部分，如果公司有一定的基础建设（主要是CICD体系），可以找到替代方案。</p><p>这部分不会作为教程的重点，毕竟影响到了<code>Buf</code>团队的商业模式了。</p></blockquote><h2 id="计费-Pricing"><a href="#计费-Pricing" class="headerlink" title="计费 - Pricing"></a>计费 - Pricing</h2><p>计费模式，是公司对产品经过反复推敲，才选定的最合适、最有价值的核心竞争力。以<a href="https://buf.build/pricing/">buf的计费模式</a>为例，我们来看看3个计费点：</p><ol><li><code>Schema Registry</code>访问方式 - private化</li><li>人工支持 - 24h答疑</li><li><code>Schema Registry</code>进阶能力 - 在平台侧提供各项进阶能力，主要和安全、协作相关</li></ol><p>分析一下这些收费点，会发现开源产品收费策略的一些共性：</p><ul><li>收费点不能限制产品核心流程上的体验</li><li>收费点不要限制产品的推广、传播</li><li>收费点要有明确的目标客户</li></ul><p>收费模式决定了产品的成败，是我们在技术选型时的重要考量点：如果你不认可该产品的收费模式，认为注定失败，那就提前规避风险、换个方案。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节从<code>Buf</code>的两大组件和收费模式进行了分析，相信大家对<code>Buf</code>的生态有了基本的认识。</p><p>一句话总结：<code>Buf Cli</code>提供了本机上的命令交互，是开发者要重点熟悉的工具；而<code>Schema Registry</code>提供了远端协作的能力，作为产品的核心收费点。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-buf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一讲，我们明确了&lt;code&gt;Buf&lt;/code&gt;套件的定位 - &lt;strong&gt;&lt;code&gt;Buf&lt;/code&gt;重点是通过对&lt;code&gt;Protobuf Schema&lt;/code&gt;的规范化，提供代码生成、依赖管理等一站式的API接口管理方案，来保证开发效率与团队协作的收益最大化。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么，&lt;code&gt;Buf&lt;/code&gt;生态究竟提供了哪些具体的工具与平台，来支撑其能力呢？通过本篇的分析，你将不仅仅了解&lt;code&gt;Buf&lt;/code&gt;项目的设计，更能窥一斑而见全豹，熟悉一个中型开源项目的构成，为后续在自己项目中的落地提供理论支撑。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Buf" scheme="http://example.com/tags/Go-Buf/"/>
    
  </entry>
  
  <entry>
    <title>Go-Buf教程 - 0.总览</title>
    <link href="http://example.com/2022/12/28/go-buf/go-buf-0/"/>
    <id>http://example.com/2022/12/28/go-buf/go-buf-0/</id>
    <published>2022-12-28T04:00:00.000Z</published>
    <updated>2023-01-02T12:03:12.505Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-buf.jpg"></p><p><code>buf</code>是一个很棒的基于<code>protobuf</code>来建立微服务API体系的工具。</p><p>我个人是<code>buf</code>的重度用户，并已在多个企业级的项目中落地。但是，鉴于<code>buf</code>以下三个特点，网上的相关教程很少：</p><ol><li>资料基本由英文文档构成</li><li>更新迭代快，有很多新增或已过时的特性</li><li>有一定的技术门槛（如熟悉<code>protobuf</code>生态）</li></ol><p>今天开始，我将以<code>Go</code>语言为背景，开启一个<code>buf</code>套件相关的教程。整个教程会分为四大篇章，分别回答以下问题：</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/buf-0.png"></p><span id="more"></span><p>本文将作为索引篇章，持续更新，帮助大家快速找到想要看的内容。</p><p>通过本教程，你将获得：</p><ul><li>掌握<code>buf</code>工具为代表的高效RPC框架（微服务框架的核心）</li><li><code>Go</code>语言的实战讲解</li><li>编程设计思想</li></ul><p>以下为本系列的目录：</p><ul><li>背景篇</li><li>入门篇</li><li>实战篇</li><li>高级篇</li></ul><p>欢迎有疑问的小伙伴可以通过下面的联系方式和我交流。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-buf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;buf&lt;/code&gt;是一个很棒的基于&lt;code&gt;protobuf&lt;/code&gt;来建立微服务API体系的工具。&lt;/p&gt;
&lt;p&gt;我个人是&lt;code&gt;buf&lt;/code&gt;的重度用户，并已在多个企业级的项目中落地。但是，鉴于&lt;code&gt;buf&lt;/code&gt;以下三个特点，网上的相关教程很少：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;资料基本由英文文档构成&lt;/li&gt;
&lt;li&gt;更新迭代快，有很多新增或已过时的特性&lt;/li&gt;
&lt;li&gt;有一定的技术门槛（如熟悉&lt;code&gt;protobuf&lt;/code&gt;生态）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天开始，我将以&lt;code&gt;Go&lt;/code&gt;语言为背景，开启一个&lt;code&gt;buf&lt;/code&gt;套件相关的教程。整个教程会分为四大篇章，分别回答以下问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/buf-0.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Buf" scheme="http://example.com/tags/Go-Buf/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习 - RPC篇:gRPC-Gateway定制mux选项</title>
    <link href="http://example.com/2022/12/27/go-study/go-rpc-6/"/>
    <id>http://example.com/2022/12/27/go-study/go-rpc-6/</id>
    <published>2022-12-27T04:00:00.000Z</published>
    <updated>2022-12-28T13:24:41.573Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>通过上一讲，我们对gRPC的拦截器有了一定的认识，也能定制出很多通用的中间件。</p><p>但在大部分的业务系统中，我们面向的还是HTTP协议。那么，今天我们就从gRPC-Gateway的mux选项出发，一起来看看一些很实用的特性。</p><span id="more"></span><h2 id="ServeMux"><a href="#ServeMux" class="headerlink" title="ServeMux"></a>ServeMux</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/grpc-ecosystem/grpc-gateway/v2/runtime&quot;</span></span><br><span class="line"></span><br><span class="line">gwMux := runtime.NewServeMux()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServeMux</span><span class="params">(opts ...ServeMuxOption)</span> *<span class="title">ServeMux</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将目标聚焦于这个<code>ServeMux</code>：</p><ol><li>目前官方区分v1和v2版本，版本不一致会导致很多编译上的问题</li><li>入参包括多个<code>option</code>选项函数，用于定制想要的mux内容</li></ol><p>具体的内容可以参考<code>ServeMux</code>的数据结构，我这里挑选几个重点的能力：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 这个是server的核心实现：即注册的handlerf</span></span><br><span class="line">handlers                  <span class="keyword">map</span>[<span class="keyword">string</span>][]handler</span><br><span class="line">  <span class="comment">// 1、转发正常响应</span></span><br><span class="line">forwardResponseOptions    []<span class="function"><span class="keyword">func</span><span class="params">(context.Context, http.ResponseWriter, proto.Message)</span> <span class="title">error</span></span></span><br><span class="line">  <span class="comment">// 2、序列化工具</span></span><br><span class="line">marshalers                marshalerRegistry</span><br><span class="line">  <span class="comment">// 3、进入时（http-&gt;grpc）的header匹配规则</span></span><br><span class="line">incomingHeaderMatcher     HeaderMatcherFunc</span><br><span class="line">  <span class="comment">// 4、返回时（grpc-&gt;http）的header匹配规则</span></span><br><span class="line">outgoingHeaderMatcher     HeaderMatcherFunc</span><br><span class="line">  <span class="comment">// 5、metadata的转换（从http转成grpc的md）</span></span><br><span class="line">metadataAnnotators        []<span class="function"><span class="keyword">func</span><span class="params">(context.Context, *http.Request)</span> <span class="title">metadata</span>.<span class="title">MD</span></span></span><br><span class="line">  <span class="comment">// 6、错误处理</span></span><br><span class="line">errorHandler              ErrorHandlerFunc</span><br><span class="line">  <span class="comment">// 7、流式错误处理</span></span><br><span class="line">streamErrorHandler        StreamErrorHandlerFunc</span><br><span class="line">  <span class="comment">// 8、路由错误</span></span><br><span class="line">routingErrorHandler       RoutingErrorHandlerFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合一下，核心能力其实包括2块：</p><ol><li>Header数据的处理</li><li>返回消息的处理（包括正常情况和错误情况）</li></ol><h2 id="Header的数据处理"><a href="#Header的数据处理" class="headerlink" title="Header的数据处理"></a>Header的数据处理</h2><h3 id="HTTP与gRPC协议头匹配"><a href="#HTTP与gRPC协议头匹配" class="headerlink" title="HTTP与gRPC协议头匹配"></a>HTTP与gRPC协议头匹配</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTTP -&gt; gRPC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithIncomingHeaderMatcher</span><span class="params">(fn HeaderMatcherFunc)</span> <span class="title">ServeMuxOption</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gRPC -&gt; HTTP</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithOutgoingHeaderMatcher</span><span class="params">(fn HeaderMatcherFunc)</span> <span class="title">ServeMuxOption</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HeaderMatcherFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure><p>这个函数只做一个简单的映射，我们可以通过下面的例子开快速了解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入参：header key</span></span><br><span class="line"><span class="comment">// 出参：返回header key，以及是否返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CustomMatcher</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> key &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;some-special-key&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> key, <span class="literal">true</span> </span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;deprecated-key&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">false</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 默认的匹配规则</span></span><br><span class="line"><span class="keyword">return</span> runtime.DefaultHeaderMatcher(key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将HTTP头转成gRPC头"><a href="#将HTTP头转成gRPC头" class="headerlink" title="将HTTP头转成gRPC头"></a>将HTTP头转成gRPC头</h3><p>上面的<code>matcher</code>只是做一个key的映射，如果<code>Header</code>里包括更复杂的部分（例如Cookie），需要引入下面函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithMetadata</span><span class="params">(annotator <span class="keyword">func</span>(context.Context, *http.Request)</span> <span class="title">metadata</span>.<span class="title">MD</span>) <span class="title">ServeMuxOption</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(serveMux *ServeMux)</span></span> &#123;</span><br><span class="line">serveMux.metadataAnnotators = <span class="built_in">append</span>(serveMux.metadataAnnotators, annotator)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意两个点：</p><ol><li>只做协议转换，不做逻辑处理（逻辑处理交给gRPC层的中间件统一处理）</li><li><code>metadata.MD</code>的底层数据结构为<code>map[string][]string</code>，与HTTP Header很类似</li></ol><p>下面给出一个HTTP的Cookie处理示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  HTTP_COOKIE_TOKEN = <span class="string">&quot;http_cookie&quot;</span></span><br><span class="line">  MD_TOKEN = <span class="string">&quot;md_cookie&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleCookieMetadataAnnotator</span><span class="params">(ctx context.Context, r *http.Request)</span> <span class="params">(md metadata.MD)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 从HTTP的cookie中读出对应的数据</span></span><br><span class="line">  c, err := r.Cookie(ODIN_JWT_TOKEN)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将值放到md里，方便在后续提取</span></span><br><span class="line"><span class="keyword">return</span> metadata.Pairs(MD_TOKEN, c.Value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回数据处理"><a href="#返回数据处理" class="headerlink" title="返回数据处理"></a>返回数据处理</h2><h3 id="正确返回"><a href="#正确返回" class="headerlink" title="正确返回"></a>正确返回</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithForwardResponseOption</span><span class="params">(forwardResponseOption <span class="keyword">func</span>(context.Context, http.ResponseWriter, proto.Message)</span> <span class="title">error</span>) <span class="title">ServeMuxOption</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确返回时，核心的数据结构为 <code>protoMessage</code>。我们不妨做一个封装：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HTTPResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">Errno <span class="keyword">int</span>         <span class="string">`json:&quot;errno&quot;`</span></span><br><span class="line">Msg   <span class="keyword">string</span>      <span class="string">`json:&quot;msg&quot;`</span></span><br><span class="line">Data  <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GatewayResponseModifier</span><span class="params">(ctx context.Context, w http.ResponseWriter, resp proto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 返回的数据，在外层同一封装了数据结构HTTPResponse，对一些历史项目兼容有很棒的效果</span></span><br><span class="line">  newResp := &amp;HTTPResponse&#123;</span><br><span class="line">    Data: resp,</span><br><span class="line">  &#125;</span><br><span class="line">pbData, _ := json.Marshal(newResp)</span><br><span class="line">  w.Write(pbData)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误返回"><a href="#错误返回" class="headerlink" title="错误返回"></a>错误返回</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithErrorHandler</span><span class="params">(fn ErrorHandlerFunc)</span> <span class="title">ServeMuxOption</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误处理在整个RPC框架中扮演了非常重要的角色，我们不妨通过如下例子来了解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GatewayErrModifier</span><span class="params">(ctx context.Context, mux *runtime.ServeMux, m runtime.Marshaler, w http.ResponseWriter, r *http.Request, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 提取error</span></span><br><span class="line">s, ok := status.FromError(err)</span><br><span class="line"><span class="comment">// 非标准错误</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">runtime.DefaultHTTPErrorHandler(ctx, mux, m, w, r, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对各类错误增加定制的逻辑</span></span><br><span class="line"><span class="keyword">switch</span> s.Code() &#123;</span><br><span class="line"><span class="keyword">case</span> codes.Unauthenticated:</span><br><span class="line"><span class="comment">// 示例：认证失败，可以加入重定向的逻辑</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">runtime.DefaultHTTPErrorHandler(ctx, mux, m, w, r, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下重点：</p><ol><li><code>error</code>尽可能用<code>gRPC</code>标准的错误<code>Status</code>表示</li><li><code>gRPC</code>的标准错误，对错误码code有一套定义（参考<code>google.golang.org/grpc/codes</code>），类似于<code>HTTP</code>的状态码</li><li>错误码code要尽量少，过多没有意义<ol><li>标准错误码尽可能复用，如资源找不到、权限不足等</li><li>业务错误码可以独立，一般一个系统定义1个即可</li></ol></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文重点介绍了<code>gRPC-Gateway</code>中2类<code>ServeMux</code>，也演示了对应的示例，大家能理解其基本用法即可。</p><p>后续，随着整体项目的落地，我会增加一些日常项目中常见的定制需求，帮助大家更好地认识RPC框架的能力。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;通过上一讲，我们对gRPC的拦截器有了一定的认识，也能定制出很多通用的中间件。&lt;/p&gt;
&lt;p&gt;但在大部分的业务系统中，我们面向的还是HTTP协议。那么，今天我们就从gRPC-Gateway的mux选项出发，一起来看看一些很实用的特性。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go-Buf教程 - 1.【背景篇】从Buf定位看API接口的演进</title>
    <link href="http://example.com/2022/12/21/go-buf/go-buf-1/"/>
    <id>http://example.com/2022/12/21/go-buf/go-buf-1/</id>
    <published>2022-12-21T04:00:00.000Z</published>
    <updated>2023-01-02T12:03:06.586Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-buf.jpg"></p><p>首先，<code>buf</code>是一个什么样的工具？我提取了三个关键词：</p><ul><li><code>Protocol Buffers</code> - 底层的技术基础是Google的<code>protobuf</code>语言</li><li><code>API Lifecycle</code> - 目标是管理<code>API</code>接口的全生命周期，重点是初次发布与后续更新</li><li><code>Team</code> - 强调的是团队协作，解决人与人之间沟通的问题</li></ul><p>要说清楚<code>buf</code>这个项目，就离不开API接口开发的历史演进。今天，我将挑选<a href="https://buf.build/">官方</a>介绍的三个重点，让大家更好地了解<code>buf</code>要解决的问题。</p><span id="more"></span><h2 id="两个角色：Producer-amp-Consumer"><a href="#两个角色：Producer-amp-Consumer" class="headerlink" title="两个角色：Producer &amp; Consumer"></a>两个角色：Producer &amp; Consumer</h2><p>对于一个API服务，有2种最重要的角色：</p><ul><li>Producer - API服务提供方，也叫被调用方</li><li>Consumer - API服务的使用方，也叫调用方，往往具有多个</li></ul><p>要调通一个API不难，但要做好，有很多问题需要解决，尤其如下三个问题：</p><ol><li><strong>理解成本</strong>：API接口怎么理解？提供文档或SDK就能满足吗？</li><li><strong>迭代问题</strong>：Producer紧急修复了问题、更新了接口，怎么通知到各个调用方？</li><li><strong>重复开发</strong>：多语言、多框架的情况下，怎么减少重复度高的编码工作，如定义数据结构？</li></ol><p>关于API的设计与实现的细节，不同团队有自己的方案，我们来看看<code>buf</code>提供的亮点：</p><ul><li>Producer<ul><li>遵循Best Practice来使用<code>protobuf</code>的API</li><li>分发API到各使用方，让对方及时更新</li><li>集中式地管理API文档</li></ul></li><li>Consumer<ul><li>根据<code>protobuf</code>定义，快速开发</li><li>用工具减少歧义</li><li>可生成的CLI/定制插件/mock服务/压力测试等特性</li></ul></li></ul><p>以上特性看起来很酷，核心方向依旧是：<strong>提高Producer和Consumer的效率与协作</strong>。</p><h2 id="方案1-RESTful"><a href="#方案1-RESTful" class="headerlink" title="方案1 - RESTful"></a>方案1 - RESTful</h2><p>官方对RESTful接口的概括如下图：</p><p><img src="https://buf.build/static/restful-apis-6cd5944265317eef85e787ad02885e6b.svg" alt="RESTful APIs"></p><p>RESTful API虽然已经被公认为一种很好的API设计标准，但在实际开发过程中，各有各的理解。所以，RESTful更像是一种风格趋势，但无法形成标准，这就对Consumer在协作开发时带来了难度：</p><ul><li>理解成本：标准不统一，调接口类似于黑盒测试</li><li>实现方式：不同调用方有自己的实现，对后续维护带来很大成本</li></ul><p>我们可以通过以下两条路径进行改善：</p><ol><li>内部统一框架：利用相关的工具，强制约束接口设计</li><li>自动生成SDK：调用方统一用SDK收敛</li></ol><p>这两点从技术实现来看并不难，但挺考验研发团队的能力，一不小心就造了个很不好用的轮子。对于大部分开发者来说，更希望找一个成熟的、长期维护的方案。</p><h2 id="方案2-Protocol-Buffers（无Buf）"><a href="#方案2-Protocol-Buffers（无Buf）" class="headerlink" title="方案2 - Protocol Buffers（无Buf）"></a>方案2 - Protocol Buffers（无Buf）</h2><p>接着，我们来看看社区中原生的<code>Protocol Buffers</code>的方案：</p><p><img src="https://buf.build/static/protobuf-ca548d51691fe9bda30b04275e0e5563.svg" alt="Protocol Buffers without Buf"></p><p>本方案最大的变化，就是有了一个协议的<strong>标准传输介质</strong> - <code>Protobuf Schema</code>。它规范了Producer侧的接口实现，并且利用<code>protobuf</code>提供了跨语言的方案。</p><p>但是，从图中可以看出，传播<code>Protobuf Schema</code>依然是一个高频出现问题的地方：</p><ul><li>Producer - 设计与发布API没有支持，全靠人工、甚至是邮件沟通</li><li>Consumer - 对<code>protobuf</code>没有统一管理的手段，如版本依赖、SDK生成等</li></ul><p>不过，<code>Protobuf</code>对API接口设计提供了很关键的基础能力 - 有了切实可落地的标准，并且实现了跨语言代码生成的基础。接下来，就是要解决 <strong>最后一公里</strong> 的问题了。</p><h2 id="方案3-Protocol-Buffers（有Buf）"><a href="#方案3-Protocol-Buffers（有Buf）" class="headerlink" title="方案3 - Protocol Buffers（有Buf）"></a>方案3 - Protocol Buffers（有Buf）</h2><p>Buf方案，核心是对<code>Protobuf Schema</code>的管理与扩展</p><p><img src="https://buf.build/static/buf-graph-f73585cb2ce571190da213de0af6e198.svg" alt="Buf"></p><p>从<code>Buf</code>提供的核心能力来说，主要分为3块：</p><ol><li>语法规范 - 从语法上规范API设计，遵循其<code>Best Practice</code></li><li>代码生成 - 包括Producer与Consumer侧的代码自动生成</li><li>依赖管理 - 对各Consumer的依赖进行统一管理</li></ol><blockquote><p>我认为核心在于第一点：规范化、标准化的程度越高，自动化的能力自然就越强：</p><p>第二、三点，往往会根据团队情况，需要定制化。</p></blockquote><p>其余能力是偏插件化的功能，就不重点讲了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天，我们通过对3个API方案的介绍，对<code>Buf</code>套件有了初步的了解。如果用一句话概括：</p><p><strong><code>Buf</code>重点是通过对<code>Protobuf Schema</code>的规范化，提供代码生成、依赖管理等一站式的API接口管理方案，来保证开发效率与团队协作的收益最大化。</strong></p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-buf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先，&lt;code&gt;buf&lt;/code&gt;是一个什么样的工具？我提取了三个关键词：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Protocol Buffers&lt;/code&gt; - 底层的技术基础是Google的&lt;code&gt;protobuf&lt;/code&gt;语言&lt;/li&gt;
&lt;li&gt;&lt;code&gt;API Lifecycle&lt;/code&gt; - 目标是管理&lt;code&gt;API&lt;/code&gt;接口的全生命周期，重点是初次发布与后续更新&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Team&lt;/code&gt; - 强调的是团队协作，解决人与人之间沟通的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要说清楚&lt;code&gt;buf&lt;/code&gt;这个项目，就离不开API接口开发的历史演进。今天，我将挑选&lt;a href=&quot;https://buf.build/&quot;&gt;官方&lt;/a&gt;介绍的三个重点，让大家更好地了解&lt;code&gt;buf&lt;/code&gt;要解决的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Buf" scheme="http://example.com/tags/Go-Buf/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 17.【Go工程化测试】业务项目中的Go单元测试心得</title>
    <link href="http://example.com/2022/12/06/go-tip/go-tip-17/"/>
    <id>http://example.com/2022/12/06/go-tip/go-tip-17/</id>
    <published>2022-12-06T04:00:00.000Z</published>
    <updated>2022-12-07T14:23:57.623Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>在网上搜索 <strong>Go单元测试</strong>，我们能找到各种开源工具和方法技巧，也可以照葫芦画瓢、快速地写出示例test case。但回到具体的工程项目里，当我们面对代码里的各种CRUD、接口与实现、内外部依赖时，往往发现很难写出有效的单元测试，空有一身技巧却无从下手。</p><p>我也被这个问题困扰许久，也反复在多个项目里折腾，发现要将单元测试落地到项目中，有一条被忽视的<code>gap</code>。下面我分享一下个人的思路。</p><p>Go单元测试的具体语法，本文会一笔带过，想了解细节的同学可以自行搜索。</p><span id="more"></span><h2 id="0-从业务项目的分层聊起"><a href="#0-从业务项目的分层聊起" class="headerlink" title="0. 从业务项目的分层聊起"></a>0. 从业务项目的分层聊起</h2><p>本文暂不讨论工具类项目，而是聚焦于结构相对复杂的业务类项目。</p><blockquote><p>偏基础工具类的代码库，写单元测试的逻辑会比较直观，也更注重性能等场景。</p></blockquote><p>业务项目通常会进行分层，本文以一个简化后的三层结构为例：</p><ul><li>请求/响应处理层 - Controller</li><li>业务领域层 - Service（Domain/Logic）</li><li>数据访问层 - Dao（Model）</li></ul><blockquote><p>很多复杂的分层可认为是上面的的一种变体。</p></blockquote><p>写Go单元测试的具体语法，本文会一笔带过，想了解细节的同学可以自行搜索。</p><h2 id="1-单元测试的外部依赖问题"><a href="#1-单元测试的外部依赖问题" class="headerlink" title="1. 单元测试的外部依赖问题"></a>1. 单元测试的外部依赖问题</h2><p>在业务开发时，有句玩笑话：如果你坚持写单测，最终会变成Postman工程师。虽然这话带有戏谑的色彩，但我们不妨想想它背后的逻辑：</p><h3 id="1-1-从“捷径”到放弃"><a href="#1-1-从“捷径”到放弃" class="headerlink" title="1.1 从“捷径”到放弃"></a>1.1 从“捷径”到放弃</h3><p>一个项目中的代码是层层调用的，我们以一个满足上述分层的服务为例：</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-unittest-func.png"></p><p>从调用栈来看，写一个顶层函数的单测，既能包括本层代码、又能覆盖下面各层，在最上层（Controller）写单元测试似乎成了最优解。这时，开发者会遇到一个常见问题 - <strong>代码的层层调用，很难屏蔽外部的依赖项</strong>，尤其是MySQL/Redis等中间件和自研服务。</p><p>接下来是我的经历，相信能引起不少人的共鸣：</p><p><strong>阶段一：依赖测试环境的服务写单测，立杆见影地跑通单测、覆盖率也不错。</strong></p><blockquote><p>我的想法：“巧妙的变通”</p><p>虽说从单元测试的定义来说，不应依赖外部服务，但不妨把这当作是一种变通，又快又方便。</p></blockquote><p><strong>阶段二：外部服务引入的问题越来越多，严格检查结果的单测很难通过，只能不断删减检查项，导致单测的质量和覆盖率越来越差。</strong></p><blockquote><p>我的想法：对外部环境不得已的“妥协”</p><p>外部服务既不稳定，又往往是有状态的，很难支撑单元测试里的各种case。单测能跑通总比跑不通好，单测质量下降并不是我偷懒，而是外部因素的不可控。</p></blockquote><p><strong>阶段三：单测能发现的问题越来越少，还不如用Postman手动请求并观察结果来得有效。食之无味，弃之可惜，单测就只作为评估绩效的指标了。</strong></p><blockquote><p>我的想法：复杂业务项目里的单元测试没什么价值，就仅仅作为一个绩效指标算了。</p><p>对项目来说，单测失去了发现问题的能力；对开发者来说，那就只是应付性地去达成单测覆盖率的指标了。</p></blockquote><p>所以，为了保证单测的价值长期有效，我们要 <strong>尽可能地屏蔽外部系统的依赖</strong>；而对外部依赖的测试，尽可能地交由更高层面的接口测试、功能测试、系统联调等途径去保障。</p><h3 id="1-2-如何屏蔽外部依赖"><a href="#1-2-如何屏蔽外部依赖" class="headerlink" title="1.2 如何屏蔽外部依赖"></a>1.2 如何屏蔽外部依赖</h3><p>屏蔽外部依赖，业界主要有两种解法：</p><ol><li><strong>容器技术</strong> - 将外部依赖转为内部项，跟随单元测试的生命周期</li><li><strong>代码mock</strong> - 拦截对外部依赖的调用，获得可预期的返回结果</li></ol><p>第一个解法比较取巧，本质上仍是依赖外部服务，只是由单元测试掌控它们的生命周期。这种方案对于验证中间件相关的功能确实非常方便，但长期维护的成本不低，慎用。（后文会再次提及）</p><p>第二个解法是单元测试最为推荐的方式，即常说的 mock/打桩。mock的具体方案依赖编程语言、框架以及对应的生态。例如在<code>Spring</code>里写单测很方便，包括：</p><ol><li>底层JVM强大的运行时能力</li><li>Spring的依赖注入</li><li>社区中成熟的各中间件Mock</li></ol><p>而Go语言在这块并没有得天独厚的优势。下面，我分享一个社区中比较推荐的解法。</p><h3 id="1-3-适配Go语言的单测方案"><a href="#1-3-适配Go语言的单测方案" class="headerlink" title="1.3 适配Go语言的单测方案"></a>1.3 适配Go语言的单测方案</h3><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-unittest-di.png"></p><p>图中的重点内容如下：</p><ol><li>三个虚箭头<ol><li>Service层的对象依赖Dao层的接口</li><li>Dao层接口的业务实现，由开发者自行编写代码</li><li>Dao层接口的mock实现，由 <a href="https://github.com/golang/mock">gomock</a> 自动生成</li></ol></li><li>依赖注入DI<ol><li>业务对象在初始化时注入想要的实现，遵循<code>IoC</code>的设计原则</li><li>正常情况下，注入业务实现；单元测试时，注入mock实现</li><li>一般可利用google的<a href="https://github.com/google/wire">wire</a>工具来自动化地生成依赖注入的代码</li></ol></li></ol><p>Mock实现无需依赖外部，我们利用面向对象的特性轻松地解决了这个问题。在复杂的工程中，还应注意两点：</p><ol><li>DI应和业务的抽象结合起来，不要只当作单纯的一种解耦的工具。</li><li>业务领域层往往内部也会分为多层（参考DDD），优先梳理上下文关系，才能设计好DI的实现。</li></ol><blockquote><p>DI是一个非常重要的解耦手段，但Go语言的框架无法强限制，往往只能靠“制定规范”， 如 <a href="https://go-kratos.dev/">Kratos</a>。</p></blockquote><h3 id="1-4-一个DI示例"><a href="#1-4-一个DI示例" class="headerlink" title="1.4 一个DI示例"></a>1.4 一个DI示例</h3><p>service层</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 依赖dao层的接口</span></span><br><span class="line">  dao.DaoReader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitBook</span><span class="params">(reader dao.DaoReader)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Reader&#123;reader&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dao层</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dao</span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">type</span> DaoReader <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务实现</span></span><br><span class="line"><span class="keyword">type</span> MyReader DaoReader</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyReader</span><span class="params">()</span> <span class="title">DaoReader</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;MyReader&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mock_dao层（建议另起一个目录）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成mock的示例命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从dao/reader.go中的interface生成</span></span><br><span class="line">mockgen -source=dao/reader.go -destination=mock_dao/reader.go</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码为自动生成，并进行了简化</span></span><br><span class="line"><span class="keyword">package</span> mock_dao</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MockDaoReader <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMockDaoReader</span><span class="params">(ctrl *gomock.Controller)</span> *<span class="title">MockDaoReader</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;MockDaoReader&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，就有了正常情况下与单元测试情况下的依赖注入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"><span class="comment">// 正常的注入</span></span><br><span class="line">reader := InitBook(dao.NewMyReader())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试的注入</span></span><br><span class="line">mockReader := mock_dao.NewMockDaoReader(gomock.NewController(t))</span><br><span class="line">reader := InitBook(mockReader)</span><br></pre></td></tr></table></figure><h2 id="2-在有限的时间内，探索“最有价值”的单元测试"><a href="#2-在有限的时间内，探索“最有价值”的单元测试" class="headerlink" title="2. 在有限的时间内，探索“最有价值”的单元测试"></a>2. 在有限的时间内，探索“最有价值”的单元测试</h2><h3 id="2-1-一个代码覆盖率的问题"><a href="#2-1-一个代码覆盖率的问题" class="headerlink" title="2.1 一个代码覆盖率的问题"></a>2.1 一个代码覆盖率的问题</h3><p>在开发过程中，上层代码对下层的代码调用往往有具有限制，如限制了传参的类型、数量、范围。以下面的代码为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上层</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  s, _ := sum(a,b)</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下层</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// case1 - a/b 为int</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// case2 - a/b 为float</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// case3 - a/b 为string</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，上层<code>Sum</code>函数的入参限制，会导致下层<code>sum</code>中被调用到的代码很有限。因此，在上层<code>Sum</code>进行单元测试，会导致下层<code>sum</code>函数的测试不完全。</p><p>这个代码覆盖率的问题是不可规避的。我们不难得出，在分层场景下，<strong>要使某层代码的覆盖率最高，尽量在同层编写单元测试</strong>。那么，如果要让整个项目的代码覆盖率达到100%，每层的单测都得写，相信没几个公司经得起这样的投入。</p><p>时间有限，我们该如何寻找“最有价值”的单元测试呢？</p><h3 id="2-2-明确核心目标-保障业务逻辑"><a href="#2-2-明确核心目标-保障业务逻辑" class="headerlink" title="2.2 明确核心目标 - 保障业务逻辑"></a>2.2 明确核心目标 - 保障业务逻辑</h3><p>一个业务项目的代码，最重要的自然是保障业务逻辑。从前面三个分层的职责来看，<strong>Service层是我们要聚焦的重点，它的代码测试覆盖度无疑是要优先保障的</strong>。</p><p>于是，我们优先在Service层写了完整的单测，覆盖率也很高，但回头看到Controller/Dao层代码的覆盖率很低：</p><ul><li>上层Controller的代码无法从Service层调用到，单测覆盖率为0</li><li>下层Dao层的里的业务实现代码也没有被调用（依赖注入的是mock实现），单测覆盖率也很低</li></ul><p>既然我们的核心目标是 <strong>保障业务逻辑</strong>，那么，我们不妨从分层的角度分析一下：Controller层与Dao层的代码对核心业务逻辑的影响有多大？</p><h3 id="2-3-Controller-Dao层的单元测试思路"><a href="#2-3-Controller-Dao层的单元测试思路" class="headerlink" title="2.3 Controller/Dao层的单元测试思路"></a>2.3 Controller/Dao层的单元测试思路</h3><p>我们先看看这两层的主要功能：</p><ul><li>Controller层是做的是协议解析和数据转化，如HTTP根据Header里的content-type解析到对应结构体</li><li>Dao层主要负责的工作是数据持久化，比如MySQL里的CRUD<ul><li>为了方便讨论，我们对Dao层做一下延伸，认为与外部应用的RPC交互也是一种Dao层操作</li></ul></li></ul><p>这两层都具备一个共同特征：<strong>高度重复性的基础工作</strong>，非常适合建设公共的工具库。于是，Controller/Dao层的建设思路往往会分两步走：</p><ol><li>沉淀并维护公共的工具库 ，并保证其单元测试覆盖率<ol><li>Controller层的RPC框架</li><li>Dao层的MySQL ORM/服务SDK</li></ol></li><li>Controller/Dao层主要工作就是去调用工具库，并适配其接口</li></ol><p>在这种模式下，Controller与Dao层发生的问题可以得到有效控制：</p><ol><li>工具库本身 - 引用优秀的开源库或自建，保证测试完备，自身很少出错（有问题就统一升级）</li><li>工具库的调用 - 依赖库设计的调用方式与使用者的经验</li><li>Controller/Dao层自身代码 - 只做简单的工具库调用与数据结构的转换</li></ol><blockquote><p>第2点中的工具库设计很重要，建议多考虑一下设计模式与Go语言强类型的特点，能提高用户体验：</p><p>比如说，工具库里要传一个时间类型的参数，可以将入参设计为 <code>duration int</code> （参数类型只有数字），但更好的方式是<code>duration time.Duration</code>（参数类型同时包含了数字+单位）。</p></blockquote><p>所以，对不熟悉框架的同学，在早期可以投入一些时间写写Controller/Dao层的单测，了解相关工具库的实现；而随着经验的积累，Controller/Dao层会专注于做2件事：</p><ul><li>选择合适的工具库进行调用</li><li>数据转化（从一个结构体转化到另一个结构体）</li></ul><p>随着项目的迭代，Controller/Dao层会变得越来越“薄”，投入单测的意义就没那么大了。</p><h3 id="2-4-评价指标"><a href="#2-4-评价指标" class="headerlink" title="2.4 评价指标"></a>2.4 评价指标</h3><p>至此，我们明确了以 <strong>保障核心业务逻辑</strong> 为单元测试的目标，并以 <strong>业务领域层</strong> 作为核心的单元测试覆盖对象，项目单元测试覆盖率指标也相对明确了，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定service路径下的所有文件，来计算单测覆盖率</span></span><br><span class="line">go test ./service/...  -coverprofile=profile.cov</span><br><span class="line">go tool cover -html=profile.cov -o coverage.html</span><br></pre></td></tr></table></figure><p>之后，就是一个不断迭代的过程了。整体的业务项目与工具库呈现如下：</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-unittest-framework-new.png"></p><h2 id="3-单元测试的相关实践"><a href="#3-单元测试的相关实践" class="headerlink" title="3.  单元测试的相关实践"></a>3.  单元测试的相关实践</h2><h3 id="3-1-Controller层不应向下传递协议类参数"><a href="#3-1-Controller层不应向下传递协议类参数" class="headerlink" title="3.1 Controller层不应向下传递协议类参数"></a>3.1 Controller层不应向下传递协议类参数</h3><p>我们先看两段代码：</p><p>标准HTTP的handler</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FooHandler</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">  service.Foo(w, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">  fmt.Fprint(w, <span class="string">&quot;my response&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gin框架的Handler</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FooHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">service.Foo(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  c.JSON(<span class="number">200</span>, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种代码都将协议相关的数据结构<code>http.ResponseWriter</code> 、<code>http.Request</code> 、 <code>gin.Context</code> 传递到了业务领域层。从功能开发来说完全正确，但大幅提升了业务领域层<code>Foo</code>函数单测的难度。</p><p>再看<code>protobuf</code>方案，通过预定义的接口文档与代码生成技术，让controller层的定义变成了如下形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(ctx context.Context, req *proto.FooRequest)</span> <span class="params">(resp *proto.FooResponse, err error)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务自定义的Controller层已经实现了与协议解耦，开发者无需关心协议是<code>HTTP</code>还是<code>gRPC</code>，数据格式是<code>json</code>还是<code>form</code>等。Controller层的这个优势，自然保证了Service层与协议无关。</p><p>所以，<code>protobuf</code> 为代表的的IDL方案，对业务领域层的单测更为友好。</p><h3 id="3-2-Dao层的业务实现高频出错，怎么写单测？"><a href="#3-2-Dao层的业务实现高频出错，怎么写单测？" class="headerlink" title="3.2 Dao层的业务实现高频出错，怎么写单测？"></a>3.2 Dao层的业务实现高频出错，怎么写单测？</h3><p>在理想状态，Dao层出现问题的概率很小，但实际情况中有诸多限制：</p><ul><li>dao层包含很多业务逻辑</li><li>开发者使用工具库的经验少，CRUD常常犯错</li><li>历史项目，dao层很难调整，工具库也常常出错</li></ul><p>当你评估Dao层的单测会给整个项目带来足够的收益时，自然可以添加Dao层的单测。这时，对于外部依赖的问题，有如下2种方式：</p><ol><li>优先使用容器，可利用<code>testing.Main</code>的特性来创建和销毁（类似python中的<code>setUp</code>和<code>tearDown</code>）</li><li>如果不得不依赖测试环境，尽可能地用<code>defer</code>的特性去清理单测产生的数据</li></ol><p>长期维护这两个方案，都比较费时费力。</p><h3 id="3-3-Go的单测有哪些好用的库或者工具？"><a href="#3-3-Go的单测有哪些好用的库或者工具？" class="headerlink" title="3.3 Go的单测有哪些好用的库或者工具？"></a>3.3 Go的单测有哪些好用的库或者工具？</h3><ol><li>Mock类<ol><li><a href="https://github.com/golang/mock">gomock</a> 官方推荐的工具，可以从接口生成mock代码</li><li><a href="https://github.com/agiledragon/gomonkey">Go Monkey</a> 可以对特定函数进行打桩，一般用于特定错误的模拟</li></ol></li><li>接口相关<ol><li><a href="https://github.com/google/wire">wire</a> 解决依赖注入的利器</li><li><a href="https://www.jetbrains.com/help/go/extract-interface-dialog.html">Goland的提取接口</a> 从具体实现中，提取出接口定义，重构代码的利器</li></ol></li><li>写单元测试<ol><li><a href="https://pkg.go.dev/testing#hdr-Main">testing.Main</a> 统一进行单测依赖项的初始化与销毁的工作，减少重复性代码</li><li><a href="https://github.com/cweill/gotests">gotests</a> 生成具体单元测试代码的框架，少写很多代码，已集成到<code>VSCode</code>/<code>Goland</code></li><li><a href="https://github.com/stretchr/testify">testify</a> 断言，可以减少单测的代码量，并增加可读性</li></ol></li><li>其它 - 发掘自己写单测时的高度重复性的代码，利用<code>go genereate</code>特性自动生成</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文讨论的业务代码是以<strong>对象</strong>为最小维度的。如果对象内部涉及到<code>goroutine</code>、<code>channel</code> 等特性，就需要在该对象的单测设计时有更多的考量，但不会影响整体项目的框架。</p><p>无论是框架分层、代码抽象，还是工具库的建设，单元测试都是高度依赖Go项目框架与规范的。<strong>良好的代码测试覆盖率是必须要框架适配的</strong>，生搬硬套往往让自己写单测写得很疲惫，也会让单元测试慢慢失去价值。</p><p>在Go项目中，要保证核心代码的高测试覆盖率，难度往往比需求开发高 - 往往过程性思维的CRUD，就能满足完成需求，而优秀的单元测试则为了保证测试的完备性，需要相当的抽象能力，并且持续重构。</p><p><strong>道阻且长，行则将至。</strong></p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h2&gt;&lt;p&gt;在网上搜索 &lt;strong&gt;Go单元测试&lt;/strong&gt;，我们能找到各种开源工具和方法技巧，也可以照葫芦画瓢、快速地写出示例test case。但回到具体的工程项目里，当我们面对代码里的各种CRUD、接口与实现、内外部依赖时，往往发现很难写出有效的单元测试，空有一身技巧却无从下手。&lt;/p&gt;
&lt;p&gt;我也被这个问题困扰许久，也反复在多个项目里折腾，发现要将单元测试落地到项目中，有一条被忽视的&lt;code&gt;gap&lt;/code&gt;。下面我分享一下个人的思路。&lt;/p&gt;
&lt;p&gt;Go单元测试的具体语法，本文会一笔带过，想了解细节的同学可以自行搜索。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习 - RPC篇:gRPC拦截器剖析</title>
    <link href="http://example.com/2022/11/17/go-study/go-rpc-5/"/>
    <id>http://example.com/2022/11/17/go-study/go-rpc-5/</id>
    <published>2022-11-17T04:00:00.000Z</published>
    <updated>2022-12-13T11:18:02.601Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>我们在前几讲提到过，优秀的RPC框架都提供了<code>middleware</code>的能力，可以减少很多重复代码的编写。在gRPC-Gateway的方案里，包括了两块中间件的能力：</p><ol><li>gRPC中的<code>ServerOption</code>，是所有gRPC+HTTP都会被处理</li><li>gRPC-Gateway中的<code>ServeMuxOption</code>，只有HTTP协议会被处理</li></ol><p>今天，我们先关注共同部分的<code>ServerOption</code>，它提供的能力最为全面，让我们一起了解下。</p><span id="more"></span><h2 id="官方实现"><a href="#官方实现" class="headerlink" title="官方实现"></a>官方实现</h2><p>在官方文件<code>google.golang.org/grpc/server.go</code>路径下，给出了很多公开的<code>ServerOption</code>方法。从本质上来说，这些方法都是为了修改服务端的一个核心数据结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> serverOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">creds                 credentials.TransportCredentials</span><br><span class="line">codec                 baseCodec</span><br><span class="line">cp                    Compressor</span><br><span class="line">dc                    Decompressor</span><br><span class="line">unaryInt              UnaryServerInterceptor</span><br><span class="line">streamInt             StreamServerInterceptor</span><br><span class="line">chainUnaryInts        []UnaryServerInterceptor</span><br><span class="line">chainStreamInts       []StreamServerInterceptor</span><br><span class="line">binaryLogger          binarylog.Logger</span><br><span class="line">inTapHandle           tap.ServerInHandle</span><br><span class="line">statsHandlers         []stats.Handler</span><br><span class="line">maxConcurrentStreams  <span class="keyword">uint32</span></span><br><span class="line">maxReceiveMessageSize <span class="keyword">int</span></span><br><span class="line">maxSendMessageSize    <span class="keyword">int</span></span><br><span class="line">unknownStreamDesc     *StreamDesc</span><br><span class="line">keepaliveParams       keepalive.ServerParameters</span><br><span class="line">keepalivePolicy       keepalive.EnforcementPolicy</span><br><span class="line">initialWindowSize     <span class="keyword">int32</span></span><br><span class="line">initialConnWindowSize <span class="keyword">int32</span></span><br><span class="line">writeBufferSize       <span class="keyword">int</span></span><br><span class="line">readBufferSize        <span class="keyword">int</span></span><br><span class="line">connectionTimeout     time.Duration</span><br><span class="line">maxHeaderListSize     *<span class="keyword">uint32</span></span><br><span class="line">headerTableSize       *<span class="keyword">uint32</span></span><br><span class="line">numServerWorkers      <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难从命名中推断到，上述结构体包含了认证、编解码、压缩、日志等各种配置，其中在初始化时有一些默认值。我们将目光聚焦于核心middleware能力的实现 - 拦截器（Interceptor）。</p><p>gRPC协议提供了两种RPC调用的方式：</p><ul><li><code>Unary</code>普通的单次调用</li><li><code>Stream</code>流式调用</li></ul><p>我们框架的RPC调用都来自gRPC-Gateway对<code>HTTP</code>协议的转发，是属于<code>Unary</code>这块，所以我们聚焦于<code>UnaryServerInterceptor</code>即可。而<code>chainUnaryInts</code>的数据结构为<code>[]UnaryServerInterceptor</code>，即支撑了链式<code>middleware</code>的调用，是自定义入口的关键。</p><p>使用示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := grpc.NewServer(</span><br><span class="line">grpc.ChainUnaryInterceptor(</span><br><span class="line"><span class="comment">// 各个拦截器</span></span><br><span class="line">),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="分析UnaryServerInterceptor"><a href="#分析UnaryServerInterceptor" class="headerlink" title="分析UnaryServerInterceptor"></a>分析UnaryServerInterceptor</h2><p>我们先一起看看这个函数的签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnaryServerInterceptor <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span></span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 1 - 前处理</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2 - 调用具体实现</span></span><br><span class="line">resp, err = handler(ctx, req)</span><br><span class="line">  <span class="comment">// 3 - 后处理</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行逻辑"><a href="#运行逻辑" class="headerlink" title="运行逻辑"></a>运行逻辑</h3><p>可以看到，整个代码分三步进行，其中handler这部分的实现是开发者编写的业务逻辑。</p><p>而当存在链式的拦截器时，这部分的实现类似于先入后出的逻辑：</p><ol><li>前处理1 -&gt; 前处理2 -&gt; … -&gt; 前处理n</li><li>具体代码实现</li><li>后处理n -&gt; 后处理n-1 -&gt; … -&gt; 后处理1</li></ol><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ol><li>ctx - 上下文</li><li>req - 入参</li><li>info - <code>Unray</code>调用的信息，主要是方法名</li><li>handler - 正常处理的函数</li><li>resp - 出参</li><li>err - 错误</li></ol><p>我们要了解这6个参数，才能真正地理解gRPC，进而合理地使用拦截器。下面，我挑选3个重点进行描述：</p><ol><li>我们无法直接使用ctx提取值，而是要用<code>metadata.FromIncomingContext(ctx)</code>提取出gRPC的metadata、再塞入到ctx中。什么是metadata呢？你可以把它简单地类比到HTTP的Header。</li><li>req与resp的类型与<code>protobuf</code>中定义的方法对应。不难猜到，对数据的序列化、反序列化等操作，是在拦截器之前工作的。</li><li>resp与err这两个返回参数尽可能规范：当<code>err != nil</code>时，调用方只需关注err；当<code>err == nil</code>时，resp才有意义。</li></ol><p>这里，我再额外补充两个容易陷入误区的点：</p><ol><li>gRPC-Gateway中也有拦截器的实现，但我们尽可能只做协议的转换：将HTTP Header转换到gRPC-Gateway。这样可以保证gRPC和HTTP的调用，数据处理逻辑用一个拦截器就可以完成，如用户认证。</li><li>尽可能只用err来表示错误，而不要在resp里封装errno等字段（我在下一篇也会给出对应兼容的方案）。这里的error用<code>google.golang.org/grpc/internal/status</code>生成，如<code>status.Error(codes.Unauthenticated, &quot;用户校验失败&quot;)</code>，这样错误才能兼容框架，同时具备错误码与错误信息。</li></ol><h2 id="示例拦截器"><a href="#示例拦截器" class="headerlink" title="示例拦截器"></a>示例拦截器</h2><p>分析完上述内容后，我们结合一些经典的拦截器，方便大家了解它的价值：</p><h3 id="日志拦截器"><a href="#日志拦截器" class="headerlink" title="日志拦截器"></a>日志拦截器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerLoggingInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 进入打印日志，确认入参</span></span><br><span class="line">log.Info()</span><br><span class="line"></span><br><span class="line">resp, err = handler(ctx, req)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理完打印日志，包括出参和error</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.Info()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个RPC调用最终会落成2个日志：</p><ol><li>进入时的Info日志</li><li>返回时<ol><li>正常，则打印Info日志</li><li>有错误，则打印Error日志</li></ol></li></ol><p>日志拦截器的对我们的日常开发意义非常大，核心思路是：<strong>通过日志的一入一出，快速定位问题</strong>。常见的如：</p><ol><li>先看进入时的日志，看看打印的参数是否如预期，如果有错往往先从协议排查，如字段命名</li><li>再看返回的日志，如果打印的输出和预期的一致，那往往是调用方的协议问题，如字段未解析</li><li>如果进入时的日志正确，但返回的打印异常，那就是<code>handler</code>的实现有问题</li></ol><h3 id="recovery拦截器"><a href="#recovery拦截器" class="headerlink" title="recovery拦截器"></a>recovery拦截器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerRecoveryInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">stacktrace := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">stacktrace = stacktrace[:runtime.Stack(stacktrace, <span class="literal">false</span>)]</span><br><span class="line"><span class="comment">// error及堆栈进行日志打印</span></span><br><span class="line">      log.Error()</span><br><span class="line">      </span><br><span class="line">err = status.Error(codes.Unavailable, <span class="string">&quot;系统异常&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着项目的迭代，<code>handler</code>里的实现很有可能出现会导致panic的代码，我们必须对这种异常兜底，而不是随便导致程序崩溃。</p><p>示例代码就是捕获对应的panic，输出到日志，返回给调用方<strong>系统异常</strong>。recovery是保证HTTP服务稳定的重要实现，其中的日志对开发者事后排查问题也提供了参考，是一个必备的工具利器。</p><h3 id="用户认证拦截器"><a href="#用户认证拦截器" class="headerlink" title="用户认证拦截器"></a>用户认证拦截器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  USER_TOKEN    = <span class="string">&quot;USER_TOKEN&quot;</span></span><br><span class="line">CTX_USERNAME  = <span class="string">&quot;CTX_USERNAME&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerAuthUnaryInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1. 提取出metadata</span></span><br><span class="line">md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.Unauthenticated, <span class="string">&quot;用户校验失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 2. parseUserName 从对应的metadata的Key里提取信息，解析出用户名</span></span><br><span class="line">userName, err := parseUserName(md.Get(USER_TOKEN)[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.Unauthenticated, <span class="string">&quot;用户校验失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 3. 将用户名塞入到ctx中</span></span><br><span class="line">ctx = context.WithValue(ctx, CTX_USERNAME, userName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 继续逻辑处理</span></span><br><span class="line"><span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在handler里，调用这个函数可以提取到用户名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserName</span><span class="params">(ctx context.Context)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctx.Value(CTX_USERNAME).(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关的步骤已经在代码注释里写得很清楚了，这里再补充3个细节：</p><ol><li>metadata的USER_TOKEN这个Key，按调用方，来源分2种情况：<ol><li>如果调用方是gRPC，那就要求调用方在metadata里填充这个Key</li><li>如果调用方是HTTP，需要人工将HTTP的Header映射到gRPC的metadata，这部分就是在gRPC-Gateway的中间件里实现</li></ol></li><li>示例中的1与2会对未认证的请求直接拦截 - 不会调用到具体handler的代码，直接返回错误给调用方</li><li>如果服务的接口要区分认证与无需认证，建议从<code>info.FullMethod</code>入手，即调用的方法名，也就是增加一段<code>if-else</code>的判断逻辑</li></ol><h3 id="数据校验拦截器"><a href="#数据校验拦截器" class="headerlink" title="数据校验拦截器"></a>数据校验拦截器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PGV里的结构，都实现了这个方法</span></span><br><span class="line"><span class="keyword">type</span> Validator <span class="keyword">interface</span> &#123;</span><br><span class="line">ValidateAll() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerValidationUnaryInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 如果接口实现了PGV的方法，就认为必须要进行校验</span></span><br><span class="line"><span class="keyword">if</span> r, ok := req.(Validator); ok &#123;</span><br><span class="line">err = r.ValidateAll()</span><br><span class="line">    <span class="comment">// 校验失败，则打印错误并返回参数校验失败</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.InvalidArgument, <span class="string">&quot;参数校验失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在protobuf里有一个非常有用的插件 - PGV，可参考<a href="https://github.com/bufbuild/protoc-gen-validate">Github</a>，它能帮助开发者快速实现对应的参数校验：</p><ul><li>简单的如整型要大于1，字符串要非空</li><li>复杂的如邮箱、IP等格式检查</li></ul><p>但是，它需要开发者手工判断一次。这时，我们就可以利用拦截器+接口，组装出一个参数校验的拦截器，而无需再每个<code>handler</code>中都去判定。</p><p>这个实现很简洁，也充分利用了接口的特性，是一个经典的拦截器实现。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天，我们对gRPC中的拦截器进行了分析，并给出了4个经典的拦截器代码实现。而<code>gin</code>等框架中的middleware实现思路也基本与其一致，差别主要在参数类型不一样。</p><p>gRPC拦截器能有效地收敛很多重复代码，保证框架的统一与高效；相反地，如果某个公共能力无法用拦截器实现，就非常值得我们反思了。</p><p>接下来，我们将视角转移到gRPC-Gateway方案，看看在针对HTTP方面又有哪些高效的middleware。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;我们在前几讲提到过，优秀的RPC框架都提供了&lt;code&gt;middleware&lt;/code&gt;的能力，可以减少很多重复代码的编写。在gRPC-Gateway的方案里，包括了两块中间件的能力：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;gRPC中的&lt;code&gt;ServerOption&lt;/code&gt;，是所有gRPC+HTTP都会被处理&lt;/li&gt;
&lt;li&gt;gRPC-Gateway中的&lt;code&gt;ServeMuxOption&lt;/code&gt;，只有HTTP协议会被处理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天，我们先关注共同部分的&lt;code&gt;ServerOption&lt;/code&gt;，它提供的能力最为全面，让我们一起了解下。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习 - RPC篇:深入gRPC-Gateway-探索常用数据类型</title>
    <link href="http://example.com/2022/11/03/go-study/go-rpc-4/"/>
    <id>http://example.com/2022/11/03/go-study/go-rpc-4/</id>
    <published>2022-11-03T04:00:00.000Z</published>
    <updated>2022-11-03T12:04:54.551Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>gRPC-Gateway的相关方案我们已经在上一篇详细描述。为了更方面地方便大家理解，我这边整理了一个最简化的git项目：<a href="https://github.com/Junedayday/grpc-gateway-buf-example/tree/v0.0.1">https://github.com/Junedayday/grpc-gateway-buf-example/tree/v0.0.1</a> </p><p>它主要包含两个特点：</p><ol><li>用buf工具构建项目</li><li>同时启动了gRPC和gRPC-Gateway服务，支持两种协议的调用</li></ol><p>今天，我们先迈出第一步：探索RPC服务中的数据类型。掌握常见的数据类型，灵活地运用到接口设计中，能帮助我们快速地提供优雅的接口类服务。</p><span id="more"></span><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p><code>protobuf</code>的基础数据类型可参考链接：<a href="https://developers.google.com/protocol-buffers/docs/proto3#scalar">https://developers.google.com/protocol-buffers/docs/proto3#scalar</a></p><p>这部分属于是<code>protobuf</code>的基础知识，如果对这块不清楚，可以花5~10分钟快速过一下。</p><h3 id="默认值问题"><a href="#默认值问题" class="headerlink" title="默认值问题"></a>默认值问题</h3><p>基础类型有一个很值得思考的问题：每一种基础类型都有一个<strong>默认值</strong>，如<code>string</code>的默认值为<code>&quot;&quot;</code>，<code>int32</code>的默认值是<code>0</code>。这就带来了一个问题：<strong>当一个字段被解析为默认值时，怎么区分是未传值，还是传的就是默认值</strong>？</p><p>举个具体的例子，比如我们的传入参数为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;a&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;b&quot;</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;b&quot;</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将数据定义为</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终解析到Go结构体中的<code>Foo.A</code>字段都为0，但是，调用方对 <code>未传值</code> 和 <code>默认值</code> 很可能有不同的定义。</p><p>这个问题有三种常规的解决思路：</p><ol><li>利用编程语言特性，区分 <code>未传值</code> 与 <code>默认值</code> 两种情况；</li><li>两边利用协议约定，保证<code>未传值</code> 与 <code>默认值</code>等同；</li><li>新增加描述性字段，表明相关字段是否生效；</li></ol><p>为了方便理解，我对上面三个case各举个例子：</p><h3 id="方案1-在编程语言中区分"><a href="#方案1-在编程语言中区分" class="headerlink" title="方案1 - 在编程语言中区分"></a>方案1 - 在编程语言中区分</h3><p>以<code>Go</code>语言为例，会利用指针的特性，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">A *<span class="keyword">int32</span></span><br><span class="line">B *<span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解析示例的json时，可以按如下方式进行区分：</p><ul><li>当为默认值0时，将A指向为0的指针</li><li>当未传值时，将A指为nil</li></ul><p>但是，这种实现对语言有一定要求：</p><ol><li>要求语言支持指针（<code>protobuf</code>目标是跨语言的RPC方案）</li><li>对指针变量的操作需要不少额外的判断、转化操作</li></ol><p>虽然方案1的普适性不高，但在Go语言的开源项目中很常见，比如各种共有云的Go SDK。</p><h3 id="方案2-协议约定效果等同"><a href="#方案2-协议约定效果等同" class="headerlink" title="方案2 - 协议约定效果等同"></a>方案2 - 协议约定效果等同</h3><p>方案2更多是一种内部约定。比如，定义了一个数据</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int64</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">float</span> price = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双方约定了：无论字段传的是默认值还是未传值，我们都按默认值处理。</p><p>但是，在接口中，我们会高频地复用数据结构。例如，Book这个数据结构在创建时没有问题，但将这个结构用在更新接口时，往往会有如下思路：</p><ul><li>如果是默认值，接口是希望将这个字段修改为默认值，如name为空</li><li>如果未传值，接口是希望不更改这个字段，即不要修改name字段</li></ul><p>所以，在方案2时，我们只能二选一：当遇到默认值时，要么认为是不改、要么认为是改成默认值。而如果要兼容，那就新增字段或者新增结构。</p><p>方案2虽然存在局限性，但是频率最高的使用方式：毕竟一般情况下调用方就几个，双方简单沟通一下就可以解决问题。但如果面向成百上千的调用方时，这个解释成本就很高了。</p><p>下面的方案3则是对其的一种演进：</p><h3 id="方案3-新增加描述性字段"><a href="#方案3-新增加描述性字段" class="headerlink" title="方案3 - 新增加描述性字段"></a>方案3 - 新增加描述性字段</h3><p>基于方案2，我们可以直接增加一个字段进行标识（类似于一种掩码的效果），如<code>mask=[&quot;id&quot;,&quot;name&quot;]</code>，表示：</p><ul><li><code>id</code>,<code>name</code>这两个字段生效</li><li><code>price</code>字段不生效</li></ul><p>这时，前面的问题就得以解决：</p><ul><li>如果希望修改name为空，mask中增加name字段</li><li>如果不希望修改name，mask中不出现name字段</li></ul><p>这个实现，就是Google推荐的<code>FieldMask</code>的实现思路，下面我们会再次说明。</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p><code>protobuf</code>的枚举的是一种可读性很强的定义，可以参考如下链接了解：<a href="https://developers.google.com/protocol-buffers/docs/proto3#enum">https://developers.google.com/protocol-buffers/docs/proto3#enum</a></p><p>需要注意的是，官方推荐的将默认值0定义为<code>XXX_UNSPECIFIED</code>（即不在规定中，不具备实际意义），如</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Corpus</span> </span>&#123;</span><br><span class="line">  CORPUS_UNSPECIFIED = <span class="number">0</span>;</span><br><span class="line">  CORPUS_UNIVERSAL = <span class="number">1</span>;</span><br><span class="line">  CORPUS_WEB = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现思路与上面的方案2很像：规定默认值为未规定的，是一个无需关心的情况。这就要求使用方尽可能地使用非默认值的枚举值，减少歧义。</p><h2 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h2><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ErrorStatus</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> google.protobuf.Any details = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Any</code>可以简单理解为<code>protobuf</code>协议中的任意类型（但必须是由proto定义的）。我们可以从两个问题来理解它：</p><ul><li><code>Any</code>如何保证兼容性？<ul><li>内部将数据转化成了byte数组，就能存储任意数据了</li></ul></li><li><code>Any</code>如何解析到特定的proto结构？<ul><li>结合上面的byte数组和对应定义的proto文件</li></ul></li></ul><p>因此，传递的数据包含2个字段：</p><ul><li>byte数组，表示具体数据</li><li>proto文件的定义，比如 <code> &quot;@type&quot;: &quot;type.googleapis.com/junedayday.grpc_gateway_buf_example.echo_service.v1.EchoRequest&quot;</code></li></ul><p>但在实际场景中，<code>Any</code>使用并不方便，往往仅用在<code>protobuf</code>的内部协议中，不适合作为通用的API。</p><h3 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="keyword">oneof</span> unique_id &#123;</span><br><span class="line">    <span class="built_in">int64</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> uuid = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Oneof</code>适用的场景是多个字段中仅允许生效其中一个，这避免了理解上的冲突。例如，我们要查找书，每本书有2个唯一标识：<code>id</code>和<code>uuid</code>。</p><ul><li>如果传任意一个，我们能正常地查到</li><li>如果同时传了<code>id</code>和<code>uuid</code>，可能存在多种理解：<ul><li>同时根据两个条件查</li><li>先根据id查，未查到再根据uuid查</li><li>现根据uuid查，未查到再根据id查</li></ul></li></ul><p>从调用方来说，只能阅读你的接口文档，阅读各字段的注释。而<code>Oneof</code>字段呢，就在接口定义上直接告诉了你，二者只能选其一；如果你硬要传2个参数，就直接返回参数错误。</p><p><code>Oneof</code>特性看起来很好用，但实际接口开发中的使用频率很低，毕竟通过有效的注释或者接口拆分，也能解决这个问题。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message EchoRequest &#123;</span><br><span class="line">  <span class="keyword">map</span>&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map是一个很常用的特性，定义和使用也十分简单。如示例，就会自动对应到Go语言中的<code>map[string]string</code>。</p><p>但从API的设计来说，<code>map</code>这个容器有很高的扩展性，缺牺牲了一定的可读性，如key中代表的含义、有哪些限制等等，只能通过注释进行说明。</p><p>因此，<code>map</code>的特性要节制地使用，优先考虑用明确的结构定义来表示。</p><h2 id="扩展类型"><a href="#扩展类型" class="headerlink" title="扩展类型"></a>扩展类型</h2><h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/struct.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EchoRequest</span> </span>&#123;</span><br><span class="line">  google.protobuf.Value info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于<code>Any</code>，<code>Value</code>不需要依赖proto的定义，更趋近于通用意义上的泛型。它本质上是一种<code>Oneof</code>：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Value</span> </span>&#123;</span><br><span class="line">  <span class="keyword">oneof</span> kind &#123;</span><br><span class="line">    NullValue null_value = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">double</span> number_value = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">string</span> string_value = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">bool</span> bool_value = <span class="number">4</span>;</span><br><span class="line">    Struct struct_value = <span class="number">5</span>;</span><br><span class="line">    ListValue list_value = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部也提供了多个数据类型的转化，可按需调用，如<code>GetXXXValue()</code>。</p><h3 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/struct.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EchoRequest</span> </span>&#123;</span><br><span class="line">  google.protobuf.Struct info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Strcut</code>可快速对应到Go语言中的结构体，可以快速地转化为 <code>map[string]structpb.Value</code>。接下来的使用方式同上面的<code>Value</code>。</p><h3 id="FieldMask"><a href="#FieldMask" class="headerlink" title="FieldMask"></a>FieldMask</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/field_mask.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EchoRequest</span> </span>&#123;</span><br><span class="line">  google.protobuf.FieldMask field_mask = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FieldMask</code>就是上面基础类型中方案3的具体实现。它的定义很简单，就是一个字符串的数组：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">FieldMask</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">string</span> paths = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的每个元素，表示一个具体要生效的字段，支持多层的数据结构，如<code>a.b</code>。</p><h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><p>持续时间，需要一个数字+单位，如<code>2s</code>，减少了单位理解上的歧义。它由两个部分组成，很容易理解</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Duration</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int64</span> seconds = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> nanos = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TimeStamp"><a href="#TimeStamp" class="headerlink" title="TimeStamp"></a>TimeStamp</h3><p>时间处理是一个很麻烦的方式，我们往往是采用<code>string</code>的方式传递、然后再次解析，相对来说比较折腾。</p><p>而官方提供了如下方式</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/timestamp.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EchoRequest</span> </span>&#123;</span><br><span class="line">  google.protobuf.Timestamp time_stamp = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以利用<code>AsTime()</code>方法，快速地转化到Go语言中的<code>time.Time</code>结构，非常省力。对与输入方来说，时间要遵循 rfc3339 格式，如 <code>2006-01-02T15:04:05Z</code>。</p><p>虽然我们更常用<code>YYYY-MM-DD HH:mm:ss</code>来表示，但rfc3339更具兼容性，建议尽可能地尝试替换。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>除了基础类型和枚举，我对今天谈到了8种类型进行了简单的概括：</p><table><thead><tr><th align="center">数据类型</th><th align="center">使用频率</th><th align="center">可读性</th></tr></thead><tbody><tr><td align="center">Any</td><td align="center">低</td><td align="center">低</td></tr><tr><td align="center">Oneof</td><td align="center">中</td><td align="center">高</td></tr><tr><td align="center">map</td><td align="center">高</td><td align="center">中</td></tr><tr><td align="center">Value</td><td align="center">中</td><td align="center">低</td></tr><tr><td align="center">Struct</td><td align="center">中</td><td align="center">低</td></tr><tr><td align="center">FieldMask</td><td align="center">低</td><td align="center">高</td></tr><tr><td align="center">Duration</td><td align="center">高</td><td align="center">高</td></tr><tr><td align="center">TimeStamp</td><td align="center">高</td><td align="center">高</td></tr></tbody></table><p>同时，文中对默认值问题的分析，也希望能对大家在接口设计上有一定的启发。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;gRPC-Gateway的相关方案我们已经在上一篇详细描述。为了更方面地方便大家理解，我这边整理了一个最简化的git项目：&lt;a href=&quot;https://github.com/Junedayday/grpc-gateway-buf-example/tree/v0.0.1&quot;&gt;https://github.com/Junedayday/grpc-gateway-buf-example/tree/v0.0.1&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;它主要包含两个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用buf工具构建项目&lt;/li&gt;
&lt;li&gt;同时启动了gRPC和gRPC-Gateway服务，支持两种协议的调用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天，我们先迈出第一步：探索RPC服务中的数据类型。掌握常见的数据类型，灵活地运用到接口设计中，能帮助我们快速地提供优雅的接口类服务。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习 - RPC篇:gRPC-Gateway示例代码概览</title>
    <link href="http://example.com/2022/10/27/go-study/go-rpc-3/"/>
    <id>http://example.com/2022/10/27/go-study/go-rpc-3/</id>
    <published>2022-10-27T04:00:00.000Z</published>
    <updated>2022-10-28T02:40:27.317Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>gRPC-Gateway是gRPC生态的一环，用于对HTTP协议的扩展，是一套高性能、高扩展的开源RPC框架。</p><p>因此，要掌握gRPC-Gateway，必须要对gRPC有一定的基础，才能明白它的定位与价值。</p><span id="more"></span><h2 id="方案概览"><a href="#方案概览" class="headerlink" title="方案概览"></a>方案概览</h2><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/grpc-gateway.png"></p><p>整个方案分为两个方向：</p><h3 id="纵向-RPC协议调用"><a href="#纵向-RPC协议调用" class="headerlink" title="纵向 - RPC协议调用"></a>纵向 - RPC协议调用</h3><p>三个模块：</p><ul><li>调用方 - API Client</li><li>HTTP服务 - Reverse Proxy</li><li>gRPC服务 - Your gRPC service</li></ul><p>两个协议：</p><ul><li>HTTP - 客户端发起的是HTTP协议，传输到反向代理</li><li>gRPC - 反向代理与gRPC服务之间的协议是gRPC</li></ul><p>关键点：</p><ol><li>Reverse Proxy实现了的关键能力是：将HTTP协议转化为gRPC协议</li><li>可同时提供2个服务：HTTP和gRPC，只是HTTP服务的最终实现还是调用到了gRPC</li></ol><h3 id="横向-Protobuf的代码生成"><a href="#横向-Protobuf的代码生成" class="headerlink" title="横向 - Protobuf的代码生成"></a>横向 - Protobuf的代码生成</h3><ul><li>gRPC-Gateway部分：自动生成反向代理</li><li>gRPC部分：自动生成stub</li></ul><p>stub这个单词很有意思，相对准确的翻译是存根、残端，和面向对象中的 <strong>接口</strong> 有异曲同工之妙：<strong>提供了实现的框架，但具体实现仍交由开发者</strong>。</p><h3 id="开发工作"><a href="#开发工作" class="headerlink" title="开发工作"></a>开发工作</h3><p>对开发者来说，整个方案的工作分为两部分：</p><ol><li>RPC部分 - 编写<code>proto</code>文件</li><li>业务逻辑部分 - 编写gRPC中的<code>stub</code>的实现</li></ol><h2 id="开发思路"><a href="#开发思路" class="headerlink" title="开发思路"></a>开发思路</h2><h3 id="1-RPC开发-proto文件的编写"><a href="#1-RPC开发-proto文件的编写" class="headerlink" title="1. RPC开发 - proto文件的编写"></a>1. RPC开发 - proto文件的编写</h3><p>我们看一个官方github上的示例<code>proto</code>文件：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> your.service.v1;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;github.com/yourorg/yourprotos/gen/go/your/service/v1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/api/annotations.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">StringMessage</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">YourService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Echo(StringMessage) <span class="keyword">returns</span> (StringMessage) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      post: <span class="string">&quot;/v1/example/echo&quot;</span></span><br><span class="line">      body: <span class="string">&quot;*&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从上到下，对里面的语法做简单的分析：</p><ul><li>proto3版本</li><li>proto的包名称</li><li>生成Go语言代码后的Go Package</li><li>导入依赖的proto文件</li><li>Message - 表示RPC的数据结构，按规则生成到各语言的代码</li><li>Service - 一组RPC的抽象</li><li>rpc - 一个具体方法，包括 方法名（请求Message） returns （返回Message）</li><li>google.api.http - HTTP协议的定义，如示例中的方法和URL</li></ul><h3 id="2-代码生成"><a href="#2-代码生成" class="headerlink" title="2. 代码生成"></a>2. 代码生成</h3><p>如何将proto文件生成为Go语言的<code>stub</code>代码，官方提供了两个路径：</p><ul><li>buf（新方式，配置简单，推荐）</li><li>protoc（经典方式，配置较为复杂）</li></ul><p>具体的操作方法可以参考： <a href="https://github.com/grpc-ecosystem/grpc-gateway#usage">https://github.com/grpc-ecosystem/grpc-gateway#usage</a> 。</p><h3 id="3-业务实现"><a href="#3-业务实现" class="headerlink" title="3. 业务实现"></a>3. 业务实现</h3><p>代码生成的只是一个<code>stub</code>，具体实现需要我们自己编码。上述方法生成的函数签名大致如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Echo</span><span class="params">(ctx context.Context, request *proto.StringMessage)</span> <span class="title">returns</span> <span class="params">(response *proto.StringMessage, err error)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 自己实现的业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于其中的context与error，我在上一讲已经讲过大致的规范。而在gRPC-Gateway中怎么使用呢？我们会在具体示例中再去讲。</p><h3 id="4-main函数框架"><a href="#4-main函数框架" class="headerlink" title="4. main函数框架"></a>4. main函数框架</h3><p>1~3步骤将一个RPC请求的开发过程串联了起来，作为web服务的高频迭代部分。</p><p>但如果要作为一个完整的服务，还需要包括基础的server启动代码，很少需要改动。我们接着看官方的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;context&quot;</span></span><br><span class="line">  <span class="string">&quot;flag&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/golang/glog&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/grpc-ecosystem/grpc-gateway/v2/runtime&quot;</span></span><br><span class="line">  <span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">  <span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line"></span><br><span class="line">  gw <span class="string">&quot;github.com/yourorg/yourrepo/proto/gen/go/your/service/v1/your_service&quot;</span>  <span class="comment">// Update</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// command-line options:</span></span><br><span class="line">  <span class="comment">// gRPC server endpoint</span></span><br><span class="line">  grpcServerEndpoint = flag.String(<span class="string">&quot;grpc-server-endpoint&quot;</span>,  <span class="string">&quot;localhost:9090&quot;</span>, <span class="string">&quot;gRPC server endpoint&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  ctx := context.Background()</span><br><span class="line">  ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">  <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register gRPC server endpoint</span></span><br><span class="line">  <span class="comment">// Note: Make sure the gRPC server is running properly and accessible</span></span><br><span class="line">  mux := runtime.NewServeMux()</span><br><span class="line">  opts := []grpc.DialOption&#123;grpc.WithTransportCredentials(insecure.NewCredentials())&#125;</span><br><span class="line">  err := gw.RegisterYourServiceHandlerFromEndpoint(ctx, mux,  *grpcServerEndpoint, opts)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start HTTP server (and proxy calls to gRPC server endpoint)</span></span><br><span class="line">  <span class="keyword">return</span> http.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line">  <span class="keyword">defer</span> glog.Flush()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    glog.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要明确一点：这部分代码并没有包括gRPC服务的启动代码，它已经默认在<code>grpcServerEndpoint</code>这个地址+端口上启动了。如果没有进程隔离的强要求，我们可以在<code>main</code>函数中同时启动 gRPC server和gRPC-Gateway server。</p><p>gRPC-Gateway启动时有4个重要参数：</p><ul><li>mux，多路复用，功能最为强大，可以添加各种自定义的拦截器等</li><li>grpcServerEndpoint，将HTTP转换成gRPC，再发给gRPC的地址</li><li>opts，服务的启动选项</li><li>:8081，启动地址</li></ul><blockquote><p>关于gRPC部分内容可以参考： <a href="https://grpc.io/docs/languages/go/quickstart/">https://grpc.io/docs/languages/go/quickstart/</a></p></blockquote><h2 id="参考示例"><a href="#参考示例" class="headerlink" title="参考示例"></a>参考示例</h2><p>整套框架的完整示例可以参考这个文件 - <a href="https://github.com/Junedayday/micro_web_service/blob/master/main.go">https://github.com/Junedayday/micro_web_service/blob/master/main.go</a></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本篇重点是对gRPC-Gateway最基础的原理和使用进行了分析。</p><p>如果你能通过本篇文章，对这个方案有一个基本认识，那么接下来我会带你玩转这个框架。你也无需担心无法实践到日常项目中：gRPC-Gateway中的能力与gin等框架都是共通的，可以轻松地举一反三。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;gRPC-Gateway是gRPC生态的一环，用于对HTTP协议的扩展，是一套高性能、高扩展的开源RPC框架。&lt;/p&gt;
&lt;p&gt;因此，要掌握gRPC-Gateway，必须要对gRPC有一定的基础，才能明白它的定位与价值。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习 - RPC篇:gin框架的基础能力剖析</title>
    <link href="http://example.com/2022/09/26/go-study/go-rpc-2/"/>
    <id>http://example.com/2022/09/26/go-study/go-rpc-2/</id>
    <published>2022-09-26T04:00:00.000Z</published>
    <updated>2022-09-30T04:26:16.964Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><h2 id="gin框架"><a href="#gin框架" class="headerlink" title="gin框架"></a>gin框架</h2><p>gin是非常流行的一款HTTP框架。相较于原生的HTTP server，gin有很多改进点，主要在于3点：</p><ol><li>上手简单，开发思路与原生HTTP基本一致</li><li>引入多个工具库，提高了开发效率</li><li>生态丰富，有许多开源的组件</li></ol><p>围绕着gin框架，我们将展开今天的话题。</p><span id="more"></span><h2 id="示例Gin代码"><a href="#示例Gin代码" class="headerlink" title="示例Gin代码"></a>示例Gin代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求结构体</span></span><br><span class="line"><span class="keyword">type</span> MyRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">MyInfo <span class="keyword">string</span> <span class="string">`form:&quot;my_info&quot; json:&quot;my_info&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应结构体</span></span><br><span class="line"><span class="keyword">type</span> MyResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">Errno  <span class="keyword">int</span>    <span class="string">`json:&quot;errno&quot;`</span></span><br><span class="line">Result <span class="keyword">string</span> <span class="string">`json:&quot;result&quot;`</span></span><br><span class="line">MyInfo <span class="keyword">string</span> <span class="string">`form:&quot;my_info&quot; json:&quot;my_info&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b MyRequest</span><br><span class="line">err := c.Bind(&amp;b)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, MyResponse&#123;</span><br><span class="line">Errno: <span class="number">1</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, MyResponse&#123;</span><br><span class="line">Result: <span class="string">&quot;my result&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// gin server</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"><span class="comment">// 中间件</span></span><br><span class="line">r.Use(gin.CustomRecovery(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context, recovered <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err, ok := recovered.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">c.String(http.StatusInternalServerError, fmt.Sprintf(<span class="string">&quot;error: %s&quot;</span>, err))</span><br><span class="line">&#125;</span><br><span class="line">c.AbortWithStatus(http.StatusInternalServerError)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/data&quot;</span>, GetData)</span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键函数分析"><a href="#关键函数分析" class="headerlink" title="关键函数分析"></a>关键函数分析</h2><h3 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">GET</span><span class="params">(relativePath <span class="keyword">string</span>, handlers ...HandlerFunc)</span> <span class="title">IRoutes</span></span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">POST</span><span class="params">(relativePath <span class="keyword">string</span>, handlers ...HandlerFunc)</span> <span class="title">IRoutes</span></span></span><br></pre></td></tr></table></figure><p>Gin支持不同HTTP方法的路由注册，这对RESTful风格的代码编写带来了很大帮助。对于阅读代码的同学，可以快速地通过路由注册的列表，如<code>r.GET(&quot;/data&quot;, GetData)</code>，找到对应的方法。</p><h3 id="Handler函数"><a href="#Handler函数" class="headerlink" title="Handler函数"></a>Handler函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(*Context)</span></span></span><br></pre></td></tr></table></figure><p>Handler函数相较于标准库，看似从2个参数<code>Request</code> 和 <code>ResponseWriter</code> 转变成了一个参数 <code>Context</code>，简化了调用，但其实对调用者来说，复杂度并没有降低：</p><ol><li><code>Context</code> 包含大量数据结构</li><li><code>Context</code> 包含了大量的方法</li></ol><p>对于一名新手，在摸索出一条最佳实践路径前，学习成本不增反减。这主要是因为<code>gin.Context</code>过重。从编程角度来看，这个对象包含了过多信息，是个大而杂的工具集。</p><p>但不可否认的是，<code>gin</code>里提供了很多工具都比原生库好用，例如参数绑定、返回JSON数据。</p><h3 id="绑定参数Bind"><a href="#绑定参数Bind" class="headerlink" title="绑定参数Bind"></a>绑定参数Bind</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Bind</span><span class="params">(obj any)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>Bind中引入了泛型中的<code>any</code>特性，但使用和原先的<code>interface&#123;&#125;</code>完全一致：</p><p>调用方可以填任意值。但实际上，Bind中必须为一个指针类型的数据结构，但由于interface{}对入参没有任何编译时的限制，导致传参问题在运行时才会报错。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b MyRequest</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">c.Bind(&amp;b)</span><br><span class="line"><span class="comment">// 错误：编译正确，但运行时异常</span></span><br><span class="line">c.Bind(b)</span><br><span class="line">c.Bind(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="返回JSON数据"><a href="#返回JSON数据" class="headerlink" title="返回JSON数据"></a>返回JSON数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">JSON</span><span class="params">(code <span class="keyword">int</span>, obj any)</span></span></span><br></pre></td></tr></table></figure><p>该方法是返回HTTP状态码为code，并且将obj数据进行JSON序列化。</p><p>它的问题同Bind函数，这里就不再赘述了。</p><h3 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h3><p>gin框架提供了middleware的能力，它可以为整个Server提供一个公共能力的封装。有了middleware，整个server处理请求变成了：</p><p>middleware预处理 -&gt; handler -&gt; middleware后处理</p><ul><li><p>常见的预处理如</p><ul><li>参数校验</li><li>用户认证</li><li>panic恢复</li></ul></li><li><p>常见的后处理则如</p><ul><li>定制HTTP状态码</li><li>异常数据封装</li></ul></li></ul><p>总体来说，middleware能帮助用户减少重复性代码的编写，沉淀为公共能力，堪称web编程的一大利器。</p><h2 id="gin能力剖析"><a href="#gin能力剖析" class="headerlink" title="gin能力剖析"></a>gin能力剖析</h2><p>我们先看看gin的改进点：</p><ol><li>mux支持RESTful风格的接口定义</li><li><code>gin.Context</code>提供了大量的工具，简化解析、返回的相关代码</li><li>middleware可解决大量重复性的代码</li></ol><p>这三点对开发者带来了不小的帮助。但是，我们在使用<code>gin</code>作为开发工具时，仍有一些问题：</p><ol><li>大量的参数类型都是<code>interface&#123;&#125;</code>类型的数据结构，需要调用方自行保证</li><li><code>gin.Context</code>过大，学习和理解的成本很高</li><li>不少问题要在运行时才能发现，编译期无能为力</li></ol><p>这些弊端汇总起来，依旧是和handler的函数定义相关：<strong>没有充分地利用Go强类型、编译检查的特点，来提高程序的质量、降低开发者的学习成本</strong>。</p><h2 id="更简单的Handler框架"><a href="#更简单的Handler框架" class="headerlink" title="更简单的Handler框架"></a>更简单的Handler框架</h2><p>那么，什么样的Handler框架对用户来说效果更好呢？我这边给出一个函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BetterHandler</span><span class="params">(ctx context.Context, req *MyRequest)</span> <span class="params">(rsp *MyResponse, err error)</span></span></span><br></pre></td></tr></table></figure><p>我们依次看一下这些参数及其使用场景：</p><ol><li>ctx - 上下文，传递公共参数以及超时控制</li><li>req - 请求的参数结构</li><li>rsp - 响应的参数结构</li><li>err - 错误信息</li></ol><p>从整个RPC框架来看，它重点做了2件事：</p><ol><li>自动将http参数解析到ctx和req中<ol><li>解析规则按标准约定，如HTTP RESTful</li><li>一般是将Header里的信息放到ctx中，将URL+Body里的信息匹配到req结构体</li></ol></li><li>自动将rsp和err对应到HTTP响应中<ol><li>err=nil时，认为请求成功，将rsp序列化后、填入到HTTP Body中</li><li>err!=nil时，认为请求去失败，返回约定的协议（如异常状态码、异常HTTP的Body）</li></ol></li></ol><p><code>BetterHandler</code>是一个很棒的编程体验：</p><ol><li>无需关心解析参数与返回响应这两步的具体实现，统一由框架封装</li><li>函数的输入和输出都是强类型的，开发者有了一个明确的“模板”</li><li>将handler中的业务逻辑与RPC框架中协议部分解耦</li></ol><p>也许你一下子无法快速理解，但反复对比下，你会逐渐体会到其中的精妙。但是，使用这个框架前，我们要解决以下两个问题：</p><ol><li>URL与Handler的匹配逻辑</li><li>怎么约定解析请求和返回响应的协议</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天，我们一起看了gin框架的相关示例，编程体验比原生http库有了明显提升。gin的生态也给出了不少的优化方案或者插件，但由于框架本身限制，很难治本。</p><p>下一讲，我们将来看一个我最为推荐的RPC框架，分析一下其相关利弊。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;gin框架&quot;&gt;&lt;a href=&quot;#gin框架&quot; class=&quot;headerlink&quot; title=&quot;gin框架&quot;&gt;&lt;/a&gt;gin框架&lt;/h2&gt;&lt;p&gt;gin是非常流行的一款HTTP框架。相较于原生的HTTP server，gin有很多改进点，主要在于3点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上手简单，开发思路与原生HTTP基本一致&lt;/li&gt;
&lt;li&gt;引入多个工具库，提高了开发效率&lt;/li&gt;
&lt;li&gt;生态丰富，有许多开源的组件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;围绕着gin框架，我们将展开今天的话题。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习 - RPC篇:理解标准库HTTP的hander实现逻辑</title>
    <link href="http://example.com/2022/09/18/go-study/go-rpc-1/"/>
    <id>http://example.com/2022/09/18/go-study/go-rpc-1/</id>
    <published>2022-09-18T04:00:00.000Z</published>
    <updated>2022-09-30T04:26:20.595Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><h2 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h2><p>作为一名开发者，我们最常见的日常工作就是web类编程：即对于CRUD请求，开发相关的业务代码。</p><p>在Go语言中，常见的RPC包括HTTP/gRPC/Thrift等，但绝大多数的开发场景仍是基于HTTP。本文对RPC的讨论，主要是基于HTTP的场景。</p><p>如果我们能熟练地掌握一套主流RPC框架，至少能提升20%的开发效率，而优秀的框架能带来更大的帮助。提效是为了有更多时间提升个人能力，我们今天就先对RPC框架有一个概览。</p><span id="more"></span><h2 id="RPC的处理过程"><a href="#RPC的处理过程" class="headerlink" title="RPC的处理过程"></a>RPC的处理过程</h2><p>对一个web程序来说，它的核心功能就是处理一个请求。一个RPC的处理流程可以简单划分为3块：</p><ol><li>解析请求数据</li><li>业务逻辑处理</li><li>返回结果</li></ol><p>这个看似简单的流程，在实际开发过程中会遇到很多问题。抛开业务逻辑，我们重点看一下1、3两步：</p><p>解析请求数据：</p><ol><li>要理解HTTP协议的标准，了解URL/Header/Body里的数据信息，如Content-Type</li><li>定义这个请求的数据结构，将数据 <strong>反序列化</strong> 到程序中的结构体</li></ol><p>返回结果：</p><ol><li>定义请求的返回数据结构，将程序中的结构体 <strong>序列化</strong></li><li>异常情况下，如业务处理错误、程序崩溃等，如何保证返回的数据结构一致</li></ol><p>简单来说，这两步的功能可以概括为：<strong>如何将数据按定义的标准，进行序列化与反序列化</strong>。</p><blockquote><p>常见的序列化工具如json/xml/protobuf等，新手主要了解 json 即可。</p></blockquote><p>接下来，我们来看看标准库对请求的处理。</p><h2 id="Go标准库的示例代码"><a href="#Go标准库的示例代码" class="headerlink" title="Go标准库的示例代码"></a>Go标准库的示例代码</h2><p>我们先来看标准HTTP库，它的实现是我们学习RPC的基础：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/router&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">  <span class="keyword">type</span> MyRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">type</span> MyResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">    Errno <span class="keyword">int</span> <span class="string">`json:&quot;errno&quot;`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> resp = <span class="built_in">new</span>(MyResponse)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 解析参数</span></span><br><span class="line">  <span class="keyword">var</span> req MyRequest</span><br><span class="line">  b, err := ioutil.ReadAll(request.Body)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    resp.Errno = <span class="number">1</span></span><br><span class="line">    b, _ = json.Marshal(resp)</span><br><span class="line">    writer.Write(b)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  json.Unmarshal(b, &amp;req)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 业务逻辑处理</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 返回结果</span></span><br><span class="line">  b, _ = json.Marshal(resp)</span><br><span class="line">  writer.Write(b)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="两个关键参数"><a href="#两个关键参数" class="headerlink" title="两个关键参数"></a>两个关键参数</h3><p>响应 <code>http.ResponseWriter</code> 与 请求<code>*http.Request</code>。这两个参数里面包含了许多信息，我这里列举最常用的几个：</p><ol><li>结构体Request<ol><li>Method - http方法</li><li>URL - http URL</li><li>Header - http头</li><li>Body - http消息体</li></ol></li><li>接口ResponseWriter<ol><li>Write - 写Body</li><li>WriteHeader - 写状态码</li></ol></li></ol><h2 id="开发思路"><a href="#开发思路" class="headerlink" title="开发思路"></a>开发思路</h2><p>我们梳理一下，一个新的HTTP接口的开发是什么样的逻辑：</p><h3 id="1-如何匹配到handler"><a href="#1-如何匹配到handler" class="headerlink" title="1.如何匹配到handler"></a>1.如何匹配到handler</h3><p>示例就是<code>/router</code>这个路由匹配，但实际情况中会更复杂：</p><ol><li>如前缀匹配、模糊匹配等</li><li>按照RESTful协议，不同Method的处理逻辑不一样</li></ol><p>对于第二点，我们自然也可以通过在handler函数中增加<code>if-else</code>的逻辑来覆盖，但这么写下来，显然会增加handler函数的复杂程度。</p><p>从RPC的编程术语来说，我们称这个匹配逻辑为<code>mux</code>，即多路复用。于是，我们就发现了http标准库中的2大优化点：</p><ol><li>更灵活的URL匹配逻辑</li><li>mux支持HTTP Method的区分</li></ol><h3 id="2-解析参数"><a href="#2-解析参数" class="headerlink" title="2.解析参数"></a>2.解析参数</h3><p>解析参数可以分解为3个问题：</p><ol><li>参数来源于哪？如URL/Header/Body</li><li>参数要怎么解析？如json/form/xml</li><li>参数要解析到那个Go结构体？</li></ol><p>有经验的朋友能深刻体会其中的繁琐（这部分工作不难，但很费开发与排查问题的时间）。比如说，在写业务层代码时，发现某个参数没有解析到，我们要分析的点非常多，包括协议问题、字段名称、字段类型、解析的工具库等等。</p><p>对于程序员来说，当然是希望尽可能地将这部分高度重复的工作进行简化，提升效率。</p><h3 id="3-返回结果"><a href="#3-返回结果" class="headerlink" title="3.返回结果"></a>3.返回结果</h3><p>返回数据的代码看过去很简单，就是将数据序列化后返回。</p><p>但是，难点在于异常情况下的处理：例如，当handler中某个逻辑出错时，我们要怎么返回数据呢？最常见的方案，就是增加一个特殊的字段进行标记，如错误码<code>errno</code>，不为0时表示错误，为0时才表示正确、再去解析数据结构。</p><h2 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h2><p>上述3点没有什么技术上的难度，但在稍微复杂点的web程序时，会遇到什么问题呢？我们再次一起看看handler这个函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span></span><br></pre></td></tr></table></figure><p>如果你随意编写一个handler，也可以轻松编译通过，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，最主要的问题是在于：<strong>没办法对开发者在编写HTTP接口时，提供一定的强制规范</strong>。</p><h3 id="质量低-容易失误"><a href="#质量低-容易失误" class="headerlink" title="质量低 - 容易失误"></a>质量低 - 容易失误</h3><p>由于handler这层的无法强制性地标准化，容易出现下限很低的失误，例如：</p><ol><li>用错了请求的数据结构，尤其是ctrl+c/ctrl+v</li><li>返回的数据结构没有强限制，完全可以自定义</li></ol><h3 id="效率低-重复编码"><a href="#效率低-重复编码" class="headerlink" title="效率低 - 重复编码"></a>效率低 - 重复编码</h3><p>对于解析参数和返回数据，往往需要大量的重复编码。这部分虽然可以通过封装一些库来缓解，但每个handler都至少仍有2个调用：</p><ul><li>解析数据的函数，如<code>Bind</code></li><li>返回数据的函数，如<code>WriteResponse</code></li></ul><p>而对于有异常情况的，如发生error，<code>WriteResponse</code>的调用量相应增加</p><h3 id="标准化低-内部实现各异"><a href="#标准化低-内部实现各异" class="headerlink" title="标准化低 - 内部实现各异"></a>标准化低 - 内部实现各异</h3><p>由于<code>handler</code>内的 <strong>解析请求</strong>和<strong>返回响应</strong> 没有任何代码限制，所以可以采用任意开源或自研的组件。</p><p>这些组件的实现各异，一旦扩散后很难收敛，很容易遇上不兼容的问题：</p><ul><li>如果只是程序内实现的不兼容，还可以通过修改完成兼容</li><li>但如果多个调用方发生了不兼容，那就很难控制了</li></ul><h3 id="测试难-单测难覆盖"><a href="#测试难-单测难覆盖" class="headerlink" title="测试难 - 单测难覆盖"></a>测试难 - 单测难覆盖</h3><p>整个handler的可测试性是很低的，构造一个单测堪比写一大串业务代码，调试时很复杂。</p><p>所以，开发者往往更愿意靠 启动go程序+postman发请求 这样相对重量级的接口测试。</p><h2 id="更大规模下的问题"><a href="#更大规模下的问题" class="headerlink" title="更大规模下的问题"></a>更大规模下的问题</h2><h3 id="实现与接口文档的不一致"><a href="#实现与接口文档的不一致" class="headerlink" title="实现与接口文档的不一致"></a>实现与接口文档的不一致</h3><p>随着平台的迭代，我们经常会去修改一些接口。</p><p>但在Go语言中，它无法直接生成接口文档（如swagger文档）。普遍的方案会利用注释，但注释依旧无法和代码里的实现保证强一致性（如接口文档为OrderV1，但实际已经升级到了OrderV2）。</p><h3 id="调用方的开发工作"><a href="#调用方的开发工作" class="headerlink" title="调用方的开发工作"></a>调用方的开发工作</h3><p>对于接口调用方，有4个工作是必须做的：</p><ol><li>定义URL/方法等</li><li>定义请求的数据结构</li><li>定义返回的数据结构</li><li>拼接处一个HTTP请求</li></ol><p>每个服务调用方，都需要重复地做这部分的工作。</p><p>这个问题可以通过统一建设公共库（SDK）来减轻，但SDK库如何与服务端的实现保证一致，是比较复杂的问题：例如新增了一个url+handler的处理逻辑，如何保证SDK会自动更新？</p><h3 id="业务逻辑的兼容性问题"><a href="#业务逻辑的兼容性问题" class="headerlink" title="业务逻辑的兼容性问题"></a>业务逻辑的兼容性问题</h3><p>业务逻辑往往是复杂的，我们更多的时间是投入在业务逻辑处理上，但传统的方式容易出现各种兼容性问题，比如：</p><p>开发者可能只是发现某个内部bug，改了某个字段的数据结构，但却导致所有调用方整个解析失败（如json.Unmarshal）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>也许，有的朋友看了上述问题，会觉得不以为然：<strong>如果能搞好工具库和标准，以上问题都能解决</strong>。</p><p>没错，上述问题都不致命，否则业界也早就出现明确的标准了。但是我们要考虑到两点：</p><ol><li>人员的不确定因素：不同的能力阶段、人员流动性</li><li>效率与质量：将开发时间更多地投入到业务逻辑上，提升质量</li></ol><p>就像是你要从上海到北京出差，你当然可以自驾、歪歪扭扭地沿着高速公路到达目的地，有很高的选择自由度；但有了更快的高铁路线，何乐而不为呢？毕竟，从出差这件事来看，最重要的是保证准时地到达目的地，</p><p>那么RPC的“高铁方案”是怎么样的呢？下一节我们继续展开。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;RPC框架&quot;&gt;&lt;a href=&quot;#RPC框架&quot; class=&quot;headerlink&quot; title=&quot;RPC框架&quot;&gt;&lt;/a&gt;RPC框架&lt;/h2&gt;&lt;p&gt;作为一名开发者，我们最常见的日常工作就是web类编程：即对于CRUD请求，开发相关的业务代码。&lt;/p&gt;
&lt;p&gt;在Go语言中，常见的RPC包括HTTP/gRPC/Thrift等，但绝大多数的开发场景仍是基于HTTP。本文对RPC的讨论，主要是基于HTTP的场景。&lt;/p&gt;
&lt;p&gt;如果我们能熟练地掌握一套主流RPC框架，至少能提升20%的开发效率，而优秀的框架能带来更大的帮助。提效是为了有更多时间提升个人能力，我们今天就先对RPC框架有一个概览。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>技术阅读摘要 - 5.Go语言面试概述类问题</title>
    <link href="http://example.com/2022/08/07/readings/go-digest-5/"/>
    <id>http://example.com/2022/08/07/readings/go-digest-5/</id>
    <published>2022-08-07T04:00:00.000Z</published>
    <updated>2022-08-14T04:20:00.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>目前，Go语言在中国市场虽然蓬勃发展，但相较于JAVA语言的成熟面试体系，Go缺少了很多“八股文”性质的资料，出现了两个问题：</p><ol><li>对新手来说，知识很难体系化；</li><li>对面试者来说，遇到的问题千奇百怪，甚至面试官之间的答案也不一样</li></ol><p>那么，我将挑选五个概述类的问题，并给出我的思考，希望能对大家带来帮助。</p><span id="more"></span><h2 id="1-谈谈你对Go语言的错误处理的思考"><a href="#1-谈谈你对Go语言的错误处理的思考" class="headerlink" title="1.谈谈你对Go语言的错误处理的思考"></a>1.谈谈你对Go语言的错误处理的思考</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在谈论这个话题前，我们最好先掌握两个知识点：</p><ol><li>了解以JAVA体系为代表的try-catch模式的错误处理方式</li><li>Go语言error封装的常见技巧</li></ol><p>我们的回答先围绕这两个点展开：</p><ol><li>Go语言对错误处理的设计是偏向于过程性的。虽然会牺牲一定的简洁性、增加代码冗余，但在阅读代码时，我们能明确地知道，错误是在方法的哪一行产生的；</li><li>推荐使用<code>github.com/pkg/errors</code>这个Go官方推荐的库（具体方法可以参考 <a href="https://junedayday.github.io/2021/05/07/go-tip/go-tip-3/">我的博客</a>）。简单来说，将错误进行堆栈化，丰富错误所包含的信息。</li></ol><p>关于这个问题，你要谈到的三个关键点是：</p><ol><li>error处理的代码会导致冗余，牺牲一定的简洁性，但阅读者可以清晰地看到错误产生的源头；</li><li>熟悉对error处理的技巧，如<code>bufio.Scanner</code>将error封装到结构体中；</li><li>官方思路 - 以<code>github.com/pkg/errors</code>为代表的，将error进行堆栈化处理；</li></ol><h2 id="2-谈谈你对Go程序故障的排查心得"><a href="#2-谈谈你对Go程序故障的排查心得" class="headerlink" title="2.谈谈你对Go程序故障的排查心得"></a>2.谈谈你对Go程序故障的排查心得</h2><p>线下问题相对简单，可以通过 <strong>单元测试</strong> 或者 <strong>代码调试</strong> 的手段进行排查。</p><p>我们讨论的重点是线上程序，我将思路分为3类：</p><ol><li>可观测性：重点是监控指标metrics与链路追踪tracing</li><li>Go语言自带的pprof：主要用来分析复杂的程序瓶颈</li><li>操作系统层面的工具：包括CPU、磁盘、网络等，如tracert、tcpdump等</li></ol><p>一般情况下，第1类成本最低，能解决绝大部分的问题，是稳定性重点建设的目标。</p><h2 id="3-你认为Go语言的弊端有什么？"><a href="#3-你认为Go语言的弊端有什么？" class="headerlink" title="3.你认为Go语言的弊端有什么？"></a>3.你认为Go语言的弊端有什么？</h2><p>我将从小到大、谈谈Go语言的三个问题（主要与JAVA进行对比）：</p><ol><li>基础库：基础库提供的能力比较受限，这就导致大量各异的轮子被发明出来，很难统一；</li><li>代码风格：风格迥异，如新手容易写出过程性的代码，资深人员会写出面向接口、高度抽象的代码；</li><li>编程框架：业界没有统一的Go框架，框架间思路也差异很大；</li></ol><p>总体来说，Go现状依然是百家齐鸣。这对语言的丰富性来说是个好事，但对工程项目来说，很难统一约束，<strong>多样性会导致可维护性变差</strong>。</p><h2 id="4-如何体现你的Go语言水平"><a href="#4-如何体现你的Go语言水平" class="headerlink" title="4.如何体现你的Go语言水平"></a>4.如何体现你的Go语言水平</h2><p>展示Go语言的能力发展分为两个方向：底层与上层。</p><p>底层能力包括：源码理解、GMP、性能问题、runtime、编译器等方向，体现出了计算机基础功底。一般来说，在底层这块进一步深钻的话，技术栈需要重点扩充操作系统与网络方向，而编程语言上也需要有一定C++的能力。</p><p>上层能力又可以区分为两块：工程化能力与特定业务领域的能力。通俗点说，工程化是怎么写出可维护的、优雅的Go代码，考验的是经验与基本功；特定业务领域能力则是掌握怎么用Go语言的特性或者特定库，去解决对应的领域问题，如云原生、区块链。</p><h2 id="5-什么样的项目适合用Go语言开发"><a href="#5-什么样的项目适合用Go语言开发" class="headerlink" title="5.什么样的项目适合用Go语言开发"></a>5.什么样的项目适合用Go语言开发</h2><p>单从语言来看，任何一门语言都具备可替代性。那么Go语言的核心竞争力是什么呢？我看重的是两点；<strong>业务生态与语言特性</strong>，其中生态的重要性远超语言特性。</p><p>先聊一下业务生态。成熟的生态会沉淀相关的工具或现成库，大幅度减少开发成本，逆主流的语言意味着重建生态。比如说，Kubernetes沉淀了Go相关的大量插件与工具，区块链领域也基本都是Go语言的天下。</p><p>在没有绝对统治力的生态下、或者重建生态的成本很低，语言自身的特性才有参考价值。比如在devops领域，常见的有Python、Go、PHP，以及少量的JAVA。这时，Go语言以学习成本低、高性能等因素，脱颖而出，成为首选。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文和大家聊了5个Go语言概述类问题，它们相对于底层问题更容易快速记忆。</p><p>希望能为大家在学习Go语言的过程中带来启发，也可以帮助大家在面试的回答中展现出亮点。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;目前，Go语言在中国市场虽然蓬勃发展，但相较于JAVA语言的成熟面试体系，Go缺少了很多“八股文”性质的资料，出现了两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对新手来说，知识很难体系化；&lt;/li&gt;
&lt;li&gt;对面试者来说，遇到的问题千奇百怪，甚至面试官之间的答案也不一样&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么，我将挑选五个概述类的问题，并给出我的思考，希望能对大家带来帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Digest" scheme="http://example.com/tags/Digest/"/>
    
  </entry>
  
  <entry>
    <title>etcd源码分析 - 5.【打通核心流程】EtcdServer消息的处理函数</title>
    <link href="http://example.com/2022/07/25/etcd/etcd-5/"/>
    <id>http://example.com/2022/07/25/etcd/etcd-5/</id>
    <published>2022-07-25T04:00:00.000Z</published>
    <updated>2022-07-26T02:45:32.730Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg"></p><p>在上一讲，我们梳理了<code>EtcdServer</code>的关键函数<code>processInternalRaftRequestOnce</code>里的四个细节。</p><p>其中，<code>wait.Wait</code>组件使用里，我们还遗留了一个细节实现，也就是请求的处理结果是怎么通过channel返回的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="comment">// 正常消息的返回，也就是我们本章要研究的</span></span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line"><span class="keyword">return</span> x.(*applyResult), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-cctx.Done():</span><br><span class="line">proposalsFailed.Inc()</span><br><span class="line">s.w.Trigger(id, <span class="literal">nil</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, s.parseProposeCtxErr(cctx.Err(), start)</span><br><span class="line"><span class="keyword">case</span> &lt;-s.done:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrStopped</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="明确问题与思路"><a href="#明确问题与思路" class="headerlink" title="明确问题与思路"></a>明确问题与思路</h2><p>我们回顾上节的问题，我们就是要找到下面两处操作的代码：</p><ol><li>往<code>ch</code>这个channel里发送了一个<code>*applyResult</code>结构的消息</li><li>对wait进行了Trigger操作</li></ol><p>常见思路分为两种：</p><ol><li>顺序思维 - 也就是自顶向下阅读代码，主要是找到调用的入口</li><li>逆向思维 - 通过IDE的代码跳转功能，查找关键函数的调用处，再向上找到对应的调用栈</li></ol><p>顺序思维不是一种源码阅读的常见行为，毕竟这需要我们非常了解源码的结构；而逆向思维，是我们快速定位到对应代码的最常见手段。</p><p>而为了加深对代码的理解，通常会采用 <strong>先逆向、理清代码调用逻辑，后顺序、理解代码层级设计</strong> 这样的两轮阅读。我们就针对今天的case来看看。</p><h2 id="逆向阅读-调用逻辑"><a href="#逆向阅读-调用逻辑" class="headerlink" title="逆向阅读 - 调用逻辑"></a>逆向阅读 - 调用逻辑</h2><h3 id="Trigger的调用"><a href="#Trigger的调用" class="headerlink" title="Trigger的调用"></a>Trigger的调用</h3><p>我们利用IDE，可以查到所有的Trigger调用代码，共计10处，可以先根据文件名快速理解：</p><ul><li>7处 <code>server.go</code> - 通用server部分</li><li>1处 <code>v2_server.go</code> - 针对v2版本协议</li><li>2处 <code>v3_server.go</code> - 针对v3版本协议（即我们阅读的<code>processInternalRaftRequestOnce</code>函数）</li></ul><p>于是，我们就跳转到<code> server.go</code>，查看这7个调用函数：</p><ul><li><p>configure - 2个Tigger</p><ul><li>配置相关，直接忽略</li></ul></li><li><p>apply - 1个Tigger</p><ul><li>发送的数据结构不为<code>*applyResult</code>，忽略</li></ul></li><li><p>applyEntryNormal - 4个Tigger</p><ul><li>前两个为V2版本</li><li>后两个为V3版本</li></ul></li></ul><p>确定了入口函数为<code>applyEntryNormal</code>，我们接下来就是去用IDE查找调用逻辑，不断跳转，查找它的调用栈了。</p><h3 id="调用栈分析"><a href="#调用栈分析" class="headerlink" title="调用栈分析"></a>调用栈分析</h3><ol><li>applyEntryNormal</li><li>apply</li><li>applyEntries</li><li>applyAll</li><li>run</li><li>start</li><li>Start</li><li>StartEtcd</li></ol><blockquote><p>序号越小，表示越底层</p></blockquote><p>这一块的代码跳转非常顺利，每一个方法基本都只有一个被调用方，我们可以快速地逐层查找，直到<code>main()</code>函数。接着，我们开始顺序阅读代码的过程。</p><h2 id="顺序阅读-代码设计"><a href="#顺序阅读-代码设计" class="headerlink" title="顺序阅读 - 代码设计"></a>顺序阅读 - 代码设计</h2><p><code>start</code>之前的方法很简单，我们直接从<code>run</code>方法开始看。</p><h3 id="EtcdServer-run"><a href="#EtcdServer-run" class="headerlink" title="(*EtcdServer) run()"></a>(*EtcdServer) run()</h3><p><code>run()</code>函数可以拆分为两部分，而关键的分界线是<code>go</code>语言里经典的<code>for+select</code>语法。在一个常驻的进程中，例如服务器，<code>for+select</code>是一个非常优雅的实现，里面的每一个case都是一种处理逻辑，类似IO复用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// 正常消息</span></span><br><span class="line">    <span class="keyword">case</span> ap := &lt;-s.r.apply():</span><br><span class="line">    <span class="comment">// 超时租约</span></span><br><span class="line">    <span class="keyword">case</span> leases := &lt;-expiredLeaseC:</span><br><span class="line">    <span class="comment">// 错误信号</span></span><br><span class="line">    <span class="keyword">case</span> err := &lt;-s.errorc:</span><br><span class="line">    <span class="comment">// 定时器</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-getSyncC():</span><br><span class="line">    <span class="comment">// 停止信号</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-s.stop:</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这种使用方法，有一个重点需要注意：<strong>每一个case中的处理耗时要尽可能地少（除了退出），这样才能保证程序的性能。</strong>尤其是对常见请求的处理，例如示例中的正常消息，要尽可能地短。</p><blockquote><p>缩短单个case的处理耗时有两种思路：性能优化 或 异步化。</p><p>后者看似很简单，比如开启一个goroutine，但很有可能破坏程序数据的一致性，需要慎重。</p></blockquote><p>正常消息的处理代码很短，即两行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行功能的函数，关键实现为applyAll，即下一层要看的代码</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(context.Context)</span></span> &#123; s.applyAll(&amp;ep, &amp;ap) &#125;</span><br><span class="line"><span class="comment">// sched是一个先入先出的调度方法，而Schedule只是把这个执行函数追加进去</span></span><br><span class="line"><span class="comment">// 这部分真正的执行在另一处，即出队列的地方，暂时无需关心</span></span><br><span class="line">sched.Schedule(f)</span><br></pre></td></tr></table></figure><h3 id="（-EtcdServer-applyAll"><a href="#（-EtcdServer-applyAll" class="headerlink" title="（*EtcdServer) applyAll()"></a>（*EtcdServer) applyAll()</h3><p>通过<code>applyEntries()</code>函数，将每一项<code>entry</code>应用到<code>etcd</code>服务上。</p><h3 id="EtcdServer-applyEntries"><a href="#EtcdServer-applyEntries" class="headerlink" title="(*EtcdServer) applyEntries()"></a>(*EtcdServer) applyEntries()</h3><p>通过<code>apply()</code>应用entry，这里有3个返回值：</p><ul><li>term - 轮次，这是raft协议相关</li><li>index - 索引</li><li>shouldstop - 是否停止</li></ul><h3 id="EtcdServer-apply"><a href="#EtcdServer-apply" class="headerlink" title="(*EtcdServer) apply()"></a>(*EtcdServer) apply()</h3><p>apply将多个entries进行处理，核心代码结构整理如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐个处理entries</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> es &#123;</span><br><span class="line">  e := es[i]</span><br><span class="line">  <span class="keyword">switch</span> e.Type &#123;</span><br><span class="line">    <span class="comment">// 常规消息</span></span><br><span class="line">    <span class="keyword">case</span> raftpb.EntryNormal:</span><br><span class="line">    <span class="comment">// 配置变更</span></span><br><span class="line">    <span class="keyword">case</span> raftpb.EntryConfChange:</span><br><span class="line">    <span class="comment">// 异常情况</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而常规消息里的三步处理也很容易理解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用普通entry的地方</span></span><br><span class="line">s.applyEntryNormal(&amp;e)</span><br><span class="line"><span class="comment">// 设置applied的索引位置，表示已经被应用</span></span><br><span class="line">s.setAppliedIndex(e.Index)</span><br><span class="line"><span class="comment">// 设置轮次term信息</span></span><br><span class="line">s.setTerm(e.Term)</span><br></pre></td></tr></table></figure><h3 id="EtcdServer-applyEntryNormal"><a href="#EtcdServer-applyEntryNormal" class="headerlink" title="(*EtcdServer) applyEntryNormal()"></a>(*EtcdServer) applyEntryNormal()</h3><p>整个函数比较长，但核心处理逻辑只有如下两块内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理raft请求，将结果返回到 *applyResult 中</span></span><br><span class="line"><span class="keyword">var</span> ar *applyResult</span><br><span class="line">needResult := s.w.IsRegistered(id)</span><br><span class="line"><span class="keyword">if</span> needResult || !noSideEffect(&amp;raftReq) &#123;</span><br><span class="line">  <span class="keyword">if</span> !needResult &amp;&amp; raftReq.Txn != <span class="literal">nil</span> &#123;</span><br><span class="line">    removeNeedlessRangeReqs(raftReq.Txn)</span><br><span class="line">  &#125;</span><br><span class="line">  ar = s.applyV3.Apply(&amp;raftReq)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用Trigger触发wait.Wait组件，将 *applyResult 发送出去</span></span><br><span class="line">s.goAttach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := &amp;pb.AlarmRequest&#123;</span><br><span class="line">    MemberID: <span class="keyword">uint64</span>(s.ID()),</span><br><span class="line">    Action:   pb.AlarmRequest_ACTIVATE,</span><br><span class="line">    Alarm:    pb.AlarmType_NOSPACE,</span><br><span class="line">  &#125;</span><br><span class="line">  s.raftRequest(s.ctx, pb.InternalRaftRequest&#123;Alarm: a&#125;)</span><br><span class="line">  s.w.Trigger(id, ar)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇重点是分享一种常见的阅读代码方式：<strong>自底向上</strong>+<strong>自顶向下</strong>。在阅读了EtcdServer处理请求后，将结果通过channel发送出去的整个逻辑，相关代码的调用链路见下图。</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd-4.png"></p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一讲，我们梳理了&lt;code&gt;EtcdServer&lt;/code&gt;的关键函数&lt;code&gt;processInternalRaftRequestOnce&lt;/code&gt;里的四个细节。&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;wait.Wait&lt;/code&gt;组件使用里，我们还遗留了一个细节实现，也就是请求的处理结果是怎么通过channel返回的。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 正常消息的返回，也就是我们本章要研究的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; x := &amp;lt;-ch:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x.(*applyResult), &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &amp;lt;-cctx.Done():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		proposalsFailed.Inc()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		s.w.Trigger(id, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, s.parseProposeCtxErr(cctx.Err(), start)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &amp;lt;-s.done:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, ErrStopped&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-etcd" scheme="http://example.com/tags/Go-etcd/"/>
    
  </entry>
  
</feed>
