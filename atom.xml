<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Junedayday Blog</title>
  
  <subtitle>六月天天的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-06T08:33:05.148Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Junedayday</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言微服务框架 - 12.ORM层的自动抽象与自定义方法的扩展</title>
    <link href="http://example.com/2021/12/02/go-framework/go-framework-12/"/>
    <id>http://example.com/2021/12/02/go-framework/go-framework-12/</id>
    <published>2021-12-02T04:00:00.000Z</published>
    <updated>2021-12-06T08:33:05.148Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>随着接口参数校验功能的完善，我们能快速定位到接口层面的参数问题；而应用服务的分层代码，也可以通过log的trace-id发现常见的业务逻辑问题。</p><p>但在最底层与数据库的操作，也就是对GORM的使用，经常会因为我们不了解ORM的一些细节，导致对数据的CRUD失败，或者没有达到预期效果。这时，我们希望能在ORM这一层，也有一个通用的解决方案，来协助问题的排查。趁这个机会，我们也对<code>gormer</code>这个工具再做一次迭代，生成新的功能。</p><span id="more"></span><h2 id="v0-7-2：ORM层的自动抽象与自定义方法的扩展"><a href="#v0-7-2：ORM层的自动抽象与自定义方法的扩展" class="headerlink" title="v0.7.2：ORM层的自动抽象与自定义方法的扩展"></a>v0.7.2：ORM层的自动抽象与自定义方法的扩展</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.7.2">https://github.com/Junedayday/micro_web_service/tree/v0.7.2</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>gormer工具支持interface的抽象与自定义方法的扩展，并具备日志打印功能。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>model层的自动抽象方案</li><li>dao层的代码实现</li><li>MySQL的SQL打印</li><li>关于gormer工具的迭代</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">    |-- order                            对应idl/order服务，同上</span><br><span class="line">     |-- swagger.json                    openapiv2的接口文档</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">   |-- order                           业务order定义，同时干</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">   |-- model                           修改：model层基本定义由gormer自动生成</span><br><span class="line">   |-- mysql                           修改：MySQL连接，支持日志打印</span><br><span class="line">   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义，新增参数校验逻辑</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- gormer.yaml                    将gormer中的参数移动到这里</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br><span class="line">|-- swagger.sh                     生成openapiv2的相关脚本</span><br></pre></td></tr></table></figure><h2 id="1-model层的自动抽象方案"><a href="#1-model层的自动抽象方案" class="headerlink" title="1.model层的自动抽象方案"></a>1.model层的自动抽象方案</h2><p>之前，我们在dao层已经实现了基本的CRUD相关代码，所以实现一个model层的定义很简单。但考虑到扩展性，也就是这个model层不仅仅需要简单的CRUD代码，还可能需要一些类似于<code>group by</code>等复杂sql，甚至包括子查询。</p><p>这时候，如果考虑全部用<code>gormer</code>工具自动生成的方案，那成本会很高，所以更建议分开维护的方案：简单的CRUD用自动代码生成的方式，而复杂SQL调用GORM库自行实现。我们来阅读代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *.go 自动生成的代码，标准方法</span></span><br><span class="line"><span class="keyword">type</span> OrderModel <span class="keyword">interface</span> &#123;</span><br><span class="line">AddOrder(ctx context.Context, order *gormer.Order) (err error)</span><br><span class="line">QueryOrders(ctx context.Context, pageNumber, pageSize <span class="keyword">int</span>, condition *gormer.OrderOptions) (orders []gormer.Order, err error)</span><br><span class="line">CountOrders(ctx context.Context, condition *gormer.OrderOptions) (count <span class="keyword">int64</span>, err error)</span><br><span class="line">UpdateOrder(ctx context.Context, updated, condition *gormer.OrderOptions) (err error)</span><br><span class="line">DeleteOrder(ctx context.Context, condition *gormer.OrderOptions) (err error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement Your Method in ext model</span></span><br><span class="line">OrderExtModel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *_ext.go 扩展方法</span></span><br><span class="line"><span class="keyword">type</span> OrderExtModel <span class="keyword">interface</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保证自定义的ext代码不被覆盖，在gormer的代码里添加如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果extFile已经存在，则不要覆盖</span></span><br><span class="line"><span class="keyword">if</span> _, err = os.Stat(extFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// 创建ext文件的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-dao层的代码实现"><a href="#2-dao层的代码实现" class="headerlink" title="2.dao层的代码实现"></a>2.dao层的代码实现</h2><p>dao层的代码基本同model层，分为<code>*.go</code>和<code>*_ext.go</code>两个。</p><p>为了保证dao层实现了model层的代码，我们也增加了一行代码，方便我们在编译期保证实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ model.OrderModel = NewOrderRepo(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h2 id="3-MySQL的SQL打印"><a href="#3-MySQL的SQL打印" class="headerlink" title="3.MySQL的SQL打印"></a>3.MySQL的SQL打印</h2><p>在GORM工具中，提供了一个callback的方式，让用户添加自定义的插件。具体可以参考 <a href="https://gorm.io/zh_CN/docs/write_plugins.html%E3%80%82%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%88%86%E4%B8%8B%E9%9D%A2%E4%B8%A4%E6%AD%A5%EF%BC%9A">https://gorm.io/zh_CN/docs/write_plugins.html。主要实现分下面两步：</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 - 操作SQL时，将ctx传入其中，用来传递一些通用参数，如traceid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">AddOrder</span><span class="params">(ctx context.Context, order *gormer.Order)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">repo.db.WithContext(ctx).</span><br><span class="line">Table(gormer.OrderTableName).</span><br><span class="line">Create(order)</span><br><span class="line">err = repo.db.Error</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 - 在操作数据库后，注册对应的插件afterLog，用来打印SQL日志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitGorm</span><span class="params">(user, password, addr <span class="keyword">string</span>, dbname <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">dsn := fmt.Sprintf(<span class="string">&quot;%s:%s@tcp(%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>,</span><br><span class="line">user, password, addr, dbname)</span><br><span class="line">GormDB, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束后</span></span><br><span class="line">_ = GormDB.Callback().Create().After(<span class="string">&quot;gorm:after_create&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line">_ = GormDB.Callback().Query().After(<span class="string">&quot;gorm:after_query&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line">_ = GormDB.Callback().Delete().After(<span class="string">&quot;gorm:after_delete&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line">_ = GormDB.Callback().Update().After(<span class="string">&quot;gorm:after_update&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line">_ = GormDB.Callback().Row().After(<span class="string">&quot;gorm:row&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line">_ = GormDB.Callback().Raw().After(<span class="string">&quot;gorm:raw&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callBackLogName = <span class="string">&quot;zlog&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">afterLog</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line">err := db.Error</span><br><span class="line">ctx := db.Statement.Context</span><br><span class="line"></span><br><span class="line">sql := db.Dialector.Explain(db.Statement.SQL.String(), db.Statement.Vars...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">zlog.WithTrace(ctx).Errorf(<span class="string">&quot;sql=%s || error=%v&quot;</span>, sql, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">zlog.WithTrace(ctx).Infof(<span class="string">&quot;sql=%s&quot;</span>, sql)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>afterLog</code>这里，我们引用了插件，实现了自定义日志组件的打印。</p><h2 id="4-关于gormer工具的迭代"><a href="#4-关于gormer工具的迭代" class="headerlink" title="4.关于gormer工具的迭代"></a>4.关于gormer工具的迭代</h2><p>在这个小版本中，我们又对gormer工具做了一次迭代。从整个框架的维度来看，我们不仅仅是把它作为一种代码生成的工具，而是一种模块化的抽象能力，关注分层能力的建设。从SQL的log打印来看，我们可以区分出前后的差异：</p><p><strong>原先</strong> - 通过调用一个<code>公共函数</code>来打印，需要侵入到每个dao层的具体代码</p><p><strong>修改后</strong> - 通过插件注册到组件中，<strong>无需侵入到具体实现的代码</strong></p><p><strong>无侵入地实现自定义功能</strong>，这个特性对每个工具组件都非常重要，GORM这里就提供了一个很好的实现思路 - 注册插件，自定义hook。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次迭代的意义很大 - <strong>标志着<code>gormer</code>这个组件实现了自定义方法的可扩展</strong>（ext文件）。</p><p>接下来，我们还会持续地对<code>gormer</code>等low code工具持续优化，实现更多的功能。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着接口参数校验功能的完善，我们能快速定位到接口层面的参数问题；而应用服务的分层代码，也可以通过log的trace-id发现常见的业务逻辑问题。&lt;/p&gt;
&lt;p&gt;但在最底层与数据库的操作，也就是对GORM的使用，经常会因为我们不了解ORM的一些细节，导致对数据的CRUD失败，或者没有达到预期效果。这时，我们希望能在ORM这一层，也有一个通用的解决方案，来协助问题的排查。趁这个机会，我们也对&lt;code&gt;gormer&lt;/code&gt;这个工具再做一次迭代，生成新的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 11.接口的参数校验功能-buf中引入PGV</title>
    <link href="http://example.com/2021/11/11/go-framework/go-framework-11/"/>
    <id>http://example.com/2021/11/11/go-framework/go-framework-11/</id>
    <published>2021-11-11T04:00:00.000Z</published>
    <updated>2021-11-15T11:45:20.470Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>随着API在线文档的发布，服务的接口将会被开放给各种各样的调用方。</p><p>大量开发接口的朋友会经常遇到<strong>接口参数校验</strong>的问题。举个例子，我们希望将某个字段是必填的，如<code>name</code>，我们经常会需要做两步：</p><ol><li>在程序中加一个<strong>判断逻辑</strong>，当这个字段为空时返回错误给调用方</li><li>在接口文档中加上<strong>注释</strong>，告诉调用方这个参数必填</li></ol><p>一旦某项工作被拆分为两步，就很容易出现<strong>不一致性</strong>：对应到参数检查，我们会经常遇到文档和具体实现不一致，从而导致双方研发的沟通成本增加。那么，今天我将引入一个方案，实现两者的一致性。</p><blockquote><p>为了缩小讨论范围，我们将 <strong>参数校验</strong> 限定为简单规则。</p><p>而复合条件的检查（逻辑组合等），不在本次的讨论范围内，主要考虑到2点：</p><ol><li>要生成跨语言的方案，技术上比较难实现</li><li>复合条件往往是一种业务逻辑的检查，放在接口层面不合适</li></ol></blockquote><span id="more"></span><h2 id="v0-7-1：接口的参数校验功能"><a href="#v0-7-1：接口的参数校验功能" class="headerlink" title="v0.7.1：接口的参数校验功能"></a>v0.7.1：接口的参数校验功能</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.7.1">https://github.com/Junedayday/micro_web_service/tree/v0.7.1</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>在线接口文档提供参数校验的逻辑，并自动生成相关代码。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>参数校验的技术选型</li><li>在buf中引入PGV</li><li>在框架中引入参数检查</li><li>buf格式检查</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">    |-- order                            对应idl/order服务，同上</span><br><span class="line">     |-- swagger.json                    openapiv2的接口文档</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">   |-- order                           业务order定义，同时干</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">   |-- model                           model层，定义对象的接口方法，具体实现在dao层</span><br><span class="line">   |-- mysql                           MySQL连接</span><br><span class="line">   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">|-- buf.gen.yaml                   修改：buf生成代码的定义，新增参数校验逻辑</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- gormer.yaml                    将gormer中的参数移动到这里</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br><span class="line">|-- swagger.sh                     生成openapiv2的相关脚本</span><br></pre></td></tr></table></figure><h2 id="1-参数校验的技术选型"><a href="#1-参数校验的技术选型" class="headerlink" title="1.参数校验的技术选型"></a>1.参数校验的技术选型</h2><p>从搜索引擎可知，protobuf的主流参数校验采用两者：</p><ol><li>go-proto-validators <a href="https://github.com/mwitkow/go-proto-validators">https://github.com/mwitkow/go-proto-validators</a></li><li>protoc-gen-validate <a href="https://github.com/envoyproxy/protoc-gen-validate">https://github.com/envoyproxy/protoc-gen-validate</a></li></ol><p>这里，我们最终选用的是protoc-gen-validate（PGV），决定性的理由有两个：</p><ol><li>buf的官方文档更倾向于PGV - <a href="https://docs.buf.build/lint/rules/#custom-options">https://docs.buf.build/lint/rules/#custom-options</a></li><li>PGV由envoy背书，长期来看更具维护性</li></ol><h2 id="2-在buf中引入PGV"><a href="#2-在buf中引入PGV" class="headerlink" title="2.在buf中引入PGV"></a>2.在buf中引入PGV</h2><p>protoc-gen-validate（PGV）作为一款插件，它已经被集成在了buf工具中。这次，我们就从其调用的顺序，来理解一下buf里的重要文件：</p><h3 id="2-1-核心文件-buf-yaml"><a href="#2-1-核心文件-buf-yaml" class="headerlink" title="2.1 核心文件 - buf.yaml"></a>2.1 核心文件 - buf.yaml</h3><p>具体引用路径可以在buf库 - <a href="https://buf.build/">https://buf.build/</a> 搜索找到，然后在文件中里添加一个依赖项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">buf.build/envoyproxy/protoc-gen-validate</span></span><br></pre></td></tr></table></figure><h3 id="2-2-生成的定义文件-buf-gen-yaml"><a href="#2-2-生成的定义文件-buf-gen-yaml" class="headerlink" title="2.2 生成的定义文件 - buf.gen.yaml"></a>2.2 生成的定义文件 - buf.gen.yaml</h3><p>这个文件定义了我们要生成什么样的代码，具体增加如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">validate</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">gen</span></span><br><span class="line">    <span class="attr">opt:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">paths=source_relative</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lang=go</span></span><br></pre></td></tr></table></figure><p>其中，要注意opt选项要增加一个参数<code>lang=go</code>，类似的，我们也可以生成其余语言的代码。</p><h3 id="2-3-proto定义文件"><a href="#2-3-proto定义文件" class="headerlink" title="2.3 proto定义文件"></a>2.3 proto定义文件</h3><p>我们以分页参数为例，添加2条规则，即要求页码、每页数量均大于0。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;validate/validate.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ListOrdersRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">1</span> [(validate.rules).<span class="built_in">int32</span> = &#123;gt: <span class="number">0</span>&#125;];</span><br><span class="line">  <span class="built_in">int32</span> page_size = <span class="number">2</span>   [(validate.rules).<span class="built_in">int32</span> = &#123;gt: <span class="number">0</span>&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-生成相关代码"><a href="#2-4-生成相关代码" class="headerlink" title="2.4 生成相关代码"></a>2.4 生成相关代码</h3><p>因为我们引入了一个新的模块，所以先需要更新依赖，用来下载新模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf mod update</span><br><span class="line">buf generate</span><br></pre></td></tr></table></figure><h3 id="2-5-参数校验的代码"><a href="#2-5-参数校验的代码" class="headerlink" title="2.5 参数校验的代码"></a>2.5 参数校验的代码</h3><p>在2.3引入validate的数据结构定义，会生成一个<code>*.pb.validate.go</code>文件，我们截取两个关键函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ListOrdersRequest)</span> <span class="title">Validate</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> m.validate(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ListOrdersRequest)</span> <span class="title">ValidateAll</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> m.validate(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从命名不难看出，<code>Validate</code>是检查到有一个不符合规则就立刻返回，<code>ValidateAll</code>是校验完所有的参数后、将不符合的规则一起返回。这两种处理方式的差异主要在于：</p><ol><li>耗时：全量检查相对会花费更多的时间</li><li>返回的信息量：全量检查的error会包含更多信息</li></ol><p>从服务端的视角，更推荐全量检查，将所有字段的检查结果返回给调用方，方便对方一次性修正。</p><h2 id="3-在框架中引入参数检查"><a href="#3-在框架中引入参数检查" class="headerlink" title="3.在框架中引入参数检查"></a>3.在框架中引入参数检查</h2><h3 id="3-1-grpc拦截器"><a href="#3-1-grpc拦截器" class="headerlink" title="3.1 grpc拦截器"></a>3.1 grpc拦截器</h3><p>grpc提供了一套拦截器Interceptor的机制，类似于http router中的middleware。之前，我们已经引入了一个拦截器，用于打印trace相关的日志。那么这次又新增了一个拦截器，该如何处理呢？</p><p>参考grpc的代码，我们可以看到下面两个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnaryInterceptor</span><span class="params">(i UnaryServerInterceptor)</span> <span class="title">ServerOption</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ChainUnaryInterceptor</span><span class="params">(interceptors ...UnaryServerInterceptor)</span> <span class="title">ServerOption</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中前者是单个拦截器，而后者是一种链式拦截器的概念。毫无疑问，我们需要扩充成多个拦截器。</p><h3 id="3-2-实现参数校验的拦截"><a href="#3-2-实现参数校验的拦截" class="headerlink" title="3.2 实现参数校验的拦截"></a>3.2 实现参数校验的拦截</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ValidateAll 对应 protoc-gen-validate 生成的 *.pb.validate.go 中的代码</span></span><br><span class="line"><span class="keyword">type</span> Validator <span class="keyword">interface</span> &#123;</span><br><span class="line">ValidateAll() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerValidationUnaryInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r, ok := req.(Validator); ok &#123;</span><br><span class="line"><span class="keyword">if</span> err := r.ValidateAll(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.InvalidArgument, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在拦截器中引入我们定义的插件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := grpc.NewServer(</span><br><span class="line">  grpc.ChainUnaryInterceptor(</span><br><span class="line">    grpc_opentracing.UnaryServerInterceptor(</span><br><span class="line">      grpc_opentracing.WithTracer(opentracing.GlobalTracer()),</span><br><span class="line">    ),</span><br><span class="line">    ServerValidationUnaryInterceptor,</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="3-3-具体调用示例"><a href="#3-3-具体调用示例" class="headerlink" title="3.3 具体调用示例"></a>3.3 具体调用示例</h3><p>我们尝试着传一个错误的接口参数，看看返回结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;invalid ListOrdersRequest.PageNumber: value must be greater than 0; invalid ListOrdersRequest.PageSize: value must be greater than 0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，结果中清晰地说明了不合规的两个参数，以及具体的规则，对调用方来说非常直观。</p><h2 id="4-buf格式检查"><a href="#4-buf格式检查" class="headerlink" title="4.buf格式检查"></a>4.buf格式检查</h2><p>随着buf工具的推进，我们引入了越来越多的内容，protobuf文件也新增了很多东西。这时，我们会希望能将protobuf的格式也能有一定的规范化。在buf之前，已经有prototool等工具，buf对此做了集成。</p><p>由于buf的lint检查有很多细节，建议酌情选用。以项目中我选择的为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lint:</span></span><br><span class="line">  <span class="attr">use:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">DEFAULT</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PACKAGE_VERSION_SUFFIX</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PACKAGE_DIRECTORY_MATCH</span></span><br><span class="line">  <span class="attr">rpc_allow_google_protobuf_empty_requests:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">rpc_allow_google_protobuf_empty_responses:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>包括两块：</p><ul><li>except排除了两个检查项，即要求protobuf的package带上版本后缀、与代码路径匹配</li><li>允许request和response设置为empty格式</li></ul><p>接下来，运行<code>buf lint</code>，会提示你需要修正的地方，逐一修改即可（很多是命名上的规范，增加可读性，推荐按插件的建议进行修改）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次框架的小迭代高度依赖了buf的生态体系，建议有时间的朋友可以再看看buf的文档链接 - <a href="https://docs.buf.build/introduction%E3%80%82buf%E5%B7%A5%E5%85%B7%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%A2%91%E7%8E%87%E6%AF%94%E8%BE%83%E9%AB%98%EF%BC%8C%E5%AF%B9%E5%85%B6%E6%96%B0%E7%89%B9%E6%80%A7%E4%BB%8D%E5%A4%84%E4%BA%8E%E8%A7%82%E6%9C%9B%E7%8A%B6%E6%80%81%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%B2%A1%E6%9C%89%E5%AE%8C%E5%85%A8%E6%8C%89%E7%85%A7%E5%85%B6Best">https://docs.buf.build/introduction。buf工具的迭代频率比较高，对其新特性仍处于观望状态，目前没有完全按照其Best</a> Practice推进。</p><p>回过头来，我们的参数检查方案依然存在一个明显问题：生成的swagger文档中没有对应的参数要求（Issue - <a href="https://github.com/grpc-ecosystem/grpc-gateway/issues/1093%EF%BC%89%E3%80%82%E5%A6%82%E6%9E%9C%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E9%95%BF%E6%9C%9F%E6%97%A0%E6%B3%95%E8%A7%A3%E5%86%B3%EF%BC%8C%E6%88%91%E4%B9%9F%E4%BC%9A%E7%BB%99%E5%87%BA%E4%B8%80%E5%A5%97%E8%87%AA%E5%B7%B1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82">https://github.com/grpc-ecosystem/grpc-gateway/issues/1093）。如果这个问题长期无法解决，我也会给出一套自己的解决方案。</a></p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着API在线文档的发布，服务的接口将会被开放给各种各样的调用方。&lt;/p&gt;
&lt;p&gt;大量开发接口的朋友会经常遇到&lt;strong&gt;接口参数校验&lt;/strong&gt;的问题。举个例子，我们希望将某个字段是必填的，如&lt;code&gt;name&lt;/code&gt;，我们经常会需要做两步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在程序中加一个&lt;strong&gt;判断逻辑&lt;/strong&gt;，当这个字段为空时返回错误给调用方&lt;/li&gt;
&lt;li&gt;在接口文档中加上&lt;strong&gt;注释&lt;/strong&gt;，告诉调用方这个参数必填&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一旦某项工作被拆分为两步，就很容易出现&lt;strong&gt;不一致性&lt;/strong&gt;：对应到参数检查，我们会经常遇到文档和具体实现不一致，从而导致双方研发的沟通成本增加。那么，今天我将引入一个方案，实现两者的一致性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了缩小讨论范围，我们将 &lt;strong&gt;参数校验&lt;/strong&gt; 限定为简单规则。&lt;/p&gt;
&lt;p&gt;而复合条件的检查（逻辑组合等），不在本次的讨论范围内，主要考虑到2点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要生成跨语言的方案，技术上比较难实现&lt;/li&gt;
&lt;li&gt;复合条件往往是一种业务逻辑的检查，放在接口层面不合适&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 10.接口文档-openapiv2的在线文档方案</title>
    <link href="http://example.com/2021/11/01/go-framework/go-framework-10/"/>
    <id>http://example.com/2021/11/01/go-framework/go-framework-10/</id>
    <published>2021-11-01T04:00:00.000Z</published>
    <updated>2021-11-02T10:08:07.124Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>随着项目的迭代，一个服务会开放出越来越多的接口供第三方调用。</p><p>虽然<code>protobuf</code>已经是通用性很广的IDL文件了，但对于未接触过这块的程序员来说，还是有很大的学习成本。在综合可读性和维护性之后，我个人比较倾向于使用oepnapiv2的方案，提供在线接口文档。</p><p>接下来，我们一起来看看这部分的实现。</p><span id="more"></span><h2 id="v0-7-0：接口文档-openapiv2的在线文档方案"><a href="#v0-7-0：接口文档-openapiv2的在线文档方案" class="headerlink" title="v0.7.0：接口文档-openapiv2的在线文档方案"></a>v0.7.0：接口文档-openapiv2的在线文档方案</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.7.0">https://github.com/Junedayday/micro_web_service/tree/v0.7.0</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>项目提供在线接口文档，供第三方快速地了解接口细节。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>了解buf的openapiv2的插件</li><li>用swagger工具合并文档</li><li>利用swagger相关容器提供在线文档</li></ol><blockquote><p>swagger 是 openapiv2 的一种具体实现，在下文可等同于一个概念。</p><p>可以参考swagger官网了解详情：<a href="https://swagger.io/specification/v2/">https://swagger.io/specification/v2/</a></p></blockquote><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">    |-- order                            对应idl/order服务，同上</span><br><span class="line">     |-- swagger.json                    新增：openapiv2的接口文档</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">   |-- order                           业务order定义，同时干</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">   |-- model                           model层，定义对象的接口方法，具体实现在dao层</span><br><span class="line">   |-- mysql                           MySQL连接</span><br><span class="line">   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义，从v1beta升到v1</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- gormer.yaml                    将gormer中的参数移动到这里</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br><span class="line">|-- swagger.sh                     新增：生成openapiv2的相关脚本</span><br></pre></td></tr></table></figure><h2 id="1-了解buf的openapiv2的插件"><a href="#1-了解buf的openapiv2的插件" class="headerlink" title="1.了解buf的openapiv2的插件"></a>1.了解buf的openapiv2的插件</h2><p>从<a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/mapping/customizing_openapi_output/#other-plugin-options">gRPC-Gateway的文档</a>中，我们可以找到对应的buf插件使用方式：在<code>buf.gen.yaml</code>文件中，我们添加如下插件内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">openapiv2</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">gen/openapiv2</span></span><br></pre></td></tr></table></figure><p>运行<code>buf generate</code>后，在<code>gen/openapiv2</code>目录下会根据我们在<code>idl</code>文件中的目录结构，生成多个接口文档。</p><h2 id="2-用swagger工具合并文档"><a href="#2-用swagger工具合并文档" class="headerlink" title="2.用swagger工具合并文档"></a>2.用swagger工具合并文档</h2><p>用buf标准的openapiv2插件会生成多份swagger文档，管理多个文件对使用方来说并不方便。最佳的使用体验，就是能将多个文档合并起来，用一个API文档统一交付。</p><p>这里，我们借助goswagger工具，合并文档。工具具体的安装方式可参考链接：<a href="https://goswagger.io/install.html%E3%80%82">https://goswagger.io/install.html。</a></p><p>安装后，运行如下命令，生成到文件 gen/swagger.json：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 合并swagger文档</span></span><br><span class="line">swagger mixin gen/openapiv2/idl/*/*.json -o gen/swagger.json</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除原始文档</span></span><br><span class="line">rm -rf gen/openapiv2</span><br></pre></td></tr></table></figure><h2 id="3-利用swagger相关容器提供在线文档"><a href="#3-利用swagger相关容器提供在线文档" class="headerlink" title="3.利用swagger相关容器提供在线文档"></a>3.利用swagger相关容器提供在线文档</h2><p>在统一了swagger文件后，在线接口文档的实现方案有很多，例如swagger官网就可以提供简单的渲染。</p><p>这里，我用了个人比较常用的docker镜像redoc为例，搭建一个在线接口文档平台。</p><blockquote><p>该镜像更多的使用方式可参考：<a href="https://hub.docker.com/r/redocly/redoc/">https://hub.docker.com/r/redocly/redoc/</a> </p></blockquote><p>运行如下命令，即将swagger.json加载到镜像中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name swagger -it --rm -d -p 80:80 -v $(pwd)/gen/swagger.json:/usr/share/nginx/html/swagger.json -e SPEC_URL=swagger.json redocly/redoc</span><br></pre></td></tr></table></figure><p>我们在本地打开浏览器，输入 <a href="http://127.0.0.1/">http://127.0.0.1:80/</a> 就能看到文档。</p><blockquote><p>扩展点 - 公共的文档服务器：</p><p>我们往往更希望把文档放在一个公共的服务器上，可以简单地利用这两个关键技术实现：</p><ol><li><a href="https://hub.docker.com/r/redocly/redoc/">https://hub.docker.com/r/redocly/redoc/</a> 中的watch方案，即watch某个目录下的文件，根据文件变化实时更新接口</li><li>利用scp命令，将本地swagger.json上传到远端服务器</li></ol><p>更复杂点的方案，可以考虑结合git流程来实现。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们实现了一个关键性的功能：<strong>代码即接口文档</strong>，保证了接口文档随着代码更新的实时性。</p><p>同时，希望大家能够认识到接口文档的价值，最好能做到<strong>接口文档即代码</strong>，也就是将相关程序的逻辑尽可能地通过接口文档表达清楚。哪怕前期接口文档问题很多，只要我们不断迭代，后续总能趋于稳定，降低维护接口的成本。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着项目的迭代，一个服务会开放出越来越多的接口供第三方调用。&lt;/p&gt;
&lt;p&gt;虽然&lt;code&gt;protobuf&lt;/code&gt;已经是通用性很广的IDL文件了，但对于未接触过这块的程序员来说，还是有很大的学习成本。在综合可读性和维护性之后，我个人比较倾向于使用oepnapiv2的方案，提供在线接口文档。&lt;/p&gt;
&lt;p&gt;接下来，我们一起来看看这部分的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 9.分布式链路追踪-OpenTracing的初步引入</title>
    <link href="http://example.com/2021/10/26/go-framework/go-framework-9/"/>
    <id>http://example.com/2021/10/26/go-framework/go-framework-9/</id>
    <published>2021-10-26T04:00:00.000Z</published>
    <updated>2021-11-01T08:11:18.225Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>我们从API层到数据库层的链路已经打通，简单的CRUD功能已经可以快速实现。</p><p>随着模块的增加，我们会越发感受到系统的复杂性，开始关注系统的可维护性。这时，有个名词会进入我们的视野：<strong>分布式链路追踪</strong>。相关的内容可以参考这我的两篇文章：</p><ul><li>OpenTelemetry <a href="https://junedayday.github.io/2021/10/14/readings/go-digest-2/">https://junedayday.github.io/2021/10/14/readings/go-digest-2/</a></li><li>Jaeger <a href="https://junedayday.github.io/2021/10/20/readings/go-digest-3/">https://junedayday.github.io/2021/10/20/readings/go-digest-3/</a></li></ul><p>我们接下来直接进入实战。</p><span id="more"></span><h2 id="v0-6-0：分布式链路追踪-OpenTracing的初步引入"><a href="#v0-6-0：分布式链路追踪-OpenTracing的初步引入" class="headerlink" title="v0.6.0：分布式链路追踪-OpenTracing的初步引入"></a>v0.6.0：分布式链路追踪-OpenTracing的初步引入</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.6.0">https://github.com/Junedayday/micro_web_service/tree/v0.6.0</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>在项目中引入Jaeger为代表的OpenTracing，用一个traceid串联整个请求的链路。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>trace的初始化</li><li>将opentracing的设置到grpc和grpc-gateway中</li><li>将traceid引入到log组件中</li><li>HTTP请求返回traceid</li></ol><blockquote><p>前两点我将一笔带过，在 <a href="https://junedayday.github.io/2021/10/20/readings/go-digest-3/">https://junedayday.github.io/2021/10/20/readings/go-digest-3/</a> 这篇中已有详细的讲解</p></blockquote><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">    |-- order                            对应idl/order服务，同上</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">   |-- order                           业务order定义，同时干</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">   |-- model                           model层，定义对象的接口方法，具体实现在dao层</span><br><span class="line">   |-- mysql                           MySQL连接</span><br><span class="line">   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义，从v1beta升到v1</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- gormer.yaml                    将gormer中的参数移动到这里</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-trace的初始化"><a href="#1-trace的初始化" class="headerlink" title="1.trace的初始化"></a>1.trace的初始化</h2><p>创建了一个jaeger的trace并设置到opentracing包里的全局变量中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">traceCfg := &amp;jaegerconfig.Configuration&#123;</span><br><span class="line">  ServiceName: <span class="string">&quot;MyService&quot;</span>,</span><br><span class="line">  Sampler: &amp;jaegerconfig.SamplerConfig&#123;</span><br><span class="line">    Type:  jaeger.SamplerTypeConst,</span><br><span class="line">    Param: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  Reporter: &amp;jaegerconfig.ReporterConfig&#123;</span><br><span class="line">    LocalAgentHostPort: <span class="string">&quot;127.0.0.1:6831&quot;</span>,</span><br><span class="line">    LogSpans:           <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">tracer, closer, err := traceCfg.NewTracer(jaegerconfig.Logger(jaeger.StdLogger))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> closer.Close()</span><br><span class="line">opentracing.SetGlobalTracer(tracer)</span><br></pre></td></tr></table></figure><h2 id="2-将opentracing的设置到grpc和grpc-gateway中"><a href="#2-将opentracing的设置到grpc和grpc-gateway中" class="headerlink" title="2.将opentracing的设置到grpc和grpc-gateway中"></a>2.将opentracing的设置到grpc和grpc-gateway中</h2><p>利用了拦截器的特性，类似于middleware。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// grpc-gateway</span></span><br><span class="line">opts := []grpc.DialOption&#123;</span><br><span class="line">  grpc.WithInsecure(),</span><br><span class="line">  grpc.WithUnaryInterceptor(</span><br><span class="line">    grpc_opentracing.UnaryClientInterceptor(</span><br><span class="line">      grpc_opentracing.WithTracer(opentracing.GlobalTracer()),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := demo.RegisterDemoServiceHandlerFromEndpoint(ctx, mux, fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, config.Viper.GetInt(<span class="string">&quot;server.grpc.port&quot;</span>)), opts); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;RegisterDemoServiceHandlerFromEndpoint error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grpc</span></span><br><span class="line">s := grpc.NewServer(grpc.UnaryInterceptor(grpc_opentracing.UnaryServerInterceptor(grpc_opentracing.WithTracer(opentracing.GlobalTracer()))))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-将traceid引入到log组件中"><a href="#3-将traceid引入到log组件中" class="headerlink" title="3.将traceid引入到log组件中"></a>3.将traceid引入到log组件中</h2><p>从Opentracing对Go语言的相关介绍可以得知，trace信息被放在go语言的context里。于是，就有了下面这一段提取traceid的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了使用方便，不修改zap源码，这里利用With函数返回一个SugaredLogger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTrace</span><span class="params">(ctx context.Context)</span> *<span class="title">zap</span>.<span class="title">SugaredLogger</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> jTraceId jaeger.TraceID</span><br><span class="line"><span class="keyword">if</span> parent := opentracing.SpanFromContext(ctx); parent != <span class="literal">nil</span> &#123;</span><br><span class="line">parentCtx := parent.Context()</span><br><span class="line"><span class="keyword">if</span> tracer := opentracing.GlobalTracer(); tracer != <span class="literal">nil</span> &#123;</span><br><span class="line">mySpan := tracer.StartSpan(<span class="string">&quot;my info&quot;</span>, opentracing.ChildOf(parentCtx))</span><br><span class="line">      <span class="comment">// 提取出一个jaeger的traceid</span></span><br><span class="line"><span class="keyword">if</span> sc, ok := mySpan.Context().(jaeger.SpanContext); ok &#123;</span><br><span class="line">jTraceId = sc.TraceID()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> mySpan.Finish()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Sugar.With(zap.String(jaeger.TraceContextHeaderName, fmt.Sprint(jTraceId)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-HTTP请求返回traceid"><a href="#4-HTTP请求返回traceid" class="headerlink" title="4.HTTP请求返回traceid"></a>4.HTTP请求返回traceid</h2><p>在拦截器里，解析出trace信息，设置到http的头里。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">trace, ok := serverSpan.Context().(jaeger.SpanContext)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">  w.Header().Set(jaeger.TraceContextHeaderName, fmt.Sprint(trace.TraceID()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们模拟一个简单的请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --request GET &#x27;http://127.0.0.1:8081/v1/orders&#x27;</span><br></pre></td></tr></table></figure><p>从返回的结果来看，可以看到<code>Uber-Trace-Id</code>头里有个具体的trace-id，例如5fd1fc3ba1715909。</p><p>而在应用代码中，我们添加了一行日志：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(orderSvc *OrderService)</span> <span class="title">List</span><span class="params">(ctx context.Context, pageNumber, pageSize <span class="keyword">int</span>, condition *gormer.OrderOptions)</span> <span class="params">([]gormer.Order, <span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">zlog.WithTrace(ctx).Infof(<span class="string">&quot;page number is %d&quot;</span>, pageNumber)</span><br><span class="line"><span class="comment">// zlog信息</span></span><br><span class="line"><span class="keyword">return</span> orders, count, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的打印如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-10-22T17:25:05.591+0800infoservice/order.go:26page number is 0&#123;&quot;uber-trace-id&quot;: &quot;5fd1fc3ba1715909&quot;&#125;</span><br></pre></td></tr></table></figure><p>虽然格式还不是那么优美，但traceid信息已经填入到了日志中。</p><p>至此，调用方只要提供返回的trace-id，我们就可以在程序日志中查找到相应的日志信息，方便针对性地排查问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OpenTracing是服务治理非常关键的一环。利用traceid串联一个请求的整个生命周期，能帮助我们快速地排查问题，在实际生产环境上能更快地定位问题。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们从API层到数据库层的链路已经打通，简单的CRUD功能已经可以快速实现。&lt;/p&gt;
&lt;p&gt;随着模块的增加，我们会越发感受到系统的复杂性，开始关注系统的可维护性。这时，有个名词会进入我们的视野：&lt;strong&gt;分布式链路追踪&lt;/strong&gt;。相关的内容可以参考这我的两篇文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OpenTelemetry &lt;a href=&quot;https://junedayday.github.io/2021/10/14/readings/go-digest-2/&quot;&gt;https://junedayday.github.io/2021/10/14/readings/go-digest-2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jaeger &lt;a href=&quot;https://junedayday.github.io/2021/10/20/readings/go-digest-3/&quot;&gt;https://junedayday.github.io/2021/10/20/readings/go-digest-3/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们接下来直接进入实战。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>技术阅读摘要 - 3.Jaeger技术分析</title>
    <link href="http://example.com/2021/10/20/readings/go-digest-3/"/>
    <id>http://example.com/2021/10/20/readings/go-digest-3/</id>
    <published>2021-10-20T04:00:00.000Z</published>
    <updated>2021-10-22T06:38:03.297Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QZ3lGpkvgdfXW7R.jpg" alt="Go-Framework"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>通过上一次技术阅读摘要，我们了解了分布式链路追踪这项技术，Jaeger是其主流的实现方案。</p><p>今天，我们就一起来看看Jaeger的相关资料，初步掌握这门技术。</p><span id="more"></span><h2 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h2><ul><li>Jaeger官网 <a href="https://www.jaegertracing.io/">https://www.jaegertracing.io/</a></li><li>Github <a href="https://github.com/jaegertracing/jaeger">https://github.com/jaegertracing/jaeger</a></li><li>Dapper <a href="https://research.google/pubs/pub36356/">https://research.google/pubs/pub36356/</a></li><li>OpenZipkin <a href="https://zipkin.io/">https://zipkin.io/</a></li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Jaeger的官方定义非常简洁 - <strong>Jaeger: open source, end-to-end distributed tracing</strong>。</p><p>关键词是<strong>端到端的分布式追踪</strong>。怎么理解这个端到端呢？它更多地是关注分布式系统中的<strong>入和出</strong>。从一个HTTP服务来看，它关注的是请求和响应的具体数据。对应到如今k8s中盛行的sidecar模式，就是一个网络的sidecar，将所有的请求进行标注（如带上traceId）。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Jaeger的官方文档上资料很丰富，更新也比较频繁。有些朋友会觉得阅读官方文档非常累，常常通篇阅读后发现抓不到重点、也没有什么印象。这里，我推荐一个页面 - <a href="https://www.jaegertracing.io/docs/1.27/architecture/">https://www.jaegertracing.io/docs/1.27/architecture/</a> ，并结合我的理解，方便大家快速理解。</p><h3 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h3><p>Span是分布式链路追踪中一个通用的术语，字面翻译为 <strong>带名称的Jaeger逻辑单元</strong>。</p><p>这里对逻辑单元的定义比较有争论，在我看来，逻辑单元的定义因具体场景而变化：</p><ul><li>在单体架构中，需要拆分成多个模块，每个模块定义成一个逻辑单元</li><li>在一个简单的微服务中，可以将服务定义成一个逻辑单元</li><li>在一个复杂的微服务中，可能需要根据更细的领域定义成一个逻辑单元</li></ul><h3 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h3><p>一个具体消息在整个分布式系统中的流转。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>Jaeger提供了2种架构的解决方案。我们先看看通用的部分：</p><ul><li>jaeger-client作为具体语言的内部库，嵌入到应用程序中</li><li>jaeger-agent作为sidecar，部署在容器或机器上，用来从jaeger收集数据，并推送到jaeger collector</li><li>jaeger collector负责将数据保存到数据库或MQ中</li><li>jaeger-query + UI 查询并显示数据</li></ul><p>而差异点就在于保存和分析数据的技术方案：</p><ul><li>简单方案：直接保存到数据库中，用Spark Jobs进行分析</li><li>高性能方案：用Kafka来削峰填谷，用Flink流式计算提高性能</li></ul><h2 id="Jaeger-Go"><a href="#Jaeger-Go" class="headerlink" title="Jaeger Go"></a>Jaeger Go</h2><h3 id="Trace的初始化"><a href="#Trace的初始化" class="headerlink" title="Trace的初始化"></a>Trace的初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">traceCfg := &amp;jaegerconfig.Configuration&#123;</span><br><span class="line">  <span class="comment">// 服务名</span></span><br><span class="line">  ServiceName: <span class="string">&quot;MyService&quot;</span>,</span><br><span class="line">  <span class="comment">// 采样参数</span></span><br><span class="line">  Sampler: &amp;jaegerconfig.SamplerConfig&#123;</span><br><span class="line">    Type:  jaeger.SamplerTypeConst,</span><br><span class="line">    Param: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 上报，这里通过jaeger sidecar的端口来上报日志</span></span><br><span class="line">  Reporter: &amp;jaegerconfig.ReporterConfig&#123;</span><br><span class="line">    LocalAgentHostPort: <span class="string">&quot;127.0.0.1:6831&quot;</span>,</span><br><span class="line">    LogSpans:           <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化tracer</span></span><br><span class="line">tracer, closer, err := traceCfg.NewTracer(jaegerconfig.Logger(jaeger.StdLogger))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> closer.Close()</span><br><span class="line"><span class="comment">// 将tracer设置到opentracing的全局变量中</span></span><br><span class="line">opentracing.SetGlobalTracer(tracer)</span><br></pre></td></tr></table></figure><p>上面这段逻辑描述了 <strong>创建jaeger的tracer并保存到opentracing的全局变量中</strong>。</p><p>这里强调一点：opentracing是一套标准，包括jaeger、zipkin等具体实现。我们可以深入看看<code>NewTracer</code>这个函数。它的注释很好地说明了这一点。具体的细节实现，我们暂时无需关注。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tracer implements opentracing.Tracer.</span></span><br><span class="line"><span class="keyword">type</span> Tracer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="技术组件引入Opentracing"><a href="#技术组件引入Opentracing" class="headerlink" title="技术组件引入Opentracing"></a>技术组件引入Opentracing</h3><p>通过上面的工作，我们已经在程序中引入了jaeger。但在实际的开发过程中，我们程序内部会有一些组件也需要引入jaeger的链路追踪，来实现更精细化的监控。</p><p>以gRPC-Gateway为例，引入Opentracing的链接如下： <a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/operations/tracing/#opentracing-support">https://grpc-ecosystem.github.io/grpc-gateway/docs/operations/tracing/#opentracing-support</a> 。这里面的代码可以直接引用，就不细看了。</p><p>目前，支持原生的Opentracing的组件越来越多。在引入一个复杂的组件时，我们要先了解清楚是否可以集成Opentracing，降低后续的运维复杂度。</p><h3 id="提取TraceId信息"><a href="#提取TraceId信息" class="headerlink" title="提取TraceId信息"></a>提取TraceId信息</h3><p>整个jaeger的引入并不复杂，就已经能很好地实现链路监控了。但在实际的开发过程中，我们仍有一个非常关键的需求：<strong>如何将一个请求的trace信息，引入到业务代码中，跟踪业务代码的处理过程</strong>。这一点，在debug问题时非常有意义，尤其是面对一些自己不太熟悉的代码。</p><p>开发人员面对这个场景，最常用的逻辑就是log，那就意味着我们要将traceid注入到日志中。那么怎么获取traceid呢？下面看一段示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从ctx获取span</span></span><br><span class="line"><span class="keyword">if</span> parent := opentracing.SpanFromContext(ctx); parent != <span class="literal">nil</span> &#123;</span><br><span class="line">  parentCtx := parent.Context()</span><br><span class="line">  <span class="comment">// 获取opentracing中的全局tracer</span></span><br><span class="line">  <span class="keyword">if</span> tracer := opentracing.GlobalTracer(); tracer != <span class="literal">nil</span> &#123;</span><br><span class="line">    mySpan := tracer.StartSpan(<span class="string">&quot;my info&quot;</span>, opentracing.ChildOf(parentCtx))</span><br><span class="line">    <span class="comment">// 由于前面opentracing中的tracer是jaeger的，所以你这里转化为jaeger.SpanContext</span></span><br><span class="line">    <span class="keyword">if</span> sc, ok := mySpan.Context().(jaeger.SpanContext); ok &#123;</span><br><span class="line">      <span class="comment">// 这里，就能获取traceid等信息了，可以放在日志里</span></span><br><span class="line">      _ = sc.TraceID()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> mySpan.Finish()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑就是从go语言的上下文context信息中，用Opentracing里定义的全局tracer，提取出traceId等信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于Jaeger内容有很多延伸点，但本文只作入门，点到即可。</p><p>如果只能记住一点，我希望大家能认识到：<strong>Jaeger是Opentracing标准的一个实现</strong>。从本文能看到，在标准统一后，具体实现的变更会变得非常简单：例如要将Jaeger替换成Zipkin，只需要初始化tracer处做到替换即可。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QZ3lGpkvgdfXW7R.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;通过上一次技术阅读摘要，我们了解了分布式链路追踪这项技术，Jaeger是其主流的实现方案。&lt;/p&gt;
&lt;p&gt;今天，我们就一起来看看Jaeger的相关资料，初步掌握这门技术。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Digest" scheme="http://example.com/tags/Digest/"/>
    
  </entry>
  
  <entry>
    <title>技术阅读摘要 - 2.OpenTelemetry技术概览</title>
    <link href="http://example.com/2021/10/14/readings/go-digest-2/"/>
    <id>http://example.com/2021/10/14/readings/go-digest-2/</id>
    <published>2021-10-14T04:00:00.000Z</published>
    <updated>2021-10-22T06:37:58.436Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QZ3lGpkvgdfXW7R.jpg" alt="Go-Framework"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>本系列的第二讲，我原先计划聊一下OpenTracing这个技术，但计划赶不上变化，我发现OpenTracing的官网上已经声明:这部分的技术将迁移到OpenTelemetry。</p><p>从OpenTelemetry的官方定义来看： <strong>An observability framework for cloud-native software</strong>，它的重点在于两块：</p><ol><li>可观察性：通过metrics、logs和traces数据，观察软件的运行情况</li><li>云原生：适配云原生理念</li></ol><p>OpenTelemetry的图标采用了一个<strong>望远镜</strong>，可见其核心在于可观察性。</p><span id="more"></span><h2 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h2><ul><li>OpenTelemetry <a href="https://opentelemetry.io/">https://opentelemetry.io/</a> </li><li>OpenTe4lemetry中文文档 <a href="https://github.com/open-telemetry/docs-cn">https://github.com/open-telemetry/docs-cn</a> </li><li>OpenTracing <a href="https://opentracing.io/">https://opentracing.io/</a> </li><li>OpenCensus <a href="https://opencensus.io/">https://opencensus.io/</a> </li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>我们先引用官方对自身的定义：<strong>OpenTelemetry is a set of APIs, SDKs, tooling and integrations that are designed for the creation and management of <em>telemetry data</em> such as traces, metrics, and logs.</strong></p><p>这句话指明了OpenTelemetry实现的3个重点数据：traces、metrics、logs。我们从简单到复杂，逐个讲述一下：</p><h3 id="Logs"><a href="#Logs" class="headerlink" title="Logs"></a>Logs</h3><p>日志：依赖程序自身的打印。可通过ELK/EFK等工具采集到统一的平台并展示。</p><h3 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h3><p>指标：程序将运行中关键的一些指标数据保存下来，常通过RPC的方式Pull/Push到统一的平台。</p><p>常见的如请求数、请求延迟、请求成功率等，也可进行一定的计算后获得更复杂的复合指标。</p><h3 id="Traces"><a href="#Traces" class="headerlink" title="Traces"></a>Traces</h3><p>分布式追踪：遵循Dapper等协议，获取一个请求在整个系统中的调用链路。</p><p>常见的如根据一个HTTP请求的requestID，获取其各个RPC、数据库、缓存等关键链路中的详情。</p><h2 id="技术标准"><a href="#技术标准" class="headerlink" title="技术标准"></a>技术标准</h2><p>到今天，OpenTelemetry还没有完全落地，但这不妨碍我们看清未来的发展方向。</p><p><strong>Metrics以Prometheus为标准，Traces以Jaeger为标准，而Logs暂时还没有明确的标准</strong>，但业界基本以ELK或EFK为技术实现。而我们常会把Traces和Logs这两点结合起来，通过在应用程序的打印日志中添加对应的Traces，来更好地排查整个数据链路。</p><p>但这样还不够，Opentelemetry期望的是将三者都关联起来，而引入了Context这个概念。熟悉Go语言的同学都清楚，context被定义为上下文，用于程序中传递数据。而Opentelemetry将这个概念进一步扩大，包括了RPC请求、多线程、跨语言、异步调用等各种复杂场景。</p><p>OpenTelemetry的推进工作非常困难，但其带来的价值是不言而喻的。今天，我们依旧以Go语言为例，试试窥一斑而见全豹，对这个技术有个基本掌握。</p><h2 id="Go语言示例"><a href="#Go语言示例" class="headerlink" title="Go语言示例"></a>Go语言示例</h2><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>参考官方在Go Package上的声明，Traces处于稳定状态，Metrics处于Alpha测试版本，而Logs则处于冻结状态。</p><blockquote><p>可见日志的优先级放在了Traces和Metrics之后。从最终实现来说，只要确定了Traces和Metrics的具体标准，Logs的实现并没有那么复杂。</p></blockquote><h3 id="1-创建Exporter"><a href="#1-创建Exporter" class="headerlink" title="1. 创建Exporter"></a>1. 创建Exporter</h3><p>OpenTelemetry要求程序中收集到的数据，都通过一定的途径发送给外部，如控制台、外部存储、端口等，所以就有了Exporter这个概念。</p><p>这里以一个简单的控制台Exporter为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">traceExporter, err := stdouttrace.New(</span><br><span class="line">  stdouttrace.WithPrettyPrint(),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">&quot;failed to initialize stdouttrace export pipeline: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-创建Trace-Provider"><a href="#2-创建Trace-Provider" class="headerlink" title="2. 创建Trace Provider"></a>2. 创建Trace Provider</h3><p>Traces这部分的概念比较多，这里先只讲解一个 - span。在分布式系统中，存在上下游的概念、也就是调用和被调用的关系，在分布式追踪系统中就将它们区分为不同的span。</p><p>示例代码初始化了Traces Provider，用于Traces相关的功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx := context.Background()</span><br><span class="line">bsp := sdktrace.NewBatchSpanProcessor(traceExporter)</span><br><span class="line">tp := sdktrace.NewTracerProvider(sdktrace.WithSpanProcessor(bsp))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle this error in a sensible manner </span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _ = tp.Shutdown(ctx) &#125;()</span><br></pre></td></tr></table></figure><blockquote><p>如果要深入了解分布式追踪技术，建议搜索Dapper论文或网上的相关资料。</p></blockquote><h3 id="3-创建Meter-Provider"><a href="#3-创建Meter-Provider" class="headerlink" title="3. 创建Meter Provider"></a>3. 创建Meter Provider</h3><p>类似Traces，Metrics也需要一个Provider，但它的名字叫做Meter Provider。</p><p>我们看一下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">metricExporter, err := stdoutmetric.New(</span><br><span class="line">  stdoutmetric.WithPrettyPrint(),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pusher := controller.New(</span><br><span class="line">  processor.New(</span><br><span class="line">    simple.NewWithExactDistribution(),</span><br><span class="line">    metricExporter,</span><br><span class="line">  ),</span><br><span class="line">  controller.WithExporter(metricExporter),</span><br><span class="line">  controller.WithCollectPeriod(<span class="number">5</span>*time.Second),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">err = pusher.Start(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle this error in a sensible manner where possible</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _ = pusher.Stop(ctx) &#125;()</span><br></pre></td></tr></table></figure><p>抛开初始化部分，其中还包含了2个关键性的内容：</p><ol><li>程序指标的计算部分</li><li>metrics的发送方式采用了push，周期为5s</li></ol><h3 id="4-设置全局选项"><a href="#4-设置全局选项" class="headerlink" title="4. 设置全局选项"></a>4. 设置全局选项</h3><p>这部分的内容不多，也很容易理解，但在实际工程中的价值很大：<strong>让调用者更方便！</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">otel.SetTracerProvider(tp)</span><br><span class="line">global.SetMeterProvider(pusher.MeterProvider())</span><br><span class="line">propagator := propagation.NewCompositeTextMapPropagator(propagation.Baggage&#123;&#125;,propagation.TraceContext&#123;&#125;)</span><br><span class="line">otel.SetTextMapPropagator(propagator)</span><br></pre></td></tr></table></figure><p>这里面做的事情很简单，就是将我们程序中自己创建的trace provider和meter provider设置到官方包中，也就是替换了官方包中的全局变量。接下来，我们想使用provider时，就统一调用官方包即可，<strong>不再需要引用本地的变量</strong>。</p><blockquote><p> 并不是所有的场景都适合把变量存放到统一的package下，可以延伸思考下~</p><p>举个例子，github.com/spf13/viper配置库只支持全局单个对象Viper，而我们程序中要创建多个对象，这时就不适用。</p></blockquote><h3 id="5-创建Metric-Instruments"><a href="#5-创建Metric-Instruments" class="headerlink" title="5. 创建Metric Instruments"></a>5. 创建Metric Instruments</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置关键属性</span></span><br><span class="line">lemonsKey := attribute.Key(<span class="string">&quot;ex.com/lemons&quot;</span>)</span><br><span class="line">anotherKey := attribute.Key(<span class="string">&quot;ex.com/another&quot;</span>)</span><br><span class="line"></span><br><span class="line">commonAttributes := []attribute.KeyValue&#123;lemonsKey.Int(<span class="number">10</span>), attribute.String(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>), attribute.String(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;2&quot;</span>), attribute.String(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;3&quot;</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Meter实例</span></span><br><span class="line">meter := global.Meter(<span class="string">&quot;ex.com/basic&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步的Observer：通过函数回调</span></span><br><span class="line">observerCallback := <span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, result metric.Float64ObserverResult)</span></span> &#123;</span><br><span class="line">  result.Observe(<span class="number">1</span>, commonAttributes...)</span><br><span class="line">&#125;</span><br><span class="line">_ = metric.Must(meter).NewFloat64ValueObserver(<span class="string">&quot;ex.com.one&quot;</span>, observerCallback,metric.WithDescription(<span class="string">&quot;A ValueObserver set to 1.0&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步的Recorder：创建一个变量，按需使用</span></span><br><span class="line">valueRecorder := metric.Must(meter).NewFloat64ValueRecorder(<span class="string">&quot;ex.com.two&quot;</span>)</span><br><span class="line">boundRecorder := valueRecorder.Bind(commonAttributes...)</span><br><span class="line"><span class="keyword">defer</span> boundRecorder.Unbind()</span><br></pre></td></tr></table></figure><h3 id="6-综合示例"><a href="#6-综合示例" class="headerlink" title="6. 综合示例"></a>6. 综合示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Tracer</span></span><br><span class="line">tracer := otel.Tracer(<span class="string">&quot;ex.com/basic&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了一个包含2个member的baggage，并结合到Go里的context</span></span><br><span class="line">foo, _ := baggage.NewMember(<span class="string">&quot;ex.com.foo&quot;</span>, <span class="string">&quot;foo1&quot;</span>)</span><br><span class="line">bar, _ := baggage.NewMember(<span class="string">&quot;ex.com.bar&quot;</span>, <span class="string">&quot;bar1&quot;</span>)</span><br><span class="line">bag, _ := baggage.New(foo, bar)</span><br><span class="line">ctx = baggage.ContextWithBaggage(ctx, bag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下为一个具体调用的示例，多层嵌套</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 根据传入的ctx，创建一个span</span></span><br><span class="line">  <span class="keyword">var</span> span trace.Span</span><br><span class="line">  ctx, span = tracer.Start(ctx, <span class="string">&quot;operation&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> span.End()</span><br><span class="line"></span><br><span class="line">  span.AddEvent(<span class="string">&quot;Nice operation!&quot;</span>, trace.WithAttributes(attribute.Int(<span class="string">&quot;bogons&quot;</span>, <span class="number">100</span>)))</span><br><span class="line">  span.SetAttributes(anotherKey.String(<span class="string">&quot;yes&quot;</span>))</span><br><span class="line"></span><br><span class="line">  meter.RecordBatch(</span><br><span class="line">    ctx,</span><br><span class="line">    commonAttributes,</span><br><span class="line">    valueRecorder.Measurement(<span class="number">2.0</span>),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 根据传入的ctx，创建一个子span</span></span><br><span class="line">    <span class="keyword">var</span> span trace.Span</span><br><span class="line">    ctx, span = tracer.Start(ctx, <span class="string">&quot;Sub operation...&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> span.End()</span><br><span class="line"></span><br><span class="line">    span.SetAttributes(lemonsKey.String(<span class="string">&quot;five&quot;</span>))</span><br><span class="line">    span.AddEvent(<span class="string">&quot;Sub span event&quot;</span>)</span><br><span class="line">    boundRecorder.Record(ctx, <span class="number">1.3</span>)</span><br><span class="line">  &#125;(ctx)</span><br><span class="line">&#125;(ctx)</span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li>文档 - <a href="https://opentelemetry.io/docs/go/">https://opentelemetry.io/docs/go/</a></li><li>Go Package - <a href="https://pkg.go.dev/go.opentelemetry.io/otel#section-readme">https://pkg.go.dev/go.opentelemetry.io/otel#section-readme</a></li><li>Github - <a href="https://github.com/open-telemetry/opentelemetry-go">https://github.com/open-telemetry/opentelemetry-go</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从现状来看，OpenTelemetry仍处于初期阶段，使用起来并不那么方便。我们应该把重点放在标准上：</p><p>从官方文档 - <a href="https://opentelemetry.io/docs/go/exporting_data/">https://opentelemetry.io/docs/go/exporting_data/</a> 中可以看出，OpenTelemetry有标准的OTLP Exporter，但目前这块更多的是一个标准，而不是一个具体实践。</p><p>针对当前已落地的技术，重要参考就是Jaeger和Prometheus。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QZ3lGpkvgdfXW7R.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;本系列的第二讲，我原先计划聊一下OpenTracing这个技术，但计划赶不上变化，我发现OpenTracing的官网上已经声明:这部分的技术将迁移到OpenTelemetry。&lt;/p&gt;
&lt;p&gt;从OpenTelemetry的官方定义来看： &lt;strong&gt;An observability framework for cloud-native software&lt;/strong&gt;，它的重点在于两块：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可观察性：通过metrics、logs和traces数据，观察软件的运行情况&lt;/li&gt;
&lt;li&gt;云原生：适配云原生理念&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OpenTelemetry的图标采用了一个&lt;strong&gt;望远镜&lt;/strong&gt;，可见其核心在于可观察性。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Digest" scheme="http://example.com/tags/Digest/"/>
    
  </entry>
  
  <entry>
    <title>技术阅读摘要 - 1.十二要素应用原则</title>
    <link href="http://example.com/2021/10/12/readings/go-digest-1/"/>
    <id>http://example.com/2021/10/12/readings/go-digest-1/</id>
    <published>2021-10-12T04:00:00.000Z</published>
    <updated>2021-10-22T06:37:50.496Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QZ3lGpkvgdfXW7R.jpg" alt="Go-Framework"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><strong>十二要素应用原则（The Twelve-Factor App）</strong> 在如今的微服务领域非常流行，相信大家或多或少有所耳闻，但了解其中细节的并不多。</p><p>今天，我将对这12个原则做一个概要分析，结合Go语言中的相关例子，根据开源与大厂的具体实践，和大家一起看看个中究竟。</p><span id="more"></span><h2 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h2><ul><li>英文链接 <a href="https://12factor.net/">https://12factor.net/</a></li><li>中文链接 <a href="https://12factor.net/zh_cn/">https://12factor.net/zh_cn/</a></li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>先对12个概念做一个简单的讲解，让不熟悉的朋友心中有个初步概念。</p><h3 id="1-Codebase-基准代码-一份基准代码，多份部署"><a href="#1-Codebase-基准代码-一份基准代码，多份部署" class="headerlink" title="1. Codebase 基准代码 - 一份基准代码，多份部署"></a>1. Codebase 基准代码 - 一份基准代码，多份部署</h3><p>示例：一个应用程序的代码，放在一个Git仓库里。</p><blockquote><p>分支算不算一个仓库呢？</p><p>这点常有不同的理解。我个人会把一个分支认为是一个轻量级的仓库，每个分支对应一个具体的业务场景。</p></blockquote><p>痛点：在分布式的环境下，保证多个机器上运行的应用程序源代码一致，提升排查问题的效率。</p><h3 id="2-Dependencies-依赖-显式声明依赖关系"><a href="#2-Dependencies-依赖-显式声明依赖关系" class="headerlink" title="2. Dependencies 依赖 - 显式声明依赖关系"></a>2. Dependencies 依赖 - 显式声明依赖关系</h3><p>示例：Go语言的go module就显式地声明了项目依赖库与版本，方便维护。</p><p>痛点：以前Go vendor模式，将依赖代码都放在本地，没有一个文件集中说明项目的依赖，这就导致想找依赖关系必须去看代码细节。如果某个库的v1.0版本有bug，需要升级到1.1，go module只需查看一个文件，而vendor模式得遍历具体的项目，甚至多次递归。</p><h3 id="3-Config-配置-在环境中存储配置"><a href="#3-Config-配置-在环境中存储配置" class="headerlink" title="3. Config 配置 - 在环境中存储配置"></a>3. Config 配置 - 在环境中存储配置</h3><p>示例：将配置信息（端口、数据库、外部服务等）放在环境中，而不要硬编码。</p><blockquote><p>环境定义的扩展：在微服务中，这个环境指的是代码具体的运行环境，包括配置文件、环境变量、配置中心的数据。</p><p>值得一提的是，按照这种实践，配置文件不应该和应用程序代码放在一个代码仓库中，而是单独管理。</p></blockquote><p>痛点：保证多机器上运行的代码一致后，把变化点转移到配置中，避免硬编码到代码仓库中、导致更新需要整体升级。</p><h3 id="4-Backing-Services-后端服务-把后端服务当作附加资源"><a href="#4-Backing-Services-后端服务-把后端服务当作附加资源" class="headerlink" title="4. Backing Services 后端服务 - 把后端服务当作附加资源"></a>4. Backing Services 后端服务 - 把后端服务当作附加资源</h3><p>示例：当前的数据库选型为MySQL，有一天突然转变成了阿里云的RDS，只需要修改一个配置。</p><p>痛点：这是一种面向标准接口编程的模式，重点是让非业务相关的代码变得灵活可替代，如数据库、缓存、第三方服务。从被调用方的角度来看，过于理想化，很多重量级的组件很难被替代；而从调用方来看，这一切又显得理所当然，谁都希望外部系统的变化是无感知的。</p><blockquote><p>这一点，非常考验每个服务的设计者的能力，尤其是API接口。</p></blockquote><h3 id="5-Build-release-run-构建，发布，运行-严格分离构建和运行"><a href="#5-Build-release-run-构建，发布，运行-严格分离构建和运行" class="headerlink" title="5. Build, release, run 构建，发布，运行 - 严格分离构建和运行"></a>5. Build, release, run 构建，发布，运行 - 严格分离构建和运行</h3><p>示例：Go程序在一个构建机器上用 go build命令生成二进制文件，在发布阶段将这个二进制文件分发到各个待运行的机器上，最后在各个机器上运行这个二进制文件。</p><p>痛点：强调了CICD一整套流水线，不要让构建和运行强绑定。举个极端的例子，如果有一台centos和一台ubuntu的机器，我们去两个机器上各自编译+运行，可能因为内核不同而发生奇怪的现象；而如果采用在一台专用的centos机器上编译成统一的可执行文件，再分发到这两台机器上，更加合理。</p><blockquote><p> 如果centos上可执行文件无法在ubuntu机器上运行，就在部署阶段报错，提醒我们去修复。我们更应该去把部署的机器改成centos统一管理，而不是去花大量精力兼容ubuntu。</p><p>随着Docker技术的推广，大量简化了这一步骤。</p></blockquote><h3 id="6-Processes-进程-以一个或多个无状态进程运行应用"><a href="#6-Processes-进程-以一个或多个无状态进程运行应用" class="headerlink" title="6. Processes 进程 - 以一个或多个无状态进程运行应用"></a>6. Processes 进程 - 以一个或多个无状态进程运行应用</h3><p>示例：程序的内存中不保存具体业务相关的数据，而应该保存在共享存储上。</p><p>痛点：程序有状态是横向扩容的一大阻碍。想要完全去掉有状态的数据过于理想化，毕竟放在共享存储上肯定不如本地内存访问快，这对一些性能敏感的应用来说影响很大；但微服务架构强调要面向失败编程，这些有状态的数据在程序崩溃时无法恢复，可能导致级联雪崩的等更可怕情况。这一点，需要服务的负责人仔细权衡。</p><h3 id="7-Port-Binding-端口绑定-通过端口绑定提供服务"><a href="#7-Port-Binding-端口绑定-通过端口绑定提供服务" class="headerlink" title="7. Port Binding 端口绑定 - 通过端口绑定提供服务"></a>7. Port Binding 端口绑定 - 通过端口绑定提供服务</h3><p>示例：通过开放端口、以RPC形式提供服务</p><p>痛点：历史上有些程序以unix socket的本地形式提供服务，维护成本比较高。目前微服务以HTTP为代表的RPC方式提供服务，适合横向扩展。</p><h3 id="8-Concurrency-并发-通过进程模型进行扩展"><a href="#8-Concurrency-并发-通过进程模型进行扩展" class="headerlink" title="8. Concurrency 并发 - 通过进程模型进行扩展"></a>8. Concurrency 并发 - 通过进程模型进行扩展</h3><p>示例：当并发量达到一定程度，通过横向扩容进程（Docker实例）来满足需求</p><p>痛点：在并发度比较小时，最简单的提升方式是纵向扩容 - 即提高机器的配置。但当并发程度达到一定级别后，无法再通过提升硬件配置来解决。如果进程做到了无状态，利用外部的调度平台（如k8s）进行扩缩容，更适合长期发展。</p><h3 id="9-Disposability-易处理-快速启动和优雅终止可最大化健壮性"><a href="#9-Disposability-易处理-快速启动和优雅终止可最大化健壮性" class="headerlink" title="9. Disposability 易处理 - 快速启动和优雅终止可最大化健壮性"></a>9. Disposability 易处理 - 快速启动和优雅终止可最大化健壮性</h3><p>示例：程序能够快速启动，遇到严重异常时也能尽可能地完成现有的任务，优雅终止。</p><p>痛点：启动时间少能让程序遇到问题后快速恢复，也可以更快速地横向扩容；而优雅终止更多地是为了保障数据的一致性。</p><h3 id="10-Dev-prod-parity-开发环境与线上环境等价-尽可能的保持开发，预发布，线上环境相同"><a href="#10-Dev-prod-parity-开发环境与线上环境等价-尽可能的保持开发，预发布，线上环境相同" class="headerlink" title="10. Dev/prod parity 开发环境与线上环境等价 - 尽可能的保持开发，预发布，线上环境相同"></a>10. Dev/prod parity 开发环境与线上环境等价 - 尽可能的保持开发，预发布，线上环境相同</h3><p>示例：开发、预发布、线上等环境上部署的代码、配置、第三方服务等，尽可能地保证一致，让故障提前在测试环境发生。</p><p>痛点：尽可能地保证线上环境的稳定性，让问题尽可能地在开发环境中暴露出来，结合CICD工作保障环境的一致性。</p><h3 id="11-Logs-日志-把日志当作事件流"><a href="#11-Logs-日志-把日志当作事件流" class="headerlink" title="11. Logs 日志 - 把日志当作事件流"></a>11. Logs 日志 - 把日志当作事件流</h3><p>示例：在微服务架构中，通过日志将一个事件（如一个RPC请求）串联起来。</p><p>痛点：利用格式化的日志+ELK，将日志收集到统一的管理平台，用于分析数据。</p><h3 id="12-Admin-processes-管理进程-后台管理任务当作一次性进程运行"><a href="#12-Admin-processes-管理进程-后台管理任务当作一次性进程运行" class="headerlink" title="12. Admin processes 管理进程 - 后台管理任务当作一次性进程运行"></a>12. Admin processes 管理进程 - 后台管理任务当作一次性进程运行</h3><p>示例：将脚本、定时任务等，也作为一个应用程序提交，由k8s等调度平台执行</p><p>痛点：手动执行脚本或任务往往会有两个严重问题：误操作与可追溯性差。更合理的方式是走一个正式的发布流程，方便管理。</p><h2 id="案例串讲"><a href="#案例串讲" class="headerlink" title="案例串讲"></a>案例串讲</h2><h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><p>你（研发人员）收到了一个需求，要实现一个分布式的订单服务。于是，你新建了一个git仓库（<strong>1.基准代码</strong>），准备用go语言编写，部署在多个机器上（<strong>8.并发</strong>）。开发期间引用了大量的开源库，用Go Module将这些依赖都管理了起来（<strong>2.依赖</strong>）。</p><p>开发过程中，由于测试和线上的数据库地址不同，所以你把这些信息放在了配置中心（<strong>3.配置</strong>），如Etcd、k8s的ConfigMap中。</p><p>由于外部服务会依赖这个订单服务，所以要求研发提供的API接口必须向前兼容，所以选用了经典的RESTful风格的HTTP接口作为对外的协议（<strong>7.端口绑定</strong>）。这样，即便订单服务后续不断迭代，对外部来说也只是修改一个调用地址即可（<strong>4.后端服务</strong>）。</p><h3 id="上线阶段"><a href="#上线阶段" class="headerlink" title="上线阶段"></a>上线阶段</h3><p>在测试、预发布环境，为了开发与测试人员更好地验证功能，绝大部分的配置参数都保证与线上一致（<strong>10.开发环境与线上环境等价</strong>）。</p><p>整个上线流程包括了测试、预发布、线上三个环境的部署和验证，统一采用CICD的技术自动化执行（<strong>5.构建，发布，运行</strong>）。</p><h3 id="维护阶段"><a href="#维护阶段" class="headerlink" title="维护阶段"></a>维护阶段</h3><p>订单服务很复杂，经常会发生崩溃，导致很多数据恢复不了。于是，研发组长决定把关键的数据都放在Redis集群中（<strong>6.进程</strong>），保证应用的无状态化。</p><p>数据不丢了，但程序崩溃后恢复很慢，发现花大量的时间在加载初始数据上。于是又做了一次优化，利用Lazy Load的思路，按需加载（<strong>9.易处理</strong>）。</p><p>程序正常运行了，但用户反馈有个请求经常失败。这时，你利用ELK收集上的日志，排查了整个链路中的信息（<strong>11.日志</strong>），发现某处代码逻辑搞混了。当前的问题修复了，你还需要去数据库修复历史数据，就又写了个sql脚本提交到专门用来维护修改数据的代码仓库，提交给平台自动运行（<strong>12.管理进程</strong>）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>业界对这12个原则的理解并不完全一致，这也是因为<strong>不同角色处于不同的阶段所导致的视野差异性</strong>。</p><p>总体来说，这12个原则强调了简单性、可维护性，我们可以把它们作为微服务架构设计的指导性原则。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QZ3lGpkvgdfXW7R.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;十二要素应用原则（The Twelve-Factor App）&lt;/strong&gt; 在如今的微服务领域非常流行，相信大家或多或少有所耳闻，但了解其中细节的并不多。&lt;/p&gt;
&lt;p&gt;今天，我将对这12个原则做一个概要分析，结合Go语言中的相关例子，根据开源与大厂的具体实践，和大家一起看看个中究竟。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Digest" scheme="http://example.com/tags/Digest/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 8.Gormer迭代-定制专属的ORM代码生成工具</title>
    <link href="http://example.com/2021/10/10/go-framework/go-framework-8/"/>
    <id>http://example.com/2021/10/10/go-framework/go-framework-8/</id>
    <published>2021-10-10T04:00:00.000Z</published>
    <updated>2021-10-25T03:08:24.698Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>在上一篇，我们写一个<code>gormer</code>工具库，支持了简单的CRUD。但是，在实际的开发场景中，这部分的功能仍显得非常单薄。</p><p>例如，我们对比一下GORM库提供的<code>gorm.Model</code>，它在新增、修改时，会自动修改对应的时间，这个可以帮我们减少很多重复性的代码编写。这里，我就针对现有的gormer工具做一个示例性的迭代。</p><span id="more"></span><h2 id="v0-5-2：Gormer迭代-定制更智能的代码生成工具"><a href="#v0-5-2：Gormer迭代-定制更智能的代码生成工具" class="headerlink" title="v0.5.2：Gormer迭代-定制更智能的代码生成工具"></a>v0.5.2：Gormer迭代-定制更智能的代码生成工具</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.5.2">https://github.com/Junedayday/micro_web_service/tree/v0.5.2</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>生成一套智能化的Dao层代码，兼容软删除和硬删除。</p><blockquote><p>这里提一下软删除的概念，就是指在数据库中用某个字段标记为删除，但这行数据仍存在；而硬删除就是直接删除整条数据。</p><p>软删除虽然增加了一定的复杂度，但带来的收益很大。最直接的好处就是能保留记录，方便查原始记录。</p></blockquote><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>gormer.yaml的文件</li><li>模板文件的修改</li><li>核心结构体梳理</li><li>API调用示例</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><p>为了方便理解，我简化对应的目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">    |-- order                            对应idl/order服务，同上</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">   |-- order                           业务order定义，同时干</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">   |-- model                           model层，定义对象的接口方法，具体实现在dao层</span><br><span class="line">   |-- mysql                           MySQL连接</span><br><span class="line">   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          修改：gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义，从v1beta升到v1</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- gormer.yaml                    新增：将gormer中的参数移动到这里</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-gormer-yaml的文件"><a href="#1-gormer-yaml的文件" class="headerlink" title="1.gormer.yaml的文件"></a>1.gormer.yaml的文件</h2><p>这里先给出具体的建表语句，可以清晰地看到orders表6个字段的具体含义：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders</span><br><span class="line">(</span><br><span class="line">id <span class="type">bigint</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">255</span>) COMMENT <span class="string">&#x27;名称，建议唯一&#x27;</span>,</span><br><span class="line">price <span class="type">decimal</span>(<span class="number">15</span>,<span class="number">3</span>) COMMENT <span class="string">&#x27;订单价格&#x27;</span>,</span><br><span class="line">create_time <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">update_time <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">delete_status tinyint(<span class="number">3</span>) COMMENT <span class="string">&#x27;删除状态，1表示软删除&#x27;</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;订单信息表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>我们回顾一下之前的gormer程序，它采用了<code>flag</code>参数解析的方式。但随着复杂度提升，命令行参数包含了大量的内容，很难维护。这时，就建议采用<strong>配置文件</strong>的方式，保证可读性、可维护性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库相关的信息</span></span><br><span class="line"><span class="attr">database:</span></span><br><span class="line">  <span class="comment"># 数据库连接</span></span><br><span class="line">  <span class="attr">dsn:</span> <span class="string">&quot;root:123456@tcp(127.0.0.1:3306)/demo&quot;</span></span><br><span class="line">  <span class="comment"># 所有要生成到Go结构体中的表</span></span><br><span class="line">  <span class="attr">tables:</span></span><br><span class="line">    <span class="comment"># name-表名</span></span><br><span class="line">    <span class="comment"># goStruct-Go中结构体名</span></span><br><span class="line">    <span class="comment"># createTime-创建时间的数据库字段，必须为时间格式</span></span><br><span class="line">    <span class="comment"># updateTime-更新时间的数据库字段，必须为时间格式</span></span><br><span class="line">    <span class="comment"># softDeleteKey-软删除的数据库字段，必须为整数型，不填则为硬删除</span></span><br><span class="line">    <span class="comment"># softDeleteValue-表示为软删除的对应值</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;orders&quot;</span></span><br><span class="line">      <span class="attr">goStruct:</span> <span class="string">&quot;Order&quot;</span></span><br><span class="line">      <span class="attr">createTime:</span> <span class="string">&quot;create_time&quot;</span></span><br><span class="line">      <span class="attr">updateTime:</span> <span class="string">&quot;update_time&quot;</span></span><br><span class="line">      <span class="attr">softDeleteKey:</span> <span class="string">&quot;delete_status&quot;</span></span><br><span class="line">      <span class="attr">softDeleteValue:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目相关的信息</span></span><br><span class="line"><span class="attr">project:</span></span><br><span class="line">  <span class="comment"># 项目的路径</span></span><br><span class="line">  <span class="attr">base:</span> <span class="string">&quot;./&quot;</span></span><br><span class="line">  <span class="comment"># gorm相关核心结构的代码路径</span></span><br><span class="line">  <span class="attr">gorm:</span> <span class="string">&quot;internal/gormer/&quot;</span></span><br><span class="line">  <span class="comment"># dao层CRUD核心结构的代码路径</span></span><br><span class="line">  <span class="attr">dao:</span> <span class="string">&quot;internal/dao/&quot;</span></span><br><span class="line">  <span class="comment"># 项目的go module信息</span></span><br><span class="line">  <span class="attr">go_mod:</span> <span class="string">&quot;github.com/Junedayday/micro_web_service&quot;</span></span><br></pre></td></tr></table></figure><h2 id="2-模板文件的修改"><a href="#2-模板文件的修改" class="headerlink" title="2.模板文件的修改"></a>2.模板文件的修改</h2><p>这里以两个具有代表性的操作为例，一起来看看具体代码。</p><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><p>利用了go template的特性，填充了create_time和update_time字段。这里包含两层if语句：</p><ul><li>第一层：在<code>gormer.yaml</code>里必须指定了createTime代码，否则不要生成这段代码</li><li>第二层：如果外部传进来的字段里没有指定时间，才填充最新的时间；否则以外部传入为准</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">daoTmplAdd = <span class="string">`func (repo *&#123;&#123;.StructName&#125;&#125;Repo) Add&#123;&#123;.StructName&#125;&#125;(&#123;&#123;.StructSmallCamelName&#125;&#125; *gormer.&#123;&#123;.StructName&#125;&#125;) (err error) &#123;</span></span><br><span class="line"><span class="string">&#123;&#123;if ne .FieldCreateTime &quot;&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">    if &#123;&#123;.StructSmallCamelName&#125;&#125;.&#123;&#123;.FieldCreateTime&#125;&#125;.IsZero() &#123;</span></span><br><span class="line"><span class="string">&#123;&#123;.StructSmallCamelName&#125;&#125;.&#123;&#123;.FieldCreateTime&#125;&#125; = time.Now()</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;if ne .FieldUpdateTime &quot;&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">    if &#123;&#123;.StructSmallCamelName&#125;&#125;.&#123;&#123;.FieldUpdateTime&#125;&#125;.IsZero() &#123;</span></span><br><span class="line"><span class="string">&#123;&#123;.StructSmallCamelName&#125;&#125;.&#123;&#123;.FieldUpdateTime&#125;&#125; = time.Now()</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">err = repo.db.</span></span><br><span class="line"><span class="string">Table(gormer.&#123;&#123;.StructName&#125;&#125;TableName).</span></span><br><span class="line"><span class="string">Create(&#123;&#123;.StructSmallCamelName&#125;&#125;).</span></span><br><span class="line"><span class="string">Error</span></span><br><span class="line"><span class="string">return</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">AddOrder</span><span class="params">(order *gormer.Order)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> order.CreateTime.IsZero() &#123;</span><br><span class="line">order.CreateTime = time.Now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> order.UpdateTime.IsZero() &#123;</span><br><span class="line">order.UpdateTime = time.Now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = repo.db.</span><br><span class="line">Table(gormer.OrderTableName).</span><br><span class="line">Create(order).</span><br><span class="line">Error</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除的逻辑主要区分了一个字段，即是否在<code>gormer.yaml</code>里指定了软删除的字段。</p><ul><li>指定了软删除的字段，则将这个字段更新为设定的值、并且更新updateTime字段；</li><li>未指定软删除的字段，则直接硬删除对应的记录；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">daoTmplDelete = <span class="string">`func (repo *&#123;&#123;.StructName&#125;&#125;Repo) Delete&#123;&#123;.StructName&#125;&#125;(condition *gormer.&#123;&#123;.StructName&#125;&#125;Options) (err error) &#123;</span></span><br><span class="line"><span class="string">if condition == nil &#123;</span></span><br><span class="line"><span class="string">return errors.New(&quot;delete must include where condition&quot;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">err = repo.db.</span></span><br><span class="line"><span class="string">        Table(gormer.&#123;&#123;.StructName&#125;&#125;TableName).</span></span><br><span class="line"><span class="string">Where(condition.&#123;&#123;.StructName&#125;&#125;, condition.Fields).</span></span><br><span class="line"><span class="string">&#123;&#123;if eq .FieldSoftDeleteKey &quot;&quot; &#125;&#125; Delete(&amp;gormer.&#123;&#123;.StructName&#125;&#125;&#123;&#125;).</span></span><br><span class="line"><span class="string">&#123;&#123; else &#125;&#125;  &#123;&#123;if eq .FieldUpdateTime &quot;&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">Select(&quot;&#123;&#123;.TableSoftDeleteKey&#125;&#125;&quot;).</span></span><br><span class="line"><span class="string">Updates(&amp;gormer.&#123;&#123;.StructName&#125;&#125;&#123;</span></span><br><span class="line"><span class="string">&#123;&#123;.FieldSoftDeleteKey&#125;&#125;:&#123;&#123;.TableSoftDeleteValue&#125;&#125;,</span></span><br><span class="line"><span class="string">&#125;).</span></span><br><span class="line"><span class="string">            &#123;&#123; else &#125;&#125;</span></span><br><span class="line"><span class="string">                Select(&quot;&#123;&#123;.TableSoftDeleteKey&#125;&#125;&quot;,&quot;&#123;&#123;.TableUpdateTime&#125;&#125;&quot;).</span></span><br><span class="line"><span class="string">Updates(&amp;gormer.&#123;&#123;.StructName&#125;&#125;&#123;</span></span><br><span class="line"><span class="string">&#123;&#123;.FieldSoftDeleteKey&#125;&#125;:&#123;&#123;.TableSoftDeleteValue&#125;&#125;,</span></span><br><span class="line"><span class="string">&#123;&#123;.FieldUpdateTime&#125;&#125; : time.Now(),</span></span><br><span class="line"><span class="string">&#125;).</span></span><br><span class="line"><span class="string">            &#123;&#123; end &#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123; end &#125;&#125;</span></span><br><span class="line"><span class="string">Error</span></span><br><span class="line"><span class="string">return</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">DeleteOrder</span><span class="params">(condition *gormer.OrderOptions)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> condition == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;delete must include where condition&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = repo.db.</span><br><span class="line">Table(gormer.OrderTableName).</span><br><span class="line">Where(condition.Order, condition.Fields).</span><br><span class="line">Select(<span class="string">&quot;delete_status&quot;</span>, <span class="string">&quot;update_time&quot;</span>).</span><br><span class="line">Updates(&amp;gormer.Order&#123;</span><br><span class="line">DeleteStatus: <span class="number">1</span>,</span><br><span class="line">UpdateTime:   time.Now(),</span><br><span class="line">&#125;).</span><br><span class="line">Error</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-核心结构体梳理"><a href="#3-核心结构体梳理" class="headerlink" title="3.核心结构体梳理"></a>3.核心结构体梳理</h2><p>我们再一起看看表结构对应到Go结构体的一个关键结构体，这里分成了4个重要的部分：</p><ol><li>表名、结构体名</li><li>表中的列信息、结构体中的Field字段信息</li><li>创建时间、更新时间</li><li>软删除的字段</li></ol><p>这个数据结构体，其实是将两个数据源进行了关联映射：</p><ul><li>原始信息：从MySQL表中查询</li><li>自定义字段信息：从gormer.yaml查询</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StructLevel <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// table -&gt; struct</span></span><br><span class="line">TableName            <span class="keyword">string</span></span><br><span class="line">StructName           <span class="keyword">string</span></span><br><span class="line">StructSmallCamelName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// table column -&gt; struct field</span></span><br><span class="line">Columns []FieldLevel</span><br><span class="line"></span><br><span class="line"><span class="comment">// create time</span></span><br><span class="line">TableCreateTime <span class="keyword">string</span></span><br><span class="line">FieldCreateTime <span class="keyword">string</span></span><br><span class="line"><span class="comment">// update time</span></span><br><span class="line">TableUpdateTime <span class="keyword">string</span></span><br><span class="line">FieldUpdateTime <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// soft delete</span></span><br><span class="line">TableSoftDeleteKey   <span class="keyword">string</span></span><br><span class="line">TableSoftDeleteValue <span class="keyword">int</span></span><br><span class="line">FieldSoftDeleteKey   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FieldLevel <span class="keyword">struct</span> &#123;</span><br><span class="line">FieldName <span class="keyword">string</span></span><br><span class="line">FieldType <span class="keyword">string</span></span><br><span class="line"><span class="comment">// gorm tag for field</span></span><br><span class="line">GormName <span class="keyword">string</span></span><br><span class="line"><span class="comment">// comment from create table sql</span></span><br><span class="line">Comment <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-API调用示例"><a href="#4-API调用示例" class="headerlink" title="4.API调用示例"></a>4.API调用示例</h2><p>从API调用的角度来看，程序对外接口如下。有兴趣的可以体验下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// List</span><br><span class="line">curl --location --request GET &#x27;http://127.0.0.1:8081/v1/orders&#x27;</span><br><span class="line"></span><br><span class="line">// Create</span><br><span class="line">curl --location --request POST &#x27;http://127.0.0.1:8081/v1/orders&#x27; \</span><br><span class="line">--header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">--data-raw &#x27;&#123;</span><br><span class="line">    &quot;name&quot;: &quot;order4&quot;,</span><br><span class="line">    &quot;price&quot;: 100.3</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br><span class="line">// Update</span><br><span class="line">curl --location --request PATCH &#x27;http://127.0.0.1:8081/v1/orders&#x27; \</span><br><span class="line">--header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">--data-raw &#x27;&#123;</span><br><span class="line">    &quot;order&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;order1&quot;,</span><br><span class="line">        &quot;price&quot;: 110.8</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;update_mask&quot;: &quot;price&quot;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br><span class="line">// Get</span><br><span class="line">curl --location --request GET &#x27;http://127.0.0.1:8081/v1/orders/order1&#x27;</span><br><span class="line"></span><br><span class="line">// Delete</span><br><span class="line">curl --location --request DELETE &#x27;http://127.0.0.1:8081/v1/orders/order1&#x27;</span><br></pre></td></tr></table></figure><h2 id="延伸思考"><a href="#延伸思考" class="headerlink" title="延伸思考"></a>延伸思考</h2><p>修改到这个版本，gormer工具已经达到了基本可用的阶段。我们回顾一下重点功能：<strong>根据数据库表结构，自动化生成dao层的CRUD代码</strong>，并扩展了两特性：</p><ol><li>支持创建时间、修改时间的字段，自动填充</li><li>支持软删除与硬删除</li></ol><p>从更远的角度来看，还有许多MySQL的特性可以添加，尤其是对事务的支持，有兴趣的可以自行探索。限于篇幅与复杂度，目前就迭代到这个版本。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Gormer是一个我们根据日常CRUD需求自行实现的工具，是框架实现高度自动化的重要环节。它的核心思想是 - <strong>在重复的日常开发过程中找到可自动化的环节，实现Generate Code</strong>。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一篇，我们写一个&lt;code&gt;gormer&lt;/code&gt;工具库，支持了简单的CRUD。但是，在实际的开发场景中，这部分的功能仍显得非常单薄。&lt;/p&gt;
&lt;p&gt;例如，我们对比一下GORM库提供的&lt;code&gt;gorm.Model&lt;/code&gt;，它在新增、修改时，会自动修改对应的时间，这个可以帮我们减少很多重复性的代码编写。这里，我就针对现有的gormer工具做一个示例性的迭代。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 7.Gormer-自动生成代码的初体验</title>
    <link href="http://example.com/2021/09/27/go-framework/go-framework-7/"/>
    <id>http://example.com/2021/09/27/go-framework/go-framework-7/</id>
    <published>2021-09-27T04:00:00.000Z</published>
    <updated>2021-10-11T09:33:37.212Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>CRUD是贯穿整个程序员日常开发的基本工作，占据了我们绝大多数的coding时间。</p><p>作为一名程序员，我们总是希望能有更简单的开发方式来解决重复性的工作问题。在这个小版本中，我将结合自己的工作，来给出一套自动生成代码的完整方案，供大家借鉴。</p><span id="more"></span><h2 id="v0-5-1：Gormer-自动生成代码的初体验"><a href="#v0-5-1：Gormer-自动生成代码的初体验" class="headerlink" title="v0.5.1：Gormer-自动生成代码的初体验"></a>v0.5.1：Gormer-自动生成代码的初体验</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.5.1">https://github.com/Junedayday/micro_web_service/tree/v0.5.1</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>自动生成一套可用的Dao层代码，兼容原始版本。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>Go Template技术概览</li><li>gormer工具核心思路</li><li>gormer的模板填充</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务</span><br><span class="line">         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">    |-- order                            对应idl/order服务</span><br><span class="line">         |-- order.pb.go                       order.proto的基础结构</span><br><span class="line">         |-- order.pb.gw.go                    order.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- order_grpc.pb.go                  order.proto的gRPC接口代码</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义</span><br><span class="line">      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">   |-- order                           业务order定义</span><br><span class="line">      |-- order.proto                      protobuffer的原始定义</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹</span><br><span class="line">      |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层</span><br><span class="line">      |-- order.go                         Order对象，订单表，实现model层的OrderRepository</span><br><span class="line">      |-- order_test.go                    Order的单元测试</span><br><span class="line">   |-- gormer                          新增：从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">      |-- order.go                         新增：gormer从orders表中获取的真实Gorm结构体</span><br><span class="line">   |-- model                           model层，定义对象的接口方法</span><br><span class="line">      |-- order.go                         OrderRepository接口，具体实现在dao层</span><br><span class="line">   |-- mysql                           MySQL连接</span><br><span class="line">      |-- init.go                          初始化连接到MySQL的工作</span><br><span class="line">   |-- server                          服务器的实现</span><br><span class="line">      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">      |-- order.go                         Order相关的服务，目前仅简单的CRUD</span><br><span class="line">     |-- zlog                            封装日志的文件夹</span><br><span class="line">        |-- zap.go                           zap封装的代码实现</span><br><span class="line">  |-- pkg                            新增：开放给第三方的工具库</span><br><span class="line">     |-- gormer                          新增：gormer工具，用于生成Gorm相关Dao层代码</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义，从v1beta升到v1</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- gen.sh                         更新：生成代码的脚本：buf+gormer</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-Go-Template技术概览"><a href="#1-Go-Template技术概览" class="headerlink" title="1.Go Template技术概览"></a>1.Go Template技术概览</h2><p>Go的标准库提供了Template功能，但网上的介绍很零散，我建议大家可以阅读以下两篇资料：</p><ul><li>原理性：官方文档 - <a href="https://pkg.go.dev/text/template">https://pkg.go.dev/text/template</a> </li><li>实践性：Blog - <a href="https://blog.gopheracademy.com/advent-2017/using-go-templates/">https://blog.gopheracademy.com/advent-2017/using-go-templates/</a> </li></ul><p>这里，为了方便大家阅读下面的内容，我简要概括下：</p><ol><li>结构体中字段填充 <code>&#123;&#123; .FieldName &#125;&#125;</code></li><li>条件语句 <code>&#123;&#123;if .FieldName&#125;&#125; // action &#123;&#123; else &#125;&#125; // action 2 &#123;&#123; end &#125;&#125;</code></li><li>循环 <code>&#123;&#123;range .Member&#125;&#125; ... &#123;&#123;end&#125;&#125;</code></li><li>流水线 <code>&#123;&#123; with $x := <^>result-of-some-action<^> &#125;&#125; &#123;&#123; $x &#125;&#125; &#123;&#123; end &#125;&#125;</code></li></ol><blockquote><p>很多资料会很自然地将Go Template和HTML结合起来，但这只是模板的其中一个用法。</p><p>HTML的结构用模板化的方式可以减少大量重复性的代码，但这种思路是前后单不分离的，个人不太推荐。</p></blockquote><h2 id="2-gormer工具核心思路"><a href="#2-gormer工具核心思路" class="headerlink" title="2.gormer工具核心思路"></a>2.gormer工具核心思路</h2><p>在pkg/gormer目录下提供了一个gormer工具，用于自动生成代码，我对主流程进行简单地讲解：</p><ol><li>解析各种关键性的参数</li><li>连接测试数据库，获取表信息</li><li>逐个处理每个表<ol><li>读取数据库中的表结构</li><li>根据表结构生成对应的Go语言结构体，放在internal/gormer下</li><li>生成相关的Dao层代码，放在internal/dao下</li></ol></li><li>执行go fmt格式化代码</li></ol><p>其中最关键的是3-b与3-c，它们是生成代码的最关键步骤。我们来看一个关键性的结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体名称，对应MySQL表级别的信息</span></span><br><span class="line"><span class="keyword">type</span> StructLevel <span class="keyword">struct</span> &#123;</span><br><span class="line">TableName      <span class="keyword">string</span></span><br><span class="line">Name           <span class="keyword">string</span></span><br><span class="line">SmallCamelName <span class="keyword">string</span></span><br><span class="line">Columns        []FieldLevel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Field字段名称，对应MySQL表里Column</span></span><br><span class="line"><span class="keyword">type</span> FieldLevel <span class="keyword">struct</span> &#123;</span><br><span class="line">FieldName <span class="keyword">string</span></span><br><span class="line">FieldType <span class="keyword">string</span></span><br><span class="line">GormName  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-gormer的模板填充"><a href="#3-gormer的模板填充" class="headerlink" title="3.gormer的模板填充"></a>3.gormer的模板填充</h2><p>结合1、2，我们可以开始生成模板的部分，具体的Template代码如下，它会将StructLevel这个结构体中的字段填充到下面内容中，生成go文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gormerTmpl = <span class="string">`</span></span><br><span class="line"><span class="string">// Table Level Info</span></span><br><span class="line"><span class="string">const &#123;&#123;.Name&#125;&#125;TableName = &quot;&#123;&#123;.TableName&#125;&#125;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Field Level Info</span></span><br><span class="line"><span class="string">type &#123;&#123;.Name&#125;&#125;Field string</span></span><br><span class="line"><span class="string">const (</span></span><br><span class="line"><span class="string">&#123;&#123;range $item := .Columns&#125;&#125;</span></span><br><span class="line"><span class="string">    &#123;&#123;$.Name&#125;&#125;Field&#123;&#123;$item.FieldName&#125;&#125; &#123;&#123;$.Name&#125;&#125;Field = &quot;&#123;&#123;$item.GormName&#125;&#125;&quot; &#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var &#123;&#123;$.Name&#125;&#125;FieldAll = []&#123;&#123;$.Name&#125;&#125;Field&#123; &#123;&#123;range $k,$item := .Columns&#125;&#125;&quot;&#123;&#123;$item.GormName&#125;&#125;&quot;, &#123;&#123;end&#125;&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Kernel struct for table for one row</span></span><br><span class="line"><span class="string">type &#123;&#123;.Name&#125;&#125; struct &#123; &#123;&#123;range $item := .Columns&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;$item.FieldName&#125;&#125;&#123;&#123;$item.FieldType&#125;&#125;`</span> + <span class="string">&quot;`&quot;</span> + <span class="string">`gorm:&quot;column:&#123;&#123;$item.GormName&#125;&#125;&quot;`</span> + <span class="string">&quot;`&quot;</span> + <span class="string">` &#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Kernel struct for table operation</span></span><br><span class="line"><span class="string">type &#123;&#123;.Name&#125;&#125;Options struct &#123;</span></span><br><span class="line"><span class="string">    &#123;&#123;.Name&#125;&#125; *&#123;&#123;.Name&#125;&#125;</span></span><br><span class="line"><span class="string">    Fields []string</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Match: case insensitive</span></span><br><span class="line"><span class="string">var &#123;&#123;$.Name&#125;&#125;FieldMap = map[string]string&#123;</span></span><br><span class="line"><span class="string">&#123;&#123;range $item := .Columns&#125;&#125;&quot;&#123;&#123;$item.FieldName&#125;&#125;&quot;:&quot;&#123;&#123;$item.GormName&#125;&#125;&quot;,&quot;&#123;&#123;$item.GormName&#125;&#125;&quot;:&quot;&#123;&#123;$item.GormName&#125;&#125;&quot;,</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func New&#123;&#123;.Name&#125;&#125;Options(target *&#123;&#123;.Name&#125;&#125;, fields ...&#123;&#123;$.Name&#125;&#125;Field) *&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">    options := &amp;&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">        &#123;&#123;.Name&#125;&#125;: target,</span></span><br><span class="line"><span class="string">        Fields: make([]string, len(fields)),</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    for index, field := range fields &#123;</span></span><br><span class="line"><span class="string">        options.Fields[index] = string(field)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return options</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func New&#123;&#123;.Name&#125;&#125;OptionsAll(target *&#123;&#123;.Name&#125;&#125;) *&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">    return New&#123;&#123;.Name&#125;&#125;Options(target, &#123;&#123;$.Name&#125;&#125;FieldAll...)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func New&#123;&#123;.Name&#125;&#125;OptionsRawString(target *&#123;&#123;.Name&#125;&#125;, fields ...string) *&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">    options := &amp;&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">        &#123;&#123;.Name&#125;&#125;: target,</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    for _, field := range fields &#123;</span></span><br><span class="line"><span class="string">        if f,ok := &#123;&#123;$.Name&#125;&#125;FieldMap[field];ok &#123;</span></span><br><span class="line"><span class="string">             options.Fields = append(options.Fields, f)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return options</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>生成的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code generated by gormer. DO NOT EDIT.</span></span><br><span class="line"><span class="keyword">package</span> gormer</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Table Level Info</span></span><br><span class="line"><span class="keyword">const</span> OrderTableName = <span class="string">&quot;orders&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field Level Info</span></span><br><span class="line"><span class="keyword">type</span> OrderField <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">OrderFieldId         OrderField = <span class="string">&quot;id&quot;</span></span><br><span class="line">OrderFieldName       OrderField = <span class="string">&quot;name&quot;</span></span><br><span class="line">OrderFieldPrice      OrderField = <span class="string">&quot;price&quot;</span></span><br><span class="line">OrderFieldCreateTime OrderField = <span class="string">&quot;create_time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> OrderFieldAll = []OrderField&#123;<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;price&quot;</span>, <span class="string">&quot;create_time&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kernel struct for table for one row</span></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">Id         <span class="keyword">int64</span>     <span class="string">`gorm:&quot;column:id&quot;`</span></span><br><span class="line">Name       <span class="keyword">string</span>    <span class="string">`gorm:&quot;column:name&quot;`</span></span><br><span class="line">Price      <span class="keyword">float64</span>   <span class="string">`gorm:&quot;column:price&quot;`</span></span><br><span class="line">CreateTime time.Time <span class="string">`gorm:&quot;column:create_time&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kernel struct for table operation</span></span><br><span class="line"><span class="keyword">type</span> OrderOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">Order  *Order</span><br><span class="line">Fields []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Match: case insensitive</span></span><br><span class="line"><span class="keyword">var</span> OrderFieldMap = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;Id&quot;</span>: <span class="string">&quot;id&quot;</span>, <span class="string">&quot;id&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line"><span class="string">&quot;Name&quot;</span>: <span class="string">&quot;name&quot;</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line"><span class="string">&quot;Price&quot;</span>: <span class="string">&quot;price&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="string">&quot;price&quot;</span>,</span><br><span class="line"><span class="string">&quot;CreateTime&quot;</span>: <span class="string">&quot;create_time&quot;</span>, <span class="string">&quot;create_time&quot;</span>: <span class="string">&quot;create_time&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderOptions</span><span class="params">(target *Order, fields ...OrderField)</span> *<span class="title">OrderOptions</span></span> &#123;</span><br><span class="line">options := &amp;OrderOptions&#123;</span><br><span class="line">Order:  target,</span><br><span class="line">Fields: <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(fields)),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, field := <span class="keyword">range</span> fields &#123;</span><br><span class="line">options.Fields[index] = <span class="keyword">string</span>(field)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderOptionsAll</span><span class="params">(target *Order)</span> *<span class="title">OrderOptions</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> NewOrderOptions(target, OrderFieldAll...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderOptionsRawString</span><span class="params">(target *Order, fields ...<span class="keyword">string</span>)</span> *<span class="title">OrderOptions</span></span> &#123;</span><br><span class="line">options := &amp;OrderOptions&#123;</span><br><span class="line">Order: target,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, field := <span class="keyword">range</span> fields &#123;</span><br><span class="line"><span class="keyword">if</span> f, ok := OrderFieldMap[field]; ok &#123;</span><br><span class="line">options.Fields = <span class="built_in">append</span>(options.Fields, f)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dao层的代码逻辑类似，我就不重复填写了。</p><p>这里，我将代码拆分成了gormer与dao两层，主要是：</p><ul><li>internal/gormer整个目录是不可变的、只能自动生成，对应基础的数据库表结构</li><li>internal/dao层会添加其余的文件，如定制化的sql。</li></ul><p>至此，再将引用的相关代码简单修改，就实现了这一整块功能.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章重点介绍了Go Template在高度重复的代码模块中的应用，结合数据库实现了一个高度自动化的工具gormer。</p><p>gormer目前实现的功能比较单一，但只要有了初步自动化的思路，我们可以在后续迭代中慢慢优化，让它适应更多的场景。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;CRUD是贯穿整个程序员日常开发的基本工作，占据了我们绝大多数的coding时间。&lt;/p&gt;
&lt;p&gt;作为一名程序员，我们总是希望能有更简单的开发方式来解决重复性的工作问题。在这个小版本中，我将结合自己的工作，来给出一套自动生成代码的完整方案，供大家借鉴。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 6.用Google风格的API接口打通MySQL操作</title>
    <link href="http://example.com/2021/09/19/go-framework/go-framework-6/"/>
    <id>http://example.com/2021/09/19/go-framework/go-framework-6/</id>
    <published>2021-09-19T04:00:00.000Z</published>
    <updated>2021-09-26T02:52:38.499Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>随着RPC与MySQL的打通，整个框架已经开始打通了数据的出入口。</p><p>接下来，我们就尝试着实现通过RPC请求操作MySQL数据库，打通整个链路，真正地让这个平台实现可用。</p><span id="more"></span><h2 id="v0-5-0：用Google风格的API接口打通MySQL操作"><a href="#v0-5-0：用Google风格的API接口打通MySQL操作" class="headerlink" title="v0.5.0：用Google风格的API接口打通MySQL操作"></a>v0.5.0：用Google风格的API接口打通MySQL操作</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.5.0">https://github.com/Junedayday/micro_web_service/tree/v0.5.0</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>从API出发，实现一个数据库表的增删改查。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>Google风格的API定义</li><li>model与dao的定义</li><li>service层的实现</li></ol><blockquote><p>注意，最近buf工具进行了一次不兼容的升级，从v1beta升级到了v1，可通过如下链接下载 <a href="https://github.com/bufbuild/buf/releases">https://github.com/bufbuild/buf/releases</a></p></blockquote><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务</span><br><span class="line">         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">    |-- order                            新增：对应idl/order服务</span><br><span class="line">         |-- order.pb.go                       新增：order.proto的基础结构</span><br><span class="line">         |-- order.pb.gw.go                    新增：order.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- order_grpc.pb.go                  新增：order.proto的gRPC接口代码</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义</span><br><span class="line">      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">   |-- order                           新增：业务order定义</span><br><span class="line">      |-- order.proto                      新增：protobuffer的原始定义</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹</span><br><span class="line">      |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层</span><br><span class="line">      |-- order.go                         更新：Order对象，订单表，实现model层的OrderRepository</span><br><span class="line">      |-- order_test.go                    Order的单元测试</span><br><span class="line">   |-- model                           新增：model层，定义对象的接口方法</span><br><span class="line">      |-- order.go                         新增：OrderRepository接口，具体实现在dao层</span><br><span class="line">   |-- mysql                           MySQL连接</span><br><span class="line">      |-- init.go                          初始化连接到MySQL的工作</span><br><span class="line">   |-- server                          服务器的实现</span><br><span class="line">      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">   |-- service                         新增：service层，作为领域实现的核心部分</span><br><span class="line">      |-- order.go                         新增：Order相关的服务，目前仅简单的CRUD</span><br><span class="line">     |-- zlog                            封装日志的文件夹</span><br><span class="line">        |-- zap.go                           zap封装的代码实现</span><br><span class="line">|-- buf.gen.yaml                   更新：buf生成代码的定义，从v1beta升到v1</span><br><span class="line">|-- buf.yaml                       更新：buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-Google风格的API定义"><a href="#1-Google风格的API定义" class="headerlink" title="1.Google风格的API定义"></a>1.Google风格的API定义</h2><p>由于整体的定义比较多，这里就以</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">CreateOrderRequest</span> </span>&#123;</span><br><span class="line">  Order order = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UpdateOrderRequest</span> </span>&#123;</span><br><span class="line">  Order order = <span class="number">1</span>;</span><br><span class="line">  google.protobuf.FieldMask update_mask = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">GetOrderRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order服务</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ListOrders(ListOrdersRequest) <span class="keyword">returns</span> (ListOrdersResponse) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      get: <span class="string">&quot;/v1/orders&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里body中的order表示HTTP的body里的数据填充到CreateOrderRequest结构中的order对象</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> CreateOrder(CreateOrderRequest) <span class="keyword">returns</span> (Order) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      post: <span class="string">&quot;/v1/orders&quot;</span></span><br><span class="line">      body: <span class="string">&quot;order&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> UpdateOrder(UpdateOrderRequest) <span class="keyword">returns</span> (google.protobuf.Empty) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      patch: <span class="string">&quot;/v1/orders&quot;</span></span><br><span class="line">      body: <span class="string">&quot;*&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里&#123;name=*&#125;表示这个字段填充到GetOrderRequest里的name字段</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetOrder(GetOrderRequest) <span class="keyword">returns</span> (Order) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      get: <span class="string">&quot;/v1/orders/&#123;name=*&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> DeleteBook(DeleteBookRequest) <span class="keyword">returns</span> (google.protobuf.Empty) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      delete: <span class="string">&quot;/v1/books&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们重点关注以下几个方法：</p><ol><li>List - 查询列表，对应HTTP的GET方法</li><li>Get - 查询单个对象，对应HTTP的GET方法</li><li>Create - 创建对象，对应HTTP的POST方法</li><li>Update - 更新对象，对应HTTP的PATCH方法</li><li>Delete - 删除对象，对应HTTP的DELETE方法（本次暂未实现，后续添加软删除时加上）</li></ol><blockquote><p>关于Google定义的标准方法细节，可以参考<a href="https://cloud.google.com/apis/design/standard_methods">Google Cloud API链接</a>，了解对资源、字段等命名的逻辑。</p><p>而对于gRPC-Gateway中对于proto3的语法，可以参考<a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/mapping/patch_feature/">gRPC-Gateway链接</a>。</p><p>以上两块内容比较多，建议边实践边学习，不要一开始就钻细节。</p></blockquote><h2 id="2-model与dao的定义"><a href="#2-model与dao的定义" class="headerlink" title="2.model与dao的定义"></a>2.model与dao的定义</h2><p>为了将模型的定义与数据库的实现分离，我将两者进行了拆分，分别放置在model与dao目录下，定位的简单介绍如下：</p><ul><li>model，数据模型的定义，更关注对业务层的数据格式统一，底层可以对应各种存储形式，如mysql、redis</li><li>dao，真实数据存储的操作，也就是model层的实现，目前实现了一种mysql的操作</li></ul><h3 id="Model层"><a href="#Model层" class="headerlink" title="Model层"></a>Model层</h3><p>重点是统一的数据结构定义<code>Order</code>，以及关键接口<code>OrderRepository</code>的定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Order针对的是 orders 表中的一行数据</span></span><br><span class="line"><span class="comment">// 在这里定义，是为了分离Model与Dao</span></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">Id    <span class="keyword">int64</span></span><br><span class="line">Name  <span class="keyword">string</span></span><br><span class="line">Price <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderFields 作为一个 数据库Order对象+fields字段的组合</span></span><br><span class="line"><span class="comment">// fields用来指定Order中的哪些字段生效</span></span><br><span class="line"><span class="keyword">type</span> OrderFields <span class="keyword">struct</span> &#123;</span><br><span class="line">Order  *Order</span><br><span class="line">Fields []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderRepository <span class="keyword">interface</span> &#123;</span><br><span class="line">AddOrder(order *Order) (err error)</span><br><span class="line">QueryOrders(pageNumber, pageSize <span class="keyword">int</span>, condition *OrderFields) (orders []Order, err error)</span><br><span class="line">UpdateOrder(updated, condition *OrderFields) (err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h3><p>Dao层代码基本与之前一致，重点关注结构体<code>OrderRepo</code>，它是Model层<code>OrderRepository</code>的一种MySQL实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OrderRepo <span class="keyword">struct</span> &#123;</span><br><span class="line">db *gorm.DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将gorm.DB作为一个参数，在初始化时赋值：方便测试时，放一个mock的db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderRepo</span><span class="params">(db *gorm.DB)</span> *<span class="title">OrderRepo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;OrderRepo&#123;db: db&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-service层的实现"><a href="#3-service层的实现" class="headerlink" title="3.service层的实现"></a>3.service层的实现</h2><p>service是核心业务实现，但目前的示例代码比较简单，基本就是透传CRUD。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Service的实现，注意orderRepo的定义是model层的interface</span></span><br><span class="line"><span class="keyword">type</span> OrderService <span class="keyword">struct</span> &#123;</span><br><span class="line">orderRepo model.OrderRepository</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象，注意orderRepo的实现为dao层代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderService</span><span class="params">()</span> *<span class="title">OrderService</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;OrderService&#123;</span><br><span class="line">orderRepo: dao.NewOrderRepo(mysql.GormDB),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以List为例，透传查询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(orderSvc *OrderService)</span> <span class="title">List</span><span class="params">(ctx context.Context, pageNumber, pageSize <span class="keyword">int</span>, condition *model.OrderFields)</span> <span class="params">([]model.Order, error)</span></span> &#123;</span><br><span class="line">orders, err := orderSvc.orderRepo.QueryOrders(pageNumber, pageSize, condition)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;OrderService List pageNumber %d pageSize %d&quot;</span>, pageNumber, pageSize)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> orders, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-模拟HTTP接口访问"><a href="#4-模拟HTTP接口访问" class="headerlink" title="4.模拟HTTP接口访问"></a>4.模拟HTTP接口访问</h2><p>本服务支持gRPC和HTTP访问，但由于gRPC不方便用工具模拟，我们这里就以HTTP对本服务进行访问</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List</span></span><br><span class="line">curl --request GET <span class="string">&#x27;http://127.0.0.1:8081/v1/orders&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create</span></span><br><span class="line">curl --request POST <span class="string">&#x27;http://127.0.0.1:8081/v1/orders&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">--data-raw <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;order1&quot;,</span></span><br><span class="line"><span class="string">    &quot;price&quot;: 100.3</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update 这里 order 表示数据，update_mask表示更新的字段是price</span></span><br><span class="line">curl --request PATCH <span class="string">&#x27;http://127.0.0.1:8081/v1/orders&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">--data-raw <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;order&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;id&quot;: &quot;1&quot;,</span></span><br><span class="line"><span class="string">        &quot;name&quot;: &quot;order1&quot;,</span></span><br><span class="line"><span class="string">        &quot;price&quot;: 110.9</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;update_mask&quot;: &quot;price&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 查询name=order1的对象</span></span><br><span class="line">curl --request GET <span class="string">&#x27;http://127.0.0.1:8081/v1/orders/order1&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="关于Google风格的API总结"><a href="#关于Google风格的API总结" class="headerlink" title="关于Google风格的API总结"></a>关于Google风格的API总结</h2><p>Google风格的API和目前的主流RESTful标准的API有很多相似点、也存在一定的区别。</p><p>我们没有必要去抠API风格的细节实现、一定要与Google风格完全一致。API接口是一个通用协议，不同团队有自己的理解，就像RESTful标准的细节实现都有差异。</p><p>作为对外协议，最重要的是可读性，每个人都可以根据实际项目情况，对接口风格做一些适配性调整。这里介绍Google风格，主要是为了扩展大家的视野、拥有更多的技术实现方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这个版本，我们打通了API接口到MySQL数据库操作的全流程，是对整个框架的一次初步整合。接下来，我们会对这一流程进行精雕细琢，使其更具通用性和易用性。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着RPC与MySQL的打通，整个框架已经开始打通了数据的出入口。&lt;/p&gt;
&lt;p&gt;接下来，我们就尝试着实现通过RPC请求操作MySQL数据库，打通整个链路，真正地让这个平台实现可用。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 7.【GORM实战剖析】基本用法和原理解析</title>
    <link href="http://example.com/2021/09/15/go-tip/go-tip-7/"/>
    <id>http://example.com/2021/09/15/go-tip/go-tip-7/</id>
    <published>2021-09-15T04:00:00.000Z</published>
    <updated>2021-09-16T03:02:44.448Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg" alt="Go-Study"></p><h2 id="GORM库的官方文档"><a href="#GORM库的官方文档" class="headerlink" title="GORM库的官方文档"></a>GORM库的官方文档</h2><p>GORM库作为Go语言最受欢迎的ORM框架，提供了非常丰富的功能，大家可以通过阅读<a href="https://gorm.io/zh_CN/docs/index.html">中文官网</a>了解详情。</p><p>这里，先着重介绍一个背景：<strong>GORM内部会区分v1与v2两个版本</strong>，其中</p><ul><li>v1的包导入路径为 <code>github.com/jinzhu/gorm</code></li><li>v2的包导入路径为 <code>gorm.io/gorm</code></li></ul><p>v1与v2对使用者来说体验相差不大，今天就主要针对v2版本进行讲解。</p><span id="more"></span><h2 id="Talk-is-Cheap-Show-me-the-code"><a href="#Talk-is-Cheap-Show-me-the-code" class="headerlink" title="Talk is Cheap. Show me the code."></a>Talk is Cheap. Show me the code.</h2><p>接下来，我先给出一套个人比较推荐的CRUD代码。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><a href="https://gorm.io/zh_CN/docs/create.html">官方链接 - 创建</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;</span><br><span class="line"><span class="comment">// 直接创建</span></span><br><span class="line">result := db.Create(&amp;user)</span><br><span class="line"><span class="comment">// 指定字段创建</span></span><br><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量创建</span></span><br><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu3&quot;</span>&#125;&#125;</span><br><span class="line">db.Create(&amp;users)</span><br></pre></td></tr></table></figure><p>推荐：</p><ol><li>通常：直接用<strong>结构体</strong>或<strong>结构体的切片</strong>进行创建；</li><li>特殊：加上指定的字段，也就是其余字段不生效，如上面的<code>Birthday</code>。</li></ol><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><a href="https://gorm.io/zh_CN/docs/query.html">官方链接 - 查询</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有对象</span></span><br><span class="line"><span class="keyword">var</span> users []User  </span><br><span class="line">result := db.Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定查询条件（where）</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制返回数量</span></span><br><span class="line">db.Limit(<span class="number">10</span>).Offset(<span class="number">5</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询部分字段（即从select * 改造为 select name, age）</span></span><br><span class="line">db.Select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其余扩展</span></span><br><span class="line">db.Order(<span class="string">&quot;age desc, name&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure><p>推荐：</p><ol><li>普通场景：简单查询用<code>Find+Where</code>的函数结合实现，结合<code>Limit+Offset+Order</code>实现分页等高频功能；</li><li>追求性能：可以引入<code>Select</code>避免查询所有字段，但会导致返回结果部分字段不存在的奇怪现象，需要权衡；</li><li>复杂查询：例如<code>Join+子查询</code>等，推荐使用下面的原生SQL，用GORM拼接的体验并不好。</li></ol><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><a href="https://gorm.io/zh_CN/docs/update.html">官方链接 - 更新</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新通常包含两块，一个是要更新的字段Select+Updates，另一个是被更新数据的条件Where</span></span><br><span class="line">db.Model(&amp;user).Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;new_name&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>零值问题：参考<a href="https://gorm.io/zh_CN/docs/update.html#%E6%9B%B4%E6%96%B0%E5%A4%9A%E5%88%97">https://gorm.io/zh_CN/docs/update.html#%E6%9B%B4%E6%96%B0%E5%A4%9A%E5%88%97</a> 下的注释</p></blockquote><p>推荐：</p><ol><li>普通场景：利用<code>Select+Updates</code>指定更新字段，利用<code>Where</code>指定更新条件；</li><li>特殊场景：复杂SQL用原生SQL。</li></ol><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><a href="https://gorm.io/zh_CN/docs/delete.html">官方链接 - 删除</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除条件不建议太复杂，所以可以用简单的Where条件来拼接</span></span><br><span class="line">db.Where(<span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>).Delete(Email&#123;&#125;)</span><br></pre></td></tr></table></figure><p>推荐：</p><ol><li>普通场景：利用<code>Where</code>限定删除条件，不建议太复杂；</li><li>软删除：在实际项目中，不太建议用<code>硬删除</code>的方式，而是用<code>软删除</code>，即更新一个标记字段。</li></ol><h3 id="原生SQL"><a href="#原生SQL" class="headerlink" title="原生SQL"></a>原生SQL</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生SQL，推荐在复杂sql场景下使用</span></span><br><span class="line">db.Raw(<span class="string">&quot;SELECT id, name, age FROM users WHERE name = ?&quot;</span>, <span class="number">3</span>).Scan(&amp;result)</span><br></pre></td></tr></table></figure><h2 id="使用GORM的核心思路梳理"><a href="#使用GORM的核心思路梳理" class="headerlink" title="使用GORM的核心思路梳理"></a>使用GORM的核心思路梳理</h2><h3 id="一个对象-一行数据"><a href="#一个对象-一行数据" class="headerlink" title="一个对象 = 一行数据"></a>一个对象 = 一行数据</h3><p>示例中的一个<code>User</code>对象，完整地对应到具体<code>users</code>表中的一行数据，让整个框架更加清晰明了。每当数据库增加了一列，就对应地在结构体中加一个字段。这里有两个注意点：</p><ol><li>不要在核心结构体<code>User</code>中加入非表中的数据，如一些计算的中间值，引起二义性；</li><li><a href="https://gorm.io/zh_CN/docs/models.html#gorm-Model">gorm.Model</a>可以提升编码效率（会减少重复编码），但会限制数据库表中字段的定义，慎用（个人更希望它能开放成一个接口）；</li></ol><h3 id="选择生效字段-核心结构体-字段数组"><a href="#选择生效字段-核心结构体-字段数组" class="headerlink" title="选择生效字段 = 核心结构体 + 字段数组"></a>选择生效字段 = 核心结构体 + 字段数组</h3><p>在 <strong>查询</strong> 和 <strong>更新</strong> 接口里，我推荐的使用方法是采用核心结构体<code>User</code>+一个fields的数组，前者保存具体的数据、也实现了结构体复用，后者则选择生效的字段。</p><p>这种风格代码和Google推荐的<a href="https://cloud.google.com/apis/design/standard_methods#update">API风格</a>非常像，可读性很棒。</p><blockquote><p>这里还遗留了一个问题，就是fields数组里的字符串必须手输，可以考虑结合go generate自动生成这些fields的字符串常量，减少出错的概率。</p></blockquote><h3 id="缩短链式调用"><a href="#缩短链式调用" class="headerlink" title="缩短链式调用"></a>缩短链式调用</h3><p>GORM的主要风格是<a href="https://gorm.io/zh_CN/docs/method_chaining.html">链式调用</a>，类似于Builder设计模式、串联堆起一个SQL语句。这种调用方式扩展性很强，但会带来了一个很严重的问题：容易写出一个超长的链式调用，可维护成本大幅度提高。</p><p>所以，在我的推荐使用方式里，区分了两种场景：</p><ol><li>简单场景 - <strong>核心结构体 + 字段数组</strong></li><li>复杂场景 - <strong>原生SQL</strong></li></ol><h3 id="聚焦微服务的场景"><a href="#聚焦微服务的场景" class="headerlink" title="聚焦微服务的场景"></a>聚焦微服务的场景</h3><p>作为一个<code>ORM</code>工具，GORM要考虑兼容各种SQL语句，内部非常庞大的。但如今更多地是考虑微服务的场景，这就能抛开大量的历史包袱，实现得更加简洁。这里我简单列举三个不太推荐使用的SQL特性：</p><ol><li>减少group by - 考虑将聚合字段再单独放在一个表中</li><li>抛弃join - 多表关联采用多次查询（先查A表，然后用In语句去B表查）、或做一定的字段冗余（即同时放在A、B两个表里）</li><li>抛弃子查询，将相关逻辑放在代码里</li></ol><p>当然，真实业务研发过程中无法完全避免复杂SQL，我们只能有意识地减少引入复杂度。</p><h3 id="避免引入非原生MySQL的特性"><a href="#避免引入非原生MySQL的特性" class="headerlink" title="避免引入非原生MySQL的特性"></a>避免引入非原生MySQL的特性</h3><p>GORM除了常规的SQL功能，还提供了一些<a href="https://gorm.io/zh_CN/docs/models.html#%E9%AB%98%E7%BA%A7%E9%80%89%E9%A1%B9">高级特性</a>、<a href="https://gorm.io/zh_CN/docs/belongs_to.html">模型关联</a>、<a href="https://gorm.io/zh_CN/docs/hooks.html">钩子</a>等，非常炫酷。</p><p>但我不推荐大家在实际项目中使用这些特性。只有尽可能地保证这个框架简洁，才能保证代码后续的可维护性。</p><p>熟悉MySQL历史的朋友都知道，<strong>存储过程</strong>在以前相当一段时间都是很好的工具，但如今都倡导<strong>去存储过程</strong>。GORM的这些特性和存储过程有异曲同工之处：一个将业务逻辑放在了数据库，另一个则放到了ORM框架里，会导致后续的迁移成本变高。</p><blockquote><p>这也是我不推荐使用 gorm.Model的重要原因。</p></blockquote><h2 id="从查询接口了解GORM的核心实现"><a href="#从查询接口了解GORM的核心实现" class="headerlink" title="从查询接口了解GORM的核心实现"></a>从查询接口了解GORM的核心实现</h2><h3 id="两个核心文件"><a href="#两个核心文件" class="headerlink" title="两个核心文件"></a>两个核心文件</h3><p>在GORM库中，有两个核心的文件，也是我们调用频率最高的函数所在：<strong>chainable_api.go</strong>和 <strong>finisher_api.go</strong>。顾名思义，前者是整个链式调用的中间部分，后者则是最终获取结果的函数。以查询为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure><p>其中<code>Where</code>是chainable，也就是还在拼接SQL条件，<code>Find</code>则是触发真正查询的finisher。</p><p>如果一开始过于关注chainable调用，很容易陷入构造SQL的细节，所以这块代码建议从finisher入手，深入看看一个SQL的到底是怎么在GORM中拼接并执行的。</p><h3 id="Find的调用链路"><a href="#Find的调用链路" class="headerlink" title="Find的调用链路"></a>Find的调用链路</h3><h4 id="1-Find的主要代码"><a href="#1-Find的主要代码" class="headerlink" title="1. Find的主要代码"></a>1. Find的主要代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Find</span><span class="params">(dest <span class="keyword">interface</span>&#123;&#125;, conds ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(tx *DB)</span></span> &#123;</span><br><span class="line">tx = db.getInstance()</span><br><span class="line">  <span class="comment">// conds是查询的条件，这里忽略，我们默认已经在前面的Chainable中完成了所有参数的拼接</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(conds) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> exprs := tx.Statement.BuildCondition(conds[<span class="number">0</span>], conds[<span class="number">1</span>:]...); <span class="built_in">len</span>(exprs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">tx.Statement.AddClause(clause.Where&#123;Exprs: exprs&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tx.Statement.Dest = dest</span><br><span class="line">  <span class="comment">// 关键的执行逻辑</span></span><br><span class="line"><span class="keyword">return</span> tx.callbacks.Query().Execute(tx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-tx-callbacks-Query-的实现"><a href="#2-tx-callbacks-Query-的实现" class="headerlink" title="2. tx.callbacks.Query()的实现"></a>2. tx.callbacks.Query()的实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *callbacks)</span> <span class="title">Query</span><span class="params">()</span> *<span class="title">processor</span></span> &#123;</span><br><span class="line">  <span class="comment">// Query 是从processors的 map 中取出 query</span></span><br><span class="line"><span class="keyword">return</span> cs.processors[<span class="string">&quot;query&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个对应的processor是 gorm.DB，也就是执行DB的Execute</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initializeCallbacks</span><span class="params">(db *DB)</span> *<span class="title">callbacks</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;callbacks&#123;</span><br><span class="line">processors: <span class="keyword">map</span>[<span class="keyword">string</span>]*processor&#123;</span><br><span class="line"><span class="string">&quot;create&quot;</span>: &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;query&quot;</span>:  &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;update&quot;</span>: &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;delete&quot;</span>: &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;row&quot;</span>:    &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;raw&quot;</span>:    &#123;db: db&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Execute的执行逻辑"><a href="#3-Execute的执行逻辑" class="headerlink" title="3. Execute的执行逻辑"></a>3. Execute的执行逻辑</h4><p>抛开一些周边逻辑，我们聚焦于下面的核心逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processor)</span> <span class="title">Execute</span><span class="params">(db *DB)</span> *<span class="title">DB</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// processor中注册了多个函数，按顺序执行。</span></span><br><span class="line">  <span class="comment">// 核心的查询逻辑也在这里面</span></span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> p.fns &#123;</span><br><span class="line">f(db)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而fns又是来自callbacks</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processor)</span> <span class="title">compile</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 对 callbacks 会做排序</span></span><br><span class="line"><span class="keyword">if</span> p.fns, err = sortCallbacks(p.callbacks); err != <span class="literal">nil</span> &#123;</span><br><span class="line">p.db.Logger.Error(context.Background(), <span class="string">&quot;Got error when compile callbacks, got %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Callback的注册"><a href="#4-Callback的注册" class="headerlink" title="4. Callback的注册"></a>4. Callback的注册</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterDefaultCallbacks</span><span class="params">(db *gorm.DB, config *Config)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 默认注册了create/query/delete/update/raw 五种 callback 大类，这里以query为例</span></span><br><span class="line">queryCallback := db.Callback().Query()</span><br><span class="line">queryCallback.Register(<span class="string">&quot;gorm:query&quot;</span>, Query)</span><br><span class="line">queryCallback.Register(<span class="string">&quot;gorm:preload&quot;</span>, Preload)</span><br><span class="line">queryCallback.Register(<span class="string">&quot;gorm:after_query&quot;</span>, AfterQuery)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(config.QueryClauses) == <span class="number">0</span> &#123;</span><br><span class="line">config.QueryClauses = queryClauses</span><br><span class="line">&#125;</span><br><span class="line">queryCallback.Clauses = config.QueryClauses</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-Query函数的实现"><a href="#5-Query函数的实现" class="headerlink" title="5. Query函数的实现"></a>5. Query函数的实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Query</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> db.Error == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 构建查询的 SQL 语句</span></span><br><span class="line">BuildQuerySQL(db)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询数据</span></span><br><span class="line"><span class="keyword">if</span> !db.DryRun &amp;&amp; db.Error == <span class="literal">nil</span> &#123;</span><br><span class="line">rows, err := db.Statement.ConnPool.QueryContext(db.Statement.Context, db.Statement.SQL.String(), db.Statement.Vars...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">db.AddError(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将结果输出到目标结构体中</span></span><br><span class="line">gorm.Scan(rows, db, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-核心-构建SQL的实现"><a href="#6-核心-构建SQL的实现" class="headerlink" title="6.核心-构建SQL的实现"></a>6.核心-构建SQL的实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildQuerySQL</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line">  <span class="comment">// SQL为空，表示需要自己构建</span></span><br><span class="line"><span class="keyword">if</span> db.Statement.SQL.String() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">db.Statement.SQL.Grow(<span class="number">100</span>) <span class="comment">// 分配初始空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(db.Statement.Selects) &gt; <span class="number">0</span> &#123; </span><br><span class="line">      <span class="comment">// 表示只select某几个字段，而不是select *</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> db.Statement.Schema != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(db.Statement.Omits) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// Omit表示忽略特定字段</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> db.Statement.Schema != <span class="literal">nil</span> &amp;&amp; db.Statement.ReflectValue.IsValid() &#123;</span><br><span class="line">      <span class="comment">// 查询到指定结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对join的处理，涉及到多表关联，暂时忽略</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(db.Statement.Joins) != <span class="number">0</span> &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">db.Statement.AddClauseIfNotExists(clause.From&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用一个map去重，符合名字中的 IfNotExists 含义</span></span><br><span class="line">db.Statement.AddClauseIfNotExists(clauseSelect)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后拼接出完整 SQL 的地方</span></span><br><span class="line">db.Statement.Build(db.Statement.BuildClauses...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文旨在介绍GORM的推荐使用方式，并简单阅读对接数据库的相关代码。这里分享我的四个观点：</p><ol><li><strong>Builder设计模式</strong> - 在面对复杂场景中，Builder设计模式扩展性很好，可分为两个阶段：存储数据+处理数据；GORM的调用就是采用了chainable+finisher的两段实现，前者保存SQL相关元数据，后者拼接SQL并执行；</li><li><strong>负重前行</strong> - GORM是一个负重前行的框架：它不仅支持了所有原生SQL的特性，也增加了很多类似Hook的高级特性，导致这个框架非常庞大。如果团队没有历史包袱，更推荐<strong>节制</strong>地使用GORM特性，适当封装一层；</li><li><strong>interface{}问题</strong> - GORM中许多函数入参的数据类型都是<code>interface&#123;&#125;</code>，底层又用reflect支持了多种类型，这种实现会导致两个问题：<ol><li>reflect导致的底层的性能不高（这点还能接受）</li><li>interface{}如果传入了不支持的复杂数据类型时，排查问题麻烦，往往要运行程序时才会报错</li></ol></li><li><strong>高频拼接重复SQL</strong> - 在一个程序运行过程中，执行的SQL语句都比较固定，而变化的往往是参数；从GORM的实现来看，每次执行都需要重新拼接一次SQL语句，是有不小的优化空间的，比如引入一定的cache。</li></ol><p>希望这四点能对大家的日常工作有所启发~</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;GORM库的官方文档&quot;&gt;&lt;a href=&quot;#GORM库的官方文档&quot; class=&quot;headerlink&quot; title=&quot;GORM库的官方文档&quot;&gt;&lt;/a&gt;GORM库的官方文档&lt;/h2&gt;&lt;p&gt;GORM库作为Go语言最受欢迎的ORM框架，提供了非常丰富的功能，大家可以通过阅读&lt;a href=&quot;https://gorm.io/zh_CN/docs/index.html&quot;&gt;中文官网&lt;/a&gt;了解详情。&lt;/p&gt;
&lt;p&gt;这里，先着重介绍一个背景：&lt;strong&gt;GORM内部会区分v1与v2两个版本&lt;/strong&gt;，其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v1的包导入路径为 &lt;code&gt;github.com/jinzhu/gorm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;v2的包导入路径为 &lt;code&gt;gorm.io/gorm&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;v1与v2对使用者来说体验相差不大，今天就主要针对v2版本进行讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 5.GORM库的适配sqlmock的单元测试</title>
    <link href="http://example.com/2021/09/05/go-framework/go-framework-5/"/>
    <id>http://example.com/2021/09/05/go-framework/go-framework-5/</id>
    <published>2021-09-05T04:00:00.000Z</published>
    <updated>2021-09-26T02:52:26.553Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>随着<code>GORM</code>库的引入，我们在数据库持久化上已经有了解决方案。但上一篇我们使用的<code>GORM</code>过于简单，应用到实际的项目中局限性很大。</p><p>与此同时，我们也缺乏一个有效的手段来验证自己编写的相关代码。如果依靠连接到真实的<code>MySQL</code>去验证功能，那成本实在太高。那么，这里我们就引入一个经典的<code>sqlmock</code>框架，并配合对数据库相关代码的修改，来实现相关代码的可测试性。</p><span id="more"></span><h2 id="v0-4-1：GORM库的适配sqlmock的单元测试"><a href="#v0-4-1：GORM库的适配sqlmock的单元测试" class="headerlink" title="v0.4.1：GORM库的适配sqlmock的单元测试"></a>v0.4.1：GORM库的适配sqlmock的单元测试</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.4.1">https://github.com/Junedayday/micro_web_service/tree/v0.4.1</a></p><blockquote><p>由于主要是针对GORM的小改动，所以增加了一个小版本号</p></blockquote><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>利用sqlmock工具，并对数据库相关代码进行修改，实现单元测试。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>Order相关代码的改造</li><li>引入sqlmock到测试代码</li><li>注意点讲解</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务</span><br><span class="line">         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义</span><br><span class="line">      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹</span><br><span class="line">      |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层</span><br><span class="line">      |-- order.go                         更新：OrderO对象，订单表</span><br><span class="line">      |-- order_test.go                    新增：Order的单元测试</span><br><span class="line">   |-- mysql                           MySQL连接</span><br><span class="line">      |-- init.go                          初始化连接到MySQL的工作</span><br><span class="line">   |-- server                          服务器的实现</span><br><span class="line">      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">     |-- zlog                            封装日志的文件夹</span><br><span class="line">        |-- zap.go                           zap封装的代码实现</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具</span><br><span class="line">|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-Order相关代码的改造"><a href="#1-Order相关代码的改造" class="headerlink" title="1.Order相关代码的改造"></a>1.Order相关代码的改造</h2><p>我们要对Order相关的代码进行改造，来满足以下两个点：</p><ol><li>可测试性，可以脱离对真实数据库连接的依赖</li><li>灵活的更新方法，可以支持对指定条件、指定字段的更新</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  gorm.io/gorm 指的是gorm V2版本，详细可参考 https://gorm.io/zh_CN/docs/v2_release_note.html</span></span><br><span class="line"><span class="comment">  github.com/jinzhu/gorm 一般指V1版本</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderRepo <span class="keyword">struct</span> &#123;</span><br><span class="line">db *gorm.DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将gorm.DB作为一个参数，在初始化时赋值：方便测试时，放一个mock的db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderRepo</span><span class="params">(db *gorm.DB)</span> *<span class="title">OrderRepo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;OrderRepo&#123;db: db&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order针对的是 orders 表中的一行数据</span></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">Id    <span class="keyword">int64</span></span><br><span class="line">Name  <span class="keyword">string</span></span><br><span class="line">Price <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderFields 作为一个 数据库Order对象+fields字段的组合</span></span><br><span class="line"><span class="comment">// fields用来指定Order中的哪些字段生效</span></span><br><span class="line"><span class="keyword">type</span> OrderFields <span class="keyword">struct</span> &#123;</span><br><span class="line">order  *Order</span><br><span class="line">fields []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderFields</span><span class="params">(order *Order, fields []<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">OrderFields</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;OrderFields&#123;</span><br><span class="line">order:  order,</span><br><span class="line">fields: fields,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">AddOrder</span><span class="params">(order *Order)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">err = repo.db.Create(order).Error</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">QueryOrders</span><span class="params">(pageNumber, pageSize <span class="keyword">int</span>, condition *OrderFields)</span> <span class="params">(orders []Order, err error)</span></span> &#123;</span><br><span class="line">db := repo.db</span><br><span class="line"><span class="comment">// condition非nil的话，追加条件</span></span><br><span class="line"><span class="keyword">if</span> condition != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 这里的field指定了order中生效的字段，这些字段会被放在SQL的where条件中</span></span><br><span class="line">db = db.Where(condition.order, condition.fields...)</span><br><span class="line">&#125;</span><br><span class="line">err = db.</span><br><span class="line">Limit(pageSize).</span><br><span class="line">Offset((pageNumber - <span class="number">1</span>) * pageSize).</span><br><span class="line">Find(&amp;orders).Error</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">UpdateOrder</span><span class="params">(updated, condition *OrderFields)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> updated == <span class="literal">nil</span> || <span class="built_in">len</span>(updated.fields) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;update must choose certain fields&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;update must include where condition&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = repo.db.</span><br><span class="line">Model(&amp;Order&#123;&#125;).</span><br><span class="line"><span class="comment">// 这里的field指定了order中被更新的字段</span></span><br><span class="line">Select(updated.fields[<span class="number">0</span>], updated.fields[<span class="number">1</span>:]...).</span><br><span class="line"><span class="comment">// 这里的field指定了被更新的where条件中的字段</span></span><br><span class="line">Where(condition.order, condition.fields...).</span><br><span class="line">Updates(updated.order).</span><br><span class="line">Error</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-引入sqlmock到测试代码"><a href="#2-引入sqlmock到测试代码" class="headerlink" title="2.引入sqlmock到测试代码"></a>2.引入sqlmock到测试代码</h2><p>sqlmock是检查数据库最常用的工具，我们先不管它使用起来的复杂性，先来看看怎么实现对应的测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，我们使用的是gorm 2.0，网上很多例子其实是针对1.0的</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">DB   *gorm.DB</span><br><span class="line">mock sqlmock.Sqlmock</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestMain是在当前package下，最先运行的一个函数，常用于初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">db  *sql.DB</span><br><span class="line">err error</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db, mock, err = sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DB, err = gorm.Open(mysql.New(mysql.Config&#123;</span><br><span class="line">Conn:                      db,</span><br><span class="line">SkipInitializeWithVersion: <span class="literal">true</span>,</span><br><span class="line">&#125;), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// m.Run 是真正调用下面各个Test函数的入口</span></span><br><span class="line">os.Exit(m.Run())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  sqlmock 对语法限制比较大，下面的sql语句必须精确匹配（包括符号和空格）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOrderRepo_AddOrder</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> order = &amp;Order&#123;Name: <span class="string">&quot;order1&quot;</span>, Price: <span class="number">1.1</span>&#125;</span><br><span class="line">orderRepo := NewOrderRepo(DB)</span><br><span class="line"></span><br><span class="line">mock.ExpectBegin()</span><br><span class="line">mock.ExpectExec(<span class="string">&quot;INSERT INTO `orders` (`name`,`price`) VALUES (?,?)&quot;</span>).</span><br><span class="line">WithArgs(order.Name, order.Price).</span><br><span class="line">WillReturnResult(sqlmock.NewResult(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">mock.ExpectCommit()</span><br><span class="line">err := orderRepo.AddOrder(order)</span><br><span class="line">assert.Nil(t, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOrderRepo_QueryOrders</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> orders = []Order&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="string">&quot;name1&quot;</span>, <span class="number">1.0</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>, <span class="string">&quot;name2&quot;</span>, <span class="number">1.0</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">page, size := <span class="number">2</span>, <span class="number">10</span></span><br><span class="line">orderRepo := NewOrderRepo(DB)</span><br><span class="line">condition := NewOrderFields(&amp;Order&#123;Price: <span class="number">1.0</span>&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;price&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">mock.ExpectQuery(</span><br><span class="line"><span class="string">&quot;SELECT * FROM `orders` WHERE `orders`.`price` = ? LIMIT 10 OFFSET 10&quot;</span>).</span><br><span class="line">WithArgs(condition.order.Price).</span><br><span class="line">WillReturnRows(</span><br><span class="line">sqlmock.NewRows([]<span class="keyword">string</span>&#123;<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;price&quot;</span>&#125;).</span><br><span class="line">AddRow(orders[<span class="number">0</span>].Id, orders[<span class="number">0</span>].Name, orders[<span class="number">0</span>].Price).</span><br><span class="line">AddRow(orders[<span class="number">1</span>].Id, orders[<span class="number">1</span>].Name, orders[<span class="number">1</span>].Price))</span><br><span class="line"></span><br><span class="line">ret, err := orderRepo.QueryOrders(page, size, condition)</span><br><span class="line">assert.Nil(t, err)</span><br><span class="line">assert.Equal(t, orders, ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOrderRepo_UpdateOrder</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">orderRepo := NewOrderRepo(DB)</span><br><span class="line"><span class="comment">// 表示要更新的字段为Order对象中的id,name两个字段</span></span><br><span class="line">updated := NewOrderFields(&amp;Order&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;test_name&quot;</span>&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// 表示更新的条件为Order对象中的price字段</span></span><br><span class="line">condition := NewOrderFields(&amp;Order&#123;Price: <span class="number">1.0</span>&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;price&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">mock.ExpectBegin()</span><br><span class="line">mock.ExpectExec(</span><br><span class="line"><span class="string">&quot;UPDATE `orders` SET `id`=?,`name`=? WHERE `orders`.`price` = ?&quot;</span>).</span><br><span class="line">WithArgs(updated.order.Id, updated.order.Name, condition.order.Price).</span><br><span class="line">WillReturnResult(sqlmock.NewResult(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">mock.ExpectCommit()</span><br><span class="line"></span><br><span class="line">err := orderRepo.UpdateOrder(updated, condition)</span><br><span class="line">assert.Nil(t, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-注意点讲解"><a href="#3-注意点讲解" class="headerlink" title="3.注意点讲解"></a>3.注意点讲解</h2><p>虽然添加了注释，我这边依旧讲一下修改的重点：</p><ol><li><code>gorm.DB</code>作为一个初始化的参数，将其转变成一个依赖注入，使这块代码更具可测试性</li><li>查询和更新采用了一个新的结构体<code>OrderFields</code>，是用里面的<code>fields</code>声明了<code>order</code>中哪个字段生效</li></ol><h2 id="GORM框架的进一步扩展"><a href="#GORM框架的进一步扩展" class="headerlink" title="GORM框架的进一步扩展"></a>GORM框架的进一步扩展</h2><p>通过这一次对GORM数据库相关代码的迭代，还是可以发现有些不足：</p><ol><li>对复杂SQL的支持不足：如group by、子查询等语句</li><li>对field这块限制不好，<code>id</code>, <code>name</code>， <code>price</code>，容易发生误填字段的问题</li><li>没有串联日志模块</li></ol><p>接下来的模块，我会逐渐对2、3两点进行补充，而第1点需要有选择性地实现，我也会结合具体的场景进行分享。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这一个小版本，我们让<code>DAO</code>这个与数据库交互模块的代码更具可读性（从调用侧可以清楚地了解到要做什么）、健壮性（单元测试）和可扩展性（对后续字段的扩展也很容易支持）。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着&lt;code&gt;GORM&lt;/code&gt;库的引入，我们在数据库持久化上已经有了解决方案。但上一篇我们使用的&lt;code&gt;GORM&lt;/code&gt;过于简单，应用到实际的项目中局限性很大。&lt;/p&gt;
&lt;p&gt;与此同时，我们也缺乏一个有效的手段来验证自己编写的相关代码。如果依靠连接到真实的&lt;code&gt;MySQL&lt;/code&gt;去验证功能，那成本实在太高。那么，这里我们就引入一个经典的&lt;code&gt;sqlmock&lt;/code&gt;框架，并配合对数据库相关代码的修改，来实现相关代码的可测试性。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 4.初识GORM库</title>
    <link href="http://example.com/2021/08/29/go-framework/go-framework-4/"/>
    <id>http://example.com/2021/08/29/go-framework/go-framework-4/</id>
    <published>2021-08-29T04:00:00.000Z</published>
    <updated>2021-09-26T02:52:13.703Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>数据持久化是服务的必要特性，最常见的组件就是关系型数据库<code>MySQL</code>。而在<code>Go</code>语言里，<code>GORM</code>已经成了对接<code>MySQL</code>事实上的标准，那么也就不去横向对比其它库了。</p><p><code>GORM</code>库是一个很强大、但同时也是一个非常复杂的工具。为了支持复杂的<code>SQL</code>语言，它比之前的配置文件加载工具<code>github.com/spf13/viper</code>要复杂不少。今天，我们不会全量地引入<code>GORM</code>里的所有特性，而是从一个最简单的场景入手，对它的基本特性有所了解。而后续随着框架的完善，我们会逐渐细化功能。</p><span id="more"></span><h2 id="v0-4-0：引入GORM库"><a href="#v0-4-0：引入GORM库" class="headerlink" title="v0.4.0：引入GORM库"></a>v0.4.0：引入GORM库</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.4.0">https://github.com/Junedayday/micro_web_service/tree/v0.4.0</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>利用GORM实现简单的增删改查功能。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>MySQL工具库的必要功能</li><li>GORM官方示例分析</li><li>使用GORM的思考</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务</span><br><span class="line">         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义</span><br><span class="line">      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹</span><br><span class="line">      |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">   |-- dao                             新增：Data Access Object层</span><br><span class="line">      |-- order.go                         新增：示例的一个Order对象，订单表</span><br><span class="line">   |-- mysql                           新增：MySQL连接</span><br><span class="line">      |-- init.go                          新增：初始化连接到MySQL的工作</span><br><span class="line">   |-- server                          服务器的实现</span><br><span class="line">      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">     |-- zlog                            封装日志的文件夹</span><br><span class="line">        |-- zap.go                           zap封装的代码实现</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具</span><br><span class="line">|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-MySQL工具库的必要功能"><a href="#1-MySQL工具库的必要功能" class="headerlink" title="1.MySQL工具库的必要功能"></a>1.MySQL工具库的必要功能</h2><p>对于<code>MySQL</code>数据库来说，我们对它的日常操作其实就关注在CRUD上（也就是增删改查）。</p><p>除此以外，还有一些是我们需要关注的点：</p><ul><li><strong>便捷性</strong>：能快速、方便地实现实现功能，而不用写大量重复性的<code>SQL</code></li><li><strong>透明性</strong>：ORM经过层层封装，最终与MySQL交互的<code>SQL</code>语句可供排查问题</li><li><strong>扩展性</strong>：支持原生的<code>SQL</code>，在复杂场景下的ORM框架不如原始的<code>SQL</code>好用</li></ul><p>这里，我们先聚焦于第一点，后面两块<code>GORM</code>框架是支持的。</p><h2 id="2-GORM官方示例分析"><a href="#2-GORM官方示例分析" class="headerlink" title="2.GORM官方示例分析"></a>2.GORM官方示例分析</h2><p>接下来，我们对照着官方文档，来看看有什么样的注意点。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>中文文档链接 - <a href="https://gorm.io/zh_CN/docs/create.html">https://gorm.io/zh_CN/docs/create.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐使用方式：定义一个结构体，填充字段</span></span><br><span class="line">user := User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;</span><br><span class="line">result := db.Create(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：指定要创建的字段名，也就是user中部分生效，很容易产生迷惑</span></span><br><span class="line"><span class="comment">// 更建议新建一个user结构体进行创建</span></span><br><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量创建同推荐</span></span><br><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu3&quot;</span>&#125;&#125;</span><br><span class="line">db.Create(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：钩子相关的特性，类似于数据库里的trigger，隐蔽而迷惑，不易维护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">BeforeCreate</span><span class="params">(tx *gorm.DB)</span> <span class="params">(err error)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：用Map硬编码创建记录，改动成本大</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Create(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 争议点：gorm.Model中预定了数据库中的四个字段，是否应该把它引入到模型的定义中</span></span><br><span class="line"><span class="comment">// 我个人不太喜欢将这四个字段强定义为数据库表中的字段名</span></span><br><span class="line"><span class="keyword">type</span> Model <span class="keyword">struct</span> &#123;</span><br><span class="line">ID        <span class="keyword">uint</span> <span class="string">`gorm:&quot;primarykey&quot;`</span></span><br><span class="line">CreatedAt time.Time</span><br><span class="line">UpdatedAt time.Time</span><br><span class="line">DeletedAt DeletedAt <span class="string">`gorm:&quot;index&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的一些操作可以看到，我推荐的使用方式有2个特点：</p><ol><li>尽可能简单，不要出现<strong>魔法变量</strong>，比如常量字符串</li><li><strong>不要让框架强约束表结构的设计</strong>，也是为了后续迁移框架、甚至语言时成本更低</li></ol><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>中文文档链接 - <a href="https://gorm.io/zh_CN/docs/query.html">https://gorm.io/zh_CN/docs/query.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐： 我个人不太建议使用First/Last这种和原生SQL定义不一致的语法，扩展性也不好</span></span><br><span class="line"><span class="comment">// 在这种情况下，我更建议采用Find+Order+Limit这样的组合方式，通用性也更强</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：Find支持返回多个记录，是最常用的方法，但需要结合一定的限制</span></span><br><span class="line">result := db.Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：条件查询的字段名采用hard code，体验不好</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line">db.Where(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：结合结构体的方式定义，体验会好很多</span></span><br><span class="line"><span class="comment">// 但是，上面这种方法不支持结构体中Field为默认值的情况，如0，&#x27;&#x27;，false等</span></span><br><span class="line"><span class="comment">// 所以，更推荐采用下面这种方式，虽然会带来一定的hard code，但能指定要查询的结构体名称。</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">20</span>&#125;).First(&amp;user)</span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：指定排序</span></span><br><span class="line">db.Order(<span class="string">&quot;age desc, name&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：限制查询范围，结合Find</span></span><br><span class="line">db.Limit(<span class="number">10</span>).Offset(<span class="number">5</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure><p>查询还有很多的特性，今天我们暂不细讲。其中，希望大家能重点看一下默认值问题：</p><p>我们固然可以通过在定义字段时，排除这些默认值的情况，如定义<code>int</code>类型字段时跳过0、从1开始。但在实际的项目中，定义往往很难控制，我们不得不做一定的妥协，这部分hard code的成本也是可以接受的。</p><p><strong>我们不能因为框架里的一些特性，过度地限制其余组件的使用</strong>。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>中文文档链接 - <a href="https://gorm.io/zh_CN/docs/update.html">https://gorm.io/zh_CN/docs/update.html</a></p><p>更新其实是最麻烦的事情，它包括<strong>更新的字段与条件</strong>。我们来看看几个重点的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐：单字段的更新，不常用</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：指定主键的多字段更新，但不支持默认类型</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>, Active: <span class="literal">false</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：指定主键的多字段的更新，但字段多了硬编码很麻烦</span></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：指定主键的多字段的更新，指定要更新的字段，*为全字段</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;new_name&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;*&quot;</span>).Update(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Role: <span class="string">&quot;admin&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：指定更新方式的多字段的更新</span></span><br><span class="line">db.Model(User&#123;&#125;).Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>中文文档链接 - <a href="https://gorm.io/zh_CN/docs/delete.html">https://gorm.io/zh_CN/docs/delete.html</a></p><p>删除我不太建议使用，更推荐用软删除的方式，也就是<strong>更新一个标识是否已经删除字段</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;email)</span><br></pre></td></tr></table></figure><h2 id="3-使用GORM的思考"><a href="#3-使用GORM的思考" class="headerlink" title="3.使用GORM的思考"></a>3.使用GORM的思考</h2><p><code>GORM</code>是一个非常重量级的工具，尤其是<code>*gorm.DB</code>提供了大量的类似于Builder模式的方法，用来拼接<code>SQL</code>。</p><p>整个使用过程，对于一个不熟悉<code>SQL</code>语言的同学来说是很痛苦的，需要大量调试问题的时间；而对于熟悉<code>SQL</code>的朋友也会很疑惑，例如<code>First</code>等这种自定义命名的底层实现。所以，基于<code>GORM</code>库做一个简单封装是非常必要的，能大幅度地降低用户的使用和理解的门槛，也是这个微服务框架后续的改善方向之一。</p><h2 id="对微服务框架的延伸思考"><a href="#对微服务框架的延伸思考" class="headerlink" title="对微服务框架的延伸思考"></a>对微服务框架的延伸思考</h2><p>从之前的分析可以看到，我对微服务的框架有一个很重要的要求 - <strong>透明</strong>，比如不要引入大量和原始SQL无关的特性、不要过度依赖ORM而忘记了原生SQL才是我们最重要的技能。</p><p><strong>透明</strong>也是一个框架能实现简单性的重要特质，减少使用方的理解成本，也就能提高研发效能。</p><p>从更高的层面来看整个微服务框架，我们会有更深的体会：</p><ol><li><strong>为什么Spring Boot那么成功？</strong>主要是Spring Boot的设计理念是比较符合工程化的，而JVM也提供了一套很好的运行时的机制；与此同时，社区提供了大量的Spring Boot组件供开发者调用，自然比较受欢迎。</li><li><strong>Go的微服务框架为什么没有统一？</strong>Go的运行时非常轻量级，很难巧妙地像Spring Boot完成框架层面对组件的大一统。Go语言提供的各类组件，很多都是开源社区对传统服务或云原生理念的自我实践，没有绝对的正确与错误。</li><li><strong>那如今社区上的那些微服务框架都不值一提吗？</strong>并不是。如果你仔细看这些框架，其实都是对各类Go优秀组件的拼装，只是各有各的想法。我觉得，所谓的Go微服务框架短期内很难统一，但这些组件都会趋于一致。</li><li><strong>那你做这个框架的意义是什么呢？</strong>其实我个人并不觉得本框架比现有框架好，我更关注两点：一是分享引入并迭代各个开源组件的过程，让大家更好地理解框架是怎么完善的；第二个是从工程化的角度去思考微服务框架的问题，从会用框架变得理解框架、并改造框架。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们简单地引入了<code>GORM</code>并实现了一套简单的增删改查的代码，更多地是讨论一些技术选型的思考，希望能给大家带来启发。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;数据持久化是服务的必要特性，最常见的组件就是关系型数据库&lt;code&gt;MySQL&lt;/code&gt;。而在&lt;code&gt;Go&lt;/code&gt;语言里，&lt;code&gt;GORM&lt;/code&gt;已经成了对接&lt;code&gt;MySQL&lt;/code&gt;事实上的标准，那么也就不去横向对比其它库了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GORM&lt;/code&gt;库是一个很强大、但同时也是一个非常复杂的工具。为了支持复杂的&lt;code&gt;SQL&lt;/code&gt;语言，它比之前的配置文件加载工具&lt;code&gt;github.com/spf13/viper&lt;/code&gt;要复杂不少。今天，我们不会全量地引入&lt;code&gt;GORM&lt;/code&gt;里的所有特性，而是从一个最简单的场景入手，对它的基本特性有所了解。而后续随着框架的完善，我们会逐渐细化功能。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 3.日志库的选型与引入</title>
    <link href="http://example.com/2021/08/25/go-framework/go-framework-3/"/>
    <id>http://example.com/2021/08/25/go-framework/go-framework-3/</id>
    <published>2021-08-25T04:00:00.000Z</published>
    <updated>2021-09-26T02:52:01.951Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>日志是一个框架的重要组成部分，那今天我们一起来看看这部分。</p><p>衡量日志库有多个指标，我们今天重点关注两点：<strong>简单易用</strong> 与 <strong>高性能</strong>。简单易用是一个日志库能被广泛使用的必要条件，而<strong>高性能</strong>则是企业级的日志库非常重要的衡量点，也能在源码层面对我们有一定的启发。</p><span id="more"></span><h2 id="v0-3-0：日志库的选型与引入"><a href="#v0-3-0：日志库的选型与引入" class="headerlink" title="v0.3.0：日志库的选型与引入"></a>v0.3.0：日志库的选型与引入</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.3.0">https://github.com/Junedayday/micro_web_service/tree/v0.3.0</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>选择一个开源的日志组件引入，支持常规的日志打印。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol start="3"><li>三款开源日志库的横向对比</li><li>zap日志库的关键实现</li><li>关于日志参数的解析</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务</span><br><span class="line">         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义</span><br><span class="line">      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- server                          服务器的实现</span><br><span class="line">      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">   |-- config                          配置相关的文件夹</span><br><span class="line">      |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">     |-- zlog                            新增：封装日志的文件夹</span><br><span class="line">        |-- zap.go                           新增：zap封装的代码实现</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具</span><br><span class="line">|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-三款开源日志库的横向对比"><a href="#1-三款开源日志库的横向对比" class="headerlink" title="1.三款开源日志库的横向对比"></a>1.三款开源日志库的横向对比</h2><ul><li>glog: <a href="https://github.com/golang/glog">https://github.com/golang/glog</a></li><li>logrus: <a href="https://github.com/sirupsen/logrus">https://github.com/sirupsen/logrus</a></li><li>zap: <a href="https://github.com/uber-go/zap">https://github.com/uber-go/zap</a></li></ul><p>如果用一次词语分别进行概括三者的特性，我分别会用：<strong>glog - 代码极简，logrus - 功能全面， zap - 高性能</strong>。经过反复思考，这个框架会选择zap库作为日志引擎的基本组件，主要考量如下：</p><ol><li><strong>高性能</strong> - 性能是一个日志库很重要的属性，它往往由前期的设计决定，很难通过后面的优化大幅度提高，所以zap的高性能很难被替代；</li><li><strong>方便封装</strong> - zap设计简单，容易进行二次封装（glog更简洁，相应地就需要更多的封装代码）</li><li><strong>大厂背书</strong> - zap库被很多大公司引用，作为内部的日志库的底层，再二次开发</li><li><strong>源码学习</strong> - zap库对性能追求极高，可以作为高性能Go语言代码的分析样例</li></ol><h2 id="2-zap日志库的关键实现"><a href="#2-zap日志库的关键实现" class="headerlink" title="2.zap日志库的关键实现"></a>2.zap日志库的关键实现</h2><h3 id="最简化的调用"><a href="#最简化的调用" class="headerlink" title="最简化的调用"></a>最简化的调用</h3><p>zap日志库的调用很简单，只需要两行代码就能实现初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger, _ := zap.NewProduction()</span><br><span class="line"><span class="keyword">defer</span> logger.Sync()</span><br></pre></td></tr></table></figure><p>但这样的zap代码存在两个明显弊端：</p><ul><li>默认输出到控制台上</li><li>无法保存到指定目录的文件</li></ul><h3 id="核心的日志文件实现"><a href="#核心的日志文件实现" class="headerlink" title="核心的日志文件实现"></a>核心的日志文件实现</h3><p>我们增加了一定的特性，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// Logger为zap提供的原始日志，但使用起来比较烦，有强类型约束</span></span><br><span class="line">logger *zap.Logger</span><br><span class="line"><span class="comment">// SugaredLogger为zap提供的一个通用性更好的日志组件，作为本项目的核心日志组件</span></span><br><span class="line">Sugar *zap.SugaredLogger</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(logPath <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 日志暂时只开放一个配置 - 配置文件路径，有需要可以后续开放</span></span><br><span class="line">hook := lumberjack.Logger&#123;</span><br><span class="line">Filename: logPath,</span><br><span class="line">&#125;</span><br><span class="line">w := zapcore.AddSync(&amp;hook)</span><br><span class="line"></span><br><span class="line">encoderConfig := zap.NewProductionEncoderConfig()</span><br><span class="line">encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder</span><br><span class="line"></span><br><span class="line">core := zapcore.NewCore(</span><br><span class="line">zapcore.NewConsoleEncoder(encoderConfig),</span><br><span class="line">w,</span><br><span class="line">zap.InfoLevel,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">logger = zap.New(core, zap.AddCaller())</span><br><span class="line">Sugar = logger.Sugar()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名和原生的Zap Log尽量一致，方便理解</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sync</span><span class="params">()</span></span> &#123;</span><br><span class="line">logger.Sync()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们是如何解决上面两个问题的呢？</p><ol><li>利用<code>go.uber.org/zap/zapcore</code>中的开放配置</li><li>借用了<code>github.com/natefinch/lumberjack</code>这个常用的日志切分库，也顺带实现了日志路径的支持</li></ol><h3 id="main函数的调用"><a href="#main函数的调用" class="headerlink" title="main函数的调用"></a>main函数的调用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logFilePath = flag.String(<span class="string">&quot;l&quot;</span>, <span class="string">&quot;log/service.log&quot;</span>, <span class="string">&quot;log file path&quot;</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">zlog.Init(*logFilePath)</span><br><span class="line"><span class="keyword">defer</span> zlog.Sync()</span><br></pre></td></tr></table></figure><p>至此，我们的日志功能已经基本打通。</p><h2 id="3-关于日志参数的解析"><a href="#3-关于日志参数的解析" class="headerlink" title="3.关于日志参数的解析"></a>3.关于日志参数的解析</h2><p>日志参数常见的方式分2种，一个是来自<code>flag</code>的解析，另一个是来自配置文件。</p><p>随着我们功能的拓展，日志库肯定会支持越来越复杂的场景。那这个时候用<code>flag</code>解析的扩展性就会很差，所以，我更推荐在微服务的框架中，<strong>用配置文件的方式去加载日志的相关配置</strong>。但这种方式会带来一个常见的现象：</p><p>程序代码的实现为：先加载配置文件，后加载日志，导致配置文件出错时，无法通过日志来排查，需要用控制台或者进程管理工具协助定位问题。</p><p>后续，随着框架的迭代，我会开放出更多的日志参数，目前只放出了一个日志路径的参数作为示例。</p><h2 id="后续的两点核心需求"><a href="#后续的两点核心需求" class="headerlink" title="后续的两点核心需求"></a>后续的两点核心需求</h2><p>至此，我们添加的代码量并不多，也算成功地实现了一个日志打印的功能。但在实际的工程中，日志模块还需要实现两个比较大的功能：</p><ol><li>支持Go程序Panic/Error Wrapping风格的<strong>多行打印与采集</strong></li><li>支持分布式TraceId的打印，用来排查<strong>微服务调用链路</strong></li></ol><p>这两块的内容会结合具体的相关相关技术，会在后续专题中专门分享，请大家重点关注。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>zap</code>库的代码是一个很棒的实现，我会在接下来的<strong>Go语言技巧系列</strong>中详细分析，欢迎大家进行关注。</p><p>至此，我们的框架逐渐成型，接下来我将对<code>GORM</code>做一个简单的讲解，引入到框架中。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;日志是一个框架的重要组成部分，那今天我们一起来看看这部分。&lt;/p&gt;
&lt;p&gt;衡量日志库有多个指标，我们今天重点关注两点：&lt;strong&gt;简单易用&lt;/strong&gt; 与 &lt;strong&gt;高性能&lt;/strong&gt;。简单易用是一个日志库能被广泛使用的必要条件，而&lt;strong&gt;高性能&lt;/strong&gt;则是企业级的日志库非常重要的衡量点，也能在源码层面对我们有一定的启发。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 2.实现加载静态配置文件</title>
    <link href="http://example.com/2021/08/21/go-framework/go-framework-2/"/>
    <id>http://example.com/2021/08/21/go-framework/go-framework-2/</id>
    <published>2021-08-21T04:00:00.000Z</published>
    <updated>2021-09-26T02:51:53.730Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>我们的基础RPC服务已经正常运行，我们再来看下一个特性：配置文件的加载。</p><p>首先，我们要正确地认识到配置文件的重要性：<strong>在程序交付后，变更代码的成本很大；相对而言，变更配置文件的成本就比较小</strong>。但有的同学又走了另一个极端，也就是将大量的逻辑放入到配置文件中，导致<strong>配置文件膨胀</strong>，本质上就是将部分本应在代码中维护的内容转移到了配置文件，导致配置文件也很难维护。</p><p>今天，我们先将重点放到加载配置文件库的技术选型，顺便分享一些常见的问题。</p><span id="more"></span><h2 id="一个基础的加载配置文件示例"><a href="#一个基础的加载配置文件示例" class="headerlink" title="一个基础的加载配置文件示例"></a>一个基础的加载配置文件示例</h2><p>在<code>Go</code>语言中，用官方库就能快速实现配置文件的加载，下面就是一个简单的代码实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b, err := ioutil.ReadFile(<span class="string">&quot;config.json&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> config MyConfig</span><br><span class="line">err = json.Unmarshal(b, &amp;config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键的实现分为两块：</p><ol><li>读取文件中的数据</li><li>将数据解析到Go程序的对象中，作为可识别的数据结构，这里指定了数据类型为<code>json</code></li></ol><h2 id="v0-2-0：实现加载静态配置文件"><a href="#v0-2-0：实现加载静态配置文件" class="headerlink" title="v0.2.0：实现加载静态配置文件"></a>v0.2.0：实现加载静态配置文件</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.2.0">https://github.com/Junedayday/micro_web_service/tree/v0.2.0</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>从配置文件中解析数据到程序中，并具备更高的可读性和扩展性。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>命令行参数与配置文件的差异</li><li>github.com/spf13/viper的介绍</li><li>使用viper库的推荐方式</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><p><code>github.com/spf13/viper</code>中存在一个全局变量<code>var v *Viper</code>（<a href="https://github.com/spf13/viper/blob/v1.7.0/viper.go#L62">点击查看</a>），如果我们调用默认的viper包，其实就是将参数解析到这个全局变量中。</p><p>在具体的项目中，更推荐的方式是将这个变量保存到内部项目中，作为一个项目中的全局变量，所以我们会新建一个<code>viper.New()</code>。配置参数会被全局调用，为了保证不会发生<strong>循环依赖</strong>，我们就需要一个专门的<code>package</code>来保存这个全局变量，这里对应项目中的<code>internal/config/viper.go</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务</span><br><span class="line">         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义</span><br><span class="line">      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- server                          服务器的实现</span><br><span class="line">      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">   |-- config                          新增：配置相关的文件夹</span><br><span class="line">      |-- viper.go                         新增：viper的相关加载逻辑</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具</span><br><span class="line">|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="1-命令行参数与配置文件的差异"><a href="#1-命令行参数与配置文件的差异" class="headerlink" title="1.命令行参数与配置文件的差异"></a>1.命令行参数与配置文件的差异</h2><p>命令行参数类似于<code>./demo --config=a.yaml --http_port=8080 --grpc_port=8081</code>，<code>Go</code>语言中自带<code>flag</code>包可供解析，开源的有<code>pflag</code>和相关的扩展工具，如<code>cobra</code>。</p><p>而配置文件则是<strong>将参数从文件解析到内存中</strong>，一般用读取文件+反序列化工具来使用。</p><p>同样是解析参数到程序里，我们该选择哪种方案呢？我们从可读性和可维护性来对比下：</p><ul><li>可读性：命令行参数是扁平化的，可读性远不如格式化后的配置文件</li><li>可维护性：配置文件增加了一个维护项，但成本不高</li></ul><p>所以，我个人倾向于的方案是：</p><ul><li>命令行参数：用于维护极少量关键性的参数，如配置文件的路径</li><li>配置文件：维护绝大多数的参数</li></ul><p>在某些极端的场景中，比如提供一个纯二进制文件作为工具，那不得不把所有配置参数都放入到命令行参数中。这并不是我们微服务框架要讨论的场景。所以，接下来我们重点讨论配置文件的加载。</p><blockquote><p>关于pflag相关的内容，在后续程序复杂到一定阶段后会引入。</p></blockquote><h2 id="2-github-com-spf13-viper的介绍"><a href="#2-github-com-spf13-viper的介绍" class="headerlink" title="2.github.com/spf13/viper的介绍"></a>2.github.com/spf13/viper的介绍</h2><p>对比上面的方案，我们来看一个业内使用最广的Go语言配置加载库<code>github.com/spf13/viper</code>的实现，对应的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">viper.SetConfigName(<span class="string">&quot;config&quot;</span>)        <span class="comment">// config file name without file type</span></span><br><span class="line">viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>)          <span class="comment">// config file type</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;./&quot;</span>)            <span class="comment">// config file path</span></span><br><span class="line"><span class="keyword">if</span> err := viper.ReadInConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在获取配置文件时，又采用key-value形式的语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viper.GetInt(<span class="string">&quot;server.grpc.port&quot;</span>)</span><br></pre></td></tr></table></figure><p>详细的特性我会在<strong>Go语言技巧系列</strong>里说明，今天我们聚焦于工程侧的宏观特性，来聊聊这个库的优劣势：</p><h3 id="可选的参数序列化"><a href="#可选的参数序列化" class="headerlink" title="可选的参数序列化"></a>可选的参数序列化</h3><p>从<code>viper</code>库的源码中(<a href="https://github.com/spf13/viper/blob/v1.7.0/viper.go#L328">点击跳转</a>)，我们可以看到它支持多种<strong>本地文件类型</strong>与<strong>远程k-v数据库</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SupportedExts are universally supported extensions.</span></span><br><span class="line"><span class="keyword">var</span> SupportedExts = []<span class="keyword">string</span>&#123;<span class="string">&quot;json&quot;</span>, <span class="string">&quot;toml&quot;</span>, <span class="string">&quot;yaml&quot;</span>, <span class="string">&quot;yml&quot;</span>, <span class="string">&quot;properties&quot;</span>, <span class="string">&quot;props&quot;</span>, <span class="string">&quot;prop&quot;</span>, <span class="string">&quot;hcl&quot;</span>, <span class="string">&quot;dotenv&quot;</span>, <span class="string">&quot;env&quot;</span>, <span class="string">&quot;ini&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SupportedRemoteProviders are universally supported remote providers.</span></span><br><span class="line"><span class="keyword">var</span> SupportedRemoteProviders = []<span class="keyword">string</span>&#123;<span class="string">&quot;etcd&quot;</span>, <span class="string">&quot;consul&quot;</span>, <span class="string">&quot;firestore&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>我们先忽略远程的存储，先看一下最常用的几个序列化的库：</p><ol><li>JSON: 官方自带的<code>encoding/json</code></li><li>TOML: 开源的<code>github.com/pelletier/go-toml</code></li><li>YAML: 官方推荐的<code>gopkg.in/yaml.v2</code></li><li>INI：官方推荐的<code>gopkg.in/ini.v1</code></li></ol><p>在这四种技术选型时，我个人倾向于选择<code>JSON</code>和<code>YAML</code>。进一步斟酌时，虽然<code>JSON</code>的适用范围最广，但当配置文件复杂到一定程度时，<code>JSON</code>格式的配置文件很难通过换行来约束，当存在大量的嵌套时，可读性很差。所以，我个人比较推荐使用<code>YAML</code>格式的配置文件，一方面通过强制的换行约束，可读性很棒；另一方面云原生相关技术大量使用了<code>YAML</code>作为配置文件，尤其是<code>Kubernetes</code>中各种定义。</p><p>例如，我们将服务的端口改造到配置文件里，就成了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">grpc:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8082</span></span><br></pre></td></tr></table></figure><p>对应的Go语言代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">viper.GetInt(<span class="string">&quot;server.http.port&quot;</span>)</span><br><span class="line">viper.GetInt(<span class="string">&quot;server.grpc.port&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="可扩展的获取参数方法"><a href="#可扩展的获取参数方法" class="headerlink" title="可扩展的获取参数方法"></a>可扩展的获取参数方法</h3><p><code>viper</code>库提供的获取参数方式为<code>viper.Get&#123;type&#125;(&quot;&#123;level1&#125;.&#123;level2&#125;.&#123;level3&#125;...&quot;)</code>的格式。随着配置文件的扩大，也只需新增Get方法即可。</p><p>从获取参数的方法来看，它的设计分为3种：</p><ol><li>基本类型，直接提供Get{具体类型}的方法，如<code>GetInt</code>，<code>GetString</code>；</li><li>任意类型，提供<code>Get(key string) interface&#123;&#125; </code>，自行转化</li><li>复杂类型的反序列化，提供<code>UnmarshalKey</code>等方法，更方便地获取复杂结构</li></ol><p>我个人建议各位只使用第一类的方法，将配置文件这个模块做到最简化。毕竟，<strong>配置文件的复杂化很容易引入各种问题，占用大量的排查故障的时间</strong>。如果你的系统必须引入一套非常复杂的配置，那么我更建议将它独立成一个专门的服务，用来维护这套配置。</p><h2 id="3-使用viper库的推荐方式"><a href="#3-使用viper库的推荐方式" class="headerlink" title="3.使用viper库的推荐方式"></a>3.使用viper库的推荐方式</h2><p>如果你仔细地阅读viper相关的代码，你会发现它有很多超酷的特性。但今天，我想告诉各位：<strong>请克制地使用进阶的特性，最棒的特性往往是简洁的</strong>。</p><p>我们对照着官方的README文件中介绍的特性进行讲解。</p><h3 id="尽量避免手动设置的参数值"><a href="#尽量避免手动设置的参数值" class="headerlink" title="尽量避免手动设置的参数值"></a>尽量避免手动设置的参数值</h3><p><a href="https://github.com/spf13/viper#establishing-defaults">原文链接</a></p><p>用<code>viper.SetDefault</code>函数可以给某些参数设置默认值，如果只是少数的几个参数还是很容易维护的。但如果设置的值过多了，就会给阅读代码的人带来困扰：<strong>这个参数是来自配置文件，还是在代码某处手动设置的？</strong>也就是存在<strong>二义性</strong>，增加了排查问题的复杂度。</p><h3 id="明确配置文件的来源"><a href="#明确配置文件的来源" class="headerlink" title="明确配置文件的来源"></a>明确配置文件的来源</h3><p><a href="https://github.com/spf13/viper#reading-config-files">原文链接</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viper.AddConfigPath(<span class="string">&quot;/etc/appname/&quot;</span>)   <span class="comment">// path to look for the config file in</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;$HOME/.appname&quot;</span>)  <span class="comment">// call multiple times to add many search paths</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)               <span class="comment">// optionally look for config in the working directory</span></span><br></pre></td></tr></table></figure><p><code>viper</code>支持多个配置文件的路径，这虽然带来了便利性，但如果多个文件路径中都存在配置文件，那究竟以哪个为准？这也是一个<strong>二义性</strong>的问题，所以我个人更建议只设置一个，而这个路径由<code>flag</code>传入。</p><h3 id="静态配置与动态配置的分离"><a href="#静态配置与动态配置的分离" class="headerlink" title="静态配置与动态配置的分离"></a>静态配置与动态配置的分离</h3><p><a href="https://github.com/spf13/viper#watching-and-re-reading-config-files">原文链接</a></p><p><code>viper</code>提供了接口<code>viper.WatchConfig()</code>，可以监听文件的变化，然后做相应的调整。这个特性很酷，我们可以用它实现<strong>热加载</strong>。但这个特性很容易让人产生混淆：例如发生了某个BUG，如何确定当时的配置文件情况？其实，这就需要引入一定的<strong>版本管理</strong>机制。</p><p>我更建议采用<strong>静态配置和动态配置分离</strong>的方案，也就是配置文件负责静态的、固定的配置，一旦启动后只加载一次；而动态的配置放在带版本管理的配置中心里，具备热加载的特性。</p><p>所以，我不太建议在配置文件这里引入监听文件变化的特性。</p><h2 id="核心代码示例"><a href="#核心代码示例" class="headerlink" title="核心代码示例"></a>核心代码示例</h2><h3 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h3><p>从<code>flag</code>中解析出配置文件路径，传到<code>config</code>包中用于解析。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> configFilePath = flag.String(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;./&quot;</span>, <span class="string">&quot;config file path&quot;</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := config.Load(*configFilePath); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="internal-config-viper-go"><a href="#internal-config-viper-go" class="headerlink" title="internal/config/viper.go"></a>internal/config/viper.go</h3><p>加载的代码并不多，尽量保证配置信息的简洁易懂。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局Viper变量</span></span><br><span class="line"><span class="keyword">var</span> Viper = viper.New()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Load</span><span class="params">(configFilePath <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">Viper.SetConfigName(<span class="string">&quot;config&quot;</span>)       <span class="comment">// config file name without file type</span></span><br><span class="line">Viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>)         <span class="comment">// config file type</span></span><br><span class="line">Viper.AddConfigPath(configFilePath) <span class="comment">// config file path</span></span><br><span class="line"><span class="keyword">return</span> Viper.ReadInConfig()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置使用方"><a href="#配置使用方" class="headerlink" title="配置使用方"></a>配置使用方</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.Viper.GetInt(<span class="string">&quot;server.grpc.port&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="使用viper库的注意事项"><a href="#使用viper库的注意事项" class="headerlink" title="使用viper库的注意事项"></a>使用viper库的注意事项</h2><p>在使用<code>viper</code>获取配置时，我们需要手动组装<code>key</code>，也就是<code>&quot;&#123;level1&#125;.&#123;level2&#125;.&#123;level3&#125;...&quot;</code>这种形式。这时，我们只能对照着原始配置文件逐个填充字段，一不小心填错、就会发生奇怪的问题。而如果采用的是将配置文件解析到结构体的方法，就能很容易地避免这个问题。</p><p>考虑到扩展性，官方库推荐的是手动组装key的方式，所以需要大家在认真查看这个<code>key</code>是否有效。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>加载静态配置文件是一个很常见的功能，<code>viper</code>提供了一套完整方案，兼具简洁和扩展性；与此同时，我们要学会<strong>克制</strong>，不要看到了<code>viper</code>中提供的各种特性、就想着应用到实际项目中，也就是常说的：<strong>手里拿了个锤子，看啥都是钉子</strong>。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们的基础RPC服务已经正常运行，我们再来看下一个特性：配置文件的加载。&lt;/p&gt;
&lt;p&gt;首先，我们要正确地认识到配置文件的重要性：&lt;strong&gt;在程序交付后，变更代码的成本很大；相对而言，变更配置文件的成本就比较小&lt;/strong&gt;。但有的同学又走了另一个极端，也就是将大量的逻辑放入到配置文件中，导致&lt;strong&gt;配置文件膨胀&lt;/strong&gt;，本质上就是将部分本应在代码中维护的内容转移到了配置文件，导致配置文件也很难维护。&lt;/p&gt;
&lt;p&gt;今天，我们先将重点放到加载配置文件库的技术选型，顺便分享一些常见的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 1.搭建gRPC+HTTP的双重网关服务</title>
    <link href="http://example.com/2021/08/19/go-framework/go-framework-1/"/>
    <id>http://example.com/2021/08/19/go-framework/go-framework-1/</id>
    <published>2021-08-19T04:00:00.000Z</published>
    <updated>2021-08-21T06:14:29.483Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>大家好，我是六月天天。如题所述，从今天开始，我将和大家一起逐步完成一个微服务框架。</p><p>整个迭代过程会围绕着两个核心思想进行：</p><ol><li><strong>关注技术选型背后的思想</strong>。虽然最终某个技术选型的可能并不是你喜欢的方案（如RPC、日志、数据库等，你可以fork后自行调整），但我们更关注各个技术组件背后的原理与思想，<strong>选择的过程比结果更重要</strong>；</li><li><strong>聚焦于简单，关注可维护性</strong>。技术框架是项目的基础设施，也是排查复杂业务问题的根本，所以框架层的功能会尽量考虑简单易用，可以让我们花更多的心思在业务开发中。许多开源库提供了大量扩展功能，但我们使用时会尽量<strong>克制</strong>，减少学习和排查问题时的成本。</li></ol><p>微服务框架系列重点介绍框架的搭建过程，期间对一些细节技术点的讲解，会在另一个系列<strong>Go语言技巧系列</strong>中展开。</p><span id="more"></span><h2 id="v0-1-0：搭建gRPC-HTTP的双重网关服务"><a href="#v0-1-0：搭建gRPC-HTTP的双重网关服务" class="headerlink" title="v0.1.0：搭建gRPC+HTTP的双重网关服务"></a>v0.1.0：搭建gRPC+HTTP的双重网关服务</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.1.0">https://github.com/Junedayday/micro_web_service/tree/v0.1.0</a></p><p>gRPC-gateway官方Github <a href="https://github.com/grpc-ecosystem/grpc-gateway">https://github.com/grpc-ecosystem/grpc-gateway</a></p><blockquote><p>有很多朋友更喜欢使用Gin框架，但我依然选择了gRPC-gateway。</p><p>主要在于gRPC-gateway方案对接Google提供的各种开源插件生态都很棒。大家会在后面框架的迭代过程中慢慢体会到它的特性。</p><p>后续我也会对Gin做一些分析。</p></blockquote><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>完成RPC服务的框架的搭建</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li><code>protobuffer</code>定义IDL（Interface Definition Language 接口定义语言）</li><li><code>buf</code>工具生成<code>Go</code>代码（包括数据结构和RPC相关服务）</li><li><code>Go</code>项目实现RPC服务（实现RPC接口）</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务</span><br><span class="line">         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义</span><br><span class="line">      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- server                          服务器的实现</span><br><span class="line">      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具</span><br><span class="line">|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-protobuffer定义IDL"><a href="#1-protobuffer定义IDL" class="headerlink" title="1. protobuffer定义IDL"></a>1. protobuffer定义IDL</h2><p>我们先看一下项目中的<code>demo.proto</code>文件，重点关注 <strong>rpc Echo(DemoRequest) returns (DemoResponse)</strong> 这个定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">message DemoRequest &#123;</span><br><span class="line">   string value = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message DemoResponse &#123;</span><br><span class="line">   int32 code = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 样例服务</span><br><span class="line">service DemoService &#123;</span><br><span class="line">  // Echo 样例接口</span><br><span class="line">  rpc Echo(DemoRequest) returns (DemoResponse) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      post : &quot;/apis/demo&quot;</span><br><span class="line">      body : &quot;*&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今天我们暂时不对<code>protobuffer</code>的语法做扩展讲解，只需要简单地了解下它的请求结构体<code>DemoRequest</code>和响应结构体<code>DemoResponse</code>。</p><h2 id="2-buf工具生成Go代码"><a href="#2-buf工具生成Go代码" class="headerlink" title="2. buf工具生成Go代码"></a>2. buf工具生成Go代码</h2><p>我们通过运行项目根目录中的<code>gen.sh</code>，会在<code>gen</code>目录下生成对应的Go语言代码。</p><p>这部分是自动化的工作，每次修改<code>proto</code>文件后需要运行。</p><blockquote><p>buf工具的安装请参考README.md，它是protoc的演进版本，不再需要大量flag参数，更加简单易用。</p><p>注意，如果修改了模块名，buf工具第一次初始化建议使用 buf beta mod init 指令</p></blockquote><h2 id="3-Go项目实现RPC服务"><a href="#3-Go项目实现RPC服务" class="headerlink" title="3.Go项目实现RPC服务"></a>3.Go项目实现RPC服务</h2><p>我们梳理一下整个逻辑，来看看这个<code>Go</code>程序是怎么提供RPC服务的。</p><ol><li>在<code>buf.gen.yaml</code>中定义了生成的2种服务， <code>go-grpc</code>和 <code>grpc-gateway</code>，分别表示<code>gRPC</code>和<code>HTTP</code></li><li><code>demo.proto</code>通过脚本，在<code>gen/idl/demo</code>生成了2个文件，<code>*_grpc.pb.go</code>和<code>*.pb.gw.go</code>，分别表示<code>gRPC</code>和<code>HTTP</code></li><li>在<code>main</code>函数中注册两个服务，分别为：<ol><li>gRPC - <code>demo.RegisterDemoServiceServer(s, &amp;server.Server&#123;&#125;)</code></li><li>HTTP - <code>demo.RegisterDemoServiceHandlerFromEndpoint(ctx, mux, *grpcServerEndpoint, opts)</code></li></ol></li><li>在<code>internal/server/server.go</code>中，<code>server.Server</code>需要实现<code>proto</code>中定义的方法，所以我们加入接口定义<code>demo.UnsafeDemoServiceServer</code></li><li>在<code>internal/server/demo.go</code>中，实现一个<code>func (s *Server) Echo(ctx context.Context, req *demo.DemoRequest) (*demo.DemoResponse, error)</code>方法</li></ol><h2 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h2><p>我们用简单的命令来运行，并用RPC访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译并运行</span></span><br><span class="line">go build &amp;&amp; ./micro_web_service </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 模拟HTTP请求</span></span><br><span class="line">curl --location --request POST &#x27;http://127.0.0.1:8081/apis/demo&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 收到返回值 &#123;<span class="string">&quot;code&quot;</span>:0&#125;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 而gRPC比较麻烦，是私有协议，我们查看一下对应的网络端口，发现正在监听，也就意味着正常运行</span></span><br><span class="line">netstat -an | grep 9090</span><br><span class="line">tcp4       0      0  127.0.0.1.9090         127.0.0.1.49266        ESTABLISHED</span><br><span class="line">tcp4       0      0  127.0.0.1.49266        127.0.0.1.9090         ESTABLISHED</span><br><span class="line">tcp46      0      0  *.9090                 *.*                    LISTEN </span><br></pre></td></tr></table></figure><h2 id="项目的私有化"><a href="#项目的私有化" class="headerlink" title="项目的私有化"></a>项目的私有化</h2><p>由于本项目只是一个框架，如果你希望修改为个人的项目，主要改动点在两处：</p><ol><li><code>go.mod</code>里的模块名，以及<code>Go</code>代码内部的import</li><li><code>proto</code>文件中定义的<code>go_package</code></li></ol><blockquote><p>建议用编辑工具全量替换</p></blockquote><h2 id="新增接口示例"><a href="#新增接口示例" class="headerlink" title="新增接口示例"></a>新增接口示例</h2><h3 id="添加proto定义"><a href="#添加proto定义" class="headerlink" title="添加proto定义"></a>添加proto定义</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EmptyMessage</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Empty 空接口</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Empty(EmptyMessage) <span class="keyword">returns</span> (EmptyMessage) </span>&#123;</span><br><span class="line">  <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">    post : <span class="string">&quot;/apis/empty&quot;</span></span><br><span class="line">    body : <span class="string">&quot;*&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成Go文件"><a href="#生成Go文件" class="headerlink" title="生成Go文件"></a>生成Go文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash gen.sh</span><br></pre></td></tr></table></figure><h3 id="添加接口定义"><a href="#添加接口定义" class="headerlink" title="添加接口定义"></a>添加接口定义</h3><p>这时候，我们会发现<code>main.go</code>中有报错，即提示<code>server.Server</code>这个对象需要实现<code>Empty</code>方法。于是，我们在<code>internal/server/demo.go</code>里添加</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Empty</span><span class="params">(ctx context.Context, req *demo.EmptyMessage)</span> <span class="params">(*demo.EmptyMessage, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;demo.EmptyMessage&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试新接口"><a href="#测试新接口" class="headerlink" title="测试新接口"></a>测试新接口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译并运行</span></span><br><span class="line">go build &amp;&amp; ./micro_web_service </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 模拟HTTP请求</span></span><br><span class="line">curl --location --request POST &#x27;http://127.0.0.1:8081/apis/empty&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回 &#123;&#125;</span> </span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>v0.1.0</code>版本是一个非常简单的web框架，只有样例的RPC接口。</p><p>开放<code>HTTP</code>接口是为了兼容传统方案，而<code>gRPC</code>则提供了高性能、跨语言的通信方案。从整个实现过程来看，我们只编写了一个具体的实现、也就是<code>Echo</code>这个方法，就完成了两种通信方式的兼容。</p><p><code>gRPC-Gateway</code>方案还有很多很棒的特性，我会在后续逐一介绍并引入。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;大家好，我是六月天天。如题所述，从今天开始，我将和大家一起逐步完成一个微服务框架。&lt;/p&gt;
&lt;p&gt;整个迭代过程会围绕着两个核心思想进行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;关注技术选型背后的思想&lt;/strong&gt;。虽然最终某个技术选型的可能并不是你喜欢的方案（如RPC、日志、数据库等，你可以fork后自行调整），但我们更关注各个技术组件背后的原理与思想，&lt;strong&gt;选择的过程比结果更重要&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;聚焦于简单，关注可维护性&lt;/strong&gt;。技术框架是项目的基础设施，也是排查复杂业务问题的根本，所以框架层的功能会尽量考虑简单易用，可以让我们花更多的心思在业务开发中。许多开源库提供了大量扩展功能，但我们使用时会尽量&lt;strong&gt;克制&lt;/strong&gt;，减少学习和排查问题时的成本。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;微服务框架系列重点介绍框架的搭建过程，期间对一些细节技术点的讲解，会在另一个系列&lt;strong&gt;Go语言技巧系列&lt;/strong&gt;中展开。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 9.【电话号码的字母组合LeetCode-17】</title>
    <link href="http://example.com/2021/08/18/go-leetcode/go-leetcode-9/"/>
    <id>http://example.com/2021/08/18/go-leetcode/go-leetcode-9/</id>
    <published>2021-08-18T04:00:00.000Z</published>
    <updated>2021-08-18T11:59:41.092Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-17-电话号码的字母组合"><a href="#Leetcode-17-电话号码的字母组合" class="headerlink" title="Leetcode-17 电话号码的字母组合"></a>Leetcode-17 电话号码的字母组合</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="基础解法"><a href="#基础解法" class="headerlink" title="基础解法"></a>基础解法</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>这道题的思路并不复杂，我们逐个处理<code>digits</code>里的字符，追加到结果上</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numToLetter = <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;2&quot;</span>: &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;3&quot;</span>: &#123;<span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;4&quot;</span>: &#123;<span class="string">&quot;g&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;i&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;5&quot;</span>: &#123;<span class="string">&quot;j&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;l&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;6&quot;</span>: &#123;<span class="string">&quot;m&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;o&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;7&quot;</span>: &#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;s&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;8&quot;</span>: &#123;<span class="string">&quot;t&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;v&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;9&quot;</span>: &#123;<span class="string">&quot;w&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> digits == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> matchNext([]<span class="keyword">string</span>&#123;&#125;, digits)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心递归，逐个处理剩余的字符串left</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">matchNext</span><span class="params">(current []<span class="keyword">string</span>, left <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> left == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> current</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从题目来看肯定是matched的</span></span><br><span class="line">matched, ok := numToLetter[<span class="keyword">string</span>(left[<span class="number">0</span>])]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> current</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(current) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> matchNext(matched, left[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line">next := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(current)*<span class="built_in">len</span>(matched))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> next &#123;</span><br><span class="line">  <span class="comment">// 利用位操作加速</span></span><br><span class="line">next[i] = current[i/<span class="built_in">len</span>(matched)] + matched[i%<span class="built_in">len</span>(matched)]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> matchNext(next, left[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="减少内存空间"><a href="#减少内存空间" class="headerlink" title="减少内存空间"></a>减少内存空间</h3><p>从运行结果来看：</p><ul><li>执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</li></ul><p>运行速度已经很难优化了，我们就想办法减少一下内存空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 减少空间，把切片转变成字符串</span></span><br><span class="line"><span class="keyword">var</span> numToLetter = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;2&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line"><span class="string">&quot;3&quot;</span>: <span class="string">&quot;def&quot;</span>,</span><br><span class="line"><span class="string">&quot;4&quot;</span>: <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line"><span class="string">&quot;5&quot;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line"><span class="string">&quot;6&quot;</span>: <span class="string">&quot;mno&quot;</span>,</span><br><span class="line"><span class="string">&quot;7&quot;</span>: <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line"><span class="string">&quot;8&quot;</span>: <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line"><span class="string">&quot;9&quot;</span>: <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> digits == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> matchNext([]<span class="keyword">string</span>&#123;&#125;, digits)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">matchNext</span><span class="params">(current []<span class="keyword">string</span>, left <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> left == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> current</span><br><span class="line">&#125;</span><br><span class="line">matched, ok := numToLetter[<span class="keyword">string</span>(left[<span class="number">0</span>])]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> current</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(current) == <span class="number">0</span> &#123;</span><br><span class="line">next := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(matched))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> matched &#123;</span><br><span class="line">next[i] = <span class="keyword">string</span>(matched[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> matchNext(next, left[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line">next := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(current)*<span class="built_in">len</span>(matched))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> next &#123;</span><br><span class="line"><span class="comment">// 利用位操作加速</span></span><br><span class="line">next[i] = current[i/<span class="built_in">len</span>(matched)] + <span class="keyword">string</span>(matched[i%<span class="built_in">len</span>(matched)])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> matchNext(next, left[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进阶：引入函数式编程"><a href="#进阶：引入函数式编程" class="headerlink" title="进阶：引入函数式编程"></a>进阶：引入函数式编程</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(digits) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result []<span class="keyword">string</span></span><br><span class="line">numToLetter := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;2&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line"><span class="string">&quot;3&quot;</span>: <span class="string">&quot;def&quot;</span>,</span><br><span class="line"><span class="string">&quot;4&quot;</span>: <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line"><span class="string">&quot;5&quot;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line"><span class="string">&quot;6&quot;</span>: <span class="string">&quot;mno&quot;</span>,</span><br><span class="line"><span class="string">&quot;7&quot;</span>: <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line"><span class="string">&quot;8&quot;</span>: <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line"><span class="string">&quot;9&quot;</span>: <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> matchNext <span class="function"><span class="keyword">func</span><span class="params">(current <span class="keyword">string</span>, left <span class="keyword">string</span>)</span></span></span><br><span class="line">matchNext = <span class="function"><span class="keyword">func</span><span class="params">(current <span class="keyword">string</span>, left <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(left) == <span class="number">0</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, current)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> numToLetter[<span class="keyword">string</span>(left[<span class="number">0</span>])] &#123;</span><br><span class="line">current = current + <span class="keyword">string</span>(v)</span><br><span class="line">matchNext(current, left[<span class="number">1</span>:])</span><br><span class="line">current = current[:<span class="built_in">len</span>(current)<span class="number">-1</span>] <span class="comment">//回溯</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">matchNext(<span class="string">&quot;&quot;</span>, digits)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个思路比较简单，最主要的优点在于将<code>numToLetter</code>和<code>matchNext</code>收敛到了函数中，对外暴露的细节就减少了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题的解法比较通俗易懂，最主要的切入点是引入<strong>递归的思想</strong>，来不断地缩减传入的字符串<code>digits</code>的长度，直到为0。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-17-电话号码的字母组合&quot;&gt;&lt;a href=&quot;#Leetcode-17-电话号码的字母组合&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-17 电话号码的字母组合&quot;&gt;&lt;/a&gt;Leetcode-17 电话号码的字母组合&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/&quot;&gt;https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;letterCombinations&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(digits &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; []&lt;span class=&quot;title&quot;&gt;string&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 8.【三数之和LeetCode-15】</title>
    <link href="http://example.com/2021/08/08/go-leetcode/go-leetcode-8/"/>
    <id>http://example.com/2021/08/08/go-leetcode/go-leetcode-8/</id>
    <published>2021-08-08T04:00:00.000Z</published>
    <updated>2021-08-15T13:18:56.227Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-15-三数之和"><a href="#Leetcode-15-三数之和" class="headerlink" title="Leetcode-15 三数之和"></a>Leetcode-15 三数之和</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="基础解法"><a href="#基础解法" class="headerlink" title="基础解法"></a>基础解法</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>在看到这道题的后，我们很自然地可以想到简单的解法，例如穷举出所有的值。这个代码我就不专门写了。</p><h3 id="利用排序进行优化"><a href="#利用排序进行优化" class="headerlink" title="利用排序进行优化"></a>利用排序进行优化</h3><p>由于这道题返回的<code>[][]int</code>要求是对应的值，而不是索引，所以我们可以利用排序做一定的加速，示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 先排序，为了方便处理</span></span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="comment">// 用于去重</span></span><br><span class="line"><span class="keyword">var</span> solutionMap = <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">3</span>]<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">for</span> k := j + <span class="number">1</span>; k &lt;= <span class="built_in">len</span>(nums)<span class="number">-1</span>; k++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i]+nums[j]+nums[k] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 取到一个解即可</span></span><br><span class="line">solutionMap[[<span class="number">3</span>]<span class="keyword">int</span>&#123;nums[i], nums[j], nums[k]&#125;] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[j]+nums[k] &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 如果已经大于0了，由于nums是递增的，无需继续循环下去了</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取一下去重后的解</span></span><br><span class="line"><span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> solutionMap &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, k[<span class="number">0</span>], k[<span class="number">1</span>], k[<span class="number">2</span>]))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但运行下来，在数据量大的情况下还是会超出时间限制</p><h3 id="利用二分查找加速"><a href="#利用二分查找加速" class="headerlink" title="利用二分查找加速"></a>利用二分查找加速</h3><p>我们把目光聚焦到<code>k</code>，在一个有序的数组中，可以利用二分查找加速</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="keyword">var</span> solutionMap = <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">3</span>]<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; j++ &#123;</span><br><span class="line"><span class="comment">// 用二分查找加速</span></span><br><span class="line"><span class="comment">// 但需要注意的是，go里的sort并不是精确匹配，所以需要二次判断</span></span><br><span class="line">k := sort.SearchInts(nums[j+<span class="number">1</span>:], -nums[i]-nums[j])</span><br><span class="line"><span class="keyword">if</span> k &lt; <span class="built_in">len</span>(nums[j+<span class="number">1</span>:]) &amp;&amp; nums[i]+nums[j]+nums[j+k+<span class="number">1</span>] == <span class="number">0</span> &#123;</span><br><span class="line">solutionMap[[<span class="number">3</span>]<span class="keyword">int</span>&#123;nums[i], nums[j], nums[j+k+<span class="number">1</span>]&#125;] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> solutionMap &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, k[<span class="number">0</span>], k[<span class="number">1</span>], k[<span class="number">2</span>]))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，代码已经可以通过验证，我们再看看有什么进一步的优化空间。</p><h3 id="优化1：减少元素的存储"><a href="#优化1：减少元素的存储" class="headerlink" title="优化1：减少元素的存储"></a>优化1：减少元素的存储</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="comment">// 缩小元素的存储</span></span><br><span class="line"><span class="keyword">var</span> solutionMap = <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">2</span>]<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; j++ &#123;</span><br><span class="line">k := sort.SearchInts(nums[j+<span class="number">1</span>:], -nums[i]-nums[j])</span><br><span class="line"><span class="keyword">if</span> k &lt; <span class="built_in">len</span>(nums[j+<span class="number">1</span>:]) &amp;&amp; nums[i]+nums[j]+nums[j+k+<span class="number">1</span>] == <span class="number">0</span> &#123;</span><br><span class="line">solutionMap[[<span class="number">2</span>]<span class="keyword">int</span>&#123;nums[i], nums[j]&#125;] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> solutionMap &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, k[<span class="number">0</span>], k[<span class="number">1</span>], -k[<span class="number">0</span>]-k[<span class="number">1</span>]))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化2：初始化切片大小，防止扩容效率"><a href="#优化2：初始化切片大小，防止扩容效率" class="headerlink" title="优化2：初始化切片大小，防止扩容效率"></a>优化2：初始化切片大小，防止扩容效率</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="keyword">var</span> solutionMap = <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">2</span>]<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; j++ &#123;</span><br><span class="line">k := sort.SearchInts(nums[j+<span class="number">1</span>:], -nums[i]-nums[j])</span><br><span class="line"><span class="keyword">if</span> k &lt; <span class="built_in">len</span>(nums[j+<span class="number">1</span>:]) &amp;&amp; nums[i]+nums[j]+nums[j+k+<span class="number">1</span>] == <span class="number">0</span> &#123;</span><br><span class="line">solutionMap[[<span class="number">2</span>]<span class="keyword">int</span>&#123;nums[i], nums[j]&#125;] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化切片空间</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(solutionMap))</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> solutionMap &#123;</span><br><span class="line">result[i] = []<span class="keyword">int</span>&#123;k[<span class="number">0</span>], k[<span class="number">1</span>], -k[<span class="number">0</span>] - k[<span class="number">1</span>]&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化3：利用map加速查询"><a href="#优化3：利用map加速查询" class="headerlink" title="优化3：利用map加速查询"></a>优化3：利用map加速查询</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="keyword">var</span> dataCountMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := dataCountMap[v]; !ok &#123;</span><br><span class="line">dataCountMap[v] = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dataCountMap[v]++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> solutionMap = <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">2</span>]<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; j++ &#123;</span><br><span class="line">expected := -nums[i] - nums[j]</span><br><span class="line"><span class="keyword">if</span> num, ok := dataCountMap[expected]; ok &amp;&amp; expected &gt;= nums[j] &#123;</span><br><span class="line"><span class="keyword">if</span> expected == nums[j] &#123;</span><br><span class="line">num--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> expected == nums[i] &#123;</span><br><span class="line">num--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">solutionMap[[<span class="number">2</span>]<span class="keyword">int</span>&#123;nums[i], nums[j]&#125;] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(solutionMap))</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> solutionMap &#123;</span><br><span class="line">result[i] = []<span class="keyword">int</span>&#123;k[<span class="number">0</span>], k[<span class="number">1</span>], -k[<span class="number">0</span>] - k[<span class="number">1</span>]&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进阶思路-双指针"><a href="#进阶思路-双指针" class="headerlink" title="进阶思路 -  双指针"></a>进阶思路 -  双指针</h2><p>我们把眼光放回到这个问题。通过排序，其实我们已经将问题变得比较清晰了。</p><p>在这个题目中，有三个关键的变量，我们可以将其中一个固定，例如<code>i</code>，将问题简化为<code>nums[j]+nums[k]=-nums[i]</code>。</p><p>于是，问题就在于<code>j</code>和<code>k</code>这两个坐标的移动。整体的代码思路并不难，但性能的提升集中在<strong>对剪枝情况的处理</strong>，尤其是值相同的元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 剪枝：最小值大于0时无需再遍历</span></span><br><span class="line"><span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 剪枝：最小值和前一个值一样时，上一个循环已经判断过，无需再判断</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// j,k 为两个指针，分别从最左边和最右边开始移动</span></span><br><span class="line">j, k := i+<span class="number">1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> j &lt; k &#123;</span><br><span class="line">left, right := nums[j], nums[k]</span><br><span class="line"><span class="keyword">if</span> nums[i]+nums[j]+nums[k] == <span class="number">0</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;nums[i], nums[j], nums[k]&#125;)</span><br><span class="line"><span class="comment">// 减枝：跳过 nums[j] == nums[j+1] 的情况</span></span><br><span class="line"><span class="keyword">for</span> j &lt; k &amp;&amp; nums[j] == left &#123;</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 减枝：跳过 nums[k] == nums[k-1] 的情况</span></span><br><span class="line"><span class="keyword">for</span> j &lt; k &amp;&amp; nums[k] == right &#123;</span><br><span class="line">k--</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[j]+nums[k] &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 和小于0，则增大最左边的j</span></span><br><span class="line">j++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 和大于0，则减少最右边的k</span></span><br><span class="line">k--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题的难度并不高，我们可以快速地实现这块代码。</p><p>与此同时，我们将更多的注意力放在了<strong>剪枝</strong>的情况，也就成为了最终算法是否高效的关键因素。在实际的工程中，<strong>剪枝</strong>是一个很重要的思想，我们经常要<strong>根据具体的数据特征进行策略调整</strong>。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-15-三数之和&quot;&gt;&lt;a href=&quot;#Leetcode-15-三数之和&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-15 三数之和&quot;&gt;&lt;/a&gt;Leetcode-15 三数之和&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/3sum/&quot;&gt;https://leetcode-cn.com/problems/3sum/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;threeSum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nums []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; [][]&lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 7.【盛最多水的容器LeetCode-11】</title>
    <link href="http://example.com/2021/08/02/go-leetcode/go-leetcode-7/"/>
    <id>http://example.com/2021/08/02/go-leetcode/go-leetcode-7/</id>
    <published>2021-08-02T04:00:00.000Z</published>
    <updated>2021-08-02T14:04:13.138Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-11-盛最多水的容器"><a href="#Leetcode-11-盛最多水的容器" class="headerlink" title="Leetcode-11 盛最多水的容器"></a>Leetcode-11 盛最多水的容器</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/container-with-most-water/">https://leetcode-cn.com/problems/container-with-most-water/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="基础解法"><a href="#基础解法" class="headerlink" title="基础解法"></a>基础解法</h2><h3 id="基本的递归"><a href="#基本的递归" class="headerlink" title="基本的递归"></a>基本的递归</h3><p>我们先通过递归来解一下这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(height) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(height) == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> height[<span class="number">0</span>] &gt; height[<span class="number">1</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> height[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> height[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右边固定为height[len(height) - 1]，左边不断移动，寻找最大的区域</span></span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(height) - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        right := height[<span class="built_in">len</span>(height) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> height[i] &lt; right &#123;</span><br><span class="line">            right = height[i]</span><br><span class="line">        &#125;</span><br><span class="line">        area := (<span class="built_in">len</span>(height) - <span class="number">1</span> - i) * right</span><br><span class="line">        <span class="keyword">if</span> area &gt; max &#123;</span><br><span class="line">            max = area</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// height去掉最右边的一个点，拆解为子问题</span></span><br><span class="line">    subArea := maxArea(height[:<span class="built_in">len</span>(height) - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> subArea &gt; max&#123;</span><br><span class="line">        <span class="keyword">return</span> subArea</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个代码的逻辑没有问题，但在线上执行的结果是<strong>超出了时间限制</strong>，也就是递归太深。</p><p>我们能否想个办法，做到<strong>减枝</strong>？我们尝试下将已经算出来的区域传递下去。</p><h3 id="利用减枝"><a href="#利用减枝" class="headerlink" title="利用减枝"></a>利用减枝</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 处理初始边界条件</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(height) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(height) == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">if</span> height[<span class="number">0</span>] &gt; height[<span class="number">1</span>] &#123;</span><br><span class="line"><span class="keyword">return</span> height[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> height[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxAreaWithAera(height, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxAreaWithAera</span><span class="params">(height []<span class="keyword">int</span>, area <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(height) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> area</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">right := height[<span class="built_in">len</span>(height)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> right != <span class="number">0</span> &#123;</span><br><span class="line">leftIndex := <span class="built_in">len</span>(height) - <span class="number">2</span></span><br><span class="line"><span class="comment">// 关键在于理解 len(height)-1-area/right，也就是左边至少从右边的边偏移area/right，才有可能大于area</span></span><br><span class="line"><span class="keyword">if</span> area != <span class="number">0</span> &amp;&amp; leftIndex &gt; <span class="built_in">len</span>(height)<span class="number">-1</span>-area/right &#123;</span><br><span class="line">leftIndex = <span class="built_in">len</span>(height) - <span class="number">1</span> - area/right</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// leftIndex往左偏移</span></span><br><span class="line"><span class="keyword">for</span> ; leftIndex &gt;= <span class="number">0</span>; leftIndex-- &#123;</span><br><span class="line">right := height[<span class="built_in">len</span>(height)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> height[leftIndex] &lt; right &#123;</span><br><span class="line">right = height[leftIndex]</span><br><span class="line">&#125;</span><br><span class="line">a := (<span class="built_in">len</span>(height) - <span class="number">1</span> - leftIndex) * right</span><br><span class="line"><span class="keyword">if</span> a &gt; area &#123;</span><br><span class="line">area = a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxAreaWithAera(height[:<span class="built_in">len</span>(height)<span class="number">-1</span>], area)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点就是<code>len(height)-1-area/right</code>这个值，这里利用了传递的<code>area</code>进行<strong>减枝</strong>。</p><h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><h3 id="梳理思路"><a href="#梳理思路" class="headerlink" title="梳理思路"></a>梳理思路</h3><p>我们跳出代码，来思考一下整个问题解决的宏观思路</p><ol><li>当左边与右边确定时，假设索引为<code>l1</code>和<code>r1</code>，区域大小是固定的<ol><li><code>area = min(height[l1], height[r1]) * (r1 - l1)</code></li></ol></li><li>接下来，我们要简化问题，也就是要将**[]height的左边界往右移或者右边界往左移**<ol><li>无论如何移动，<strong>x轴是不断缩小的</strong>，所以问题在于<code>左边界height[l2]</code>和右边界的高度<code>height[r2]</code></li><li><code>area2 = min(height[l2], height[r2]) * (r2 - l2)</code></li></ol></li><li><code>l2</code>和<code>r2</code>同时改变的话，整个计算方式就会很复杂，那我们就尝试固定其中一个不变，例如<ol><li><code>l1 = l2</code> 并且 <code>r1 &gt; r2</code>，即<strong>右边界往左移动</strong>，此时</li><li><code>area = min(height[l1], height[r1]) * (r1 - l1)</code></li><li><code>area2 = min(height[l1], height[r2]) * (r2 - l1)</code></li></ol></li><li>有什么办法可以对比<code>area</code>与<code>area2</code> 呢？<ol><li><code>r1 - l1 &gt; r2 - l1</code>可根据条件快速判断</li><li>核心在于对比 <code>min(height[l1], height[r1])</code> 和 <code>min(height[l1], height[r2])</code><ol><li>如果 <code>height[r1])</code> &gt;= <code>min(height[l1]</code>，也就是**[]height高度最右边最高于左边**，那么 <code>min(height[l1], height[r1])</code> &gt;=  <code>min(height[l1], height[r2])</code>成立，此时 area &gt;= area2 也必定成立</li><li>如果 <code>height[r1])</code> &lt; <code>min(height[l1]</code>，那么 area 与 area2 的关系没法判断</li></ol></li><li>归纳一下上面这个情况：就是<strong>当[]height高度最右边高于最左边时，移动右边面积肯定变小，移动左边面积变化未知</strong>。</li></ol></li><li>用更通用的说法就是，如果要找到[]height子集中更大的面积，<strong>固定较高边，移动较低边</strong>。在编程中，这种接法往往称为<strong>双指针</strong>。</li></ol><h3 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        <span class="keyword">var</span> area <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">if</span> height[left] &gt; height[right] &#123;</span><br><span class="line">            area = height[right] * (right - left)</span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            area = height[left] * (right - left)</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> area &gt; max &#123;</span><br><span class="line">            max = area</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双指针解法很简洁</strong>，但最重要的是推导过程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在编写代码的过程中，我们很难一步到位就写出最佳实现的解法，而前面的<strong>递归+减枝</strong>方法，虽然代码比较复杂，但是更符合我们直观逻辑的。<strong>双指针解法</strong>并不直观，这也就是体现出了刷题的价值。</p><p>值得一提的是，如果你上手就写出双指针解法，面试官会认为你是靠刷题记忆的，所以在面试算法的过程中，我们更应该关注<strong>解决问题的递进式思路</strong>，答案只是评价算法能力的其中一个重要项。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-11-盛最多水的容器&quot;&gt;&lt;a href=&quot;#Leetcode-11-盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-11 盛最多水的容器&quot;&gt;&lt;/a&gt;Leetcode-11 盛最多水的容器&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water/&quot;&gt;https://leetcode-cn.com/problems/container-with-most-water/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxArea&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(height []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 6.【正则表达式匹配LeetCode-10】</title>
    <link href="http://example.com/2021/07/28/go-leetcode/go-leetcode-6/"/>
    <id>http://example.com/2021/07/28/go-leetcode/go-leetcode-6/</id>
    <published>2021-07-28T04:00:00.000Z</published>
    <updated>2021-07-28T14:01:40.988Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-10-正则表达式匹配"><a href="#Leetcode-10-正则表达式匹配" class="headerlink" title="Leetcode-10 正则表达式匹配"></a>Leetcode-10 正则表达式匹配</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/regular-expression-matching/">https://leetcode-cn.com/problems/regular-expression-matching/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="基础解法"><a href="#基础解法" class="headerlink" title="基础解法"></a>基础解法</h2><p>我们先理一下正则匹配的大致思路：<strong>逐个对比s和p两个字符串，匹配则继续往后，发现不匹配直接退出</strong>。</p><p>那么，我们先简化一下问题，看看代码的大致结构：</p><h3 id="普通字符串匹配"><a href="#普通字符串匹配" class="headerlink" title="普通字符串匹配"></a>普通字符串匹配</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> || <span class="built_in">len</span>(p) == <span class="number">0</span> || s[<span class="number">0</span>] != p[<span class="number">0</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码思路很清晰，我们重点要解决的是两个通配符<code>.</code>和<code>*</code>：</p><h3 id="单个字符匹配"><a href="#单个字符匹配" class="headerlink" title="单个字符匹配"></a>单个字符匹配</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> || <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果p[0]为. ，则必定匹配</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] != p[<span class="number">0</span>] &amp;&amp; p[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配"><a href="#匹配" class="headerlink" title="*匹配"></a>*匹配</h2><p>接下来，我们就要解决最复杂的*匹配，也就是star符号。具体的解法我在下面给出，大家可以参考注释阅读：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 边界情况，即s为空，p前两个为 x*</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(p) &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> isMatch(s, p[<span class="number">2</span>:])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p是否为 x* 形式</span></span><br><span class="line"><span class="keyword">var</span> hasStar <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(p) &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">hasStar = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isMatch表示s与p的第一个字符是否匹配</span></span><br><span class="line"><span class="keyword">var</span> isMatched = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> s[<span class="number">0</span>] != p[<span class="number">0</span>] &amp;&amp; p[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">isMatched = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hasStar &#123;</span><br><span class="line"><span class="keyword">if</span> isMatched &#123;</span><br><span class="line"><span class="comment">// 情况1： 有星且第一个字符匹配，则递归包括2个情况：s去掉第一个字符，p去掉star这两个字符</span></span><br><span class="line"><span class="keyword">return</span> isMatch(s[<span class="number">1</span>:], p) || isMatch(s, p[<span class="number">2</span>:])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况2：有星且不匹配，则去掉p的前两个字符继续匹配</span></span><br><span class="line"><span class="keyword">return</span> isMatch(s, p[<span class="number">2</span>:])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !isMatched &#123;</span><br><span class="line"><span class="comment">// 情况3：没星且不匹配，则直接返回不匹配</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况4：没有星但是匹配，s和p删掉匹配的第一个字符，继续匹配</span></span><br><span class="line"><span class="keyword">return</span> isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解法虽然看过去复杂，但是比较直观，核心在于两个变量<code>hasStar</code>和<code>isMatch</code>，以及它们组合起来的四个情况。</p><h2 id="动态规划解"><a href="#动态规划解" class="headerlink" title="动态规划解"></a>动态规划解</h2><p>动态规划是一个面试高频的题，其核心是<strong>状态转移方程</strong>。这道题很符合动态规划的特征，我们通过了上面的递归解法，其实已经有了基本的思路：<strong>递归中的四种情况，其实就是状态转移方程的大致思路</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">row, col := <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp 就是核心的状态转移方程，这里注意要+1，是为了空字符串这个边界条件</span></span><br><span class="line"><span class="comment">// 所以后面的i/j默认都要-1</span></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, row+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, col+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充dp[0]数组，也就是s为空字符串</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; col+<span class="number">1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// p为空字符串的情况</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line"><span class="comment">// 如果p[j-1]为*，则可以认为匹配p和p[0:j-2]一样，类似于情况2</span></span><br><span class="line">dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-2</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充整个dp数组，注意i和j在dp中不变，但对应到字符串s/p中都要-1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; row+<span class="number">1</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; col+<span class="number">1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// 对应情况1，有星且第一个字符匹配</span></span><br><span class="line">dp[i][j] = dp[i][j<span class="number">-2</span>] || dp[i<span class="number">-1</span>][j]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 对应情况2，有星且不匹配</span></span><br><span class="line">dp[i][j] = dp[i][j<span class="number">-2</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// 对应情况4，没有星但是匹配</span></span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其余的对应情况3，没星且不匹配，即默认false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[row][col]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要有了递归解法的思路，动态规划的难度并不高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们又完成了一道hard级别的题目！</p><p>这道题，让我们看到了递归与动态规划存在共性。其中，递归解法的核心思路是<strong>将问题拆解为复杂度更低的子问题，直到边界情况</strong>，而动态规划解法的核心思路是<strong>从边界情况开始推导，从复杂度低的问题推导出复杂度更高的问题</strong>。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-10-正则表达式匹配&quot;&gt;&lt;a href=&quot;#Leetcode-10-正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-10 正则表达式匹配&quot;&gt;&lt;/a&gt;Leetcode-10 正则表达式匹配&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/regular-expression-matching/&quot;&gt;https://leetcode-cn.com/problems/regular-expression-matching/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isMatch&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(s &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;, p &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
</feed>
