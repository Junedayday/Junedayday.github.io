<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"8.0.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="Blog信息">
<meta property="og:type" content="website">
<meta property="og:title" content="Junedayday Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Junedayday Blog">
<meta property="og:description" content="Blog信息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Junedayday">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Junedayday Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Junedayday Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">六月天天的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Junedayday</p>
  <div class="site-description" itemprop="description">Blog信息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/24/sharing-5min/2022-01/2022Week04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/sharing-5min/2022-01/2022Week04/" class="post-title-link" itemprop="url">五分钟技术小分享 - 2022Week04</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-01-24 12:00:00 / 修改时间：22:34:58" itemprop="dateCreated datePublished" datetime="2022-01-24T12:00:00+08:00">2022-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">每日技术分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg" alt="2022-01"></p>
<h2 id="2022-01-24-CNCF-Linkerd"><a href="#2022-01-24-CNCF-Linkerd" class="headerlink" title="2022-01-24 CNCF-Linkerd"></a>2022-01-24 CNCF-Linkerd</h2><p>今天我们来看 <strong>Orchestration &amp; Management 编排和管理</strong> 层最后一个核心项目 - Linkerd。从严格意义上来说，我们应称它为Linkerd2，区别于原来的1.0版本。</p>
<blockquote>
<p>Linkerd是Service Mesh的第一个产品，但在Google的Istio入场后在功能与性能上完全超越。这一段的历史很有意思，大家可以自行搜索了解。</p>
</blockquote>
<p>关于Service Mesh，我们已经聊过两款CNCF中的软件了 - Envoy/Contour，这个Linkerd是两者的结合。我们来看一下它的架构示意图，整体来说分为三块：</p>
<img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/control-plane.png" alt="Linkerd2" style="zoom:50%;" />

<ol>
<li>CLI - 客户端，对Linkerd2进行管理</li>
<li>Control Plane 控制平面<ol>
<li>destination 获取各类信息，如服务发现、网络策略、性能和监控指标</li>
<li>indentity 主要是TLS安全相关</li>
<li>proxy-injector 是一种Kubernetes的Admission Controller，用于对初始化pod注入linkerd相关的信息</li>
</ol>
</li>
<li>Data Plane 数据平面<ol>
<li>linkerd-proxy 核心的功能实现，包括代理、路由、TLS、限流等等</li>
<li>linkerd-init 是一种Kubernetes的Init Containter，用iptables的特性将Pod的流量都导向linkerd-proxy</li>
</ol>
</li>
</ol>
<p>Linkerd的架构非常清晰明了，与Kubernetes的特性紧密结合。我们也不难看到，它的核心能力非常依赖linkerd-proxy这个组件。linkerd-proxy采用了Rust语言编写，而对应的Envoy使用的是C++，从性能来看两者相差无几，更多地是语言生态上的选择不同。</p>
<p>我们再一起读一段<a target="_blank" rel="noopener" href="https://linkerd.io/what-is-a-service-mesh/">Linkerd官方对Service Mesh的定义</a>：</p>
<blockquote>
<p>A service mesh like Linkerd is a tools for adding observability, security, and reliability features to “cloud native” applications by transparently inserting this functionality at the platform layer rather than the application layer.</p>
</blockquote>
<ul>
<li><p>observability - 可观察性：logging、metrics、tracing</p>
</li>
<li><p>security - 安全性：TLS等特性</p>
</li>
<li><p>reliability - 可靠性：体现在对网络层的统一管理</p>
</li>
</ul>
<p>从目前来看，Linkerd仍处于一个比较早期的阶段，对标Istio还有大量的功能缺失，我在短期内不太看好。不过它引入了Rust语言有可能吸引一批优秀的人才，成为突破口。</p>
<h2 id="2022-01-25-Go1-18的两个教程"><a href="#2022-01-25-Go1-18的两个教程" class="headerlink" title="2022-01-25 Go1.18的两个教程"></a>2022-01-25 Go1.18的两个教程</h2><p>在1月初，我们已经一起看了Go官方对1.18的新特性讲解，想回顾的朋友可以点击这个链接：<a target="_blank" rel="noopener" href="https://junedayday.github.io/2022/01/04/sharing-5min/2022-01/2022Week01/#2022-01-04-Go1-18%E6%A6%82%E8%A7%88">Go1.18概览</a>。前几天，官方又发布了对泛型和Fuzzing的两个教程，我们再一起浏览下，查漏补缺。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://go.dev/doc/tutorial/generics">Tutorial: Getting started with generics</a></li>
<li><a target="_blank" rel="noopener" href="https://go.dev/doc/tutorial/fuzz">Tutorial: Getting started with fuzzing</a></li>
</ul>
<h3 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumIntsOrFloats</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">int64</span> | <span class="title">float64</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span> <span class="title">V</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s V</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        s += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>comparable 是个关键词，指得是支持操作符<code>==</code> 和 <code>!=</code></li>
<li>int64 | float64 则用简洁的语法表示了两种支持的类型</li>
</ul>
<p>但第二点，如果支持的类型太多，就需要做一次抽象，如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Number <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int64</span> | <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumNumbers</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">Number</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span> <span class="title">V</span></span> &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言的泛型表示方法非常简单，其支持的能力也很有限。相对于C++与JAVA中的泛型，无疑逊色了很多。我们可以简单地归纳Go泛型的使用场景：用于 <strong>基础类型</strong> 的通用操作，如int/int32/int64/float64等这种重复性很高的基本运算。</p>
<p>作为一种标准，Go的泛型落地非常坎坷，短期内官方也不太可能在这块扩增新的特性，所以Go的泛型适用性会比较窄。</p>
<p>随着1.18的完全落地，我们可以在很多基础库中看到泛型的实践，到时候我们再可以根据具体case进行了解。</p>
<h3 id="Fuzzing"><a href="#Fuzzing" class="headerlink" title="Fuzzing"></a>Fuzzing</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuzzReverse</span><span class="params">(f *testing.F)</span></span> &#123;</span><br><span class="line">    testcases := []<span class="keyword">string</span>&#123;<span class="string">&quot;Hello, world&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;!12345&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, tc := <span class="keyword">range</span> testcases &#123;</span><br><span class="line">        f.Add(tc)  <span class="comment">// Use f.Add to provide a seed corpus</span></span><br><span class="line">    &#125;</span><br><span class="line">    f.Fuzz(<span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, orig <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        rev := Reverse(orig)</span><br><span class="line">        doubleRev := Reverse(rev)</span><br><span class="line">        <span class="keyword">if</span> orig != doubleRev &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;Before: %q, after: %q&quot;</span>, orig, doubleRev)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> utf8.ValidString(orig) &amp;&amp; !utf8.ValidString(rev) &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;Reverse produced invalid UTF-8 string %q&quot;</span>, rev)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对于传统的单元测试，Fuzzing Test更强调一种 <strong>不确定性的输入</strong> 理念 - 由于输入的数据是随机的，输出往往是不确定的，那我们最好可以通过一定的操作，<strong>减少甚至消除输出的不确定性</strong>，才能保证测试的完备性：</p>
<p>比如说，示例中对字符串的反转，转变成了两个测试点：</p>
<ol>
<li>Reversing a string twice preserves the original value 即两次反转后成为原字符串，</li>
<li>The reversed string preserves its state as valid UTF-8 字符串依然为UTF-8编码格式</li>
</ol>
<p>从输入和输出来看，如果每个输入都对应枚举出一个输出，那就是单元测试；而Fuzzing Test的理念是尽可能地将输出做到可控，更方便地写各种测试。</p>
<p>在实际工程中，能用到Fuzzing特性的地方很少，更多地还是依赖简单地单元测试保障我们的代码质量。</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/23/go-tip/go-tip-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/23/go-tip/go-tip-13/" class="post-title-link" itemprop="url">Go语言技巧 - 13.【浅析微服务框架】Go-Kit概览</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-01-23 12:00:00 / 修改时间：21:35:59" itemprop="dateCreated datePublished" datetime="2022-01-23T12:00:00+08:00">2022-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="Go-Kit概况"><a href="#Go-Kit概况" class="headerlink" title="Go-Kit概况"></a>Go-Kit概况</h2><p>截止到本文发布时，<code>Go-Kit</code>在github上的star数为22.2k，超过了我们已经一起看过的<code>Go-Micro</code>与<code>Kratos</code>。</p>
<p><code>Go-Kit</code>不同于前两者，它更像是一种Go语言的工具集，而不是一种统一化的框架。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/01/23/go-tip/go-tip-13/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/17/sharing-5min/2022-01/2022Week03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/17/sharing-5min/2022-01/2022Week03/" class="post-title-link" itemprop="url">五分钟技术小分享 - 2022Week03</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-17 12:00:00" itemprop="dateCreated datePublished" datetime="2022-01-17T12:00:00+08:00">2022-01-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-01-22 21:49:36" itemprop="dateModified" datetime="2022-01-22T21:49:36+08:00">2022-01-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">每日技术分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg" alt="2022-01"></p>
<h2 id="2022-01-17-CNCF-gRPC"><a href="#2022-01-17-CNCF-gRPC" class="headerlink" title="2022-01-17 CNCF-gRPC"></a>2022-01-17 CNCF-gRPC</h2><p>今天，我们一起来看CNCF的 <strong>Remote Procedure Call - RPC</strong> 模块中最具代表性的项目 - gRPC。</p>
<p>gRPC官网的定义很简洁，重点强调了其<strong>高性能</strong>的特点：</p>
<blockquote>
<p>A high performance, open source universal RPC framework.</p>
</blockquote>
<p>我们再看一段官方更详细的描述：</p>
<blockquote>
<p>gRPC is a modern open source high performance Remote Procedure Call (RPC) framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking and authentication. It is also applicable in last mile of distributed computing to connect devices, mobile applications and browsers to backend services.</p>
</blockquote>
<p>除了高性能，这里还提到了两个重要特性：</p>
<ul>
<li><strong>插件化的支持</strong>：负载均衡、tracing、健康监测、认证等</li>
<li><strong>最后一公里</strong>：将手机app、浏览器与后端服务器的联通</li>
</ul>
<p>第一点体现出了gRPC的高度可扩展性。这里的插件化不仅体现在上面列举的这些具体功能，甚至像序列化的方案、底层通信的协议，都可以做到快速替换与迭代。</p>
<p>第二点在实际生产上应用的case并不多，仍需要大量的实践与经验沉淀后，才建议大家尝试。目前，绝大多数的gRPC通信都是发生在后端服务之间。</p>
<p>接下来，我们来谈谈官网列举的四个特性：</p>
<h3 id="Simple-service-definition"><a href="#Simple-service-definition" class="headerlink" title="Simple service definition"></a>Simple service definition</h3><p>gRPC采用<code>Protocol Buffers</code>进行定义，从整体来说阅读体验确实是比较简洁的，但在实际工程中仍存在两个问题：</p>
<ol>
<li><strong>迁移成本大</strong>：gRPC没有提供从很多历史RPC解决方案中迁移的途径，如Thrift等，完全是另起炉灶，这对有历史包袱的团队来说很难接受；</li>
<li><strong>配套开发工具缺失</strong>：高频使用<code>Protocol Buffers</code>的朋友都有了解，主流IDE对<code>pb</code>文件的错误提示和文件格式化都有缺失，很多问题都无法在coding的过程中实时提示，而是需要运行二进制命令<code>protoc</code>后才能了解。</li>
</ol>
<h3 id="Start-quickly-and-scale"><a href="#Start-quickly-and-scale" class="headerlink" title="Start quickly and scale"></a>Start quickly and scale</h3><p><strong>快速启动</strong> - 强调的是通过<code>Protocol Buffers</code>生成的代码，可以在各语言内用简洁的代码就可运行（这部分与各语言强相关）</p>
<p><strong>快速扩容</strong> - 这个特性需要与<code>Kubernetes</code>的能力结合。</p>
<h3 id="Works-across-languages-and-platforms"><a href="#Works-across-languages-and-platforms" class="headerlink" title="Works across languages and platforms"></a>Works across languages and platforms</h3><p>跨语言与平台的特性，非常依赖背后的生态 - 需要大量的工作去兼容多语言，也要兼顾性能、稳定性等问题。</p>
<p>所以，这不仅仅是技术上的问题，更需要社区、资金等复杂因素的支持。</p>
<h3 id="Bi-directional-streaming-and-integrated-auth"><a href="#Bi-directional-streaming-and-integrated-auth" class="headerlink" title="Bi-directional streaming and integrated auth"></a>Bi-directional streaming and integrated auth</h3><ul>
<li><strong>双向流式通信</strong> - 这点是gRPC的核心特性，体现出了与其它RPC方案的差异</li>
<li><strong>集成认证功能</strong> - Auth是gRPC插件化生态中的重要一环，这部分其实与服务网格的功能存在一定的重叠</li>
</ul>
<h2 id="2022-01-18-CNCF-Envoy"><a href="#2022-01-18-CNCF-Envoy" class="headerlink" title="2022-01-18 CNCF-Envoy"></a>2022-01-18 CNCF-Envoy</h2><p>作为云原生Service Mesh代表性的产品之一，Envoy占据了大壁江山。</p>
<blockquote>
<p>Envoy is an L7 proxy and communication bus designed for large modern service oriented architectures.</p>
</blockquote>
<ol>
<li>定位：L7 代理和通信总线</li>
<li>重点服务对象：SOA面向服务架构（也完全适用于微服务架构）</li>
</ol>
<p>核心理念：</p>
<blockquote>
<p>The network should be transparent to applications. When network and application problems do occur it should be easy to determine the source of the problem.</p>
<p>网络应对应用程序透明。当网络和应用程序出现问题时，应该很容易地确定问题根源。</p>
</blockquote>
<p>文档资料：</p>
<ul>
<li>官方：<a target="_blank" rel="noopener" href="https://www.envoyproxy.io/docs/envoy/latest/intro/intro">https://www.envoyproxy.io/docs/envoy/latest/intro/intro</a></li>
<li>中文版：<a target="_blank" rel="noopener" href="https://www.servicemesher.com/envoy/">https://www.servicemesher.com/envoy/</a></li>
</ul>
<p>我们依旧挑选三个核心特性展开：</p>
<h3 id="Out-of-process-architecture-进程外架构"><a href="#Out-of-process-architecture-进程外架构" class="headerlink" title="Out of process architecture 进程外架构"></a>Out of process architecture 进程外架构</h3><p>进程外架构，其实就是一种微服务理念的体现，它的利与弊也是和微服务强相关的。</p>
<p>优点很直观 - Envoy可以支持多语言，也可以独立于业务快速迭代与发展。</p>
<p>而弊端在官网上没有体现，最关键的一点是：<strong>性能损耗</strong>。作为一种side-car模式，Envoy是在本机内、进程间进行通信，远远地比进程内调用的压栈、出栈更花时间。</p>
<h3 id="Service-discovery-and-dynamic-configuration-服务发现和动态配置"><a href="#Service-discovery-and-dynamic-configuration-服务发现和动态配置" class="headerlink" title="Service discovery and dynamic configuration 服务发现和动态配置"></a>Service discovery and dynamic configuration 服务发现和动态配置</h3><p>很多运维同学都会拿Envoy去对比Nginx，确实在很多特性上，两者有很大的相似之处。但在这个特性上，Envoy有得天独厚的优势。</p>
<p>以一个常见的动态负载均衡为例，nginx需要结合consul template来实现，还需要对应用程序做一定的侵入。而Envoy可以与Kubernetes完美契合，大幅度减少维护成本。</p>
<h3 id="Best-in-class-observability-最佳的可观察性"><a href="#Best-in-class-observability-最佳的可观察性" class="headerlink" title="Best in class observability 最佳的可观察性"></a>Best in class observability 最佳的可观察性</h3><p>Envoy 的最主要目标是使网络透明，而最佳的可观测性往往会从OpenTelemetry推荐的三点入手：Metrics、Logging、Tracing。</p>
<p>Envoy提供了大量的插件，一方面保证了Envoy内部的问题清晰明了，同时也能快速地协助定位到应用侧的问题。</p>
<h2 id="2022-01-19-CNCF-Contour"><a href="#2022-01-19-CNCF-Contour" class="headerlink" title="2022-01-19 CNCF-Contour"></a>2022-01-19 CNCF-Contour</h2><p>作为CNCF中的控制平面的主打产品，Contour的知名度远不如Google的Istio。但由于种种原因，Istio并没有被捐献给云原生基金会，于是CNCF就孵化了Contour。</p>
<blockquote>
<p>定义</p>
<p>Contour is an open source Kubernetes ingress controller providing the control plane for the Envoy edge and service proxy. Contour supports dynamic configuration updates and multi-team ingress delegation out of the box while maintaining a lightweight profile.</p>
<p>三大特性</p>
<ul>
<li>Envoy Inside</li>
<li>Flexible Architecture</li>
<li>TLS Certificate Delegation</li>
</ul>
</blockquote>
<p>从定义与三个特性的描述里，我们很难真实地感受到Contour的特点。</p>
<p>今天我将换一个角度：从控制平面与数据平面进行分析。如果我们能清楚地认识到这两者的定义与边界，那么会对云原生的Service Mesh理念，以及Envoy、Contour、Istio等产品有更深的理解。</p>
<p><a target="_blank" rel="noopener" href="http://dockone.io/article/9919">这篇博客</a>的定义很具有参考意义：</p>
<ul>
<li><strong>控制平面</strong> - 通过配置和控制消息来组织编排网络的逻辑，并下发给数据平面</li>
<li><strong>数据平面</strong> - 以 Sidecar 的形式与应用部署在一起，承载其流量的发送与接收</li>
</ul>
<p>控制平面的关键功能就是<strong>控制与管理</strong>，重点对象是<strong>配置信息</strong>。</p>
<p>我们可以将数据平面看作为基础的Nginx服务，它是和底层的应用强相关的，解析相关的数据包并实现路由、负载均衡等功能。但Nginx自身也需要有一定的配置信息，比如说：</p>
<ul>
<li>数据平面的服务发现中心往往是因服务而异的；</li>
<li>数据平面的超时参数会频繁调整；</li>
<li>在做蓝绿测试时，需要频繁调整流量；</li>
<li>认证相关的设置往往需要统一更新，如证书；</li>
</ul>
<p>在我看来，控制平面更像是数据平面的配置中心，解决的是高频变化或应用间差异性很大的配置信息，让数据平面更稳定地运行。</p>
<blockquote>
<p>从架构层面来说，如果一层解决不了问题，那就再抽象一层。</p>
</blockquote>
<p>从具体的工程实践来说，数据平面主要负责的是底层实现，在保证稳定性的情况下更要兼具性能，所以不宜有太多丰富的功能。这时，引入了控制平面，我们可以将很多的配置信息通过界面UI方式进行管理，下发到各个控制平面，然后控制平面再针对性地进行转发到数据平面，就能大幅度地提高整个Service Mesh方案的可维护性。</p>
<h2 id="2022-01-20-CNCF-Emissary-Ingress"><a href="#2022-01-20-CNCF-Emissary-Ingress" class="headerlink" title="2022-01-20 CNCF-Emissary-Ingress"></a>2022-01-20 CNCF-Emissary-Ingress</h2><p>Emissary-Ingress是CNCF中又一个与网络相关的项目。这款软件的前身叫作Ambassador。但Ambassador是一款商业软件，为了避免相关的问题，更名为Emissary-Ingress后被捐献给了CNCF。因为网上资料更多的都是Ambassador，下面统一用Ambassador对这款软件进行描述。</p>
<p>CNCF上的定义为：</p>
<blockquote>
<p>open source Kubernetes-native API gateway for microservices built on the Envoy Proxy</p>
</blockquote>
<p>我们很容易将这个产品与Istio、Envoy混淆起来，那它们之间的区别是什么呢？这里有篇<a target="_blank" rel="noopener" href="https://itnext.io/ambassador-and-istio-edge-proxy-and-service-mesh-814aac9f23df">文章</a>，介绍了具体的实践，但我们直接可以从标题中得到关键信息：</p>
<ul>
<li>Ambassador - Edge proxy</li>
<li>Istio - service mesh</li>
</ul>
<p>而Envoy+Contour对标的是Istio，所以不难看出，云原生推荐将Ambassador作为一种边缘网关，更多地是作为整体流量的出入口。如果说service mesh是一种对网络的精细化管理，那么边缘网关更多地是对整体流量的管理。</p>
<p>但在实际使用中，两者有大量的重叠功能，如路由、认证、限速等，而我也没有在网上找到相关的Best Practice，这部分就很需要大家的经验与摸索了。从我的角度来看，更倾向于大家多使用Envoy的特性，毕竟它的生态最成熟。即便后续有了替代品，对方也往往会提供对应的兼容方案。</p>
<p>这里，我引用了一个<a target="_blank" rel="noopener" href="https://www.getambassador.io/docs/emissary/latest/topics/concepts/microservices-api-gateways/#microservices-api-gateways-vs-enterprise-api-gateways">链接</a>，讲述了微服务网关(Emissary-Ingress定位)与传统企业级网关的差异。</p>
<h3 id="Primary-Purpose-主要目标"><a href="#Primary-Purpose-主要目标" class="headerlink" title="Primary Purpose 主要目标"></a>Primary Purpose 主要目标</h3><ul>
<li>传统企业级网关 - Expose, compose, and manage internal business APIs</li>
<li>微服务网关 - Expose and observe internal business services</li>
</ul>
<p>微服务网关相对而言会更轻量级，而且对外以服务的维度呈现。</p>
<h3 id="Publishing-Functionality-发布功能"><a href="#Publishing-Functionality-发布功能" class="headerlink" title="Publishing Functionality 发布功能"></a>Publishing Functionality 发布功能</h3><ul>
<li>传统企业级网关 - API management team or service team registers / updates gateway via admin API</li>
<li>微服务网关 - Service team registers / updates gateway via declarative code as part of the deployment process</li>
</ul>
<p>微服务网关更倡导自运维的方式。</p>
<h3 id="Handling-and-Debugging-Issues-处理和Debug问题"><a href="#Handling-and-Debugging-Issues-处理和Debug问题" class="headerlink" title="Handling and Debugging Issues 处理和Debug问题"></a>Handling and Debugging Issues 处理和Debug问题</h3><ul>
<li><p>传统企业级网关 - L7 error-handling (e.g. custom error page or payload). Run gateway/API with additional logging. Troubleshoot issue in staging environment</p>
</li>
<li><p>微服务网关 - Configure more detailed monitoring. Enable traffic shadowing and / or canarying</p>
</li>
</ul>
<p>微服务网关更强调的是网络侧的更细致化的管理，突出了灵活性。</p>
<h2 id="2022-01-21-谈谈Context在Go程序外的传递"><a href="#2022-01-21-谈谈Context在Go程序外的传递" class="headerlink" title="2022-01-21 谈谈Context在Go程序外的传递"></a>2022-01-21 谈谈Context在Go程序外的传递</h2><p>这两天，有个读者跟我讨论了一个关于链路追踪的问题 - 他发现通过context传递的trace-id丢失了。从根本上来说，这涉及到了<strong>Context在Go程序外的传递</strong>的理解，细想的话很有意思，所以我今天专门拿出来讲讲。</p>
<p>如果你对Go语言有一定的基础，会很习惯地使用Context作为上下文信息的传递：无论是内部函数的调用，还是RPC的调用，这就会产生一种错觉：<strong>context的传递是水到渠成的</strong>。</p>
<p>这位同学的调用链路是 Go程序 - MQ - Go程序，发现context中的trace-id丢失了。</p>
<blockquote>
<p>trace-id用于分布式的链路追踪</p>
</blockquote>
<p>分析这个问题不难，有很多种思路，但我比较建议大家从底层实现去理解：</p>
<ol>
<li>context的本质，是一种key-value的数据结构；</li>
<li>服务之间的调用，本质上是一种网络上的二进制数据的传递，而<strong>context信息肯定是保存在其中的</strong>；</li>
<li>HTTP是一种二进制数据上的协议表达格式，我们常见的RESTful API 的 json数据是填入到body中，但HTTP协议还有很多地方可以保存数据，尤其是HTTP Header。context信息大概率是被保存在Header里的；</li>
</ol>
<p><strong>Go语言的Client将context封装到Header里，Server将context从Header中解析出来</strong>。</p>
<blockquote>
<p>默认的官方库是不会写直接写的，需要做一层浅封装：</p>
<p>发送前，从ctx中将对应的k-v填入到header；</p>
<p>收到后，从header中提取k-v，写入到context。</p>
</blockquote>
<p>要验证一下上面的猜想很简单，我强烈大家用最底层的方式：<strong>Wireshark抓包</strong>。事实也如我们的预期，Go语言的ctx传递正是用这种方式实现的。而MQ这种第三方组件，往往不会去解析这种特定的Header，所以会发生丢失。</p>
<p>这时，我们有什么样的解决方案呢？</p>
<ol>
<li>制定标准。这也是OpenTracing等规范推崇的，对广大的开发者来说非常友好，尤其是跨语言的情况，但这块非常依赖生态，需要大量的SDK，整体来说推进进度比较难。（这就体现了Service Mesh的价值）</li>
<li>显示传递。相当于把关键信息填到HTTP的body里，对具体代码的实现来说侵入性很强，但不失为中小型公司快速落地的方案；遇到一些不支持标准的第三方软件，我们也往往只能采用这种方式。</li>
</ol>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/10/sharing-5min/2022-01/2022Week02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/10/sharing-5min/2022-01/2022Week02/" class="post-title-link" itemprop="url">五分钟技术小分享 - 2022Week02</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-10 12:00:00" itemprop="dateCreated datePublished" datetime="2022-01-10T12:00:00+08:00">2022-01-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-01-15 21:28:52" itemprop="dateModified" datetime="2022-01-15T21:28:52+08:00">2022-01-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">每日技术分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg" alt="2022-01"></p>
<h2 id="2022-01-10-Unix设计哲学概览"><a href="#2022-01-10-Unix设计哲学概览" class="headerlink" title="2022-01-10 Unix设计哲学概览"></a>2022-01-10 Unix设计哲学概览</h2><p>Unix设计哲学在程序员的圈子里经久不衰，备受追捧。而<code>Go</code>语言背后有很多<code>Unix</code>与<code>C语言</code>的影子，三位创始人Rob Pike（罗伯. 派克），Ken Thompson（肯. 汤普森）和Robert Griesemer（罗伯特. 格利茨默）都是这两块领域的泰山北斗。了解Unix的设计哲学，对写出优秀的代码很有帮助。</p>
<ul>
<li>英文资料 - <a target="_blank" rel="noopener" href="https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html">https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html</a></li>
<li>中文wiki - <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unix%E5%93%B2%E5%AD%A6">https://zh.wikipedia.org/wiki/Unix%E5%93%B2%E5%AD%A6</a></li>
</ul>
<h3 id="Doug-McIlroy的总结"><a href="#Doug-McIlroy的总结" class="headerlink" title="Doug McIlroy的总结"></a>Doug McIlroy的总结</h3><blockquote>
<p>Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface.</p>
<p>做一件事，做好它。让程序能够互相协同工作。应该让程序处理文本数据流，因为这是一个通用的接口。</p>
</blockquote>
<p>作为管道机制的发明者，Doug McIlroy对这块的解释重点很具有管道特色。这里，我们聚焦于一个点：<strong>做好一件事</strong>。</p>
<p>将其拆分一下，主要分为两块：</p>
<ol>
<li><strong>做好。</strong>做一件事，可能只需要10分的能力；而做好，则需要100分的能力（但 <code>做好</code> 这个标准，尽可能地按照自己的认知上限去做，才可能有成长）。</li>
<li><strong>一件事。</strong>怎么定义一件事呢？边界的定义就难倒了很多人。这个非常考验能力，更具体可能需要<code>case by case</code>去看。</li>
</ol>
<h3 id="Rob-Pike的总结"><a href="#Rob-Pike的总结" class="headerlink" title="Rob Pike的总结"></a>Rob Pike的总结</h3><blockquote>
<ol>
<li>你永远不会知道你的程序会在什么地方耗费时间。程序的瓶颈常常出现在意想不到的地方，因此在你确信找到瓶颈后再动手优化代码吧。</li>
<li>测试代码。只有在你详细测试了代码，并且发现一部分代码耗费了绝大部分的运行时间时再对程序作速度优化。</li>
<li>功能全面的算法（fancy algorithm）在处理小规模问题时效率很低，这是因为算法时间效率中的常量很大，而问题往往规模很小。除非你知道你遇到的常常是复杂的情况，否则就让代码丑陋但是简单而高效吧。（即使问题规模确实很大，也首先尝试第二条规则。）</li>
<li>功能全面的算法比简单的算法更容易产生bug，更难实现。尽量使用简单的算法和数据结构。</li>
<li>数据决定一切。如果选择的数据结构能很好的管理数据，算法部分往往不言自明。记住，数据结构，而非算法，才是编程的关键。</li>
<li>没有第六条规则。</li>
</ol>
</blockquote>
<p>按照wiki上的说法，1、2可以归纳为 <strong>过早的优化是一切罪恶的根源</strong>，3、4可以理解为 <strong>疑惑不定之时最适合穷举</strong>。</p>
<p>而第五条就非常有意思，也就是 <strong>数据结构比算法更重要</strong>。</p>
<p>这点，和我们在刷算法题时认知相反 - 在做算法题目时，我们往往已经得到了一个具体的数据结构，要做的更多是根据这个数据结构选择合适的算法。当数据结构确定时，可选择的算法就很有限了，这也大大缩小了题解的范围。</p>
<p>在复杂的场景中，我们首先得确定数据结构，这一步尤为复杂：</p>
<ol>
<li>复合 - 数据结构往往是复合的、嵌套的，单一的数据结构很少见；</li>
<li>抓住核心 - 可用数据结构解往往有多种，关键是识别其中决定性的因素；</li>
<li>不确定性 - 最优解的数据结构，往往会根据时间变化而变化；</li>
<li>简单性 - 性能最优解并不一定是最终的解，实际工程中多考虑简单性；</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关于Unix的设计哲学还有很多优秀的见解，但综合起来，可以归纳为<code>KISS</code>原则，也就是<strong>简单性</strong>。希望大家能在工程实践中，多多思考怎么保证简单性，对做出优秀的设计会很有启发。</p>
<h2 id="2022-01-11-CNCF-CrossPlane"><a href="#2022-01-11-CNCF-CrossPlane" class="headerlink" title="2022-01-11 CNCF-CrossPlane"></a>2022-01-11 CNCF-CrossPlane</h2><p>今天我们一起来看CNCF中的第二个项目 - <code>CrossPlane</code> 。它位于CNCF全景图中<code>Kubernetes</code>旁，受众比较小。</p>
<p>先看一段来自官网 <a target="_blank" rel="noopener" href="https://crossplane.io/">https://crossplane.io/</a> 的信息：</p>
<blockquote>
<p> Crossplane is an open source Kubernetes add-on that enables platform teams to assemble infrastructure from multiple vendors, and expose higher level self-service APIs for application teams to consume, without having to write any code.</p>
</blockquote>
<p>我们依旧抽取其中关键的词进行解析：</p>
<ul>
<li><code>Kubernetes add-on</code> CrossPlane的定位是<code>Kubernetes</code>的插件，并非一个独立的平台</li>
<li><code>assemble infrastructure from multiple vendors</code> 统一封装多个依赖方的基础设施</li>
<li><code>expose higher level self-service APIs</code> 暴露高层接口</li>
</ul>
<p>然后，官方描述了五个关键性的特征：</p>
<ul>
<li>Provision and manage cloud infrastructure and services using kubectl</li>
<li>There is a flavor of infrastructure for everyone on Crossplane</li>
<li>Publish simplified infrastructure abstractions for your applications</li>
<li>The Universal Cloud API</li>
<li>Run Crossplane anywhere</li>
</ul>
<p>概括起来，可以定义为：<strong>使用 kubectl 封装了各类云的API，来统一管理基础设施、服务和应用</strong>。</p>
<p>我们从具体的实践角度来看，统一封装接口往往只是加分项，而核心在于 <strong>支持的云基础设施与服务的范围</strong>。</p>
<p>从 <a target="_blank" rel="noopener" href="https://crossplane.io/docs/v1.6/getting-started/provision-infrastructure.html">官方文档</a> 可以看到，<code>CrossPlane</code>主要支持了亚马逊云、谷歌云、微软云等厂商。可以看到，这款产品主要面向的是<strong>国外的公有云厂商</strong>。这其实也决定了<code>CrossPlane</code>更多面向的是国外开发者。</p>
<p>学习<code>CrossPlane</code>的更多细节，对我们来说暂时没有更大的意义。我们可以尝试着从其理念中得到以下启发：</p>
<ol>
<li><strong>对接各类云厂商是复杂的。</strong>尽管<code>CNCF</code>统一了大致上的理念，但细节上的实现各有不同；尤其是结合了账号、权限、资源分配等各类特性后，对接起来的复杂度很高。</li>
<li><strong>如果一层不能解决，那就加一层。</strong> 直接对接各类公有云复杂度很高，也会为<code>Kubernetes</code>这个核心项目带来大量侵入性极强的代码。这时，引入另一个项目作为<strong>防腐层</strong>，很具有扩展意义。</li>
<li><strong>一个核心项目不一定需要做成大型平台，更重要的是它的特性符合整个生态的发展理念。</strong></li>
</ol>
<h2 id="2022-01-12-微服务架构特征"><a href="#2022-01-12-微服务架构特征" class="headerlink" title="2022-01-12 微服务架构特征"></a>2022-01-12 微服务架构特征</h2><p>今天的话题将围绕着一篇谈论微服务架构的文章展开。下面给出原文链接，以及一个翻译的版本：</p>
<ul>
<li>原文 - <a target="_blank" rel="noopener" href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a></li>
<li>中文翻译 - <a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15127669/4175353">https://blog.51cto.com/u_15127669/4175353</a> </li>
</ul>
<p>文中给出了以下九个微服务特征：</p>
<ol>
<li>Componentization via Services 通过服务来实现组件化</li>
<li>Organized around Business Capabilities 围绕业务能力构建</li>
<li>Products not Projects 面向产品，而不是面向项目</li>
<li>Smart endpoints and dumb pipes 终端智能化，通讯轻量化</li>
<li>Decentralized Governance 分散治理</li>
<li>Decentralized Data Management 数据去中心化管理</li>
<li>Infrastructure Automation 基础设施自动化</li>
<li>Design for failure 容错性设计</li>
<li>Evolutionary Design 演进式设计</li>
</ol>
<p>这些点，每个抛出来都可以写一篇长文。建议有兴趣的各位可以阅读原文，结合自己的实践多多思考。</p>
<p>这里，我选择三个最近感触比较深的点，自己也曾经陷入过的认知误区，在这里和大家聊聊：</p>
<h3 id="围绕业务能力构建"><a href="#围绕业务能力构建" class="headerlink" title="围绕业务能力构建"></a>围绕业务能力构建</h3><p>业务能力的概念很抽象，虽然我们会经常提及，但在实践过程中又往往容易忽略。</p>
<p>从系统的角度来看，业务能力往往就是对外呈现的功能，对应到内部的技术模块，往往已经决定了七七八八。如何将这些技术模块做合理的拆分与合并，就是微服务架构需要考量的点。这里我谈谈最近比较有心得的三个考量点：</p>
<ul>
<li>拆分高频变化与低频变化</li>
<li>分离计算密集型和IO密集型</li>
<li>基础能力尽早引入业界的通用模块</li>
</ul>
<p>当然，还有更多的内容，需要大家在实践中摸索。</p>
<h3 id="终端智能化，通讯轻量化"><a href="#终端智能化，通讯轻量化" class="headerlink" title="终端智能化，通讯轻量化"></a>终端智能化，通讯轻量化</h3><p>这一点在云原生的服务中体现得淋漓尽致：以<strong>RPC</strong>、<strong>Service Mesh</strong>、<strong>服务发现</strong>等技术为代表。</p>
<p>终端体现在<code>Pod</code>这一层，也就是对一个具体运行的App来说，通过Istio、CoreDNS等技术将分布式的服务做到和单体应用一致，然后通过轻量级的通讯方案，如HTTP进行交互。这种方式的优点很明显：</p>
<ol>
<li>分布式服务之间的通讯复杂度最高的部分，由专用的、成熟的组件，引入到Pod层面完成；</li>
<li>开发者的代码实现只需要关心RPC的数据出入，复杂度大幅度降低；</li>
</ol>
<p>目前云原生的Service Mesh技术还未完全形成行业标准，相信很快随着它的落地，将迎来微服务的又一波热潮。</p>
<h3 id="容错性设计"><a href="#容错性设计" class="headerlink" title="容错性设计"></a>容错性设计</h3><p>容错性设计，也就是为错误而设计，这一点很反直觉。</p>
<p>作为一名开发者，我们实现功能的思路往往是按照顺序的逻辑步骤；一个一个步骤的串联，才能保证最后的功能实现。但这个时候，如果要我们去关注各类错误的发生，小到网络波动、程序崩溃，大到机房断电，很容易无所适从。</p>
<p>这里，我谈谈自己的理解：<strong>主要从发生的概率与影响的严重程度来思考，不要过度追求细节</strong>。这里有一个很重要的权衡点 - **健壮性 **与 <strong>简单性</strong> ：一般来说，要保证程序足够健壮，会引入各种异常的容错性设计，增加系统的复杂度，但这一点并不是绝对的。</p>
<p><strong>从系统整体功能的维度，虽然看起来增加了复杂度，但通过分层、模块化、服务拆分等方式，分而治之 - 一些简单的模块用简单的规则组合成一个大模块，可维护性远远高于一个复杂的模块。</strong></p>
<h2 id="2022-01-13-CNCF-CoreDNS"><a href="#2022-01-13-CNCF-CoreDNS" class="headerlink" title="2022-01-13 CNCF-CoreDNS"></a>2022-01-13 CNCF-CoreDNS</h2><p><code>CoreDNS</code>是CNCF全景图中 <strong>协调与服务发现</strong> 模块的核心项目，在<code>Kubernetes</code>1.12版本之后成为了默认的DNS服务。熟悉<code>CoreDNS</code>是掌握<code>Kubernetes</code>必不可少的技能。</p>
<p>照例，我们先一起看下其核心定义，非常简洁明了：</p>
<blockquote>
<p>官网 - CoreDNS: DNS and Service Discovery</p>
<p>CNCF - CoreDNS is a DNS server that chains plugins</p>
</blockquote>
<p>今天，我们将围绕一个关键词<code>chains plugins</code> - <strong>链式插件</strong> 展开，这也是<code>CoreDNS</code>实现的核心特性。</p>
<p>官方对这个特性的定义如下，</p>
<blockquote>
<p>CoreDNS chains plugins. Each plugin performs a DNS function, such as Kubernetes service discovery, prometheus metrics, rewriting queries, or just serving from zone files. And many more.</p>
</blockquote>
<p>从中不难看出，<code>CoreDNS</code>将各种<code>DNS</code>的功能抽象成一个插件，进行链式调用。</p>
<p>我们用 <a target="_blank" rel="noopener" href="https://github.com/coredns/coredns">官方github上的Corefile</a> 来了解这个特性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example.org:1053 &#123;</span><br><span class="line">    file /var/lib/coredns/example.org.signed</span><br><span class="line">    transfer &#123;</span><br><span class="line">        to * 2001:500:8f::53</span><br><span class="line">    &#125;</span><br><span class="line">    errors</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. &#123;</span><br><span class="line">    any</span><br><span class="line">    forward . 8.8.8.8:53</span><br><span class="line">    errors</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>当访问<code>example.org:1053</code> 时，依次触发 file、transfer、errors、log四个插件</li>
<li>访问其余DNS时，依次触发 any、forward、errors、log四个插件</li>
</ol>
<p>上面的语法与<code>nginx</code>非常类似，而作者实际上是参考<code>Caddy</code>软件进行设计的，有兴趣的可以查阅相关资料，例如这个 <a target="_blank" rel="noopener" href="https://mritd.com/2021/06/30/understand-caddyfile-syntax/">博客</a>。</p>
<p>链式调用是一种表述形式非常强的语法：<strong>它以一个大众容易接受的顺序逻辑，讲述了一个完整的调用过程，将各个细节也描述地很清晰</strong>。</p>
<p>既然链式调用的描述方式那么棒，为什么目前没有大规模地推广到各类工具上呢？这里，我谈谈个人的三个理解：</p>
<ol>
<li><strong>核心模块支持插件化</strong> - 链式调用需要动态加载各类插件，这一点对核心的模块要求很高，很多软件设计之初就决定了很难走插件化的道路；</li>
<li><strong>无需兼容历史问题</strong> - 很多的工具都存在大量的历史版本，很难做到完全兼容这种表达形式；而<code>CoreDNS</code>在设计之初就强制采用这种规范，没有历史包袱；</li>
<li><strong>每个插件的输入与输出保持一致</strong> - 作为一种链式调用，为了保证前者输入可以作为后者输出，两者支持的数据格式必须一样（可以参考Unix中的管道）。DNS服务的功能比较简单，可以保证一致；</li>
</ol>
<p>同样的，Corefile这种声明方式，也或多或少带来了一些问题，例如：</p>
<ol>
<li><strong>文件解析的复杂性</strong>（这点与链式调用本身无关） - 比如数据类型的问题，很难确定文件中的<code>5</code>是数字还是字符串；</li>
<li><strong>链式调用很难解决前后有依赖的情况</strong> - 如调用A插件的结果有个特别的输出，用于插件B的输入时，很难解决；</li>
<li><strong>长链式调用的复杂度</strong> - 如果链式调用过长，一方面带来了异常情况下排查问题的复杂度，另一方面很容易出现性能问题；</li>
</ol>
<p><code>CoreDNS</code>的成功，<strong>链式调用插件</strong> 这个特性只体现了简单性的理念，并不是关键性的原因，而更多地是依赖大量开箱即用的<a target="_blank" rel="noopener" href="https://coredns.io/plugins/">插件</a>。</p>
<h2 id="2022-01-14-不可变基础设施"><a href="#2022-01-14-不可变基础设施" class="headerlink" title="2022-01-14 不可变基础设施"></a>2022-01-14 不可变基础设施</h2><p>看起来，这功能描述与<code>CICD</code>流程差不多，但使用体验差距很大。在传统的模式下，我们执行的是一个<strong>具体的动作</strong>，比如扩1个应用、升级2个程序等；而在k8s里，使用者只要<strong>声明最终的预期状态</strong>，比如5个应用运行v1.0版本的程序，那么整个系统该扩容还是缩容、该升级还是回滚，都由k8s自行根据当前状态进行判断。</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>ab4ea1c14f669e0e42040689da7aa074c4e479f3</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>云原生有五大代表性的技术 - <strong>容器、服务网格、微服务、不可变基础设施和声明式 API</strong>。相对于其余四种概念，不可变基础设施 - <code>Immutable Infrastructure</code> 更难理解，今天我们来一起看看。</p>
<blockquote>
<p>入门可以参考这篇文章 - <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/382203966">https://zhuanlan.zhihu.com/p/382203966</a> </p>
</blockquote>
<p>网上可搜索到的<strong>不可变基础设施</strong>定义有很多，这里我选择一个比较有代表性的：</p>
<blockquote>
<p>Immutable infrastructure refers to servers (or VMs) that are never modified after deployment.</p>
</blockquote>
<p>从开发者的角度来看，不可变基础设施是一个很棒的概念。如果用一个词总结它的优点，那就是 <strong>时间与空间上的一致性</strong>。</p>
<p>如果有一个传统应用希望改造成适配 <strong>不可变基础设施</strong> 的场景，那么会有哪些常见的改造点呢？</p>
<ol>
<li>将传统应用的运行环境打造成一个具体的服务器，例如虚拟机、容器；</li>
<li>重点分析该应用的输出形式，让其与 <strong>服务器无关</strong>；</li>
</ol>
<p>第二点有些抽象，这里我举三个具体的例子：</p>
<ol>
<li>本地缓存 - 转移到分布式缓存服务；</li>
<li>本地保存的文件 - 转移到分布式存储服务中；</li>
<li>本地日志 - 将原来打印到本地文件的日志服务，重定向到标准输出，由日志采集的side-car收集后统一汇总；</li>
</ol>
<p>但在实际的工程中，追求 <strong>不可变基础设施</strong> 很难完全落地，我们可以适当地做一些权衡：</p>
<ol>
<li>如果日志不允许落盘对部分程序的改造成本很高，那么我们可以用ELK等一套日志收集方案做准实时的同步，保证日志可丢失；</li>
<li>如果完全依赖分布式缓存对性能压力过大，那么就建立一套分布式缓存与本地缓存的自动同步机制，保证重启后本地缓存丢失，仍可以恢复；</li>
</ol>
<p>不难看出，只要我们保证应用在基础设施上产生的数据 <strong>可在任意时间丢失</strong>，就能实现了一定程度上 <strong>应用无状态化</strong>，也能保证了<strong>不可变基础设施</strong>的落地。</p>
<p><strong>不可变基础设施</strong>是一种理念，具体落地的技术非常依赖容器或虚拟机，以及分布式存储等配套设施。我们没有必要把它作为一种技术标准去强制执行，而应该结合现状，选择性地朝着这个方向不断优化。</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/sharing-5min/2022-01/2022Week01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/sharing-5min/2022-01/2022Week01/" class="post-title-link" itemprop="url">五分钟技术小分享 - 2022Week01</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-04 12:00:00" itemprop="dateCreated datePublished" datetime="2022-01-04T12:00:00+08:00">2022-01-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-01-11 14:50:57" itemprop="dateModified" datetime="2022-01-11T14:50:57+08:00">2022-01-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">每日技术分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg" alt="2022-01"></p>
<h2 id="2022-01-04-Go1-18概览"><a href="#2022-01-04-Go1-18概览" class="headerlink" title="2022-01-04 Go1.18概览"></a>2022-01-04 Go1.18概览</h2><p>在2021年年底，<code>Go</code>推出了<code>1.18Beta</code>版本。由于正式版本没有完全敲定，普通开发人员没有必要研究到底层实现，但如果能先形成一个全局上的认知，能帮助我们领先一步。</p>
<p>关于1.18的核心改动，是 <strong>对泛型(Generics)的支持</strong>。Go语言的泛型语法比较简单，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> numeric <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="keyword">int</span>, <span class="keyword">int8</span>, <span class="keyword">int16</span>, <span class="keyword">int32</span>, <span class="keyword">int64</span>, <span class="keyword">uint</span>, <span class="keyword">uint8</span>, <span class="keyword">uint16</span>, <span class="keyword">uint32</span>, <span class="keyword">uint64</span>, <span class="keyword">float32</span>, <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span>[<span class="title">T</span> <span class="title">numeric</span>]<span class="params">(a, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要在实际工程上落地，还有很多考量点，我这边重点提三点：</p>
<ol>
<li><strong>主流IDE的支持</strong> - 包括Goland与VSCode，尽量帮助开发者能在编码时发现问题；</li>
<li><strong>历史库的迁移与兼容</strong> - 实现泛型后，许多主流库会有大量的冗余函数，如何提供迁移方案，值得我们去关注；</li>
<li><strong>泛型的最佳工程实践</strong> - 作为一种新特性，Go的泛型如何应用在工程中、尤其是复杂工程中，需要一定的实践摸索，并总结规律（可借鉴其余支持泛型的语言）；</li>
</ol>
<p>除了泛型，另外一个比较大的特性就是<code>Fuzzy Testing</code>。</p>
<p>这个特性是为<strong>单元测试提供更全面的数据输入</strong>，这样就能覆盖更多的case，提前发现问题。关键词<code>Fuzzy</code>支持的主要特性是将一个输入参数，<strong>从具体的值变成范围</strong>，如原先输入<code>a=1</code>，现在支持<code>a</code>输入范围为<code>[-10,10]</code>。在跑单元测试时，大量的<code>Fuzzy</code>肯定会带来一定的性能压力，这时可以引入一定的并发特性。</p>
<p>总体来说，<code>Go1.18</code>对工程侧的影响更多地是提高代码的 <strong>简洁性</strong>。新特性的学习成本很低，我们不用过于急着引入，可以多花时间学习底层原理。</p>
<blockquote>
<p><strong>Go Blog</strong> - <a target="_blank" rel="noopener" href="https://go.dev/blog/go1.18beta1">https://go.dev/blog/go1.18beta1</a></p>
<p><strong>Medium</strong> - <a target="_blank" rel="noopener" href="https://betterprogramming.pub/golang-1-18-what-you-need-to-know-a5701f7e14ab">https://betterprogramming.pub/golang-1-18-what-you-need-to-know-a5701f7e14ab</a></p>
</blockquote>
<h2 id="2022-01-05-CNCF-概览"><a href="#2022-01-05-CNCF-概览" class="headerlink" title="2022-01-05 CNCF-概览"></a>2022-01-05 CNCF-概览</h2><p>CNCF作为云原生的代表性组织，提供了大量开源的软件，以及配套的、开箱即用的解决方案。有很多朋友对CNCF和云原生的认识可能仍停留在新闻报道里。今天，我先带大家在整体上入个门，后续选择具有代表性的软件进行分析。</p>
<blockquote>
<p>由于篇幅所限，我的分享只会提重点知识，帮大家建立这部分的知识框架，更详细的内容需要大家自行学习。</p>
</blockquote>
<p>CNCF的概览可以参考这个全景图 - <a target="_blank" rel="noopener" href="https://landscape.cncf.io/%EF%BC%8C%E6%9B%B4%E6%96%B0%E8%BF%AD%E4%BB%A3%E9%9D%9E%E5%B8%B8%E9%A2%91%E7%B9%81%E3%80%82%E5%85%B6%E4%B8%AD%EF%BC%8C%E6%9C%80%E6%A0%B8%E5%BF%83%E7%9A%84%E4%B8%BA%E4%B8%8B%E9%9D%A2%E4%BA%94%E5%9D%97%EF%BC%9A">https://landscape.cncf.io/，更新迭代非常频繁。其中，最核心的为下面五块：</a></p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/landscape.png" alt="landscape"></p>
<ul>
<li>App Definition and Development 应用定义与开发<ul>
<li>Database 数据库</li>
<li>Streaming &amp; Messaging 流处理和消息通信</li>
<li>Application Definition &amp; Image Build 应用定义与镜像构建</li>
<li>Continuous Integration &amp; Delivery 持续集成与交付</li>
</ul>
</li>
<li>Orchestration &amp; Management 编排和管理<ul>
<li>Scheduling &amp; Orchestration 调度与编排</li>
<li>Coordination &amp; Service Discovery 协调与服务发现</li>
<li>Remote Procedure Call 远程过程调用</li>
<li>Service Proxy 服务代理</li>
<li>API Gateway API网关</li>
<li>Service Mesh 服务网格</li>
</ul>
</li>
<li>RunTime 运行时<ul>
<li>Cloud Native Storage 云原生存储</li>
<li>Container Runtime 容器运行时</li>
<li>Cloud Native Network 云原生网络</li>
</ul>
</li>
<li>Provisioning 提供者<ul>
<li>Automation &amp; Configuration 自动化与配置</li>
<li>Container Registry 容器注册</li>
<li>Security &amp; Compliance 安全与合规</li>
<li>Key Management 密钥管理</li>
</ul>
</li>
<li>Observability and Analysis 可观察性和分析<ul>
<li>Monitoring 监控</li>
<li>Logging 日志</li>
<li>Tracing 跟踪</li>
<li>Chaos Engineering 混沌工程</li>
</ul>
</li>
</ul>
<p>其余还包括Kubernetes的平台提供商、Serverless、成员、认证的服务提供商等周边内容，并不在我们讨论的范围之内。但从基金会来看，它提供了一整套生态，非常有助于落地。</p>
<p>那么，如何认识这五块呢？其实Landscape提供了很好的图形效果，我们只要记住两点：</p>
<ol>
<li><strong>应用定义与开发</strong>、<strong>编排和管理</strong>、<strong>运行时</strong>、<strong>提供者</strong> 这四块是自上而下的核心链路，下层为上层提供能力支撑</li>
<li><strong>Observability and Analysis</strong> 是核心链路旁边的重要支撑</li>
</ol>
<p>相信到这里，你对CNCF已经有了初步认识。</p>
<h2 id="2022-01-06-《我做系统架构的一些原则》From-陈皓"><a href="#2022-01-06-《我做系统架构的一些原则》From-陈皓" class="headerlink" title="2022-01-06 《我做系统架构的一些原则》From 陈皓"></a>2022-01-06 《我做系统架构的一些原则》From 陈皓</h2><p>今天，给大家推荐一篇来自左耳朵耗子-陈皓的<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/21672.html">文章</a>。</p>
<ol>
<li>关注于真正的收益而不是技术本身</li>
<li>以应用服务和 API 为视角，而不是以资源和技术为视角</li>
<li>选择最主流和成熟的技术</li>
<li>完备性会比性能更重要</li>
<li>制定并遵循服从标准、规范和最佳实践</li>
<li>重视架构扩展性和可运维性</li>
<li>对控制逻辑进行全面收口</li>
<li>不要迁就老旧系统的技术债务</li>
<li>不要依赖自己的经验，要依赖于数据和学习</li>
<li>千万要小心 X – Y 问题，要追问原始需求</li>
<li>激进胜于保守，创新与实用并不冲突</li>
</ol>
<p>以上11点，理解会因人而异，我重点挑三个争议性比较大的聊聊，其余的内容建议大家阅读原文。</p>
<h3 id="完备性会比性能更重要"><a href="#完备性会比性能更重要" class="headerlink" title="完备性会比性能更重要"></a>完备性会比性能更重要</h3><p>借用书中的一句话：<strong>使用最科学严谨的技术模型为主，并以不严谨的模型作为补充</strong>，也就是先紧后松。</p>
<p>有不少开发者在实际工程中的实践往往相反：为了追求快速落地，会希望毕其功于一役，引入所谓的“一站式解决方案”（如例子中NoSQL），但实践下来引入大量的问题，让后人叫苦不迭。</p>
<p>关于这个问题，我个人有三个思考：</p>
<ul>
<li><strong>不断提高自己的基础能力</strong>。很多架构上的局限性，往往是设计者停留于自己的舒适区，不愿意往前一步。</li>
<li><strong>分清主次、合理分工。</strong> 在设计时，我们要分清楚核心功能和非核心功能，懂得取舍，将功能交由合适的模块或软件。</li>
<li><strong>功能的实现不是对应到单模块，而是整个系统的涌现。</strong>性能问题的解法不仅仅限于单个软件，而是有一整套生态，可以多去查一些大厂的分享。</li>
</ul>
<h3 id="不要迁就老旧系统的技术债务"><a href="#不要迁就老旧系统的技术债务" class="headerlink" title="不要迁就老旧系统的技术债务"></a>不要迁就老旧系统的技术债务</h3><p>为了缩小讨论范围，我对这里 <strong>技术债务</strong> 做一个收口：不仅仅是指有弊端的技术问题，更是需要投入时间精力等成本去维护。有技术债务，不代表就一定要去还，而需要一个契机 - <strong>维护的成本 &gt; 修复的收益</strong>。</p>
<p>举个例子，某个程序写得很烂，性能很差：</p>
<ul>
<li>前期可以通过扩容快速解决，上线后业务收益很高，那就是 成本大于收益，不需要排到最高优先级去修复；</li>
<li>但随着业务收益稳定下来，增长只有个位数，但发现在机器上投入的成本很高，通过优化预计能缩容50%，可以让总收益提升20%，那这时还技术债务的优先级就很高了。</li>
</ul>
<p>还技术债，技术能力只是一个基本，以下两点更为重要：</p>
<ul>
<li>评估成本与收益，尽可能地做到有数据支撑，有助于决策者下决心还债；</li>
<li>用更长远、更广维度地看待技术债务问题，不要拆东墙补西墙。</li>
</ul>
<h3 id="激进胜于保守，创新与实用并不冲突"><a href="#激进胜于保守，创新与实用并不冲突" class="headerlink" title="激进胜于保守，创新与实用并不冲突"></a>激进胜于保守，创新与实用并不冲突</h3><p>这个观点是很aggressive的，遇到这样的观念冲突时，决策者找不到客观标准去评估，就很难有二义性的定义：要么激进，要么保守；要么创新，要么实用。这种情况下，我遇到过的比较好的解法有两种：</p>
<ol>
<li>决策者自身技术能力强，能掌控团队技术的大致走向。</li>
<li>决策者和执行者之间培养出足够的信任，适当评审与把控，放权实践。</li>
</ol>
<p>第一种情况在实际工作场景中并不多见，尤其当团队规模很大时，就像CTO往往不是公司技术最强的那位。所以，我更倾向于大家多尝试第二种途径。</p>
<p>当然，我也遇到过很多效果不好的解法，比如说：决策者既然不清楚怎么做才好，那就找2个执行者进行battle，一个代表创新方，另一个代表保守方。也许在少数情况下，最后能帮助决策者找到正确的方向；但更多的实际场景中，会产生如下问题：</p>
<ul>
<li>两个执行者碰撞越来越激烈，但始终谁也说服不了谁</li>
<li>决策者越听越迷茫，不知道该如何抉择</li>
</ul>
<p>在我看来，这类决策者往往是偏管理，技术上的掌控力不足，导致在决策时没有足够的倾向性；同时，与执行者之间的信任也不足，就希望把决策这件事下移、尝试着走平衡之道。</p>
<p>我个人的想法是：先选择一个能力相对优秀的执行者，认真评估其方案，然后交由对方执行；最后哪怕失败了，也可以通过复盘改进，想想下次如何更好地决策，更好地把控方案；当然，如果你认为纯粹是执行者的问题，那就换个可信赖的人。</p>
<h2 id="2022-01-07-CNCF-Kubernetes"><a href="#2022-01-07-CNCF-Kubernetes" class="headerlink" title="2022-01-07 CNCF-Kubernetes"></a>2022-01-07 CNCF-Kubernetes</h2><p>今天，我们一起来看看CNCF中的最核心项目 - <code>Kubernetes</code>。<code>Kubernetes</code>相关内容非常庞大，我们依旧关注聚焦于核心能力。</p>
<p><code>Kubernetes</code> 位于CNCF核心的 <strong>调度与编排</strong> 模块，也就是整个解决方案的基石。在CNCF上的介绍为：</p>
<blockquote>
<p>Kubernetes is an open-source system for automating deployment, scaling, and management of containerized applications.</p>
</blockquote>
<p>对这个定义，我们关注两个点：</p>
<ul>
<li><code>automating deployment, scaling, and management</code> 自动化的部署、扩缩容和管理，这是k8s核心能力；</li>
<li><code>containerized applications</code> 容器化应用，这是k8s操作的基本对象；</li>
</ul>
<p>为了更好地介绍Kubernetes，我对<a target="_blank" rel="noopener" href="https://kubernetes.io/">官方首页</a>描述中的关键特性再做一些更详细地说明：</p>
<h3 id="Automated-rollouts-and-rollbacks"><a href="#Automated-rollouts-and-rollbacks" class="headerlink" title="Automated rollouts and rollbacks"></a>Automated rollouts and rollbacks</h3><p>自动化扩缩容和升级回滚。这个特性是k8s最核心的，也是大规模推广的根本原因。</p>
<p>看起来，这功能描述与<code>CICD</code>流程差不多，但使用体验差距很大。在传统的模式下，我们执行的是一个<strong>具体的动作</strong>，比如扩1个机器、升级2个程序等；而在k8s里，使用者只要<strong>声明最终的预期状态</strong>，比如5台机器运行v1.0版本的程序，那么整个系统该扩容还是缩容、该升级还是回滚，都由k8s自行根据当前状态进行判断。</p>
<p>这个，就是云原生的一大特性：<strong>声明式API</strong> ，而不是传统上的<strong>命令式API</strong>。</p>
<blockquote>
<p>声明式API不一定比命令式API好。在应用程序开发时，命令式API更容易理解。</p>
</blockquote>
<h3 id="Service-discovery-and-load-balancing"><a href="#Service-discovery-and-load-balancing" class="headerlink" title="Service discovery and load balancing"></a>Service discovery and load balancing</h3><p>服务发现与负载均衡。这个功能很大程度上减少了分布式软件运行模式的复杂性。</p>
<p>服务发现，以前非常依赖<code>zookeeper</code>/<code>etcd</code>等这类注册中心，往往需要侵入到业务代码；而负载均衡，则很依赖<code>nginx</code>这类软件，并在上面做复杂配置。</p>
<p>当然，k8s给出的只是通用解法，对一些具备很强业务属性的服务发现与负载均衡，仍需要程序自行实现。</p>
<h3 id="Storage-orchestration"><a href="#Storage-orchestration" class="headerlink" title="Storage orchestration"></a>Storage orchestration</h3><p>存储编排。存储的编排是k8s重点演进的功能。</p>
<p>k8s抽象了存储概念，从传统的本地存储扩展为分布式云存储，对上层应用屏蔽了存储这块的复杂度。</p>
<h3 id="Designed-for-extensibility"><a href="#Designed-for-extensibility" class="headerlink" title="Designed for extensibility"></a>Designed for extensibility</h3><p>为扩展性而设计。</p>
<p>扩展性是k8s非常重视的点，无论是开放出容器、网络、存储等接口规范，还是像自定义资源(CRD)等插件的开放，都体现出了一种开放的精神，也是k8s如今能作为云原生标志性的软件的立足之本。</p>
<p>有一个点希望大家认识到：k8s的成功不是简单地因为开放性，更重要的是，它定义的这些开放性的规范与接口，都是<code>Google</code>经过实践总结出来的经验，符合主流厂商的趋势与开发者的需求。</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/31/go-tip/go-tip-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/31/go-tip/go-tip-12/" class="post-title-link" itemprop="url">Go语言技巧 - 12.【Go实体框架】Facebook开源ent概览</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-12-31 12:00:00 / 修改时间：23:11:30" itemprop="dateCreated datePublished" datetime="2021-12-31T12:00:00+08:00">2021-12-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="Ent概览"><a href="#Ent概览" class="headerlink" title="Ent概览"></a>Ent概览</h2><p><strong>Simple, yet powerful ORM for modeling and querying data.</strong></p>
<p><code>Ent</code>作为一款由<code>Facebook</code>开源的库，官方定义为<code>An entity framework for Go</code>。从整个微服务框架来看，它更准确的定位应是 <strong>数据模型层的工具库</strong>。了解<code>Ent</code>这款企业级工具的大致实现，不仅有助于我们在技术选型时拓宽视野，也能帮助我们能更好地认识数据模型层。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/12/31/go-tip/go-tip-12/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/28/go-tip/go-tip-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/28/go-tip/go-tip-11/" class="post-title-link" itemprop="url">Go语言技巧 - 11.【初始化代码生成】Wire进阶使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-28 12:00:00" itemprop="dateCreated datePublished" datetime="2021-12-28T12:00:00+08:00">2021-12-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-30 13:45:34" itemprop="dateModified" datetime="2021-12-30T13:45:34+08:00">2021-12-30</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="Wire进阶"><a href="#Wire进阶" class="headerlink" title="Wire进阶"></a>Wire进阶</h2><p>通过上一篇的讲解，我们已经掌握<code>wire</code>工具的基本用法了。但应用在实际工程中，这些基本功能还是有很多局限性。</p>
<p>在这一篇，我们一起看看Google推出的<code>wire</code>的进阶使用方法，并总结出一套实践思路。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/12/28/go-tip/go-tip-11/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/25/go-tip/go-tip-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/25/go-tip/go-tip-10/" class="post-title-link" itemprop="url">Go语言技巧 - 10.【初始化代码生成】Wire工具基础讲解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-25 12:00:00" itemprop="dateCreated datePublished" datetime="2021-12-25T12:00:00+08:00">2021-12-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-28 19:53:19" itemprop="dateModified" datetime="2021-12-28T19:53:19+08:00">2021-12-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="Wire概览"><a href="#Wire概览" class="headerlink" title="Wire概览"></a>Wire概览</h2><p>在讲解Kratos的过程中，我们引入了google推出的wire这个工具。我们先阅读一下官方的定义：</p>
<p><strong>Wire is a code generation tool that automates connecting components using dependency injection.</strong></p>
<p>从关键词入手：</p>
<ul>
<li><strong>code generation 代码生成</strong>，一方面说明了有学习成本，需要了解这个工具的原理；另一方面，也说明了它的目标是消除重复性的coding</li>
<li><strong>automates connecting components 自动连接组件</strong>，明确了wire工具的目标是将多个对象组合起来</li>
<li><strong>dependency injection 依赖注入</strong>，指明了wire实现自动连接组件的思想。依赖注入是一个很强大的功能，我会在下面结合具体的case聊一聊</li>
</ul>
<p>我们从具体的case着手，学习wire这个工具。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/12/25/go-tip/go-tip-10/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/20/go-tip/go-tip-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/20/go-tip/go-tip-8/" class="post-title-link" itemprop="url">Go语言技巧 - 8.【浅析微服务框架】Go-Micro概览</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-12-20 12:00:00 / 修改时间：19:27:55" itemprop="dateCreated datePublished" datetime="2021-12-20T12:00:00+08:00">2021-12-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="Go-Micro框架概况"><a href="#Go-Micro框架概况" class="headerlink" title="Go Micro框架概况"></a>Go Micro框架概况</h2><p>截止到本文发布时，Go-Micro在github上的star数达到了10.8k，也已经累计发布了v1、v2、v3这三个大版本，目前前两个已经停止维护。</p>
<p>本文主要以最新的技术视角去看待这个框架，所以会集中目光在v3版本。本文包含大量个人的主观观点，请大家选择性听取，更欢迎与我讨论。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/12/20/go-tip/go-tip-8/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/20/go-tip/go-tip-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/20/go-tip/go-tip-9/" class="post-title-link" itemprop="url">Go语言技巧 - 9.【浅析微服务框架】Kratos概览</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-20 12:00:00" itemprop="dateCreated datePublished" datetime="2021-12-20T12:00:00+08:00">2021-12-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-27 20:50:20" itemprop="dateModified" datetime="2021-12-27T20:50:20+08:00">2021-12-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="Kratos框架概况"><a href="#Kratos框架概况" class="headerlink" title="Kratos框架概况"></a>Kratos框架概况</h2><p>截止到本文发布时，Kratos在github上的star数达到了15.9k。其中，在2021年7月，也正式推出了v2这个大版本。</p>
<p>本人并不是Kratos的重度使用者，主要会通过官方介绍对它的特性进行剖析。接下来的内容依旧包含大量主观认知，可能会对官方文档有理解上的偏差，欢迎大家与我讨论。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/12/20/go-tip/go-tip-9/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junedayday</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<div class=BbeiAn-info">
  浙ICP备 -
  <a target="_blank" rel="noopener" href="http://www.miitbeian.gov.cn/">19051676号-1</a>
  </a>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  















  








  

  

</body>
</html>
