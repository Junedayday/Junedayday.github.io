<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Junedayday Blog</title>
  
  <subtitle>六月天天的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-20T14:03:54.952Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Junedayday</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【每周小结】2023-Week12</title>
    <link href="http://example.com/2023/03/19/weekly/weekly-2023-12/"/>
    <id>http://example.com/2023/03/19/weekly/weekly-2023-12/</id>
    <published>2023-03-19T10:00:00.000Z</published>
    <updated>2023-03-20T14:03:54.952Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><span id="more"></span><h2 id="Go技巧-经典命令行工具库cobra"><a href="#Go技巧-经典命令行工具库cobra" class="headerlink" title="Go技巧 - 经典命令行工具库cobra"></a>Go技巧 - 经典命令行工具库cobra</h2><h3 id="cobra简介"><a href="#cobra简介" class="headerlink" title="cobra简介"></a>cobra简介</h3><p><code>Go</code>程序的主流交付的形式为2种：服务端程序与命令行工具。服务端程序一般长期运行在服务器上，而命令行工具则往往是一次性运行的，又被称为<code>CLI</code>，即<code>client</code>客户端的简写。</p><p><code>CLI</code>工具的开发不难，但要做到方便易用，类似于<code>Kubernetes</code>的<code>kubectl</code>，还是非常考验开发能力的。今天，我介绍一款开发命令行程序的利器 - <a href="https://github.com/spf13/cobra">cobra</a>。</p><p><code>cobra</code>的安装命令如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/spf13/cobra@latest</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>cobra init</code>可以快速地初始化一个程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化 go module</span></span><br><span class="line">go mod init github.com/Junedayday/cobra-demo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化cobra命令行工具，包括作者和License</span></span><br><span class="line">cobra init --author &quot;junedayday@gmail.com&quot; --license apache</span><br></pre></td></tr></table></figure><p>接下来，我会从结构与功能两个层面，对<code>cobra</code>进行介绍：</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="新增子命令"><a href="#新增子命令" class="headerlink" title="新增子命令"></a>新增子命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新增子命令 create和delete</span></span><br><span class="line">cobra add create</span><br><span class="line">cobra add delete</span><br></pre></td></tr></table></figure><p>在运行完上述两个命令后，我们编译一下程序，尝试着运行一下这个工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost] ./cobra-demo -h</span><br><span class="line">Available Commands:</span><br><span class="line">  completion  Generate the autocompletion script for the specified shell</span><br><span class="line">  create      A brief description of your command</span><br><span class="line">  delete      A brief description of your command</span><br><span class="line">  help        Help about any command</span><br><span class="line"></span><br><span class="line">[root@localhost] ./cobra-demo create</span><br><span class="line">create called</span><br><span class="line"></span><br><span class="line">[root@localhost] ./cobra-demo delete</span><br><span class="line">delete called</span><br></pre></td></tr></table></figure><p>相关的提示已经自动添加了。而整体的代码架构也很清晰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- cmd/</span><br><span class="line">  - create.go</span><br><span class="line">  - delete.go</span><br><span class="line">  - root.go</span><br><span class="line">- main.go    </span><br></pre></td></tr></table></figure><h4 id="新增多级子命令"><a href="#新增多级子命令" class="headerlink" title="新增多级子命令"></a>新增多级子命令</h4><p>当工具变得复杂时，多级命令的可读性会比较棒，<code>cobra</code>也支持这个功能。假设我们要对上述的 <code>cobra-demo create</code>增加一种<code>mock</code>机制，即和正常创建方式区分开来，那么我们就可以运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> p即parent，对应的父命令</span></span><br><span class="line">cobra add mock -p=createCmd</span><br></pre></td></tr></table></figure><p>整个文件目录就成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- cmd/</span><br><span class="line">  - create.go</span><br><span class="line">  - delete.go</span><br><span class="line">  - mock.go</span><br><span class="line">  - root.go</span><br><span class="line">- main.go </span><br></pre></td></tr></table></figure><p>重新编译后，命令行工具运行<code>create</code>时多了一个子命令提示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost] ./cobra-demo create</span><br><span class="line">Available Commands:</span><br><span class="line">  mock        A brief description of your command</span><br></pre></td></tr></table></figure><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><p><code>cobra</code>工具在生成时，支持对每一个命令进行参数解析。官方在生成代码时提供了示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">foo    *<span class="keyword">string</span></span><br><span class="line">toggle *<span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">rootCmd.AddCommand(createCmd)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here you will define your flags and configuration settings.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cobra supports Persistent Flags which will work for this command</span></span><br><span class="line"><span class="comment">// and all subcommands, e.g.:</span></span><br><span class="line">foo = createCmd.PersistentFlags().String(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;A help for foo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cobra supports local flags which will only run when this command</span></span><br><span class="line"><span class="comment">// is called directly, e.g.:</span></span><br><span class="line">toggle = createCmd.Flags().BoolP(<span class="string">&quot;toggle&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;Help message for toggle&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的注释写得很清楚，参数分为2类：</p><ul><li><code>Persistent Flags</code> - 对该命令以及它的所有子命令生效</li><li><code>Local Flags</code> - 仅对该命令生效</li></ul><p>在复杂命令行工具的开发中，<code>Flag</code>经常会变得很多、很乱，我有两点建议：</p><ol><li><strong>用增加子命令的方式来减少入参的数量</strong>：参数越多，往往会让使用变得复杂性；而子命令相对而言更容易理解</li><li><strong>特殊的功能单独开放一个子命令</strong>：隔离复杂度</li></ol><h4 id="Command钩子"><a href="#Command钩子" class="headerlink" title="Command钩子"></a>Command钩子</h4><p><code>cobra</code>最核心的能力都放在结构体<code>cobra.Command</code>里，内部包含了诸多可自定义的能力，如简写、数据校验、版本等，而最核心的运行逻辑则是为以下5步（按顺序执行）：</p><ul><li>PersistentPreRun()</li><li>PreRun()</li><li>Run()</li><li>PostRun()</li><li>PersistentPostRun()</li></ul><p>如果想要支持返回<code>error</code>，则将<code>XXXRun()</code>调整为<code>XXXRunE()</code>即可。<code>cobra</code>是一个开放的、普适性的工具，我们在使用它的特性时需要节制，才能保证后续的可维护性，例如：</p><ul><li>如果有复杂的业务功能，独立到另一个<code>package</code>中单独维护；</li><li>如果有数据一致性的要求，就尽量维护在一个命令中操作，如<code>Run</code>；</li></ul><p>一般建议在<code>cobra</code>命令层做的只做三件事：<strong>提高命令的可读性</strong>、<strong>解析参数</strong> 与 <strong>校验参数的基本格式</strong>。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>cobra</code>工具是帮助开发者构建<code>CLI</code>程序的一款利器，核心优势在于能大幅度地提升使用者的体验（尤其是结合了Terminal中命令自动填充、美化等扩展能力）。</p><p>而在复杂项目中，则应提前考虑分层设计：<strong>隔离<code>cobra</code>生成代码与人工编写的业务代码</strong> - 前者是命令式地执行，后者更需要抽象。</p><h2 id="编程思考-以终为始的思维方式"><a href="#编程思考-以终为始的思维方式" class="headerlink" title="编程思考 - 以终为始的思维方式"></a>编程思考 - 以终为始的思维方式</h2><p><strong>以终为始</strong>，初听像是一个只停留于方法论的词汇，但它所代表的思维方式是非常有意义的。</p><p>以接口的两种风格为例：<strong>命令式</strong> 像是指挥者，必须很清楚内部的各项实现，然后指挥系统一步一步执行；而<strong>声明式</strong>则是告诉平台自己所期望的最终状态，而不关心其内部具体是怎么实现的。</p><p>命令式固然是一个很棒的解决方案，可以明确地指导我们达成目标，但过程中往往会遇到各种瓶颈，导致最终结果产生偏差；而声明式则是一种“以终为始”的解决方式，先明确自己的最终目标是什么，再逐步探索达到目标的路径。也许两者最终的效果一致，但“以终为始”的方式能让我们更聚焦于目标，减少过程中的损耗。</p><p>我们的开发工作也十分类似。过程中存在诸多的不确定性，未达预期是一种常态。以终为始的思路，能让我们减少复杂过程中的损耗。</p><h2 id="工作生活-资产配置"><a href="#工作生活-资产配置" class="headerlink" title="工作生活 - 资产配置"></a>工作生活 - 资产配置</h2><p>最近我开始接触理财相关的概念，其中印象最为深刻的是 <strong>4321原则</strong>，即</p><ul><li>40%投资</li><li>30%生活开销</li><li>20%储蓄备用</li><li>10%保险</li></ul><p>各位如果和我一样是个理财新手，不妨先按这种方式梳理一下个人或家庭的资产情况。这个理论提供的只是参考值，真正的执行可以按需调整，重点是要有长期的投资思想，如个人成长、房地产、股票，在人生的不同阶段有不同选择。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>【每周小结】2023-Week11</title>
    <link href="http://example.com/2023/03/12/weekly/weekly-2023-11/"/>
    <id>http://example.com/2023/03/12/weekly/weekly-2023-11/</id>
    <published>2023-03-12T10:00:00.000Z</published>
    <updated>2023-03-14T11:43:09.436Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><span id="more"></span><h2 id="Go技巧-Variable-Shadowing"><a href="#Go技巧-Variable-Shadowing" class="headerlink" title="Go技巧 - Variable Shadowing"></a>Go技巧 - Variable Shadowing</h2><p><code>Go</code> 语法中有一个较为隐蔽的特性 - <code>Variable Shadowing</code>，常被翻译为 <strong>变量隐藏</strong>。官方对这块提供的资料很少，经常有不少<code>Go</code>语言开发者在这块“踩雷”。</p><h3 id="语法意义-作用域"><a href="#语法意义-作用域" class="headerlink" title="语法意义 - 作用域"></a>语法意义 - 作用域</h3><p>既然<code>Go</code>官方支持这个特性，那就有对应的语法意义，简而言之就是 <strong>控制变量的作用域</strong>。</p><p>下面是一个简单的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// value - 0</span></span><br><span class="line">fmt.Println(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line"><span class="comment">// variable shadowing</span></span><br><span class="line">x := <span class="number">1</span></span><br><span class="line">x++</span><br><span class="line"><span class="comment">// value - 2</span></span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// value - 0</span></span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而其中的<code>x := 1</code>是创建了一个新的变量，它的作用域仅在 <code>if true</code>之后的括号内。当离开作用域之后，<code> x</code>变量又回到了原值。</p><h3 id="一个隐蔽的错误示例"><a href="#一个隐蔽的错误示例" class="headerlink" title="一个隐蔽的错误示例"></a>一个隐蔽的错误示例</h3><p>上述示例可以将 <code>x := 1</code> 修改为 <code>x = 1</code>，或者重新命名变量<code>x</code>，就可以避免引入 <code>variable shadowing</code> 。</p><p>但在实际开发中，常常出现一些隐蔽的case：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, err := foo()</span><br><span class="line">_ = f</span><br><span class="line"></span><br><span class="line"><span class="comment">// variable shadowing</span></span><br><span class="line"><span class="keyword">if</span> b, err := bar(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">_ = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nil</span></span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多变量返回时，很容易出现<code>variable shadowing</code>的情况。例如，上述示例中的<code>b, err := bar()</code> ，有两个返回值：</p><ul><li><code>b</code> ，前文未定义，作用域仅在对应的括号中，不会出现问题</li><li><code>err</code>，前文已定义，这里发生了<code>variable shadowing</code>，所以在括号内外是两个变量</li></ul><p>由于<code>Go</code>语言推荐将<code>error</code>作为最后一个返回值，所以往往在error这个变量上会发生<code>variable shadowing</code>，常被称为<code>error shadowing</code>。</p><p>尽管官方支持这种语法，但很容易发生预期不一致的结果。社区也提供了相关的工具<code>shadow</code>，可用下方的命令快速体验：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow@latest</span><br><span class="line"><span class="meta">#</span><span class="bash"> 普通模式</span></span><br><span class="line">shadow ./...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 严格模式</span></span><br><span class="line">shadow -strict ./...</span><br></pre></td></tr></table></figure><p>用工具可以发现问题，但如何解决呢？我推荐两个思路：</p><h3 id="思路一：移除-赋值使用"><a href="#思路一：移除-赋值使用" class="headerlink" title="思路一：移除:=赋值使用"></a>思路一：移除<code>:=</code>赋值使用</h3><p><code>variable shadowing</code>常出现的场景是多变量返回，并且同时存在已定义与未定义的变量。那么，我们可以尝试提前定义所需的变量，移除<code>:=</code>的赋值方式。例如将示例改造为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> b, err = bar(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">  _ = b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种提前定义的方式会增加代码量，但它不仅避免了<code>variable shadowing</code>，还有一个比较大的优势：<strong>提高可读性</strong>。</p><p>一行简单的变量定义，尤其是当定义的内容是一个复杂对象时，我们能从这个定义中读到很多内容，如一个<code>var fe foo.Example</code>，让变量简写<code>fe</code>和变量的定义<code>foo.Example</code>结合在一起，非常清晰。</p><h3 id="思路二：重命名"><a href="#思路二：重命名" class="headerlink" title="思路二：重命名"></a>思路二：重命名</h3><p>重命名时，我们对变量有两种处理方式，以下面的<code>errB</code>为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 变量仅被用于括号内，被丢弃</span></span><br><span class="line"><span class="keyword">if</span> b, errB := bar(); errB == <span class="literal">nil</span> &#123;</span><br><span class="line">  _ = b</span><br><span class="line">  _ = errB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 变量被用于括号内外，赋值给外部变量err</span></span><br><span class="line"><span class="keyword">if</span> b, errB := bar(); errB == <span class="literal">nil</span> &#123;</span><br><span class="line">  _ = b</span><br><span class="line">  err = errB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="个人推荐方案"><a href="#个人推荐方案" class="headerlink" title="个人推荐方案"></a>个人推荐方案</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量的生命周期 - 仅在括号内</span></span><br><span class="line"><span class="comment">// 重命名</span></span><br><span class="line"><span class="keyword">if</span> b, errB := bar(); errB == <span class="literal">nil</span> &#123;</span><br><span class="line">  _ = b</span><br><span class="line">  _ = errB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量的生命周期 - 括号内外</span></span><br><span class="line"><span class="comment">// 移除:=</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> b, err = bar(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">  _ = b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是我个人的一种编程习惯，能减少因 <code>variable shadowing</code> 发生错误的概率，希望能帮助到各位同学。</p><h2 id="编程思考-表述不清晰，往往是因为掌握得不够深入"><a href="#编程思考-表述不清晰，往往是因为掌握得不够深入" class="headerlink" title="编程思考 - 表述不清晰，往往是因为掌握得不够深入"></a>编程思考 - 表述不清晰，往往是因为掌握得不够深入</h2><p>在写方案、查问题、沟通业务时，开发者们经常有种感觉 - 我已经表达得很清晰了，但别人常常无法听懂。</p><p>我也经常遇到这种情况。以前，我会觉得是对方的问题，如对相关领域的知识储备太少；而现在，我更倾向于是自己对这块内容的掌握度仍不够，导致无法通俗易懂地表达。</p><p>我的思维主要有两点转变：</p><ol><li>大师能面向不同人群、通俗易懂地讲清深奥的知识；</li><li>改变优先从自身出发，而不是寄希望于他人的主动变化；</li></ol><p>当收到他人对你表述不清晰的评价时，不要过于抵触，不妨趁这个机会再深入研究相关知识点，提升自己的水平。</p><h2 id="工作生活-你看到的，是你想看到的"><a href="#工作生活-你看到的，是你想看到的" class="headerlink" title="工作生活 - 你看到的，是你想看到的"></a>工作生活 - 你看到的，是你想看到的</h2><p>最近读完了《拆掉了思维里的墙》，我印象最深的一句话是：<strong>你看到的，是你想看到的</strong>。</p><p>这个世界可能是客观的，但每个人的世界都是主观的。在事前或者事后，很多人都清楚该以什么样的态度面对世界，理论上很完美；但事到临头，面对带有负面内容的事物，我们往往会不自觉地以自己最习惯的方式来抵抗、躲避。</p><p>如果你想看到一个自己理想中的世界，往往需要一定的锻炼，形成“肌肉记忆”，让自己的心态变得更强壮。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>【每周小结】2023-Week10</title>
    <link href="http://example.com/2023/03/05/weekly/weekly-2023-10/"/>
    <id>http://example.com/2023/03/05/weekly/weekly-2023-10/</id>
    <published>2023-03-05T10:00:00.000Z</published>
    <updated>2023-03-05T13:26:16.104Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><p>进入3月，天气逐渐变得暖和。</p><p>趁现在，出门走走，感受一下清风与阳光，给心灵一段轻松的休憩。</p><span id="more"></span><h2 id="Go技巧-我是如何做Code-Review的"><a href="#Go技巧-我是如何做Code-Review的" class="headerlink" title="Go技巧 - 我是如何做Code Review的?"></a>Go技巧 - 我是如何做Code Review的?</h2><p>如何做Code Review，这个话题过大，容易出现很多争议性的内容。为了缩小讨论的范围，我今天分享的内容主要源于个人的经验，适用于多种后端语言。</p><h3 id="CR的最终目标是什么？"><a href="#CR的最终目标是什么？" class="headerlink" title="CR的最终目标是什么？"></a>CR的最终目标是什么？</h3><p>我先抛出自己的观点，CR的最终目标分两个方向：</p><ul><li><strong>技术上，保证代码的可维护性</strong></li><li><strong>业务上，保证系统功能的正确性</strong></li></ul><p>第一点相对容易做到，毕竟代码风格很容易直接看出来。不过代码是否能保证可维护性，还是很考验团队技术负责人的水平，这里就不展开了。</p><p>不少人对第二点会存在争议：CR的reviewer往往不了解这个需求的背景与技术实现，在有限的时间里，如何保证系统功能的正确性？诚然，系统功能的正确性是极难解决的问题，别说CR，连单测、联调、验收、甚至上线后都可能频繁出现问题，靠一个“纸上谈兵”的CR能解决什么？</p><p>功能的正确性很难保障是编程圈的常态，导致CR不断被人诟病 - 麻烦又没小姑偶。但是，我们也可以观察到有很多追求技术的团队与个人分享了各自的实践，或多或少带来了帮助。</p><p>下面，我来谈谈个人的三个实践，简单来说就是 <strong>总 - 分 - 总</strong>。</p><blockquote><p>以下的内容不适用于部分维护遗留系统的团队，投入与产出不成比例。</p><p>但从个人来说，可以按照下面的思路CR自己提交的代码，是一个提升个人能力的有效手段。</p></blockquote><h3 id="梳理功能：从出入口串联逻辑"><a href="#梳理功能：从出入口串联逻辑" class="headerlink" title="梳理功能：从出入口串联逻辑"></a>梳理功能：从出入口串联逻辑</h3><p>做一个功能的开发，出入口是最好把控整体的方法。以一个微服务程序为例，主要出入口分为3种：</p><ol><li>服务本身的接口</li><li>数据库层的定义</li><li>调用第三方服务的接口</li></ol><p>如果能结合分层，将1放在最上层，2、3放在最下层，整体的代码就清晰很多。这时，Reviewer的重心可以分这三步：</p><ol><li><strong>先看最上层接口的数据定义</strong>：根据出入的数据定义，可快速了解接口要做什么</li><li><strong>再看业务层的技术方案</strong>：业务层为分两种情况<ol><li>CRUD类，没有什么复杂业务逻辑，可不写方案，直接读代码就能看懂</li><li>复杂业务类，重点看技术方案中的核心设计（缺少技术方案时，就要求<strong>把核心业务逻辑写在一个或几个重点函数中，注释详尽</strong>）</li></ol></li><li><strong>最后看下层的数据库与RPC调用</strong>：通过了解系统怎么与外部交互的，完善对整个功能的理解</li></ol><h3 id="细节打磨：从分层特性打磨代码"><a href="#细节打磨：从分层特性打磨代码" class="headerlink" title="细节打磨：从分层特性打磨代码"></a>细节打磨：从分层特性打磨代码</h3><p>串联了整个逻辑，只代表了我们大致了解了逻辑，距离技术上的代码可维护性和业务上的功能正确性都还有相当一段路。接下来，我会从分层的维度去打磨代码。</p><p>接口层的代码是整个服务的门面，我重点关注两块。首先是<strong>数据定义适宜</strong> - 既不缺失关键字段导致无法使用，又没有冗余字段来提升调用方的理解成本，这点比较考验经验，是一个不断优化的过程；其次，我非常重视<strong>接口文档的正确性</strong> - 让代码实现与接口文档保证一致，这部分往往会结合框架进行自动化。</p><p>业务层相关的代码是服务的核心，风格因团队、框架而异，但我建议以一个实践为核心：<strong>可测试性</strong>。业务变化很快，可测试性是重要保障的一个门槛。为了提升可测试性，我们应先考虑对相关代码进行优化，例如抽象、拆分、mock等手段，再去写相关的单元测试。</p><p>最下层的数据库与RPC调用相关的代码一般都有ORM或SDK的封装，功能上复杂度不高，但仍是CR的重点之一：<strong>优先关注边界问题</strong>，即通过数据库或第三服务是不是一个最优解，毕竟一旦涉及到第三方系统，后续排查的复杂度就会越来越大；其次要<strong>关注性能</strong>，如数据库的索引字段，外部服务的接口性能等。</p><h3 id="掌控全局：再次俯瞰整个功能"><a href="#掌控全局：再次俯瞰整个功能" class="headerlink" title="掌控全局：再次俯瞰整个功能"></a>掌控全局：再次俯瞰整个功能</h3><p>打磨完了细节，这时再从整体功能的角度来看这部分代码，往往能找到很多更重要的优化项，例如：</p><ul><li>优化命名</li><li>抽象合理</li><li>日志齐全</li><li>超时处理</li></ul><p>这一阶段是保障功能正确的最重要机会，是对以上两个阶段的“厚积薄发”。我个人尤其注重这一阶段。</p><h2 id="编程思考-珍惜工作中的决策机会"><a href="#编程思考-珍惜工作中的决策机会" class="headerlink" title="编程思考 - 珍惜工作中的决策机会"></a>编程思考 - 珍惜工作中的决策机会</h2><p>最近有同学在工作一段时间后，发现个人的能力遇到了瓶颈，找我聊了聊。在我看来，他们的瓶颈往往是由于个人的认知非常受限，突破瓶颈的一个有效手段就是有足够的决策机会。</p><p>举个例子，如果你是维护某个模块的工程师，对这部分的功能已经了如指掌，这时你需要有一个机会：如果让你重新设计这个模块、或者规划更大的系统，这就能让你的能力有一次突破。</p><p>决策小到一个技术方案，大到一个系统设计，这里面需要关注两方面：</p><ol><li>自身能力的不断提高</li><li>在团队中树立足够的信誉</li></ol><p>不少同学往往忽略了第二点，工作中总抱着一种怀才不遇的心态，而团队领导则认为他好高骛远。理论与实践总是存在偏差，我们要从每个小的机会入手，逐步证明自己，才能在更大的舞台上展现自己。</p><h2 id="工作生活-10公里慢跑"><a href="#工作生活-10公里慢跑" class="headerlink" title="工作生活 - 10公里慢跑"></a>工作生活 - 10公里慢跑</h2><p>近一个月，我已经养成了每周一次10公里慢跑的习惯。</p><p>奔跑的过程中，最困难的是3~5公里，我会不断产生各种念头劝自己放弃；最后几公里反而是最顺畅的，因为我的目标很明确、只要再坚持跑几步就能达到。</p><p>一次长跑，也是一个对心性磨炼的过程。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;进入3月，天气逐渐变得暖和。&lt;/p&gt;
&lt;p&gt;趁现在，出门走走，感受一下清风与阳光，给心灵一段轻松的休憩。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>【每周小结】2023-Week9</title>
    <link href="http://example.com/2023/02/26/weekly/weekly-2023-9/"/>
    <id>http://example.com/2023/02/26/weekly/weekly-2023-9/</id>
    <published>2023-02-26T10:00:00.000Z</published>
    <updated>2023-02-27T14:05:47.825Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><span id="more"></span><h2 id="Go技巧-快速学习官方库ast"><a href="#Go技巧-快速学习官方库ast" class="headerlink" title="Go技巧 - 快速学习官方库ast"></a>Go技巧 - 快速学习官方库<code>ast</code></h2><p>当我们谈及<code>Go</code>语言底层时，往往会聊<code>GMP</code>相关的并发原理，或者是以<code>reflect</code>为代表的反射处理，它们也是面试中的常客。</p><p>而我今天想推荐的一个底层库 - <code>ast</code>，全名抽象语法树（abstract syntax tree），不仅能让我们进一步掌握<code>Go</code>的基础语法，更是一个开发<strong>标准化</strong>和<strong>提效</strong>工具的关键技能。</p><h3 id="AST的基本概念"><a href="#AST的基本概念" class="headerlink" title="AST的基本概念"></a>AST的基本概念</h3><p><code>ast</code>的官方概念理解起来比较复杂，有兴趣的可以参考<a href="https://zhuanlan.zhihu.com/p/28516587">这篇知乎</a>，或者阅读更专业的资料。</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/20230224211609.png"></p><p>对初学者来说，抓住上图中的两个关键因素：</p><ol><li>树 - 了解树相关的深度遍历算法</li><li>节点 - 各语法特征，如变量、条件语句等</li></ol><h3 id="Go的AST节点类型"><a href="#Go的AST节点类型" class="headerlink" title="Go的AST节点类型"></a>Go的AST节点类型</h3><p>学习<code>ast</code>，从它底层的数据定义入手会让我们事半功倍。</p><p><code>ast</code>语法的核心抽象是<code>Node</code>，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">interface</span> &#123;</span><br><span class="line">Pos() token.Pos <span class="comment">// 起始定义的位置</span></span><br><span class="line">End() token.Pos <span class="comment">// 结束定义的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用就是解析出对应语法的位置。整个<code>Node</code>相关的接口与实现比较复杂，我以网上的一个版本为例：</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/ast-tree.jpeg"></p><p>整个语法树很庞杂，每个接口与结构体都有自己的一些特点。为了方便大家加深这部分的理解，我们从一个具体的case入手</p><h3 id="AST的示例代码"><a href="#AST的示例代码" class="headerlink" title="AST的示例代码"></a>AST的示例代码</h3><p>示例代码如下，即解析本身main.go文件，打印出import的库与类型定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go/ast&quot;</span></span><br><span class="line"><span class="string">&quot;go/parser&quot;</span></span><br><span class="line"><span class="string">&quot;go/token&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义解析的具体文件</span></span><br><span class="line">fSet := token.NewFileSet()</span><br><span class="line">f, err := parser.ParseFile(fSet, <span class="string">&quot;main.go&quot;</span>, <span class="literal">nil</span>, parser.ParseComments)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 怎么解析 - 用visit对象去Walk(遍历)对应文件</span></span><br><span class="line">visit := &amp;MyVisitor&#123;&#125;</span><br><span class="line">ast.Walk(visit, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyVisitor <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vi *MyVisitor)</span> <span class="title">Visit</span><span class="params">(node ast.Node)</span> <span class="title">ast</span>.<span class="title">Visitor</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> node.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *ast.ImportSpec:</span><br><span class="line"><span class="comment">// import库</span></span><br><span class="line">fmt.Println(node.(*ast.ImportSpec).Path.Value)</span><br><span class="line"><span class="keyword">case</span> *ast.TypeSpec:</span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line">fmt.Println(node.(*ast.TypeSpec).Name.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余语法的使用，大家可以参考前面图中的<code>Node</code>接口与实现的定义，对照着实现。</p><p>为了加深大家对<code>ast</code>这棵树的理解，我们再细化一下上面的例子。</p><h3 id="AST的两种处理思路"><a href="#AST的两种处理思路" class="headerlink" title="AST的两种处理思路"></a>AST的两种处理思路</h3><p>示例中的<code>import</code>代码，即</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go/ast&quot;</span></span><br><span class="line"><span class="string">&quot;go/parser&quot;</span></span><br><span class="line"><span class="string">&quot;go/token&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>它对应的<code>ast</code>中的结构体是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GenDecl <span class="keyword">struct</span> &#123;</span><br><span class="line">Doc    *CommentGroup <span class="comment">// associated documentation; or nil</span></span><br><span class="line">TokPos token.Pos     <span class="comment">// position of Tok</span></span><br><span class="line">Tok    token.Token   <span class="comment">// IMPORT, CONST, TYPE, or VAR</span></span><br><span class="line">Lparen token.Pos     <span class="comment">// position of &#x27;(&#x27;, if any</span></span><br><span class="line">Specs  []Spec</span><br><span class="line">Rparen token.Pos <span class="comment">// position of &#x27;)&#x27;, if any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而每个import选项，则是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象</span></span><br><span class="line"><span class="keyword">type</span> Spec <span class="keyword">interface</span> &#123;</span><br><span class="line">Node</span><br><span class="line">specNode()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">type</span> ImportSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">Doc     *CommentGroup <span class="comment">// associated documentation; or nil</span></span><br><span class="line">Name    *Ident        <span class="comment">// local package name (including &quot;.&quot;); or nil</span></span><br><span class="line">Path    *BasicLit     <span class="comment">// import path</span></span><br><span class="line">Comment *CommentGroup <span class="comment">// line comments; or nil</span></span><br><span class="line">EndPos  token.Pos     <span class="comment">// end of spec (overrides Path.Pos if nonzero)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，我们可以有两种方式来访问到每个<code>ImportSpec</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vi *MyVisitor)</span> <span class="title">Visit</span><span class="params">(node ast.Node)</span> <span class="title">ast</span>.<span class="title">Visitor</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> node.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="comment">// 方法1 - 直接处理下层的叶子节点</span></span><br><span class="line"><span class="keyword">case</span> *ast.ImportSpec:</span><br><span class="line"><span class="comment">// import库</span></span><br><span class="line">fmt.Println(node.(*ast.ImportSpec).Path.Value)</span><br><span class="line"><span class="comment">// 方法2 - 先解析出上层节点，再处理下层节点</span></span><br><span class="line"><span class="keyword">case</span> *ast.GenDecl:</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> node.(*ast.GenDecl).Specs &#123;</span><br><span class="line"><span class="keyword">switch</span> v.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *ast.ImportSpec:</span><br><span class="line">fmt.Println(v.(*ast.ImportSpec).Path.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在用<code>ast</code>编写相关工具时，我建议优先按思路2去编写代码，它的优势在于两点：</p><ol><li><strong>扩大上下文信息</strong> - 除了基本的<code>ImportSpec</code>，还可以使用父节点<code>GenDecl</code>中的共用信息</li><li><strong>代码可读性高</strong> - 先处理父节点，解析到具体的结构体，再进行各个子节点的处理，思路很自然</li></ol><p>当整个<code>Visit</code>处理的内容比较多时，就需要进行一定的拆分，用<strong>递归</strong>来减少复杂度。</p><h3 id="AST在日常工作中的使用示例"><a href="#AST在日常工作中的使用示例" class="headerlink" title="AST在日常工作中的使用示例"></a>AST在日常工作中的使用示例</h3><p><code>ast</code>的特性看起来很酷，但很少会直接应用在项目的代码里。</p><p>不过，作为官方支持、可用来分析<code>Go</code>代码的库，它常用于制作二进制工具，在不同的场景使用：</p><ol><li><strong>进阶性的代码规范性检查</strong> - 如检查某层代码的import情况，保证分层规范</li><li><strong>自定义的代码生成</strong> - 如根据注释自动生成定义，根据方法生成mock接口</li><li><strong>编译前统一对库或方法的替换</strong> - 在编译前，对某些特定的库或方法进行替换，修改原<code>go</code>文件</li></ol><p>在优秀的框架中，<code>ast</code>往往与标准化相辅相成，形成正反馈：<strong>代码标准化的程度越高，<code>ast</code>就越能提升自动化、保障质量；<code>ast</code>应用得越广泛，代码的标准化程度自然就越高</strong>。</p><h2 id="编程思考-业务也是技术人员的核心能力"><a href="#编程思考-业务也是技术人员的核心能力" class="headerlink" title="编程思考 - 业务也是技术人员的核心能力"></a>编程思考 - 业务也是技术人员的核心能力</h2><p>最近，为了项目的推进，我和大量的开发人员进行了沟通，发现部分新人对“业务”的认知有明显偏差。</p><p>技术有两个极致的方向：</p><ol><li>底层理论性的研究</li><li>面向业务的trade-off</li></ol><p>前者是为技术领域开辟新的领域，只有极少的研究员会参与这类工作；而面向业务的trade-off则是大多数开发者能接触到的终极目标，难点往往在于：</p><ol><li>技术储备广 - 有多样的解决方案，各有利弊</li><li>业务认知深 - 洞察业务的核心价值</li><li>技术 ✖️ 业务 - 两者结合时的决策能力</li></ol><p><strong>技术是开发者的立身之本，而业务是公司的立身之本。</strong> 优秀的开发者并不在于能想出100个技术方案，而是能提出3个各有利弊的关键技术方案、并且能根据业务情况给出自己的意见。</p><h2 id="工作生活-如果无法理解，也请包容他人"><a href="#工作生活-如果无法理解，也请包容他人" class="headerlink" title="工作生活 - 如果无法理解，也请包容他人"></a>工作生活 - 如果无法理解，也请包容他人</h2><p>我有段时间心理洁癖非常严重：我会尝试各种方法、各种角度去理解一些人，但如果用尽方法、仍无法理解对方的所作所为，我就会对其非常反感（当然，这样的人是极少数的）。</p><p>理解是一个很理想的方式，能让我更深刻地了解对方，也更适合深度、长期的关系。但在现实生活中，我们很难投入那么多的时间与情绪去熟悉每个人，也因不可避免的个人认知偏差导致误会。</p><p>所以，在和大部分人相处时，包容是一种让自己更轻松的方式。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>【每周小结】2023-Week8</title>
    <link href="http://example.com/2023/02/19/weekly/weekly-2023-8/"/>
    <id>http://example.com/2023/02/19/weekly/weekly-2023-8/</id>
    <published>2023-02-19T10:00:00.000Z</published>
    <updated>2023-02-21T13:16:52.242Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><p>这段时间，我在尝试着远离抖音、B站、头条等消息媒介。</p><p>这些平台承载了过多大数据推荐算法，反复向人们推送着高度重复性的内容，脱离了获取信息的初衷 - <strong>扩大自己的认知面</strong>。如果你关注的内容包括了失业等负面内容，还容易加强你的焦虑感。</p><span id="more"></span><h2 id="Go技巧-结构体的赋值小技巧"><a href="#Go技巧-结构体的赋值小技巧" class="headerlink" title="Go技巧 - 结构体的赋值小技巧"></a>Go技巧 - 结构体的赋值小技巧</h2><p>在日常的CRUD开发过程中，我们往往会用到一些结构体：它们只是一些简单的数据的组合，很难用对象来封装。比如说，有一个订单表，里面包括20+个field。当我们创建时，就需要对这些field赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 包括近20个字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们来看三种常见的方法，并分析各自的利弊：</p><h3 id="方案1-全量透传结构体"><a href="#方案1-全量透传结构体" class="headerlink" title="方案1-全量透传结构体"></a>方案1-全量透传结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据从http body中解析出来</span></span><br><span class="line"><span class="keyword">var</span> b []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析到order</span></span><br><span class="line"><span class="keyword">var</span> order = <span class="built_in">new</span>(Order)</span><br><span class="line">json.Unmarshal(b, &amp;order)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建到数据库</span></span><br><span class="line">db.Insert(order)</span><br></pre></td></tr></table></figure><p>这种思路确实非常方便，但仅限于轻量级项目。</p><p>如果业务逻辑稍微复杂点，就会出现无法支持的情况。问题的根本在于：<strong>在程序的不同层面，结构体各有各的使用场景，像传输效率、安全、性能等</strong>。</p><blockquote><p>最经典的莫过于时间类型的参数：在数据库保存为<code>timestamp</code>格式，而在接口层往往是<code>YYYY-MM-DD hh:mm:ss</code>或<code>int64</code>类型，无法用透传实现。</p></blockquote><h3 id="方案2-用一个通用库解决问题"><a href="#方案2-用一个通用库解决问题" class="headerlink" title="方案2-用一个通用库解决问题"></a>方案2-用一个通用库解决问题</h3><p>既然我们要从一个结构体转成另一个结构体，就自然产生了一个想法 - 写个通用库。</p><p>常见的实现思路有2种：序列化工具或发射。这里以序列化工具为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源结构体，来自http</span></span><br><span class="line"><span class="keyword">type</span> OrderDTO <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 目标结构体，保存到MySQL</span></span><br><span class="line"><span class="keyword">type</span> OrderDao <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> order *orderDTO</span><br><span class="line">b, err := json.Marshal(order)</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">new</span>(OrderDao)</span><br><span class="line">err = json.Unmarshal(b, target)</span><br></pre></td></tr></table></figure><p>这种思路在编写代码时确实方便，但是，长期来看有两大隐患：</p><ol><li>中间操作的性能可能成为性能瓶颈</li><li>两个结构体不一定能保证一致，如数据库里叫<code>name</code>，但接口则叫<code>order_name</code></li></ol><p>尤其是第二点，使得通用库变得不再通用，就会出现一些tricky的实现，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`json:&quot;order_name&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式很容易在未来成为一个埋雷点。随着通用库的封装，埋雷越来越多，往往就变得不可维护了。</p><h3 id="方案3-傻瓜式赋值"><a href="#方案3-傻瓜式赋值" class="headerlink" title="方案3-傻瓜式赋值"></a>方案3-傻瓜式赋值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transfer</span><span class="params">(from *orderDTO)</span> <span class="params">(to *OrderDao)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> OrderDao &#123;</span><br><span class="line">  Id:          from.Id,</span><br><span class="line">  Name:        from.OrderName,</span><br><span class="line">  CreateTime:  from.CreateTime.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>),</span><br><span class="line">  Cost:        from.EndTime.Sub(from.StartTime).Seconds(),</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样的代码写起来很累，但对阅读者来说是非常方便的（往往封装成一个函数，放在文件末尾即可）。在开发与排查问题的过程中，它有三个优点无可比拟：</p><ol><li><strong>填充逻辑清晰</strong>：数据源来自哪个字段，又被填充到了哪个字段，一目了然</li><li><strong>灵活自定义加工</strong>：如代码中时间<code>CreateTime</code>的格式化，以及耗时<code>Cost</code>的逻辑计算</li><li><strong>兼容性与安全性高</strong>：两个结构体的变更，要么不影响这个转换逻辑（兼容性高，如新增字段），要么就会编译报错（安全性高，如修改相关字段的名称或类型）</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在我开发<code>Go</code>语言的近六年时间里，看到相关的代码风格远不止这3种。通过反反复复倒腾，我认为代码可维护性最为重要，所以更倾向于 <strong>傻瓜式赋值</strong> 这个方法，哪怕牺牲一部分效率也是值得的（在IDE的帮助下，其实效率几乎没有影响）。</p><p>你的想法又是怎么样呢？欢迎与我交流沟通。</p><h2 id="编程思考-重视技术评审的过程性价值"><a href="#编程思考-重视技术评审的过程性价值" class="headerlink" title="编程思考 - 重视技术评审的过程性价值"></a>编程思考 - 重视技术评审的过程性价值</h2><p>我们模拟个场景：你写了一个自认为 <strong>当下最优解的技术方案</strong>，信心满满地拿出来评审，结果遭到各方的挑战，无法回答清楚很多问题，心里忿忿不平；评审后仍按你的方案执行，结果出来也很不错，你就觉得当时提问的那些评委都不如你。</p><p>相信很多人都有这样的经历，我也相当一段时间处于这种状态。不过，现在的我更愿意静下心，去关注过程里的一些内容：</p><ul><li>评委提出的“无意义”问题，是否有一部分来源于我叙述的不清楚？尤其是背景</li><li>评委们关心的角度是否与我的视角有差异？比如我更关心代码实现，而评委关注的是业务、稳定性、安全等</li><li>你获得的成果，是否仍有改进空间？适当地收集一些评委意见，弥补个人视角的盲区</li></ul><p>技术评审的主要价值是 <strong>优化方案</strong>。作为评审方，大部分的评委在多方面的能力都是高于本人的。如果你抱着“评委就是跟我过不去、就是乱挑刺”的想法去面对他们，那么对你来说就是浪费时间。</p><p>如果真有这么一个瞎挑刺的评委、他又是你工作中绕不过的领导，那该怎么办呢？退而求其次，技术评审还提供了一个交流的机会，你可以尝试着摸清他的一些思路，想想如何与其相处，<strong>为自己营造更轻松的工作环境</strong>。</p><h2 id="工作生活-主动创造美好瞬间"><a href="#工作生活-主动创造美好瞬间" class="headerlink" title="工作生活 - 主动创造美好瞬间"></a>工作生活 - 主动创造美好瞬间</h2><p>这个小标题起得有点煽情。</p><p>我想表达的是：在年轻时，我们可以肆意地享受人生的美好。但随着时间推移，我们往往会被家庭琐事、工作压力、身体健康等问题困扰，这就需要我们从被动的享受、慢慢地转变为主动创造，这样就能大幅提高生活的幸福感。</p><p>而且，我们创造的美好瞬间能让家人与朋友同样感受到快乐，提高整个圈子的幸福感；而整体氛围的提升，往往能形成正反馈，收益人也包括了你。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这段时间，我在尝试着远离抖音、B站、头条等消息媒介。&lt;/p&gt;
&lt;p&gt;这些平台承载了过多大数据推荐算法，反复向人们推送着高度重复性的内容，脱离了获取信息的初衷 - &lt;strong&gt;扩大自己的认知面&lt;/strong&gt;。如果你关注的内容包括了失业等负面内容，还容易加强你的焦虑感。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>【每周小结】2023-Week7</title>
    <link href="http://example.com/2023/02/12/weekly/weekly-2023-7/"/>
    <id>http://example.com/2023/02/12/weekly/weekly-2023-7/</id>
    <published>2023-02-12T10:00:00.000Z</published>
    <updated>2023-02-15T04:51:58.773Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><p>本周的总结发得比较晚，花在打磨编程思考部分的时间比较多。</p><p>虽然最终版本也不是很满意，不过也算达到了阶段性交付的水平。</p><span id="more"></span><h2 id="Go技巧-并发代码的单元测试"><a href="#Go技巧-并发代码的单元测试" class="headerlink" title="Go技巧 - 并发代码的单元测试"></a>Go技巧 - 并发代码的单元测试</h2><p>在<code>Go</code>语言开发的过程中，我们或多或少会引入并发模式，常见的如<code>go</code>、<code>channel</code>、<code>sync.WaitGroup</code>等。这些并发原语使用起来很方便，但常常会阻碍相关代码的单元测试，如依赖的<code>channel</code>发生阻塞，<code>mutex</code>被锁等，导致想验证的重要代码根本跑不到。</p><p>这里，我介绍一下自己的三个心得，用一句话概括，<strong>合理利用分层进行拆分，屏蔽并发逻辑</strong>。</p><blockquote><p>没有分层的基础或工具库不在本次的讨论范围内，但也可以借鉴这里的思想。</p></blockquote><h3 id="多协程的逻辑交由上层控制"><a href="#多协程的逻辑交由上层控制" class="headerlink" title="多协程的逻辑交由上层控制"></a>多协程的逻辑交由上层控制</h3><p>如下，原先的业务逻辑代码包括了两块处理逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 逻辑A</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑B</span></span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于逻辑B相关的代码无法验证，所以这个单元测试能做的很有限。这时，通过分层，我们将代码拆分为两部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上层代码 - 使用基础的并发特性，没有必要做单元测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  FooA()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">go</span> FooB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下层代码 - 做严格的单元测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FooA</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FooB</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的单元测试就变得直观了。</p><h3 id="锁类逻辑由下层对象封装"><a href="#锁类逻辑由下层对象封装" class="headerlink" title="锁类逻辑由下层对象封装"></a>锁类逻辑由下层对象封装</h3><p>业务代码常常会包含锁，这就导致很多函数中有大量的<code>Lock</code>、<code>UnLock</code>操作，容易在单元测试里验证一些逻辑时发生死锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// do a</span></span><br><span class="line">  m.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.UnLock()</span><br><span class="line">  <span class="comment">// do b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从抽象层面来说，业务逻辑的核心代码尽量减少锁这种 <strong>底层的并发原语</strong>，把它们放在业务逻辑里也很影响阅读体验。这时，将锁划分到下层会让代码逻辑更清晰：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下层对象</span></span><br><span class="line"><span class="keyword">type</span> FooA <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FooB <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 锁</span></span><br><span class="line">  sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 这里不包含锁逻辑</span></span><br><span class="line">  fooA.Do()</span><br><span class="line">  <span class="comment">// 这里包含锁逻辑</span></span><br><span class="line">  fooB.DO()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从使用锁的角度来说，<code>Lock</code>与<code>UnLock</code>之间的逻辑应尽量短，所以很适合放在底层对象、交由它自行控制，也能缩短锁的影响范围。</p><h3 id="同层抽离出核心控制函数"><a href="#同层抽离出核心控制函数" class="headerlink" title="同层抽离出核心控制函数"></a>同层抽离出核心控制函数</h3><p>在<code>Go</code>语言中，有一些并发特性、尤其以<code>channel</code>为代表，很难通过分层解决。例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">  <span class="comment">// 发送消息</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// send to c</span></span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 接收消息</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// receive from c</span></span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>channel</code>更多的是一种具有业务特性的并发控制，单独抽出一个 <strong>核心控制函数</strong> 就能提升整体的可读性与可测试性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心控制函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送逻辑</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := logicA()</span><br><span class="line">    c &lt;- a</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 接收逻辑</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := &lt;- c</span><br><span class="line">    logicB(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下逻辑均不包含channel，方便单元测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logicA</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logicB</span><span class="params">(a <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心控制函数很难通过单元测试完整验证，更考验的是开发人员对<code>Go</code>并发编程的基本功。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上三点是我在工作过程中的经验心得，帮助我解决了很多并发代码中的单元测试问题。它们不一定是最佳实践，但希望能对各位遇到相关问题时有一些启发。</p><h2 id="编程思考-平台开发的三个阶段"><a href="#编程思考-平台开发的三个阶段" class="headerlink" title="编程思考 - 平台开发的三个阶段"></a>编程思考 - 平台开发的三个阶段</h2><p>如今， <strong>平台开发</strong> 这个词已经广泛应用在程序员圈子内。在我看来，相关的开发者可以分为三个阶段：</p><ol><li><strong>初级阶段</strong>：根据用户的需求明细写过程性的CRUD，实现功能</li><li><strong>中级阶段</strong>：以<code>OpenAPI</code>的方式向多业务、多用户提供能力</li><li><strong>高级阶段</strong>：定制核心能力+复用通用能力</li></ol><p>其中，很多人往往走到中级阶段后就阻塞不前了，并且心得意满、认为平台的已经处于最终形态。但是，平台如果长期处于中级阶段，相关弊端会随着时间推移越发凸显，例如：</p><ul><li>没有技术壁垒 - 越是通用，越是普通，很容易被开源产品取代</li><li>调用方的使用成本高 - 开放接口往往透传各类参数，使用方成本高</li><li>无法贴合一线业务创造价值 - 平台以甲方自居，不去理解业务的使用场景</li></ul><p>我见过许多工作了近10年仍处于中级阶段的工程师，他们的技术能力十分高超，但很难在职业发展的道路上再进一步，关键就是在于对平台的认知 - <strong>平台的核心价值是靠 为业务创造的价值 来间接体现的，而不是靠 平台自身的能力 来直接评价</strong>。</p><h2 id="工作生活-少给自己找借口的机会"><a href="#工作生活-少给自己找借口的机会" class="headerlink" title="工作生活 - 少给自己找借口的机会"></a>工作生活 - 少给自己找借口的机会</h2><p>年后，我完整地跑了2次十公里，过程中也有近10次跑了不到一半就放弃。我的跑步配速不快，理应每次都能达成目标，那为什么还有这么多次半途而废呢？</p><p>我回顾了这几次的经历，总结如下：<strong>一旦我想要中途放弃，借口总是能找到的；所以，在整个跑步的过程中，保持一个稳定、平和的心态，不要让放弃的想法有可趁之机。</strong> </p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;本周的总结发得比较晚，花在打磨编程思考部分的时间比较多。&lt;/p&gt;
&lt;p&gt;虽然最终版本也不是很满意，不过也算达到了阶段性交付的水平。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>【每周小结】2023-Week6</title>
    <link href="http://example.com/2023/02/05/weekly/weekly-2023-6/"/>
    <id>http://example.com/2023/02/05/weekly/weekly-2023-6/</id>
    <published>2023-02-05T10:00:00.000Z</published>
    <updated>2023-02-07T02:10:36.455Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><p>本周开始，绝大多数人的工作与生活步入了常规模式。</p><p>希望大家的身体与心理都能尽快地适应工作或学习节奏，保持一颗愉悦的心情。</p><span id="more"></span><h2 id="Go技巧-浅谈1-20版本特性"><a href="#Go技巧-浅谈1-20版本特性" class="headerlink" title="Go技巧 - 浅谈1.20版本特性"></a>Go技巧 - 浅谈1.20版本特性</h2><p>本周<code>Go</code>语言<a href="https://tip.golang.org/doc/go1.20">1.20版本正式发布</a>，我们对其重要特性进行简单分析，为后续掌握<code>Go</code>的发展脉络做好铺垫。</p><h3 id="切片转数组"><a href="#切片转数组" class="headerlink" title="切片转数组"></a>切片转数组</h3><p>在1.17版本时，切换转数组的<a href="https://tip.golang.org/ref/spec#Conversions_from_slice_to_array_or_array_pointer">语法</a>已经支持，只是写起来比较冗余。在这次1.20版本进行了优化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更早版本 - 手工填充</span></span><br><span class="line"><span class="keyword">var</span> s = [<span class="number">4</span>]<span class="keyword">byte</span>&#123;x[<span class="number">0</span>],x[<span class="number">1</span>],x[<span class="number">2</span>],x[<span class="number">3</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go1.17 - 指针操作</span></span><br><span class="line"><span class="keyword">var</span> s = *(*[<span class="number">4</span>]<span class="keyword">byte</span>)(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go1.20 - 直接类型转换</span></span><br><span class="line"><span class="keyword">var</span> s = [<span class="number">4</span>]<span class="keyword">byte</span>(x)</span><br></pre></td></tr></table></figure><p>这个语法本身没有太多的学习成本，但官方在此时才完全支持，这就导致：<strong>在1.17版本前的绝大多数开发场景下，<code>Go</code>开发者都更愿意用更灵活的切片来代替数组</strong>。但相较于切片，固定长度的数组对节约内存更为友好。</p><p>而随着1.20版本的推出，使用数组的语法便利性大幅提高，相信会有更多追求极致性能的人开始引入数组。</p><h3 id="unsafe三个新函数"><a href="#unsafe三个新函数" class="headerlink" title="unsafe三个新函数"></a>unsafe三个新函数</h3><p>unsafe中提供了三个新函数：<code>SliceData</code>、<code>String</code>和<code>StringData</code>。</p><p>这三个函数是低频使用的，我们按需阅读<a href="https://pkg.go.dev/unsafe">官方文档</a>即可。如果你对<strong>指针</strong>的相关知识基础扎实，很容易理解这三个函数。</p><h3 id="时间常量的定义"><a href="#时间常量的定义" class="headerlink" title="时间常量的定义"></a>时间常量的定义</h3><p>终于，在1.20版本引入了开发者最常用的<a href="https://pkg.go.dev/time#pkg-constants">时间戳格式</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DateTime   = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br></pre></td></tr></table></figure><p>经历了多少次手写时间，查找了多少个相关的低级bug，官方终于把这个时间格式放到了标准库中。强烈建议升级到1.20版本的项目，先做一次变量的全局替换。</p><p>这里分享一个小tip：如何记忆这个时间戳？记住1~6：</p><ul><li>1月</li><li>2日</li><li>下午3点</li><li>4分</li><li>5秒</li><li>06年</li></ul><h3 id="error的组合"><a href="#error的组合" class="headerlink" title="error的组合"></a>error的组合</h3><p>标准库中的<code>error</code>支持了组合的能力，扩展了错误的使用场景。</p><p>例如，程序发生了错误，从开发者来看，既有属于数据库的错误A，又有属于业务逻辑的错误B。在上层用<code>errors.Is</code>判定时，只能在A与B中二选一。而1.20则引入了<code>Join</code>类型，则可以将两个错误组合起来，上层判断时两个都成立。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errA error</span><br><span class="line"><span class="keyword">var</span> errB error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合错误</span></span><br><span class="line"><span class="keyword">var</span> err = errors.Join(errA, errB)</span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>更新<strong>结构体比较</strong>的规范的说明（严格来说是修正了不严谨的说明，代码已经实现）</li><li>泛型类型对<code>Comparable</code>更多的支持</li><li><code>Go</code>后续支持各操作系统的计划</li><li>相关工具链的优化</li><li>编译速度提升，达到差不多引入泛型前的水平</li><li>运行时提升CPU效率约2%</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从近几个版本的迭代来看，<code>Go</code>官方一直关注前后版本兼容性，这对开发者来说体验是很棒的。官方把主要精力花在了两个方面：</p><ol><li>相关工具与库的建设，完善基本开发的生态</li><li>底层能力（如编译）的建设</li></ol><p>可见，<code>Go</code>团队通过前期的设计，帮助我们屏蔽了下层的细节，是一个很棒的编程体验。</p><h2 id="编程思考-对成长来说，划分边界是为了扩大边界"><a href="#编程思考-对成长来说，划分边界是为了扩大边界" class="headerlink" title="编程思考 - 对成长来说，划分边界是为了扩大边界"></a>编程思考 - 对成长来说，划分边界是为了扩大边界</h2><p>在编程开发中，有许多划分边界的事情，如：</p><ol><li>代码的模块划分</li><li>微服务的划分</li><li>业务领域的划分</li><li>网络的分层</li></ol><p>划分边界后就有了分工，优秀的分工协作可以带来组织效率的提升。但是，随着日复一日的重复性工作，很容易就只专注于自己职责范围内的部分，而忽略了相关方。近几年，许多公司倡导的 “跳出当前角色”、“共赢思想”、“FT-Feature Team” 等词汇，都是一种跨出当前工作内容、与周边其余组织团队合作的思想。</p><p>我们要从更高的视角来理解： 划分边界是为了整体实现更高价值的一种方法，而不是成为一种阻碍。所以，我们要不断地跨出当前职责，比如：</p><ul><li>了解某个模块的依赖方 - 如学习ORM库时，顺便了解一下数据库的基本知识</li><li>主动了解周边服务 - 如做支付系统时，了解订单系统的设计与交互</li></ul><p>从许多大厂的职级定义来看，职级的提升往往就是边界的扩大 - 从单个服务、一个系统、整套业务，最后甚至要有跳出技术的视角。</p><h2 id="工作生活-学习一些营养学知识"><a href="#工作生活-学习一些营养学知识" class="headerlink" title="工作生活 - 学习一些营养学知识"></a>工作生活 - 学习一些营养学知识</h2><p>最近看了<a href="https://book.douban.com/subject/27590675/">《你是你吃出来的》</a>和<a href="https://book.douban.com/subject/35340053/">《你是你吃出来的2》</a>两本书。书的内容涉及到许多健康、医学相关的内容，作者的文笔已经很通俗易懂了，有兴趣的朋友可以自己去看看。</p><blockquote><p>对书中的例子要保持理性：</p><p>比如某患者听了作者的说法，换了食谱，三个月后就恢复了。但是，三个月内其余因素是否有变化？比如吃了药、加强锻炼、心态变化等。</p></blockquote><p>读完本书，我有个观点一直萦绕心头：高血压、糖尿病等这种亚健康的情况，是很难定义边界的。虽然业内有参考值，但很容易因人种、环境等因素而变化，颇为个性化。而我们称它们为“病”，往往是已经严重到远超临界值了。对于这些情况，吃药就像是亡羊补牢 - 虽然有效果，但很难根治。我相信，大众更需要的是营养学知识的普及。</p><p>目前，绝大多数人很难有专属的家庭医生，这就要求每个人都拥有基础的营养学知识储备。相关的理论知识已经很完善了，但当前社会缺少一个权威的宣传路径，把这块知识普及到大众。</p><p>个人觉得像公众号、抖音视频等，由于整个传播路径上干扰信息过多，但很难具有公众说服力。而类似于 <strong>国家反诈中心</strong> 这种独立app更具有权威效应。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;本周开始，绝大多数人的工作与生活步入了常规模式。&lt;/p&gt;
&lt;p&gt;希望大家的身体与心理都能尽快地适应工作或学习节奏，保持一颗愉悦的心情。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>【每周小结】2023-Week5</title>
    <link href="http://example.com/2023/01/29/weekly/weekly-2023-5/"/>
    <id>http://example.com/2023/01/29/weekly/weekly-2023-5/</id>
    <published>2023-01-29T10:00:00.000Z</published>
    <updated>2023-02-07T01:47:49.755Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><p>本周过后，绝大多数打工人就需要从休假模式切换到工作模式。</p><p>趁着春节假期的尾巴，我们聊三个轻松的话题。</p><span id="more"></span><h2 id="Go技巧-从官方问卷谈谈未来发展"><a href="#Go技巧-从官方问卷谈谈未来发展" class="headerlink" title="Go技巧 - 从官方问卷谈谈未来发展"></a>Go技巧 - 从官方问卷谈谈未来发展</h2><p><code>Go</code>官方最近开放了一个<a href="https://google.qualtrics.com/jfe/form/SV_bNnbAtFZ0vfRTH8?s=b">问卷</a>，里面收集了用户的相关意见。整个问卷是全英文的，全部填完需要15min左右，有很多是收集用户背景与满意度的常规问题。</p><p>这里，我对其中的关键信息做一下提炼。</p><h3 id="配套工具的两个开发方向-Module与IDE"><a href="#配套工具的两个开发方向-Module与IDE" class="headerlink" title="配套工具的两个开发方向 - Module与IDE"></a>配套工具的两个开发方向 - Module与IDE</h3><p>官方在工具侧的两大投入方向在 <strong>模块化</strong> 与 <strong>IDE配套</strong> 。</p><p>先说说模块化。自<code>Go Module</code>推出之后，已成为一套官方标准，但仍有不少缺憾：如多模块化管理、互相依赖问题，需要官方给出明确的指导意见。而IDE配套，最常见的包括<code>Goland</code>、<code>VsCode</code>、<code>Vim</code>，需要有更多的插件进行支持，如接口与实现的跳转、重构相关工具等。</p><p>在我看来，IDE配套工具比模块化更为重要。尽管<code>Goland</code>已支撑了不少能力，但是其高收费、吃内存的特性，对开发者很不友好，而相对轻量级的<code>VsCode</code>面对复杂项目时，各项能力很难支撑。而模块化的问题虽然重要，但目前已有临时的解决方案，只要关注官方推出的方案即可。</p><h3 id="用Go语言开发的领域"><a href="#用Go语言开发的领域" class="headerlink" title="用Go语言开发的领域"></a>用Go语言开发的领域</h3><p>问卷中的领域方向罗列如下：</p><ul><li>Games</li><li>Mobile apps</li><li>Libraries or frameworks</li><li>Agents and daemons (e.g., monitoring)</li><li>Automation/scripts (e.g., deployment, configuration management)</li><li>A runnable/interactive program (CLI)</li><li>Desktop / GUI applications</li><li>Embedded devices / Internet of Things</li><li>Websites / web services (returning HTML)</li><li>Machine learning / Artificial intelligence</li><li>API/RPC services (returning non-HTML)</li><li>Data processing (e.g., pipelines, aggregation)</li></ul><p>我们不妨思考一下，<strong>Go语言适合哪些方向</strong>？（官方在问卷后面征询了用户意见，希望<code>Go</code>语言支持哪些方向）</p><p>这里，其实大部分的方向都具有 <strong>门槛</strong>，并不适合<code>Go</code>语言，例如：</p><ul><li>游戏方向需要引擎基础，主流是<code>C++</code></li><li>移动设备上的应用注重体验，要用原生的语言</li><li>嵌入设备很吃性能，主流是<code>C/C++</code></li><li>机器学习有TensorFlow/PyTorch等框架，主流是<code>Python</code></li><li>大数据生态基本定型，主流是<code>Java</code></li></ul><p>所以，目前用到<code>Go</code>语言的场景主要是三块：</p><ul><li>基础库与框架</li><li>命令行工具（采集agent、交互CLI）</li><li>后端服务（包括返回HTML与普通RPC）</li></ul><p>对这三个领域，我有如下建议，希望能引起思考：</p><ol><li>基础库与框架<ol><li>入门：基础库与框架的最重要目标是提效，那么如何量化到具体指标呢？</li><li>进阶：<code>Go</code>开源社区有不少库与框架，该如何取长补短、又能形成自己的技术壁垒呢？</li></ol></li><li>命令行工具<ol><li>入门：<code>Go</code>语言工具与脚本（<code>Shell</code>/<code>Python</code>）等的优劣比较，如何选型？</li><li>进阶：云原生技术生态结合，找准工具的切入角度与定位</li></ol></li><li>后端服务<ol><li>入门：与主流编程语言（<code>Java</code>）、框架（<code>Spring</code>）的优劣比较，如何选型？</li><li>进阶：沉淀一整套用<code>Go</code>语言开发的方法论（基建、迭代流程、技术价值等）</li></ol></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从目前来看，<code>Go</code>语言自身的迭代频率不高，整个生态也没有具有突破性的新产品诞生（如<code>Kubernetes</code>），接下来很难有井喷式的增长。而另一方面，<code>Go</code>语言入门的门槛较低，很难形成一定的壁垒（如果希望单靠编程语言就能具有技术壁垒的，建议走C++的路）。</p><p>所以，想要有足够的市场竞争力，除了<code>Go</code>语言，我们还需要 <strong>综合培养多方面的技能</strong>：如计算机基础、业务理解、项目管理等，而不要固守一项技能，被市场慢慢淘汰。</p><h2 id="编程思考-不要陷入过程性的编码"><a href="#编程思考-不要陷入过程性的编码" class="headerlink" title="编程思考 - 不要陷入过程性的编码"></a>编程思考 - 不要陷入过程性的编码</h2><p>这个子标题包含两层意思。</p><p>第一层比较直观：<strong>不要单纯面向过程地编码，而是学会抽象、面向对象</strong>。这是一个老生常谈的话题，我举一个例子：</p><p>现在，要开发一个管理书本的功能。在面向过程时，我们思路是增删改查，很容易写出对应的代码；而如果要抽象，我们需要钻研 - <strong>书</strong> 这个对象，就冒出各种问题：</p><ul><li>书需要哪些属性？</li><li>书的管理有权限吗？</li><li>书与书之间有关联吗？</li></ul><p>这些问题也许最终并没有对代码开发有所帮助，但能帮助开发者锻炼抽象思维与理解业务场景。</p><p>第二层则是一种工作状态：<strong>不要闷头写代码，而应时不时确认方向的正确性。</strong></p><p>在Coding时，有些人会陷入 <strong>心流</strong> 的状态，感觉如有神助，一下子写出几千行代码，但回过头却发现这些代码是无效的 - 不满足需求。要解决这个问题，需要突破两个舒适区：</p><ol><li><strong>高频沟通</strong>：以文档或demo的方式与需求方沟通，而不要闷头“自嗨式”地闭门造车</li><li><strong>放弃沉没成本</strong>：在软件行业高频迭代的场景下，很容易出现某项工作中途叫停的情况。如果有足够的自信支撑，那么继续坚持是一种勇气；而如果判断最终大概率失败，那么选择中途放弃也是很大的勇气。</li></ol><p>用一个词来总结以上两点的话，就是常谈的 <strong>以终为始</strong> 。</p><h2 id="工作生活-更多维的视角"><a href="#工作生活-更多维的视角" class="headerlink" title="工作生活 - 更多维的视角"></a>工作生活 - 更多维的视角</h2><p>在春节的尾巴，我和朋友去吃了个自助餐。</p><p>入座后，我发现隔壁座有个小哥哥，穿着一身睡衣，一个人不紧不慢地吃着，时不时地和服务员闲聊两句，整个就餐过程表现得非常轻松；而到我这边，则一心想着“吃回本”，填鸭式地往嘴里塞，就餐过程非常仓促，最后挺着撑饱的肚子才离开。</p><p>我的这种情况在网上非常常见，尤其是那些大胃王的短视频，给观众带来价值观是一种 <strong>零和博弈</strong> - 吃得少就是商家赚、食客亏，吃得多就是食客赚、商家亏。这种观点没有问题，却扭曲了很多人吃自助餐的初衷 - 吃自助只是为了不受拘束地点餐或者享受某个美食。如果顾客只是为了吃亏商家，那么商家要么降低服务品质，要么只能倒闭。</p><p>世界并不是非黑即白的，我们要从更多维的视角来看问题：单维度的视角（如金钱的得失）很容易发生冲突，而多维度的视角（比如那位小哥哥享受了就餐的过程）可以让我们更享受生活。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;本周过后，绝大多数打工人就需要从休假模式切换到工作模式。&lt;/p&gt;
&lt;p&gt;趁着春节假期的尾巴，我们聊三个轻松的话题。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>【每周小结】2023-Week4</title>
    <link href="http://example.com/2023/01/22/weekly/weekly-2023-4/"/>
    <id>http://example.com/2023/01/22/weekly/weekly-2023-4/</id>
    <published>2023-01-22T12:00:00.000Z</published>
    <updated>2023-01-24T15:03:30.620Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><p>新的一年已经到来，祝各位读者2023年身体健康、家庭美满。</p><p>回到本篇的主题，我继续来聊聊本周的一些心得。</p><span id="more"></span><h2 id="Go技巧-接口实现下的三个代码复用技巧"><a href="#Go技巧-接口实现下的三个代码复用技巧" class="headerlink" title="Go技巧 - 接口实现下的三个代码复用技巧"></a>Go技巧 - 接口实现下的三个代码复用技巧</h2><p>在面向对象开发的场景下，我们经常会写高度重复的<code>Go</code>代码。为了帮助大家形成一定的方法论，这里以一个具体场景为例，分享我的三个技巧。</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/interface-3-way.png"></p><h3 id="示例：一个接口-三个实现"><a href="#示例：一个接口-三个实现" class="headerlink" title="示例：一个接口 + 三个实现"></a>示例：一个接口 + 三个实现</h3><p>我们以上图为例，看看示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义 - 订单</span></span><br><span class="line"><span class="comment">// 方法定义：创建订单Create与关闭订单Close</span></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">interface</span> &#123;</span><br><span class="line">  Create() error</span><br><span class="line">  Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三种具体的订单类型 Order1 Order2 Order3</span></span><br><span class="line"><span class="comment">// 为了实现接口Order，这三个结构都需要实现 Create与Close 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Order1部分</span></span><br><span class="line"><span class="keyword">type</span> Order1 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order1)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order1)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order2部分</span></span><br><span class="line"><span class="keyword">type</span> Order2 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order2)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order2)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order3部分</span></span><br><span class="line"><span class="keyword">type</span> Order3 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order3)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order3)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际场景中，<code>Order1</code>/<code>Order2</code>/<code>Order3</code>的逻辑、数据高度相似，出现大量的重复性代码。如何提升这部分代码的开发效率呢？下面给出三个途径：</p><h3 id="方法1：快刀斩乱麻-函数复用"><a href="#方法1：快刀斩乱麻-函数复用" class="headerlink" title="方法1：快刀斩乱麻 - 函数复用"></a>方法1：快刀斩乱麻 - 函数复用</h3><p>最直接的方法就是抛开面向对象的一堆概念，单纯地用函数复用来解决问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createOrder</span><span class="params">(ctx context.Context, data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closeOrder</span><span class="params">(ctx context.Context, data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以Order1为例，Order2/Order3类似</span></span><br><span class="line"><span class="keyword">type</span> Order1 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order1)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 调用 createOrder</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order1)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123; </span><br><span class="line">  <span class="comment">// 调用 closeOrder</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种编程思维是面向过程的，虽然不够抽象，但它确实是 <strong>最便捷的代码复用方式</strong>。而且，在很多情况下，我们不会对这块代码有大更新，函数复用是一个 <strong>高性价比</strong> 的选择。</p><p>但我们的追求不仅限于此：如果这块代码涉及业务核心，高频迭代，会出现什么样的现象呢？举3个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1 - 入参不断增加</span></span><br><span class="line"><span class="comment">// 某些订单的需要一些额外的数据，那么就必须增加入参（并且这个参数很难通用！）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createOrder</span><span class="params">(ctx context.Context, data <span class="keyword">interface</span>&#123;&#125;, other, more <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2 - 大量的if-else</span></span><br><span class="line"><span class="comment">// 一个函数适配多种逻辑，只能增加判断逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createOrder</span><span class="params">(ctx context.Context, data <span class="keyword">interface</span>&#123;&#125;, otherData <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> orderType == <span class="number">1</span> &#123;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> price &gt; <span class="number">1000</span> &#123;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例3 - 创建多个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createOrder2</span><span class="params">()</span> <span class="title">error</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createOrder3</span><span class="params">()</span> <span class="title">error</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>以上这些代码是不整洁的，相信大部分人不愿在自己开发过程中看到。这种过程性代码复用的思路，见效虽快，但在复杂场景下弊端愈发明显。下面，我们引入第二个方法：</p><h3 id="方法2：对象抽象的妙用-嵌套-Overwrite"><a href="#方法2：对象抽象的妙用-嵌套-Overwrite" class="headerlink" title="方法2：对象抽象的妙用 - 嵌套+Overwrite"></a>方法2：对象抽象的妙用 - 嵌套+Overwrite</h3><p><code>Go</code>并不是一门完全面向对象的语言，但对于复杂场景，会用嵌套来支持一定的代码复用。代码示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个基础对象，实现了接口 Order</span></span><br><span class="line"><span class="keyword">type</span> CommonOrder <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *CommonOrder)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *CommonOrder)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order1 利用嵌套，直接实现了Create和Close两个方法</span></span><br><span class="line"><span class="keyword">type</span> Order1 <span class="keyword">struct</span> &#123;</span><br><span class="line">  *CommonOrder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order2 也利用了嵌套，Close方法会复用，但Create方法会被覆盖</span></span><br><span class="line"><span class="keyword">type</span> Order2 <span class="keyword">struct</span> &#123;</span><br><span class="line">  *CommonOrder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overwrite</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order2)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order3 两个方法都会被覆盖</span></span><br><span class="line"><span class="keyword">type</span> Order3 <span class="keyword">struct</span> &#123;</span><br><span class="line">  *CommonOrder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overwrite</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order3)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overwrite</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order3)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套+<code>Overwrite</code>的组合能力，支撑了<code>Go</code>语言面向对象的很多特性。与之前的函数复用对比，这种方法的可读性会更棒（这也非常依赖开发者面向对象的抽象能力）。</p><p>到这一阶段，维护绝大多数的项目已经足够。但如果你是一个苛求细节的人，在继续开发的过程中会发现一个问题：<strong>即便代码的逻辑一致，我们却常常因为数据结构不同，而编写出高度重复性的代码。</strong>那么，我们再看第三个方法：</p><h3 id="方法3：剥离数据结构的差异-泛型"><a href="#方法3：剥离数据结构的差异-泛型" class="headerlink" title="方法3：剥离数据结构的差异 - 泛型"></a>方法3：剥离数据结构的差异 - 泛型</h3><p>我们先看如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OrderInfo1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order1)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 数据结构 OrderInfo1 保存的是 Order1 订单信息</span></span><br><span class="line">  <span class="keyword">var</span> order *OrderInfo1</span><br><span class="line">  <span class="comment">// 插入msyql</span></span><br><span class="line">  err := mysql.Insert(order)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 序列化后打印</span></span><br><span class="line">  b,err := json.Marshal(order)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderInfo2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order2)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 数据结构 OrderInfo2 保存的是 Order2 订单信息</span></span><br><span class="line">  <span class="keyword">var</span> order *OrderInfo2</span><br><span class="line">  <span class="comment">// 后面操作同Order1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderInfo3 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order3)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 数据结构 OrderInfo3 保存的是 Order3 订单信息</span></span><br><span class="line">  <span class="keyword">var</span> order *OrderInfo3</span><br><span class="line">  <span class="comment">// 后面操作同Order1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码很难通过上述两个方法解决。而如果利用泛型，会变得非常巧妙：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将公共逻辑抽象到这个泛型函数中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span>[<span class="title">OrderInfo</span> <span class="title">interface</span></span>&#123;&#125;](order OrderInfo) error &#123;</span><br><span class="line">  err := mysql.Insert(order)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  b,err := json.Marshal(order)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个Order的Create方法就非常清晰了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order1)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> order *OrderInfo1</span><br><span class="line">  <span class="keyword">return</span> Create[OrderInfo1](order)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order2)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> order *OrderInfo2</span><br><span class="line">  <span class="keyword">return</span> Create[OrderInfo2](order)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order3)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> order *OrderInfo3</span><br><span class="line">  <span class="keyword">return</span> Create[OrderInfo3](order)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型特性的引入，往往出现在数据处理层，即和基础库、工具库相关的地方，而在业务层很少出现。我们可以从如下两点进行分析：</p><ul><li>业务层主要的特点在与 <strong>逻辑差异大</strong>，对数据结构也有各种校验等，不适用泛型；</li><li>数据处理层则往往逻辑一致，仅仅只有数据结构的差异，泛型非常适配。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>函数复用、嵌套+<code>Overwrite</code>、泛型，是三种非常有效的代码复用技巧。希望大家能够循序渐进，在工程中找到属于自己的最佳实践。</p><h2 id="编程思考-开发前的三个文档"><a href="#编程思考-开发前的三个文档" class="headerlink" title="编程思考 - 开发前的三个文档"></a>编程思考 - 开发前的三个文档</h2><p>在开发一个项目前，有三个文档是必备的，我们称为 - <strong>BRD</strong>、<strong>PRD</strong>、<strong>技术方案</strong>，它们在项目流程中依次编写。</p><ol><li>BRD（商业需求文档）：这个文档有一个关键词 - 商业价值，不仅要了解用户痛点，更要结合市场，发掘价值</li><li>PRD（产品需求文档）：与产品经理角色相关，设计功能交互，体现出两种重要的思维：产品思维与用户思维</li><li>技术方案：开发者最熟悉的文档，最主要的是设计，但更重要的是评估能力，如排期、风险</li></ol><p>编写技术方案不难，普通开发者工作两三年就能有一个很棒的呈现；而PRD则须要 <strong>视野转换</strong>，从用户与产品的角度来思考功能的开发；BRD则最为复杂，往往要多年行业经验积累以及深刻的用户洞察。</p><p>大家可以在日常开发中多主动地接触优秀的PRD、BRD，不仅能拓宽视野，更能提升个人认知。</p><h2 id="工作生活-学会聚焦，才能做好取舍"><a href="#工作生活-学会聚焦，才能做好取舍" class="headerlink" title="工作生活 - 学会聚焦，才能做好取舍"></a>工作生活 - 学会聚焦，才能做好取舍</h2><p>不同人、在不同的阶段，对工作和生活的平衡点都有不同的理解。所以，我认为没有必要去过多地从他人经验里去探求 <strong>最佳平衡点</strong>，也没有必要把工作和生活当作对立面，而是在日常反复问自己：<strong>我究竟想要什么？</strong></p><p>有取，往往就需要舍弃，这时就会犹豫代价是否过大。我总是过多地担忧所失去的，就扭曲了原问题：<strong>不再关注自己最想要的，而转过头去关注可能失去的，情绪上出现焦虑，甚至恐慌</strong>。简而言之，就是要认清自己，学会聚焦。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;新的一年已经到来，祝各位读者2023年身体健康、家庭美满。&lt;/p&gt;
&lt;p&gt;回到本篇的主题，我继续来聊聊本周的一些心得。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>【每周小结】2023-Week3</title>
    <link href="http://example.com/2023/01/15/weekly/weekly-2023-3/"/>
    <id>http://example.com/2023/01/15/weekly/weekly-2023-3/</id>
    <published>2023-01-15T12:00:00.000Z</published>
    <updated>2023-01-16T02:52:25.866Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><p>本周，我的工作模式正式从远程办公回到了现场办公。恰逢过年，整体工作节奏放缓，切换的过程很顺畅。</p><p>虽然我十分期待远程办公成为常态，但不得不承认，这种模式在中国落地，还有一段路要走。</p><span id="more"></span><h2 id="Go技巧-提高ORM使用体验的三个要点"><a href="#Go技巧-提高ORM使用体验的三个要点" class="headerlink" title="Go技巧 - 提高ORM使用体验的三个要点"></a>Go技巧 - 提高ORM使用体验的三个要点</h2><p>ORM是一个非常高频使用的开发工具。以下图为例，<strong>Go程序内与MySQL中，数据存储是异构的</strong> ，这就导致传统开发方式会分成两步：</p><ol><li>将Go程序中的数据转换成MySQL的 <code>SQL</code> 语句</li><li>解析MySQL 返回的数据到具体结构体中</li></ol><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/ORM.png"></p><p>这部分的开发有大量重复性的代码，如拼接SQL、数据解析，所以就有了ORM这个概念 - <strong>将内存中的数据结构（对象）与数据库中的表对应起来</strong>。一旦映射关系建立，那就可以调用ORM里的CRUD完成日常开发。在Go语言程序中，最常见的就是<a href="https://gorm.io/zh_CN/docs/">gorm</a>。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们以Book作为对象为例，它在Go程序中的定义是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id         <span class="keyword">int64</span>     <span class="string">`gorm:&quot;column:id&quot;`</span></span><br><span class="line">    BookName   <span class="keyword">string</span>    <span class="string">`gorm:&quot;column:book_name&quot;`</span></span><br><span class="line">    UpdateTime time.Time <span class="string">`gorm:&quot;column:update_time&quot;`</span></span><br><span class="line">    Status     <span class="keyword">int</span>       <span class="string">`gorm:&quot;column:status&quot;`</span>     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应MySQL中的建表语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `books`</span><br><span class="line">(</span><br><span class="line">    `id`          <span class="type">bigint</span>(<span class="number">20</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    `book_name`   <span class="type">varchar</span>(<span class="number">255</span>)        <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;书名&#x27;</span>,</span><br><span class="line">    `update_time` datetime            <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> NOW() COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    `status`      tinyint(<span class="number">3</span>)          <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">  CHARSET <span class="operator">=</span> utf8mb4</span><br><span class="line">  <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_bin COMMENT <span class="string">&#x27;书&#x27;</span>;</span><br></pre></td></tr></table></figure><p>完成定义后，我们可以使用<code>gorm</code>库实现CRUD了。但基于ORM库，开发中还是会高频出现一些奇怪的问题：<strong>明明程序没有bug，ORM的操作结果却没有达到预期</strong>。例如插入时<code>status</code>字段是0，没有报错，但查询时缺变成了100。</p><p>这类问题，往往是开发者在设计时没有注重 <strong>用户认知</strong> 导致的，也就是说 现象反直觉、所见非所得。我们今天的话题，将基于此展开：</p><h3 id="要点一：程序侧-节制地使用ORM能力"><a href="#要点一：程序侧-节制地使用ORM能力" class="headerlink" title="要点一：程序侧 - 节制地使用ORM能力"></a>要点一：程序侧 - 节制地使用ORM能力</h3><p>ORM往往扩展了很多能力，但大幅度地增加了用户的学习成本与排查问题时的成本。以<a href="https://gorm.io/zh_CN/docs/models.html#%E5%AD%97%E6%AE%B5%E7%BA%A7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6">GORM字段权限控制</a>为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;&lt;-:create&quot;`</span> <span class="comment">// 允许读和创建</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;&lt;-:update&quot;`</span> <span class="comment">// 允许读和更新</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;&lt;-&quot;`</span>        <span class="comment">// 允许读和写（创建和更新）</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;&lt;-:false&quot;`</span>  <span class="comment">// 允许读，禁止写</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;-&gt;&quot;`</span>        <span class="comment">// 只读（除非有自定义配置，否则禁止写）</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;-&gt;;&lt;-:create&quot;`</span> <span class="comment">// 允许读和写</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;-&gt;:false;&lt;-:create&quot;`</span> <span class="comment">// 仅创建（禁止从 db 读）</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;-&quot;`</span>  <span class="comment">// 通过 struct 读写会忽略该字段</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;-:all&quot;`</span>        <span class="comment">// 通过 struct 读写、迁移会忽略该字段</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;-:migration&quot;`</span>  <span class="comment">// 通过 struct 迁移会忽略该字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来特性很酷，但如果你作为读代码的人，你愿意去读一个结构体中每个Field的<code>tag</code>详情吗？而且，这种限制藏得很隐蔽，发生问题后排查起来很累。</p><p>因此，程序侧的ORM定义，最重要的是能<strong>保证程序数据结构与数据库存储结构一一映射，其余特性需要慎用</strong>。</p><blockquote><p>慎用不代表不用。</p><p>如果能在团队内部形成规范，一方面这个规范能落地到代码里，另一方面也能宣传到各个成员、让大家形成共识，那就能用这些特性提升开发效率。</p></blockquote><h3 id="要点二：数据库侧-最简化设计"><a href="#要点二：数据库侧-最简化设计" class="headerlink" title="要点二：数据库侧 - 最简化设计"></a>要点二：数据库侧 - 最简化设计</h3><p>程序侧的代码对开发者可见，排查问题相对清晰。而如果问题最终是在数据库侧导致的，那么就变得复杂了：</p><ul><li>技术领域不同 - 数据库存在一定的专业性，经验尚浅的开发者需要一定的经验积累</li><li>访问权限 - 角色、环境等问题，可能导致排查困难</li><li>滞后性 - 出现问题的优先排查对象往往是代码，数据库往往会被我们“默认”认为没问题</li></ul><p>所以，我们在前期设计数据库侧的内容时，要尽可能地保证简单。我个人的评判标准是：<strong>让Go结构体的数据，和MySQL表中的一行数据完全对应</strong>，不做额外的工作。</p><p>我举两个反例：</p><ol><li>字段默认值有特殊的含义，如建表时<code>status</code>的默认值设置为100<ol><li>改进方案：如果100这个值有业务含义，应在Go程序中设置</li></ol></li><li>表中增加Trigger，如<code>status</code>字段修改为某个值后，自动触发另一个字段的修改<ol><li>改进方案：在Go程序中实现这块逻辑</li></ol></li></ol><h3 id="要点三：ORM能力与数据库特性的综合考量"><a href="#要点三：ORM能力与数据库特性的综合考量" class="headerlink" title="要点三：ORM能力与数据库特性的综合考量"></a>要点三：ORM能力与数据库特性的综合考量</h3><p>第三个要点最为复杂，它需要结合ORM库的具体能力以及数据库的自身特性来综合考量：ORM的有些特性并不完善，具体在哪实现？</p><p>依旧以gorm为例，在用<code>Book</code>结构体进行<a href="https://gorm.io/zh_CN/docs/update.html#%E6%9B%B4%E6%96%B0%E5%A4%9A%E5%88%97">多列更新</a>时，无法更新其中的默认值，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 官方示例</span></span><br><span class="line"><span class="comment">// 代码原理：Active字段是默认值false，所以不会更新</span></span><br><span class="line"><span class="comment">// 用户认知：因为惯性思维，往往认为这个值会被设置为false</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>, Active: <span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure><p>我们先不考虑具体解决方案，而是希望大家能认识到ORM的局限性 - 想用一个结构体完全覆盖所有的增删改查场景，是不现实的。选择方案，其实是<code>trade-off</code>，选择一个团队更能快速理解的策略。</p><blockquote><p>想了解方案的同学，可以参考我之前的<a href="https://junes.tech/2022/11/03/go-study/go-rpc-4/">博客</a>。</p></blockquote><p>第三点是进阶性质的能力，需要大量ORM与数据库侧的开发经验，今天不作展开。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>ORM的使用体验会大幅提升CRUD的开发与维护效率。我比较提倡 <strong>在设计时，最简化ORM与数据库侧的特性</strong>，只采用其核心的映射能力。</p><p>而当简化到一定程度后，我们可以打通两侧的数据结构，如示例中的<code>Book</code>结构体与<code>books</code>建表语句。由于MySQL中的数据类型更为复杂，可以维护一个从 <strong>解析建表语句，自动生成Go中ORM结构体</strong> 的代码生成工具。</p><blockquote><p>实现可以参考<a href="https://junes.tech/2021/09/27/go-framework/go-framework-7/">博客</a> </p></blockquote><h2 id="编程思考-开发者的coding经验"><a href="#编程思考-开发者的coding经验" class="headerlink" title="编程思考 - 开发者的coding经验"></a>编程思考 - 开发者的coding经验</h2><p>如今的应届生在校或实习时就具备了颇为深厚的编程经验，参加工作后能快速地胜任日常需求，这就引起了老一批工程师的焦虑，不禁怀疑：我们的coding经验究竟有什么价值？</p><p>下面，我分享一下个人的思考，会从低到高三个维度进行讲述：</p><ol><li><strong>代码维度 - 写得好，读得懂</strong>：看过、写过的代码多，一方面让自己写代码时可读性提高，另一方面也能适应五花八门的项目风格。</li><li><strong>功能维度 - 懂需求，善取舍</strong>：代码所实现的功能，往往和最终预期有出入，如沟通损耗、认知差异等；而功能实现的过程中往往需要取舍，要理清主次先后。</li><li><strong>系统维度 - 识风险，促迭代</strong>：开发的代码从来就不是孤立的，需要识别出它对系统其余功能是否会产生风险；同时，本次开发也是一个迭代的机会，例如建设更通用的模块、修复一些历史包袱等。</li></ol><p>以上三点维度不同，但很难从价值维度区分高低。从这三点来看，一个资深coder对团队的价值非常重要。</p><h2 id="工作生活-焦虑感的缓解"><a href="#工作生活-焦虑感的缓解" class="headerlink" title="工作生活 - 焦虑感的缓解"></a>工作生活 - 焦虑感的缓解</h2><p>这几年，我的焦虑感与日俱增，尤其是近两年的行业低谷。面对焦虑，专家们有很多思路，这里分享三个对我帮助最大的方法：</p><ul><li>多锻炼，既能保证身体能量充沛，又可以释放很多负能量</li><li>多读书（尤其是心理学），提升心智成熟，坦然地面对不确定性</li><li>多沟通，与同事、领导、朋友等多种角色，进行真诚的交流</li></ul><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;本周，我的工作模式正式从远程办公回到了现场办公。恰逢过年，整体工作节奏放缓，切换的过程很顺畅。&lt;/p&gt;
&lt;p&gt;虽然我十分期待远程办公成为常态，但不得不承认，这种模式在中国落地，还有一段路要走。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>【每周小结】2023-Week2</title>
    <link href="http://example.com/2023/01/08/weekly/weekly-2023-2/"/>
    <id>http://example.com/2023/01/08/weekly/weekly-2023-2/</id>
    <published>2023-01-08T12:00:00.000Z</published>
    <updated>2023-01-08T13:10:10.874Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg"></p><p>作为一名年龄30+程序员，随着2023年的到来，我的工作和生活正在逐步变化。</p><p>本系列会以周维度为周期，记录我对如下三块内容的思考，大家挑选各自感兴趣的内容阅读即可：</p><ul><li><strong>Go技巧</strong> - Go开发者作为重点阅读的群体，不忘初心</li><li><strong>编程思考</strong> - 面向所有开发者，从系统设计等高层维度进行分享</li><li><strong>工作生活</strong> - 以更贴近生活的视角，分享时间管理、职业发展、焦虑感的一些心得</li></ul><span id="more"></span><h2 id="Go技巧-用接口interface提高模块间协作效率"><a href="#Go技巧-用接口interface提高模块间协作效率" class="headerlink" title="Go技巧 - 用接口interface提高模块间协作效率"></a>Go技巧 - 用接口<code>interface</code>提高模块间协作效率</h2><p>本周要分享的一个技巧是 - <strong>用接口<code>interface</code>提高模块间协作效率</strong>。</p><p>我们在协作开发时，在划分清边界后，就需要协同开发。而这个边界，如果能结合<code>interface</code>特性，就会大幅提升效率。从边界功能的角色来看，主要包括2个：<strong>提供方</strong>与<strong>调用方</strong>。</p><p>从下图来看：</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1.png"></p><p>我们以一个具体工作内容为例：我们要开发一个Book的CRUD的工作，但时间紧迫，所以计划分为两块：</p><ul><li>A同学 - HTTP API部分</li><li>B同学 - MySQL数据库部分</li></ul><p>而由于数据库部分的工作比较少，所以计划让B同学来主导接口这块工作，即B是提供方，A是使用方。接下来的三块工作内容如下：</p><h3 id="1-设计接口"><a href="#1-设计接口" class="headerlink" title="1 - 设计接口"></a>1 - 设计接口</h3><p>B同学给出一版接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心接口定义</span></span><br><span class="line"><span class="keyword">type</span> BookDao <span class="keyword">interface</span> &#123;</span><br><span class="line">  Create(book *Book) error</span><br><span class="line">  Delete(bookId <span class="keyword">int64</span>) error</span><br><span class="line">  List(pageNumber,pageSize <span class="keyword">int</span>) ([]*Book, error)</span><br><span class="line">  Update(bookId <span class="keyword">int64</span>, bookName <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化，新建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBookDao</span><span class="params">()</span> <span class="title">BookDao</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里并没有真正的代码实现。代码重点包括3个部分：</p><ul><li><code>interface</code>的定义：核心内容，方便使用者阅读</li><li>实例化：<code>interface</code>怎么创建</li><li>数据结构：<code>interface</code>涉及的结构体</li></ul><p>这一块，非常考验B同学的代码设计能力：怎么样让使用者快速了解你的设计？注释固然是一个不错的方式，但更好的方式是通过函数名、参数名等，详情可参考《 Effective Go》、《代码整洁之道》等资料。</p><h3 id="2-审核接口"><a href="#2-审核接口" class="headerlink" title="2 - 审核接口"></a>2 - 审核接口</h3><p>在B同学完成初步设计后，就需要A同学进行审核。审核主要的目标：<strong>发掘信息差，保证最终功能的正确性</strong>。</p><p>信息差来源于不同模块的上下文差异。比如说，数据库同学更关注底层的数据存储，而API层的同学更关注用户的使用场景。所以，通过评审，A同学可以发现与B同学的信息差，并对接口提出意见、希望B同学加以改进。</p><p>从上面的示例来看，可能存在如下问题，我用注释的方式加以说明（往往结合Code Review）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BookDao <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 需求点1：提供批量创建的能力</span></span><br><span class="line">  Create(book *Book) error</span><br><span class="line">  <span class="comment">// 需求点2：能否支持软删除</span></span><br><span class="line">  Delete(bookId <span class="keyword">int64</span>) error</span><br><span class="line">  <span class="comment">// 需求点3：查询能否支持一些字段的模糊查询，如bookName</span></span><br><span class="line">  <span class="comment">// 需求点4：需要查询满足条件的Book总数，支持分页功能</span></span><br><span class="line">  List(pageNumber,pageSize <span class="keyword">int</span>) ([]*Book, error)</span><br><span class="line">  <span class="comment">// 需求点5：需要修改其余字段，如作者author</span></span><br><span class="line">  Update(bookId <span class="keyword">int64</span>, bookName <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需求点6：字段缺失：如出版商、出版时间</span></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，就是A与B的不断沟通、不断修改<code>interface</code>的过程，直到双方基本达成一致。</p><h3 id="3-实现与使用接口"><a href="#3-实现与使用接口" class="headerlink" title="3 - 实现与使用接口"></a>3 - 实现与使用接口</h3><p>随着接口的敲定，接下来的工作就可以兵分两路了:</p><ul><li>B - 提供方去编写这个接口的具体实现，也就是MySQL相关的部分</li><li>A - 使用方调用代码，完成上层业务部分的开发</li></ul><p>可以看到，<code>interface</code>的定义有利于将工作进行拆分，定义关键边界，然后各自完成独立开发。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从两个角色来看，他们侧重的能力点会有差异：</p><ul><li>提供者：偏向基础能力，主要在于代码的可读性与能力的通用性（不仅仅对接一个使用方）</li><li>使用者：偏向业务能力，需要结合用户使用场景来思考程序设计</li></ul><p>这个情况不仅仅存在于模块间设计，在更大的系统设计时也有非常重要的体现。所以，这是一个很好的提升能力的机会。</p><h2 id="编程思考-提高个人的市场竞争力"><a href="#编程思考-提高个人的市场竞争力" class="headerlink" title="编程思考 - 提高个人的市场竞争力"></a>编程思考 - 提高个人的市场竞争力</h2><p>最近，我经常看到一个问题：<strong>我该学习什么编程能力？</strong> 我会先关心提问者的初衷，常见分为两种：</p><ul><li>提升编程能力</li><li>提高个人的市场竞争力</li></ul><p>相信绝大多数的人都是为了后者。单纯为了提升编程能力的话，自己去啃那些经典教材即可。</p><p>认清并承认自己的目标很重要。关于<strong>程序员的市场竞争力</strong>这个问题，我分享个人的三点看法：</p><ul><li>从ROI的角度分析个人的能力成长方向，把自己当作一个商品（想不清楚的话，多搜搜各大公司的招聘要求）</li><li>多和“高阶人士”交流，扩展视野：可以是职位比你高的领导，也可以是某个方向的资深人员</li><li>为机遇创造条件（能力储备、人脉），但不要一心追求机遇，而是逐步成长</li></ul><h2 id="工作生活-记录生活作息"><a href="#工作生活-记录生活作息" class="headerlink" title="工作生活 - 记录生活作息"></a>工作生活 - 记录生活作息</h2><p>我从本周开始，记录了自己的每日生活作息，分为7类：</p><ul><li>睡眠</li><li>吃饭</li><li>工作</li><li>娱乐</li><li>学习</li><li>运动</li><li>家庭</li></ul><p>记录的动作很简单，拿纸笔就能快速完成，但我在今年才开始真正地做这件事。这背后，我长期存在的一个性格问题：<strong>我清楚自己浪费时间的问题所在，但不敢真正地去面对它，更羞于看到具体的浪费时长。</strong></p><p>我的最终目标也不是为了成为一个时间管理领域的达人，而是 <strong>让自己时间更可控</strong>，减少来自浪费时间的焦虑感。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/weekly.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;作为一名年龄30+程序员，随着2023年的到来，我的工作和生活正在逐步变化。&lt;/p&gt;
&lt;p&gt;本系列会以周维度为周期，记录我对如下三块内容的思考，大家挑选各自感兴趣的内容阅读即可：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Go技巧&lt;/strong&gt; - Go开发者作为重点阅读的群体，不忘初心&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编程思考&lt;/strong&gt; - 面向所有开发者，从系统设计等高层维度进行分享&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作生活&lt;/strong&gt; - 以更贴近生活的视角，分享时间管理、职业发展、焦虑感的一些心得&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Weekly" scheme="http://example.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>Go-Buf教程 - 2.【背景篇】Buf生态概览</title>
    <link href="http://example.com/2022/12/30/go-buf/go-buf-2/"/>
    <id>http://example.com/2022/12/30/go-buf/go-buf-2/</id>
    <published>2022-12-30T04:00:00.000Z</published>
    <updated>2023-01-09T11:47:52.828Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-buf.jpg"></p><p>在上一讲，我们明确了<code>Buf</code>套件的定位 - <strong><code>Buf</code>重点是通过对<code>Protobuf Schema</code>的规范化，提供代码生成、依赖管理等一站式的API接口管理方案，来保证开发效率与团队协作的收益最大化。</strong></p><p>那么，<code>Buf</code>生态究竟提供了哪些具体的工具与平台，来支撑其能力呢？通过本篇的分析，你将不仅仅了解<code>Buf</code>项目的设计，更能窥一斑而见全豹，熟悉一个中型开源项目的构成，为后续在自己项目中的落地提供理论支撑。</p><span id="more"></span><h2 id="两大组件-Schema-Registry与CLI"><a href="#两大组件-Schema-Registry与CLI" class="headerlink" title="两大组件 - Schema Registry与CLI"></a>两大组件 - Schema Registry与CLI</h2><p>作为<code>buf</code>主推的两大产品，<code>Schema Registry</code> 和 <code>CLI</code> 的定位非常清晰：</p><ul><li><a href="https://buf.build/product/bsr/">Schema Registry</a> 是一个远端管理<code>buf schema</code>的解决方案，可以类比<code>github</code></li><li><a href="https://docs.buf.build/tour/introduction/">CLI</a> 是一个在本地终端运行的二进制工具，也是与<code>Schema Registry</code>交互的工具</li></ul><p><img src="https://buf.build/static/buf-graph-f73585cb2ce571190da213de0af6e198.svg" alt="Buf"></p><p>对照上面的设计图，这两个产品的功能不难猜测。这里，我换一个角度和大家聊聊这两个产品 - 收费pricing。如果你作为负责人，你会想要怎么收费呢？没错，收费的重点放在<code>Schema Registry</code>上：</p><ul><li><code>CLI</code>作为一个和各终端交互的工具，如果作为收费点，一来很难控制，二来很影响用户的直接体验；</li><li><code>Schema Registry</code>作为一个集中式的、远端的服务，对官方来说容易升级维护，也是协作能力的卖点所在；</li></ul><p>到这里，我们对这两个产品有了一定的理解，而且明确了学习的重点 - <code>CLI</code>的使用。</p><blockquote><p>关于<code>Schema Registry</code>部分，如果公司有一定的基础建设（主要是CICD体系），可以找到替代方案。</p><p>这部分不会作为教程的重点，毕竟影响到了<code>Buf</code>团队的商业模式了。</p></blockquote><h2 id="计费-Pricing"><a href="#计费-Pricing" class="headerlink" title="计费 - Pricing"></a>计费 - Pricing</h2><p>计费模式，是公司对产品经过反复推敲，才选定的最合适、最有价值的核心竞争力。以<a href="https://buf.build/pricing/">buf的计费模式</a>为例，我们来看看3个计费点：</p><ol><li><code>Schema Registry</code>访问方式 - private化</li><li>人工支持 - 24h答疑</li><li><code>Schema Registry</code>进阶能力 - 在平台侧提供各项进阶能力，主要和安全、协作相关</li></ol><p>分析一下这些收费点，会发现开源产品收费策略的一些共性：</p><ul><li>收费点不能限制产品核心流程上的体验</li><li>收费点不要限制产品的推广、传播</li><li>收费点要有明确的目标客户</li></ul><p>收费模式决定了产品的成败，是我们在技术选型时的重要考量点：如果你不认可该产品的收费模式，认为注定失败，那就提前规避风险、换个方案。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节从<code>Buf</code>的两大组件和收费模式进行了分析，相信大家对<code>Buf</code>的生态有了基本的认识。</p><p>一句话总结：<code>Buf Cli</code>提供了本机上的命令交互，是开发者要重点熟悉的工具；而<code>Schema Registry</code>提供了远端协作的能力，作为产品的核心收费点。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-buf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一讲，我们明确了&lt;code&gt;Buf&lt;/code&gt;套件的定位 - &lt;strong&gt;&lt;code&gt;Buf&lt;/code&gt;重点是通过对&lt;code&gt;Protobuf Schema&lt;/code&gt;的规范化，提供代码生成、依赖管理等一站式的API接口管理方案，来保证开发效率与团队协作的收益最大化。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么，&lt;code&gt;Buf&lt;/code&gt;生态究竟提供了哪些具体的工具与平台，来支撑其能力呢？通过本篇的分析，你将不仅仅了解&lt;code&gt;Buf&lt;/code&gt;项目的设计，更能窥一斑而见全豹，熟悉一个中型开源项目的构成，为后续在自己项目中的落地提供理论支撑。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Buf" scheme="http://example.com/tags/Go-Buf/"/>
    
  </entry>
  
  <entry>
    <title>Go-Buf教程 - 0.总览</title>
    <link href="http://example.com/2022/12/28/go-buf/go-buf-0/"/>
    <id>http://example.com/2022/12/28/go-buf/go-buf-0/</id>
    <published>2022-12-28T04:00:00.000Z</published>
    <updated>2023-01-02T12:03:12.505Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-buf.jpg"></p><p><code>buf</code>是一个很棒的基于<code>protobuf</code>来建立微服务API体系的工具。</p><p>我个人是<code>buf</code>的重度用户，并已在多个企业级的项目中落地。但是，鉴于<code>buf</code>以下三个特点，网上的相关教程很少：</p><ol><li>资料基本由英文文档构成</li><li>更新迭代快，有很多新增或已过时的特性</li><li>有一定的技术门槛（如熟悉<code>protobuf</code>生态）</li></ol><p>今天开始，我将以<code>Go</code>语言为背景，开启一个<code>buf</code>套件相关的教程。整个教程会分为四大篇章，分别回答以下问题：</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/buf-0.png"></p><span id="more"></span><p>本文将作为索引篇章，持续更新，帮助大家快速找到想要看的内容。</p><p>通过本教程，你将获得：</p><ul><li>掌握<code>buf</code>工具为代表的高效RPC框架（微服务框架的核心）</li><li><code>Go</code>语言的实战讲解</li><li>编程设计思想</li></ul><p>以下为本系列的目录：</p><ul><li>背景篇</li><li>入门篇</li><li>实战篇</li><li>高级篇</li></ul><p>欢迎有疑问的小伙伴可以通过下面的联系方式和我交流。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-buf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;buf&lt;/code&gt;是一个很棒的基于&lt;code&gt;protobuf&lt;/code&gt;来建立微服务API体系的工具。&lt;/p&gt;
&lt;p&gt;我个人是&lt;code&gt;buf&lt;/code&gt;的重度用户，并已在多个企业级的项目中落地。但是，鉴于&lt;code&gt;buf&lt;/code&gt;以下三个特点，网上的相关教程很少：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;资料基本由英文文档构成&lt;/li&gt;
&lt;li&gt;更新迭代快，有很多新增或已过时的特性&lt;/li&gt;
&lt;li&gt;有一定的技术门槛（如熟悉&lt;code&gt;protobuf&lt;/code&gt;生态）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天开始，我将以&lt;code&gt;Go&lt;/code&gt;语言为背景，开启一个&lt;code&gt;buf&lt;/code&gt;套件相关的教程。整个教程会分为四大篇章，分别回答以下问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/buf-0.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Buf" scheme="http://example.com/tags/Go-Buf/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习 - RPC篇:gRPC-Gateway定制mux选项</title>
    <link href="http://example.com/2022/12/27/go-study/go-rpc-6/"/>
    <id>http://example.com/2022/12/27/go-study/go-rpc-6/</id>
    <published>2022-12-27T04:00:00.000Z</published>
    <updated>2022-12-28T13:24:41.573Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>通过上一讲，我们对gRPC的拦截器有了一定的认识，也能定制出很多通用的中间件。</p><p>但在大部分的业务系统中，我们面向的还是HTTP协议。那么，今天我们就从gRPC-Gateway的mux选项出发，一起来看看一些很实用的特性。</p><span id="more"></span><h2 id="ServeMux"><a href="#ServeMux" class="headerlink" title="ServeMux"></a>ServeMux</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/grpc-ecosystem/grpc-gateway/v2/runtime&quot;</span></span><br><span class="line"></span><br><span class="line">gwMux := runtime.NewServeMux()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServeMux</span><span class="params">(opts ...ServeMuxOption)</span> *<span class="title">ServeMux</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将目标聚焦于这个<code>ServeMux</code>：</p><ol><li>目前官方区分v1和v2版本，版本不一致会导致很多编译上的问题</li><li>入参包括多个<code>option</code>选项函数，用于定制想要的mux内容</li></ol><p>具体的内容可以参考<code>ServeMux</code>的数据结构，我这里挑选几个重点的能力：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 这个是server的核心实现：即注册的handlerf</span></span><br><span class="line">handlers                  <span class="keyword">map</span>[<span class="keyword">string</span>][]handler</span><br><span class="line">  <span class="comment">// 1、转发正常响应</span></span><br><span class="line">forwardResponseOptions    []<span class="function"><span class="keyword">func</span><span class="params">(context.Context, http.ResponseWriter, proto.Message)</span> <span class="title">error</span></span></span><br><span class="line">  <span class="comment">// 2、序列化工具</span></span><br><span class="line">marshalers                marshalerRegistry</span><br><span class="line">  <span class="comment">// 3、进入时（http-&gt;grpc）的header匹配规则</span></span><br><span class="line">incomingHeaderMatcher     HeaderMatcherFunc</span><br><span class="line">  <span class="comment">// 4、返回时（grpc-&gt;http）的header匹配规则</span></span><br><span class="line">outgoingHeaderMatcher     HeaderMatcherFunc</span><br><span class="line">  <span class="comment">// 5、metadata的转换（从http转成grpc的md）</span></span><br><span class="line">metadataAnnotators        []<span class="function"><span class="keyword">func</span><span class="params">(context.Context, *http.Request)</span> <span class="title">metadata</span>.<span class="title">MD</span></span></span><br><span class="line">  <span class="comment">// 6、错误处理</span></span><br><span class="line">errorHandler              ErrorHandlerFunc</span><br><span class="line">  <span class="comment">// 7、流式错误处理</span></span><br><span class="line">streamErrorHandler        StreamErrorHandlerFunc</span><br><span class="line">  <span class="comment">// 8、路由错误</span></span><br><span class="line">routingErrorHandler       RoutingErrorHandlerFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合一下，核心能力其实包括2块：</p><ol><li>Header数据的处理</li><li>返回消息的处理（包括正常情况和错误情况）</li></ol><h2 id="Header的数据处理"><a href="#Header的数据处理" class="headerlink" title="Header的数据处理"></a>Header的数据处理</h2><h3 id="HTTP与gRPC协议头匹配"><a href="#HTTP与gRPC协议头匹配" class="headerlink" title="HTTP与gRPC协议头匹配"></a>HTTP与gRPC协议头匹配</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTTP -&gt; gRPC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithIncomingHeaderMatcher</span><span class="params">(fn HeaderMatcherFunc)</span> <span class="title">ServeMuxOption</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gRPC -&gt; HTTP</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithOutgoingHeaderMatcher</span><span class="params">(fn HeaderMatcherFunc)</span> <span class="title">ServeMuxOption</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HeaderMatcherFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure><p>这个函数只做一个简单的映射，我们可以通过下面的例子开快速了解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入参：header key</span></span><br><span class="line"><span class="comment">// 出参：返回header key，以及是否返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CustomMatcher</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> key &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;some-special-key&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> key, <span class="literal">true</span> </span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;deprecated-key&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">false</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 默认的匹配规则</span></span><br><span class="line"><span class="keyword">return</span> runtime.DefaultHeaderMatcher(key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将HTTP头转成gRPC头"><a href="#将HTTP头转成gRPC头" class="headerlink" title="将HTTP头转成gRPC头"></a>将HTTP头转成gRPC头</h3><p>上面的<code>matcher</code>只是做一个key的映射，如果<code>Header</code>里包括更复杂的部分（例如Cookie），需要引入下面函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithMetadata</span><span class="params">(annotator <span class="keyword">func</span>(context.Context, *http.Request)</span> <span class="title">metadata</span>.<span class="title">MD</span>) <span class="title">ServeMuxOption</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(serveMux *ServeMux)</span></span> &#123;</span><br><span class="line">serveMux.metadataAnnotators = <span class="built_in">append</span>(serveMux.metadataAnnotators, annotator)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意两个点：</p><ol><li>只做协议转换，不做逻辑处理（逻辑处理交给gRPC层的中间件统一处理）</li><li><code>metadata.MD</code>的底层数据结构为<code>map[string][]string</code>，与HTTP Header很类似</li></ol><p>下面给出一个HTTP的Cookie处理示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  HTTP_COOKIE_TOKEN = <span class="string">&quot;http_cookie&quot;</span></span><br><span class="line">  MD_TOKEN = <span class="string">&quot;md_cookie&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleCookieMetadataAnnotator</span><span class="params">(ctx context.Context, r *http.Request)</span> <span class="params">(md metadata.MD)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 从HTTP的cookie中读出对应的数据</span></span><br><span class="line">  c, err := r.Cookie(ODIN_JWT_TOKEN)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将值放到md里，方便在后续提取</span></span><br><span class="line"><span class="keyword">return</span> metadata.Pairs(MD_TOKEN, c.Value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回数据处理"><a href="#返回数据处理" class="headerlink" title="返回数据处理"></a>返回数据处理</h2><h3 id="正确返回"><a href="#正确返回" class="headerlink" title="正确返回"></a>正确返回</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithForwardResponseOption</span><span class="params">(forwardResponseOption <span class="keyword">func</span>(context.Context, http.ResponseWriter, proto.Message)</span> <span class="title">error</span>) <span class="title">ServeMuxOption</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确返回时，核心的数据结构为 <code>protoMessage</code>。我们不妨做一个封装：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HTTPResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">Errno <span class="keyword">int</span>         <span class="string">`json:&quot;errno&quot;`</span></span><br><span class="line">Msg   <span class="keyword">string</span>      <span class="string">`json:&quot;msg&quot;`</span></span><br><span class="line">Data  <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GatewayResponseModifier</span><span class="params">(ctx context.Context, w http.ResponseWriter, resp proto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 返回的数据，在外层同一封装了数据结构HTTPResponse，对一些历史项目兼容有很棒的效果</span></span><br><span class="line">  newResp := &amp;HTTPResponse&#123;</span><br><span class="line">    Data: resp,</span><br><span class="line">  &#125;</span><br><span class="line">pbData, _ := json.Marshal(newResp)</span><br><span class="line">  w.Write(pbData)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误返回"><a href="#错误返回" class="headerlink" title="错误返回"></a>错误返回</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithErrorHandler</span><span class="params">(fn ErrorHandlerFunc)</span> <span class="title">ServeMuxOption</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误处理在整个RPC框架中扮演了非常重要的角色，我们不妨通过如下例子来了解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GatewayErrModifier</span><span class="params">(ctx context.Context, mux *runtime.ServeMux, m runtime.Marshaler, w http.ResponseWriter, r *http.Request, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 提取error</span></span><br><span class="line">s, ok := status.FromError(err)</span><br><span class="line"><span class="comment">// 非标准错误</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">runtime.DefaultHTTPErrorHandler(ctx, mux, m, w, r, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对各类错误增加定制的逻辑</span></span><br><span class="line"><span class="keyword">switch</span> s.Code() &#123;</span><br><span class="line"><span class="keyword">case</span> codes.Unauthenticated:</span><br><span class="line"><span class="comment">// 示例：认证失败，可以加入重定向的逻辑</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">runtime.DefaultHTTPErrorHandler(ctx, mux, m, w, r, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下重点：</p><ol><li><code>error</code>尽可能用<code>gRPC</code>标准的错误<code>Status</code>表示</li><li><code>gRPC</code>的标准错误，对错误码code有一套定义（参考<code>google.golang.org/grpc/codes</code>），类似于<code>HTTP</code>的状态码</li><li>错误码code要尽量少，过多没有意义<ol><li>标准错误码尽可能复用，如资源找不到、权限不足等</li><li>业务错误码可以独立，一般一个系统定义1个即可</li></ol></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文重点介绍了<code>gRPC-Gateway</code>中2类<code>ServeMux</code>，也演示了对应的示例，大家能理解其基本用法即可。</p><p>后续，随着整体项目的落地，我会增加一些日常项目中常见的定制需求，帮助大家更好地认识RPC框架的能力。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;通过上一讲，我们对gRPC的拦截器有了一定的认识，也能定制出很多通用的中间件。&lt;/p&gt;
&lt;p&gt;但在大部分的业务系统中，我们面向的还是HTTP协议。那么，今天我们就从gRPC-Gateway的mux选项出发，一起来看看一些很实用的特性。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go-Buf教程 - 1.【背景篇】从Buf定位看API接口的演进</title>
    <link href="http://example.com/2022/12/21/go-buf/go-buf-1/"/>
    <id>http://example.com/2022/12/21/go-buf/go-buf-1/</id>
    <published>2022-12-21T04:00:00.000Z</published>
    <updated>2023-01-02T12:03:06.586Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-buf.jpg"></p><p>首先，<code>buf</code>是一个什么样的工具？我提取了三个关键词：</p><ul><li><code>Protocol Buffers</code> - 底层的技术基础是Google的<code>protobuf</code>语言</li><li><code>API Lifecycle</code> - 目标是管理<code>API</code>接口的全生命周期，重点是初次发布与后续更新</li><li><code>Team</code> - 强调的是团队协作，解决人与人之间沟通的问题</li></ul><p>要说清楚<code>buf</code>这个项目，就离不开API接口开发的历史演进。今天，我将挑选<a href="https://buf.build/">官方</a>介绍的三个重点，让大家更好地了解<code>buf</code>要解决的问题。</p><span id="more"></span><h2 id="两个角色：Producer-amp-Consumer"><a href="#两个角色：Producer-amp-Consumer" class="headerlink" title="两个角色：Producer &amp; Consumer"></a>两个角色：Producer &amp; Consumer</h2><p>对于一个API服务，有2种最重要的角色：</p><ul><li>Producer - API服务提供方，也叫被调用方</li><li>Consumer - API服务的使用方，也叫调用方，往往具有多个</li></ul><p>要调通一个API不难，但要做好，有很多问题需要解决，尤其如下三个问题：</p><ol><li><strong>理解成本</strong>：API接口怎么理解？提供文档或SDK就能满足吗？</li><li><strong>迭代问题</strong>：Producer紧急修复了问题、更新了接口，怎么通知到各个调用方？</li><li><strong>重复开发</strong>：多语言、多框架的情况下，怎么减少重复度高的编码工作，如定义数据结构？</li></ol><p>关于API的设计与实现的细节，不同团队有自己的方案，我们来看看<code>buf</code>提供的亮点：</p><ul><li>Producer<ul><li>遵循Best Practice来使用<code>protobuf</code>的API</li><li>分发API到各使用方，让对方及时更新</li><li>集中式地管理API文档</li></ul></li><li>Consumer<ul><li>根据<code>protobuf</code>定义，快速开发</li><li>用工具减少歧义</li><li>可生成的CLI/定制插件/mock服务/压力测试等特性</li></ul></li></ul><p>以上特性看起来很酷，核心方向依旧是：<strong>提高Producer和Consumer的效率与协作</strong>。</p><h2 id="方案1-RESTful"><a href="#方案1-RESTful" class="headerlink" title="方案1 - RESTful"></a>方案1 - RESTful</h2><p>官方对RESTful接口的概括如下图：</p><p><img src="https://buf.build/static/restful-apis-6cd5944265317eef85e787ad02885e6b.svg" alt="RESTful APIs"></p><p>RESTful API虽然已经被公认为一种很好的API设计标准，但在实际开发过程中，各有各的理解。所以，RESTful更像是一种风格趋势，但无法形成标准，这就对Consumer在协作开发时带来了难度：</p><ul><li>理解成本：标准不统一，调接口类似于黑盒测试</li><li>实现方式：不同调用方有自己的实现，对后续维护带来很大成本</li></ul><p>我们可以通过以下两条路径进行改善：</p><ol><li>内部统一框架：利用相关的工具，强制约束接口设计</li><li>自动生成SDK：调用方统一用SDK收敛</li></ol><p>这两点从技术实现来看并不难，但挺考验研发团队的能力，一不小心就造了个很不好用的轮子。对于大部分开发者来说，更希望找一个成熟的、长期维护的方案。</p><h2 id="方案2-Protocol-Buffers（无Buf）"><a href="#方案2-Protocol-Buffers（无Buf）" class="headerlink" title="方案2 - Protocol Buffers（无Buf）"></a>方案2 - Protocol Buffers（无Buf）</h2><p>接着，我们来看看社区中原生的<code>Protocol Buffers</code>的方案：</p><p><img src="https://buf.build/static/protobuf-ca548d51691fe9bda30b04275e0e5563.svg" alt="Protocol Buffers without Buf"></p><p>本方案最大的变化，就是有了一个协议的<strong>标准传输介质</strong> - <code>Protobuf Schema</code>。它规范了Producer侧的接口实现，并且利用<code>protobuf</code>提供了跨语言的方案。</p><p>但是，从图中可以看出，传播<code>Protobuf Schema</code>依然是一个高频出现问题的地方：</p><ul><li>Producer - 设计与发布API没有支持，全靠人工、甚至是邮件沟通</li><li>Consumer - 对<code>protobuf</code>没有统一管理的手段，如版本依赖、SDK生成等</li></ul><p>不过，<code>Protobuf</code>对API接口设计提供了很关键的基础能力 - 有了切实可落地的标准，并且实现了跨语言代码生成的基础。接下来，就是要解决 <strong>最后一公里</strong> 的问题了。</p><h2 id="方案3-Protocol-Buffers（有Buf）"><a href="#方案3-Protocol-Buffers（有Buf）" class="headerlink" title="方案3 - Protocol Buffers（有Buf）"></a>方案3 - Protocol Buffers（有Buf）</h2><p>Buf方案，核心是对<code>Protobuf Schema</code>的管理与扩展</p><p><img src="https://buf.build/static/buf-graph-f73585cb2ce571190da213de0af6e198.svg" alt="Buf"></p><p>从<code>Buf</code>提供的核心能力来说，主要分为3块：</p><ol><li>语法规范 - 从语法上规范API设计，遵循其<code>Best Practice</code></li><li>代码生成 - 包括Producer与Consumer侧的代码自动生成</li><li>依赖管理 - 对各Consumer的依赖进行统一管理</li></ol><blockquote><p>我认为核心在于第一点：规范化、标准化的程度越高，自动化的能力自然就越强：</p><p>第二、三点，往往会根据团队情况，需要定制化。</p></blockquote><p>其余能力是偏插件化的功能，就不重点讲了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天，我们通过对3个API方案的介绍，对<code>Buf</code>套件有了初步的了解。如果用一句话概括：</p><p><strong><code>Buf</code>重点是通过对<code>Protobuf Schema</code>的规范化，提供代码生成、依赖管理等一站式的API接口管理方案，来保证开发效率与团队协作的收益最大化。</strong></p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-buf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先，&lt;code&gt;buf&lt;/code&gt;是一个什么样的工具？我提取了三个关键词：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Protocol Buffers&lt;/code&gt; - 底层的技术基础是Google的&lt;code&gt;protobuf&lt;/code&gt;语言&lt;/li&gt;
&lt;li&gt;&lt;code&gt;API Lifecycle&lt;/code&gt; - 目标是管理&lt;code&gt;API&lt;/code&gt;接口的全生命周期，重点是初次发布与后续更新&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Team&lt;/code&gt; - 强调的是团队协作，解决人与人之间沟通的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要说清楚&lt;code&gt;buf&lt;/code&gt;这个项目，就离不开API接口开发的历史演进。今天，我将挑选&lt;a href=&quot;https://buf.build/&quot;&gt;官方&lt;/a&gt;介绍的三个重点，让大家更好地了解&lt;code&gt;buf&lt;/code&gt;要解决的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Buf" scheme="http://example.com/tags/Go-Buf/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 17.【Go工程化测试】业务项目中的Go单元测试心得</title>
    <link href="http://example.com/2022/12/06/go-tip/go-tip-17/"/>
    <id>http://example.com/2022/12/06/go-tip/go-tip-17/</id>
    <published>2022-12-06T04:00:00.000Z</published>
    <updated>2022-12-07T14:23:57.623Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>在网上搜索 <strong>Go单元测试</strong>，我们能找到各种开源工具和方法技巧，也可以照葫芦画瓢、快速地写出示例test case。但回到具体的工程项目里，当我们面对代码里的各种CRUD、接口与实现、内外部依赖时，往往发现很难写出有效的单元测试，空有一身技巧却无从下手。</p><p>我也被这个问题困扰许久，也反复在多个项目里折腾，发现要将单元测试落地到项目中，有一条被忽视的<code>gap</code>。下面我分享一下个人的思路。</p><p>Go单元测试的具体语法，本文会一笔带过，想了解细节的同学可以自行搜索。</p><span id="more"></span><h2 id="0-从业务项目的分层聊起"><a href="#0-从业务项目的分层聊起" class="headerlink" title="0. 从业务项目的分层聊起"></a>0. 从业务项目的分层聊起</h2><p>本文暂不讨论工具类项目，而是聚焦于结构相对复杂的业务类项目。</p><blockquote><p>偏基础工具类的代码库，写单元测试的逻辑会比较直观，也更注重性能等场景。</p></blockquote><p>业务项目通常会进行分层，本文以一个简化后的三层结构为例：</p><ul><li>请求/响应处理层 - Controller</li><li>业务领域层 - Service（Domain/Logic）</li><li>数据访问层 - Dao（Model）</li></ul><blockquote><p>很多复杂的分层可认为是上面的的一种变体。</p></blockquote><p>写Go单元测试的具体语法，本文会一笔带过，想了解细节的同学可以自行搜索。</p><h2 id="1-单元测试的外部依赖问题"><a href="#1-单元测试的外部依赖问题" class="headerlink" title="1. 单元测试的外部依赖问题"></a>1. 单元测试的外部依赖问题</h2><p>在业务开发时，有句玩笑话：如果你坚持写单测，最终会变成Postman工程师。虽然这话带有戏谑的色彩，但我们不妨想想它背后的逻辑：</p><h3 id="1-1-从“捷径”到放弃"><a href="#1-1-从“捷径”到放弃" class="headerlink" title="1.1 从“捷径”到放弃"></a>1.1 从“捷径”到放弃</h3><p>一个项目中的代码是层层调用的，我们以一个满足上述分层的服务为例：</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-unittest-func.png"></p><p>从调用栈来看，写一个顶层函数的单测，既能包括本层代码、又能覆盖下面各层，在最上层（Controller）写单元测试似乎成了最优解。这时，开发者会遇到一个常见问题 - <strong>代码的层层调用，很难屏蔽外部的依赖项</strong>，尤其是MySQL/Redis等中间件和自研服务。</p><p>接下来是我的经历，相信能引起不少人的共鸣：</p><p><strong>阶段一：依赖测试环境的服务写单测，立杆见影地跑通单测、覆盖率也不错。</strong></p><blockquote><p>我的想法：“巧妙的变通”</p><p>虽说从单元测试的定义来说，不应依赖外部服务，但不妨把这当作是一种变通，又快又方便。</p></blockquote><p><strong>阶段二：外部服务引入的问题越来越多，严格检查结果的单测很难通过，只能不断删减检查项，导致单测的质量和覆盖率越来越差。</strong></p><blockquote><p>我的想法：对外部环境不得已的“妥协”</p><p>外部服务既不稳定，又往往是有状态的，很难支撑单元测试里的各种case。单测能跑通总比跑不通好，单测质量下降并不是我偷懒，而是外部因素的不可控。</p></blockquote><p><strong>阶段三：单测能发现的问题越来越少，还不如用Postman手动请求并观察结果来得有效。食之无味，弃之可惜，单测就只作为评估绩效的指标了。</strong></p><blockquote><p>我的想法：复杂业务项目里的单元测试没什么价值，就仅仅作为一个绩效指标算了。</p><p>对项目来说，单测失去了发现问题的能力；对开发者来说，那就只是应付性地去达成单测覆盖率的指标了。</p></blockquote><p>所以，为了保证单测的价值长期有效，我们要 <strong>尽可能地屏蔽外部系统的依赖</strong>；而对外部依赖的测试，尽可能地交由更高层面的接口测试、功能测试、系统联调等途径去保障。</p><h3 id="1-2-如何屏蔽外部依赖"><a href="#1-2-如何屏蔽外部依赖" class="headerlink" title="1.2 如何屏蔽外部依赖"></a>1.2 如何屏蔽外部依赖</h3><p>屏蔽外部依赖，业界主要有两种解法：</p><ol><li><strong>容器技术</strong> - 将外部依赖转为内部项，跟随单元测试的生命周期</li><li><strong>代码mock</strong> - 拦截对外部依赖的调用，获得可预期的返回结果</li></ol><p>第一个解法比较取巧，本质上仍是依赖外部服务，只是由单元测试掌控它们的生命周期。这种方案对于验证中间件相关的功能确实非常方便，但长期维护的成本不低，慎用。（后文会再次提及）</p><p>第二个解法是单元测试最为推荐的方式，即常说的 mock/打桩。mock的具体方案依赖编程语言、框架以及对应的生态。例如在<code>Spring</code>里写单测很方便，包括：</p><ol><li>底层JVM强大的运行时能力</li><li>Spring的依赖注入</li><li>社区中成熟的各中间件Mock</li></ol><p>而Go语言在这块并没有得天独厚的优势。下面，我分享一个社区中比较推荐的解法。</p><h3 id="1-3-适配Go语言的单测方案"><a href="#1-3-适配Go语言的单测方案" class="headerlink" title="1.3 适配Go语言的单测方案"></a>1.3 适配Go语言的单测方案</h3><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-unittest-di.png"></p><p>图中的重点内容如下：</p><ol><li>三个虚箭头<ol><li>Service层的对象依赖Dao层的接口</li><li>Dao层接口的业务实现，由开发者自行编写代码</li><li>Dao层接口的mock实现，由 <a href="https://github.com/golang/mock">gomock</a> 自动生成</li></ol></li><li>依赖注入DI<ol><li>业务对象在初始化时注入想要的实现，遵循<code>IoC</code>的设计原则</li><li>正常情况下，注入业务实现；单元测试时，注入mock实现</li><li>一般可利用google的<a href="https://github.com/google/wire">wire</a>工具来自动化地生成依赖注入的代码</li></ol></li></ol><p>Mock实现无需依赖外部，我们利用面向对象的特性轻松地解决了这个问题。在复杂的工程中，还应注意两点：</p><ol><li>DI应和业务的抽象结合起来，不要只当作单纯的一种解耦的工具。</li><li>业务领域层往往内部也会分为多层（参考DDD），优先梳理上下文关系，才能设计好DI的实现。</li></ol><blockquote><p>DI是一个非常重要的解耦手段，但Go语言的框架无法强限制，往往只能靠“制定规范”， 如 <a href="https://go-kratos.dev/">Kratos</a>。</p></blockquote><h3 id="1-4-一个DI示例"><a href="#1-4-一个DI示例" class="headerlink" title="1.4 一个DI示例"></a>1.4 一个DI示例</h3><p>service层</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 依赖dao层的接口</span></span><br><span class="line">  dao.DaoReader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitBook</span><span class="params">(reader dao.DaoReader)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Reader&#123;reader&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dao层</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dao</span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">type</span> DaoReader <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务实现</span></span><br><span class="line"><span class="keyword">type</span> MyReader DaoReader</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyReader</span><span class="params">()</span> <span class="title">DaoReader</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;MyReader&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mock_dao层（建议另起一个目录）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成mock的示例命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从dao/reader.go中的interface生成</span></span><br><span class="line">mockgen -source=dao/reader.go -destination=mock_dao/reader.go</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码为自动生成，并进行了简化</span></span><br><span class="line"><span class="keyword">package</span> mock_dao</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MockDaoReader <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMockDaoReader</span><span class="params">(ctrl *gomock.Controller)</span> *<span class="title">MockDaoReader</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;MockDaoReader&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，就有了正常情况下与单元测试情况下的依赖注入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"><span class="comment">// 正常的注入</span></span><br><span class="line">reader := InitBook(dao.NewMyReader())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试的注入</span></span><br><span class="line">mockReader := mock_dao.NewMockDaoReader(gomock.NewController(t))</span><br><span class="line">reader := InitBook(mockReader)</span><br></pre></td></tr></table></figure><h2 id="2-在有限的时间内，探索“最有价值”的单元测试"><a href="#2-在有限的时间内，探索“最有价值”的单元测试" class="headerlink" title="2. 在有限的时间内，探索“最有价值”的单元测试"></a>2. 在有限的时间内，探索“最有价值”的单元测试</h2><h3 id="2-1-一个代码覆盖率的问题"><a href="#2-1-一个代码覆盖率的问题" class="headerlink" title="2.1 一个代码覆盖率的问题"></a>2.1 一个代码覆盖率的问题</h3><p>在开发过程中，上层代码对下层的代码调用往往有具有限制，如限制了传参的类型、数量、范围。以下面的代码为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上层</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  s, _ := sum(a,b)</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下层</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// case1 - a/b 为int</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// case2 - a/b 为float</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// case3 - a/b 为string</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，上层<code>Sum</code>函数的入参限制，会导致下层<code>sum</code>中被调用到的代码很有限。因此，在上层<code>Sum</code>进行单元测试，会导致下层<code>sum</code>函数的测试不完全。</p><p>这个代码覆盖率的问题是不可规避的。我们不难得出，在分层场景下，<strong>要使某层代码的覆盖率最高，尽量在同层编写单元测试</strong>。那么，如果要让整个项目的代码覆盖率达到100%，每层的单测都得写，相信没几个公司经得起这样的投入。</p><p>时间有限，我们该如何寻找“最有价值”的单元测试呢？</p><h3 id="2-2-明确核心目标-保障业务逻辑"><a href="#2-2-明确核心目标-保障业务逻辑" class="headerlink" title="2.2 明确核心目标 - 保障业务逻辑"></a>2.2 明确核心目标 - 保障业务逻辑</h3><p>一个业务项目的代码，最重要的自然是保障业务逻辑。从前面三个分层的职责来看，<strong>Service层是我们要聚焦的重点，它的代码测试覆盖度无疑是要优先保障的</strong>。</p><p>于是，我们优先在Service层写了完整的单测，覆盖率也很高，但回头看到Controller/Dao层代码的覆盖率很低：</p><ul><li>上层Controller的代码无法从Service层调用到，单测覆盖率为0</li><li>下层Dao层的里的业务实现代码也没有被调用（依赖注入的是mock实现），单测覆盖率也很低</li></ul><p>既然我们的核心目标是 <strong>保障业务逻辑</strong>，那么，我们不妨从分层的角度分析一下：Controller层与Dao层的代码对核心业务逻辑的影响有多大？</p><h3 id="2-3-Controller-Dao层的单元测试思路"><a href="#2-3-Controller-Dao层的单元测试思路" class="headerlink" title="2.3 Controller/Dao层的单元测试思路"></a>2.3 Controller/Dao层的单元测试思路</h3><p>我们先看看这两层的主要功能：</p><ul><li>Controller层是做的是协议解析和数据转化，如HTTP根据Header里的content-type解析到对应结构体</li><li>Dao层主要负责的工作是数据持久化，比如MySQL里的CRUD<ul><li>为了方便讨论，我们对Dao层做一下延伸，认为与外部应用的RPC交互也是一种Dao层操作</li></ul></li></ul><p>这两层都具备一个共同特征：<strong>高度重复性的基础工作</strong>，非常适合建设公共的工具库。于是，Controller/Dao层的建设思路往往会分两步走：</p><ol><li>沉淀并维护公共的工具库 ，并保证其单元测试覆盖率<ol><li>Controller层的RPC框架</li><li>Dao层的MySQL ORM/服务SDK</li></ol></li><li>Controller/Dao层主要工作就是去调用工具库，并适配其接口</li></ol><p>在这种模式下，Controller与Dao层发生的问题可以得到有效控制：</p><ol><li>工具库本身 - 引用优秀的开源库或自建，保证测试完备，自身很少出错（有问题就统一升级）</li><li>工具库的调用 - 依赖库设计的调用方式与使用者的经验</li><li>Controller/Dao层自身代码 - 只做简单的工具库调用与数据结构的转换</li></ol><blockquote><p>第2点中的工具库设计很重要，建议多考虑一下设计模式与Go语言强类型的特点，能提高用户体验：</p><p>比如说，工具库里要传一个时间类型的参数，可以将入参设计为 <code>duration int</code> （参数类型只有数字），但更好的方式是<code>duration time.Duration</code>（参数类型同时包含了数字+单位）。</p></blockquote><p>所以，对不熟悉框架的同学，在早期可以投入一些时间写写Controller/Dao层的单测，了解相关工具库的实现；而随着经验的积累，Controller/Dao层会专注于做2件事：</p><ul><li>选择合适的工具库进行调用</li><li>数据转化（从一个结构体转化到另一个结构体）</li></ul><p>随着项目的迭代，Controller/Dao层会变得越来越“薄”，投入单测的意义就没那么大了。</p><h3 id="2-4-评价指标"><a href="#2-4-评价指标" class="headerlink" title="2.4 评价指标"></a>2.4 评价指标</h3><p>至此，我们明确了以 <strong>保障核心业务逻辑</strong> 为单元测试的目标，并以 <strong>业务领域层</strong> 作为核心的单元测试覆盖对象，项目单元测试覆盖率指标也相对明确了，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定service路径下的所有文件，来计算单测覆盖率</span></span><br><span class="line">go test ./service/...  -coverprofile=profile.cov</span><br><span class="line">go tool cover -html=profile.cov -o coverage.html</span><br></pre></td></tr></table></figure><p>之后，就是一个不断迭代的过程了。整体的业务项目与工具库呈现如下：</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-unittest-framework-new.png"></p><h2 id="3-单元测试的相关实践"><a href="#3-单元测试的相关实践" class="headerlink" title="3.  单元测试的相关实践"></a>3.  单元测试的相关实践</h2><h3 id="3-1-Controller层不应向下传递协议类参数"><a href="#3-1-Controller层不应向下传递协议类参数" class="headerlink" title="3.1 Controller层不应向下传递协议类参数"></a>3.1 Controller层不应向下传递协议类参数</h3><p>我们先看两段代码：</p><p>标准HTTP的handler</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FooHandler</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">  service.Foo(w, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">  fmt.Fprint(w, <span class="string">&quot;my response&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gin框架的Handler</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FooHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">service.Foo(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  c.JSON(<span class="number">200</span>, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种代码都将协议相关的数据结构<code>http.ResponseWriter</code> 、<code>http.Request</code> 、 <code>gin.Context</code> 传递到了业务领域层。从功能开发来说完全正确，但大幅提升了业务领域层<code>Foo</code>函数单测的难度。</p><p>再看<code>protobuf</code>方案，通过预定义的接口文档与代码生成技术，让controller层的定义变成了如下形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(ctx context.Context, req *proto.FooRequest)</span> <span class="params">(resp *proto.FooResponse, err error)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务自定义的Controller层已经实现了与协议解耦，开发者无需关心协议是<code>HTTP</code>还是<code>gRPC</code>，数据格式是<code>json</code>还是<code>form</code>等。Controller层的这个优势，自然保证了Service层与协议无关。</p><p>所以，<code>protobuf</code> 为代表的的IDL方案，对业务领域层的单测更为友好。</p><h3 id="3-2-Dao层的业务实现高频出错，怎么写单测？"><a href="#3-2-Dao层的业务实现高频出错，怎么写单测？" class="headerlink" title="3.2 Dao层的业务实现高频出错，怎么写单测？"></a>3.2 Dao层的业务实现高频出错，怎么写单测？</h3><p>在理想状态，Dao层出现问题的概率很小，但实际情况中有诸多限制：</p><ul><li>dao层包含很多业务逻辑</li><li>开发者使用工具库的经验少，CRUD常常犯错</li><li>历史项目，dao层很难调整，工具库也常常出错</li></ul><p>当你评估Dao层的单测会给整个项目带来足够的收益时，自然可以添加Dao层的单测。这时，对于外部依赖的问题，有如下2种方式：</p><ol><li>优先使用容器，可利用<code>testing.Main</code>的特性来创建和销毁（类似python中的<code>setUp</code>和<code>tearDown</code>）</li><li>如果不得不依赖测试环境，尽可能地用<code>defer</code>的特性去清理单测产生的数据</li></ol><p>长期维护这两个方案，都比较费时费力。</p><h3 id="3-3-Go的单测有哪些好用的库或者工具？"><a href="#3-3-Go的单测有哪些好用的库或者工具？" class="headerlink" title="3.3 Go的单测有哪些好用的库或者工具？"></a>3.3 Go的单测有哪些好用的库或者工具？</h3><ol><li>Mock类<ol><li><a href="https://github.com/golang/mock">gomock</a> 官方推荐的工具，可以从接口生成mock代码</li><li><a href="https://github.com/agiledragon/gomonkey">Go Monkey</a> 可以对特定函数进行打桩，一般用于特定错误的模拟</li></ol></li><li>接口相关<ol><li><a href="https://github.com/google/wire">wire</a> 解决依赖注入的利器</li><li><a href="https://www.jetbrains.com/help/go/extract-interface-dialog.html">Goland的提取接口</a> 从具体实现中，提取出接口定义，重构代码的利器</li></ol></li><li>写单元测试<ol><li><a href="https://pkg.go.dev/testing#hdr-Main">testing.Main</a> 统一进行单测依赖项的初始化与销毁的工作，减少重复性代码</li><li><a href="https://github.com/cweill/gotests">gotests</a> 生成具体单元测试代码的框架，少写很多代码，已集成到<code>VSCode</code>/<code>Goland</code></li><li><a href="https://github.com/stretchr/testify">testify</a> 断言，可以减少单测的代码量，并增加可读性</li></ol></li><li>其它 - 发掘自己写单测时的高度重复性的代码，利用<code>go genereate</code>特性自动生成</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文讨论的业务代码是以<strong>对象</strong>为最小维度的。如果对象内部涉及到<code>goroutine</code>、<code>channel</code> 等特性，就需要在该对象的单测设计时有更多的考量，但不会影响整体项目的框架。</p><p>无论是框架分层、代码抽象，还是工具库的建设，单元测试都是高度依赖Go项目框架与规范的。<strong>良好的代码测试覆盖率是必须要框架适配的</strong>，生搬硬套往往让自己写单测写得很疲惫，也会让单元测试慢慢失去价值。</p><p>在Go项目中，要保证核心代码的高测试覆盖率，难度往往比需求开发高 - 往往过程性思维的CRUD，就能满足完成需求，而优秀的单元测试则为了保证测试的完备性，需要相当的抽象能力，并且持续重构。</p><p><strong>道阻且长，行则将至。</strong></p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h2&gt;&lt;p&gt;在网上搜索 &lt;strong&gt;Go单元测试&lt;/strong&gt;，我们能找到各种开源工具和方法技巧，也可以照葫芦画瓢、快速地写出示例test case。但回到具体的工程项目里，当我们面对代码里的各种CRUD、接口与实现、内外部依赖时，往往发现很难写出有效的单元测试，空有一身技巧却无从下手。&lt;/p&gt;
&lt;p&gt;我也被这个问题困扰许久，也反复在多个项目里折腾，发现要将单元测试落地到项目中，有一条被忽视的&lt;code&gt;gap&lt;/code&gt;。下面我分享一下个人的思路。&lt;/p&gt;
&lt;p&gt;Go单元测试的具体语法，本文会一笔带过，想了解细节的同学可以自行搜索。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习 - RPC篇:gRPC拦截器剖析</title>
    <link href="http://example.com/2022/11/17/go-study/go-rpc-5/"/>
    <id>http://example.com/2022/11/17/go-study/go-rpc-5/</id>
    <published>2022-11-17T04:00:00.000Z</published>
    <updated>2022-12-13T11:18:02.601Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>我们在前几讲提到过，优秀的RPC框架都提供了<code>middleware</code>的能力，可以减少很多重复代码的编写。在gRPC-Gateway的方案里，包括了两块中间件的能力：</p><ol><li>gRPC中的<code>ServerOption</code>，是所有gRPC+HTTP都会被处理</li><li>gRPC-Gateway中的<code>ServeMuxOption</code>，只有HTTP协议会被处理</li></ol><p>今天，我们先关注共同部分的<code>ServerOption</code>，它提供的能力最为全面，让我们一起了解下。</p><span id="more"></span><h2 id="官方实现"><a href="#官方实现" class="headerlink" title="官方实现"></a>官方实现</h2><p>在官方文件<code>google.golang.org/grpc/server.go</code>路径下，给出了很多公开的<code>ServerOption</code>方法。从本质上来说，这些方法都是为了修改服务端的一个核心数据结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> serverOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">creds                 credentials.TransportCredentials</span><br><span class="line">codec                 baseCodec</span><br><span class="line">cp                    Compressor</span><br><span class="line">dc                    Decompressor</span><br><span class="line">unaryInt              UnaryServerInterceptor</span><br><span class="line">streamInt             StreamServerInterceptor</span><br><span class="line">chainUnaryInts        []UnaryServerInterceptor</span><br><span class="line">chainStreamInts       []StreamServerInterceptor</span><br><span class="line">binaryLogger          binarylog.Logger</span><br><span class="line">inTapHandle           tap.ServerInHandle</span><br><span class="line">statsHandlers         []stats.Handler</span><br><span class="line">maxConcurrentStreams  <span class="keyword">uint32</span></span><br><span class="line">maxReceiveMessageSize <span class="keyword">int</span></span><br><span class="line">maxSendMessageSize    <span class="keyword">int</span></span><br><span class="line">unknownStreamDesc     *StreamDesc</span><br><span class="line">keepaliveParams       keepalive.ServerParameters</span><br><span class="line">keepalivePolicy       keepalive.EnforcementPolicy</span><br><span class="line">initialWindowSize     <span class="keyword">int32</span></span><br><span class="line">initialConnWindowSize <span class="keyword">int32</span></span><br><span class="line">writeBufferSize       <span class="keyword">int</span></span><br><span class="line">readBufferSize        <span class="keyword">int</span></span><br><span class="line">connectionTimeout     time.Duration</span><br><span class="line">maxHeaderListSize     *<span class="keyword">uint32</span></span><br><span class="line">headerTableSize       *<span class="keyword">uint32</span></span><br><span class="line">numServerWorkers      <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难从命名中推断到，上述结构体包含了认证、编解码、压缩、日志等各种配置，其中在初始化时有一些默认值。我们将目光聚焦于核心middleware能力的实现 - 拦截器（Interceptor）。</p><p>gRPC协议提供了两种RPC调用的方式：</p><ul><li><code>Unary</code>普通的单次调用</li><li><code>Stream</code>流式调用</li></ul><p>我们框架的RPC调用都来自gRPC-Gateway对<code>HTTP</code>协议的转发，是属于<code>Unary</code>这块，所以我们聚焦于<code>UnaryServerInterceptor</code>即可。而<code>chainUnaryInts</code>的数据结构为<code>[]UnaryServerInterceptor</code>，即支撑了链式<code>middleware</code>的调用，是自定义入口的关键。</p><p>使用示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := grpc.NewServer(</span><br><span class="line">grpc.ChainUnaryInterceptor(</span><br><span class="line"><span class="comment">// 各个拦截器</span></span><br><span class="line">),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="分析UnaryServerInterceptor"><a href="#分析UnaryServerInterceptor" class="headerlink" title="分析UnaryServerInterceptor"></a>分析UnaryServerInterceptor</h2><p>我们先一起看看这个函数的签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnaryServerInterceptor <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span></span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 1 - 前处理</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2 - 调用具体实现</span></span><br><span class="line">resp, err = handler(ctx, req)</span><br><span class="line">  <span class="comment">// 3 - 后处理</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行逻辑"><a href="#运行逻辑" class="headerlink" title="运行逻辑"></a>运行逻辑</h3><p>可以看到，整个代码分三步进行，其中handler这部分的实现是开发者编写的业务逻辑。</p><p>而当存在链式的拦截器时，这部分的实现类似于先入后出的逻辑：</p><ol><li>前处理1 -&gt; 前处理2 -&gt; … -&gt; 前处理n</li><li>具体代码实现</li><li>后处理n -&gt; 后处理n-1 -&gt; … -&gt; 后处理1</li></ol><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ol><li>ctx - 上下文</li><li>req - 入参</li><li>info - <code>Unray</code>调用的信息，主要是方法名</li><li>handler - 正常处理的函数</li><li>resp - 出参</li><li>err - 错误</li></ol><p>我们要了解这6个参数，才能真正地理解gRPC，进而合理地使用拦截器。下面，我挑选3个重点进行描述：</p><ol><li>我们无法直接使用ctx提取值，而是要用<code>metadata.FromIncomingContext(ctx)</code>提取出gRPC的metadata、再塞入到ctx中。什么是metadata呢？你可以把它简单地类比到HTTP的Header。</li><li>req与resp的类型与<code>protobuf</code>中定义的方法对应。不难猜到，对数据的序列化、反序列化等操作，是在拦截器之前工作的。</li><li>resp与err这两个返回参数尽可能规范：当<code>err != nil</code>时，调用方只需关注err；当<code>err == nil</code>时，resp才有意义。</li></ol><p>这里，我再额外补充两个容易陷入误区的点：</p><ol><li>gRPC-Gateway中也有拦截器的实现，但我们尽可能只做协议的转换：将HTTP Header转换到gRPC-Gateway。这样可以保证gRPC和HTTP的调用，数据处理逻辑用一个拦截器就可以完成，如用户认证。</li><li>尽可能只用err来表示错误，而不要在resp里封装errno等字段（我在下一篇也会给出对应兼容的方案）。这里的error用<code>google.golang.org/grpc/internal/status</code>生成，如<code>status.Error(codes.Unauthenticated, &quot;用户校验失败&quot;)</code>，这样错误才能兼容框架，同时具备错误码与错误信息。</li></ol><h2 id="示例拦截器"><a href="#示例拦截器" class="headerlink" title="示例拦截器"></a>示例拦截器</h2><p>分析完上述内容后，我们结合一些经典的拦截器，方便大家了解它的价值：</p><h3 id="日志拦截器"><a href="#日志拦截器" class="headerlink" title="日志拦截器"></a>日志拦截器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerLoggingInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 进入打印日志，确认入参</span></span><br><span class="line">log.Info()</span><br><span class="line"></span><br><span class="line">resp, err = handler(ctx, req)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理完打印日志，包括出参和error</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.Info()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个RPC调用最终会落成2个日志：</p><ol><li>进入时的Info日志</li><li>返回时<ol><li>正常，则打印Info日志</li><li>有错误，则打印Error日志</li></ol></li></ol><p>日志拦截器的对我们的日常开发意义非常大，核心思路是：<strong>通过日志的一入一出，快速定位问题</strong>。常见的如：</p><ol><li>先看进入时的日志，看看打印的参数是否如预期，如果有错往往先从协议排查，如字段命名</li><li>再看返回的日志，如果打印的输出和预期的一致，那往往是调用方的协议问题，如字段未解析</li><li>如果进入时的日志正确，但返回的打印异常，那就是<code>handler</code>的实现有问题</li></ol><h3 id="recovery拦截器"><a href="#recovery拦截器" class="headerlink" title="recovery拦截器"></a>recovery拦截器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerRecoveryInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">stacktrace := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">stacktrace = stacktrace[:runtime.Stack(stacktrace, <span class="literal">false</span>)]</span><br><span class="line"><span class="comment">// error及堆栈进行日志打印</span></span><br><span class="line">      log.Error()</span><br><span class="line">      </span><br><span class="line">err = status.Error(codes.Unavailable, <span class="string">&quot;系统异常&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着项目的迭代，<code>handler</code>里的实现很有可能出现会导致panic的代码，我们必须对这种异常兜底，而不是随便导致程序崩溃。</p><p>示例代码就是捕获对应的panic，输出到日志，返回给调用方<strong>系统异常</strong>。recovery是保证HTTP服务稳定的重要实现，其中的日志对开发者事后排查问题也提供了参考，是一个必备的工具利器。</p><h3 id="用户认证拦截器"><a href="#用户认证拦截器" class="headerlink" title="用户认证拦截器"></a>用户认证拦截器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  USER_TOKEN    = <span class="string">&quot;USER_TOKEN&quot;</span></span><br><span class="line">CTX_USERNAME  = <span class="string">&quot;CTX_USERNAME&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerAuthUnaryInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1. 提取出metadata</span></span><br><span class="line">md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.Unauthenticated, <span class="string">&quot;用户校验失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 2. parseUserName 从对应的metadata的Key里提取信息，解析出用户名</span></span><br><span class="line">userName, err := parseUserName(md.Get(USER_TOKEN)[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.Unauthenticated, <span class="string">&quot;用户校验失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 3. 将用户名塞入到ctx中</span></span><br><span class="line">ctx = context.WithValue(ctx, CTX_USERNAME, userName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 继续逻辑处理</span></span><br><span class="line"><span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在handler里，调用这个函数可以提取到用户名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserName</span><span class="params">(ctx context.Context)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctx.Value(CTX_USERNAME).(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关的步骤已经在代码注释里写得很清楚了，这里再补充3个细节：</p><ol><li>metadata的USER_TOKEN这个Key，按调用方，来源分2种情况：<ol><li>如果调用方是gRPC，那就要求调用方在metadata里填充这个Key</li><li>如果调用方是HTTP，需要人工将HTTP的Header映射到gRPC的metadata，这部分就是在gRPC-Gateway的中间件里实现</li></ol></li><li>示例中的1与2会对未认证的请求直接拦截 - 不会调用到具体handler的代码，直接返回错误给调用方</li><li>如果服务的接口要区分认证与无需认证，建议从<code>info.FullMethod</code>入手，即调用的方法名，也就是增加一段<code>if-else</code>的判断逻辑</li></ol><h3 id="数据校验拦截器"><a href="#数据校验拦截器" class="headerlink" title="数据校验拦截器"></a>数据校验拦截器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PGV里的结构，都实现了这个方法</span></span><br><span class="line"><span class="keyword">type</span> Validator <span class="keyword">interface</span> &#123;</span><br><span class="line">ValidateAll() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerValidationUnaryInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 如果接口实现了PGV的方法，就认为必须要进行校验</span></span><br><span class="line"><span class="keyword">if</span> r, ok := req.(Validator); ok &#123;</span><br><span class="line">err = r.ValidateAll()</span><br><span class="line">    <span class="comment">// 校验失败，则打印错误并返回参数校验失败</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.InvalidArgument, <span class="string">&quot;参数校验失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在protobuf里有一个非常有用的插件 - PGV，可参考<a href="https://github.com/bufbuild/protoc-gen-validate">Github</a>，它能帮助开发者快速实现对应的参数校验：</p><ul><li>简单的如整型要大于1，字符串要非空</li><li>复杂的如邮箱、IP等格式检查</li></ul><p>但是，它需要开发者手工判断一次。这时，我们就可以利用拦截器+接口，组装出一个参数校验的拦截器，而无需再每个<code>handler</code>中都去判定。</p><p>这个实现很简洁，也充分利用了接口的特性，是一个经典的拦截器实现。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天，我们对gRPC中的拦截器进行了分析，并给出了4个经典的拦截器代码实现。而<code>gin</code>等框架中的middleware实现思路也基本与其一致，差别主要在参数类型不一样。</p><p>gRPC拦截器能有效地收敛很多重复代码，保证框架的统一与高效；相反地，如果某个公共能力无法用拦截器实现，就非常值得我们反思了。</p><p>接下来，我们将视角转移到gRPC-Gateway方案，看看在针对HTTP方面又有哪些高效的middleware。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;我们在前几讲提到过，优秀的RPC框架都提供了&lt;code&gt;middleware&lt;/code&gt;的能力，可以减少很多重复代码的编写。在gRPC-Gateway的方案里，包括了两块中间件的能力：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;gRPC中的&lt;code&gt;ServerOption&lt;/code&gt;，是所有gRPC+HTTP都会被处理&lt;/li&gt;
&lt;li&gt;gRPC-Gateway中的&lt;code&gt;ServeMuxOption&lt;/code&gt;，只有HTTP协议会被处理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天，我们先关注共同部分的&lt;code&gt;ServerOption&lt;/code&gt;，它提供的能力最为全面，让我们一起了解下。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习 - RPC篇:深入gRPC-Gateway-探索常用数据类型</title>
    <link href="http://example.com/2022/11/03/go-study/go-rpc-4/"/>
    <id>http://example.com/2022/11/03/go-study/go-rpc-4/</id>
    <published>2022-11-03T04:00:00.000Z</published>
    <updated>2022-11-03T12:04:54.551Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>gRPC-Gateway的相关方案我们已经在上一篇详细描述。为了更方面地方便大家理解，我这边整理了一个最简化的git项目：<a href="https://github.com/Junedayday/grpc-gateway-buf-example/tree/v0.0.1">https://github.com/Junedayday/grpc-gateway-buf-example/tree/v0.0.1</a> </p><p>它主要包含两个特点：</p><ol><li>用buf工具构建项目</li><li>同时启动了gRPC和gRPC-Gateway服务，支持两种协议的调用</li></ol><p>今天，我们先迈出第一步：探索RPC服务中的数据类型。掌握常见的数据类型，灵活地运用到接口设计中，能帮助我们快速地提供优雅的接口类服务。</p><span id="more"></span><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p><code>protobuf</code>的基础数据类型可参考链接：<a href="https://developers.google.com/protocol-buffers/docs/proto3#scalar">https://developers.google.com/protocol-buffers/docs/proto3#scalar</a></p><p>这部分属于是<code>protobuf</code>的基础知识，如果对这块不清楚，可以花5~10分钟快速过一下。</p><h3 id="默认值问题"><a href="#默认值问题" class="headerlink" title="默认值问题"></a>默认值问题</h3><p>基础类型有一个很值得思考的问题：每一种基础类型都有一个<strong>默认值</strong>，如<code>string</code>的默认值为<code>&quot;&quot;</code>，<code>int32</code>的默认值是<code>0</code>。这就带来了一个问题：<strong>当一个字段被解析为默认值时，怎么区分是未传值，还是传的就是默认值</strong>？</p><p>举个具体的例子，比如我们的传入参数为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;a&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;b&quot;</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;b&quot;</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将数据定义为</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终解析到Go结构体中的<code>Foo.A</code>字段都为0，但是，调用方对 <code>未传值</code> 和 <code>默认值</code> 很可能有不同的定义。</p><p>这个问题有三种常规的解决思路：</p><ol><li>利用编程语言特性，区分 <code>未传值</code> 与 <code>默认值</code> 两种情况；</li><li>两边利用协议约定，保证<code>未传值</code> 与 <code>默认值</code>等同；</li><li>新增加描述性字段，表明相关字段是否生效；</li></ol><p>为了方便理解，我对上面三个case各举个例子：</p><h3 id="方案1-在编程语言中区分"><a href="#方案1-在编程语言中区分" class="headerlink" title="方案1 - 在编程语言中区分"></a>方案1 - 在编程语言中区分</h3><p>以<code>Go</code>语言为例，会利用指针的特性，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">A *<span class="keyword">int32</span></span><br><span class="line">B *<span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解析示例的json时，可以按如下方式进行区分：</p><ul><li>当为默认值0时，将A指向为0的指针</li><li>当未传值时，将A指为nil</li></ul><p>但是，这种实现对语言有一定要求：</p><ol><li>要求语言支持指针（<code>protobuf</code>目标是跨语言的RPC方案）</li><li>对指针变量的操作需要不少额外的判断、转化操作</li></ol><p>虽然方案1的普适性不高，但在Go语言的开源项目中很常见，比如各种共有云的Go SDK。</p><h3 id="方案2-协议约定效果等同"><a href="#方案2-协议约定效果等同" class="headerlink" title="方案2 - 协议约定效果等同"></a>方案2 - 协议约定效果等同</h3><p>方案2更多是一种内部约定。比如，定义了一个数据</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int64</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">float</span> price = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双方约定了：无论字段传的是默认值还是未传值，我们都按默认值处理。</p><p>但是，在接口中，我们会高频地复用数据结构。例如，Book这个数据结构在创建时没有问题，但将这个结构用在更新接口时，往往会有如下思路：</p><ul><li>如果是默认值，接口是希望将这个字段修改为默认值，如name为空</li><li>如果未传值，接口是希望不更改这个字段，即不要修改name字段</li></ul><p>所以，在方案2时，我们只能二选一：当遇到默认值时，要么认为是不改、要么认为是改成默认值。而如果要兼容，那就新增字段或者新增结构。</p><p>方案2虽然存在局限性，但是频率最高的使用方式：毕竟一般情况下调用方就几个，双方简单沟通一下就可以解决问题。但如果面向成百上千的调用方时，这个解释成本就很高了。</p><p>下面的方案3则是对其的一种演进：</p><h3 id="方案3-新增加描述性字段"><a href="#方案3-新增加描述性字段" class="headerlink" title="方案3 - 新增加描述性字段"></a>方案3 - 新增加描述性字段</h3><p>基于方案2，我们可以直接增加一个字段进行标识（类似于一种掩码的效果），如<code>mask=[&quot;id&quot;,&quot;name&quot;]</code>，表示：</p><ul><li><code>id</code>,<code>name</code>这两个字段生效</li><li><code>price</code>字段不生效</li></ul><p>这时，前面的问题就得以解决：</p><ul><li>如果希望修改name为空，mask中增加name字段</li><li>如果不希望修改name，mask中不出现name字段</li></ul><p>这个实现，就是Google推荐的<code>FieldMask</code>的实现思路，下面我们会再次说明。</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p><code>protobuf</code>的枚举的是一种可读性很强的定义，可以参考如下链接了解：<a href="https://developers.google.com/protocol-buffers/docs/proto3#enum">https://developers.google.com/protocol-buffers/docs/proto3#enum</a></p><p>需要注意的是，官方推荐的将默认值0定义为<code>XXX_UNSPECIFIED</code>（即不在规定中，不具备实际意义），如</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Corpus</span> </span>&#123;</span><br><span class="line">  CORPUS_UNSPECIFIED = <span class="number">0</span>;</span><br><span class="line">  CORPUS_UNIVERSAL = <span class="number">1</span>;</span><br><span class="line">  CORPUS_WEB = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现思路与上面的方案2很像：规定默认值为未规定的，是一个无需关心的情况。这就要求使用方尽可能地使用非默认值的枚举值，减少歧义。</p><h2 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h2><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ErrorStatus</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> google.protobuf.Any details = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Any</code>可以简单理解为<code>protobuf</code>协议中的任意类型（但必须是由proto定义的）。我们可以从两个问题来理解它：</p><ul><li><code>Any</code>如何保证兼容性？<ul><li>内部将数据转化成了byte数组，就能存储任意数据了</li></ul></li><li><code>Any</code>如何解析到特定的proto结构？<ul><li>结合上面的byte数组和对应定义的proto文件</li></ul></li></ul><p>因此，传递的数据包含2个字段：</p><ul><li>byte数组，表示具体数据</li><li>proto文件的定义，比如 <code> &quot;@type&quot;: &quot;type.googleapis.com/junedayday.grpc_gateway_buf_example.echo_service.v1.EchoRequest&quot;</code></li></ul><p>但在实际场景中，<code>Any</code>使用并不方便，往往仅用在<code>protobuf</code>的内部协议中，不适合作为通用的API。</p><h3 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="keyword">oneof</span> unique_id &#123;</span><br><span class="line">    <span class="built_in">int64</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> uuid = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Oneof</code>适用的场景是多个字段中仅允许生效其中一个，这避免了理解上的冲突。例如，我们要查找书，每本书有2个唯一标识：<code>id</code>和<code>uuid</code>。</p><ul><li>如果传任意一个，我们能正常地查到</li><li>如果同时传了<code>id</code>和<code>uuid</code>，可能存在多种理解：<ul><li>同时根据两个条件查</li><li>先根据id查，未查到再根据uuid查</li><li>现根据uuid查，未查到再根据id查</li></ul></li></ul><p>从调用方来说，只能阅读你的接口文档，阅读各字段的注释。而<code>Oneof</code>字段呢，就在接口定义上直接告诉了你，二者只能选其一；如果你硬要传2个参数，就直接返回参数错误。</p><p><code>Oneof</code>特性看起来很好用，但实际接口开发中的使用频率很低，毕竟通过有效的注释或者接口拆分，也能解决这个问题。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message EchoRequest &#123;</span><br><span class="line">  <span class="keyword">map</span>&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map是一个很常用的特性，定义和使用也十分简单。如示例，就会自动对应到Go语言中的<code>map[string]string</code>。</p><p>但从API的设计来说，<code>map</code>这个容器有很高的扩展性，缺牺牲了一定的可读性，如key中代表的含义、有哪些限制等等，只能通过注释进行说明。</p><p>因此，<code>map</code>的特性要节制地使用，优先考虑用明确的结构定义来表示。</p><h2 id="扩展类型"><a href="#扩展类型" class="headerlink" title="扩展类型"></a>扩展类型</h2><h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/struct.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EchoRequest</span> </span>&#123;</span><br><span class="line">  google.protobuf.Value info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于<code>Any</code>，<code>Value</code>不需要依赖proto的定义，更趋近于通用意义上的泛型。它本质上是一种<code>Oneof</code>：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Value</span> </span>&#123;</span><br><span class="line">  <span class="keyword">oneof</span> kind &#123;</span><br><span class="line">    NullValue null_value = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">double</span> number_value = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">string</span> string_value = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">bool</span> bool_value = <span class="number">4</span>;</span><br><span class="line">    Struct struct_value = <span class="number">5</span>;</span><br><span class="line">    ListValue list_value = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部也提供了多个数据类型的转化，可按需调用，如<code>GetXXXValue()</code>。</p><h3 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/struct.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EchoRequest</span> </span>&#123;</span><br><span class="line">  google.protobuf.Struct info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Strcut</code>可快速对应到Go语言中的结构体，可以快速地转化为 <code>map[string]structpb.Value</code>。接下来的使用方式同上面的<code>Value</code>。</p><h3 id="FieldMask"><a href="#FieldMask" class="headerlink" title="FieldMask"></a>FieldMask</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/field_mask.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EchoRequest</span> </span>&#123;</span><br><span class="line">  google.protobuf.FieldMask field_mask = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FieldMask</code>就是上面基础类型中方案3的具体实现。它的定义很简单，就是一个字符串的数组：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">FieldMask</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">string</span> paths = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的每个元素，表示一个具体要生效的字段，支持多层的数据结构，如<code>a.b</code>。</p><h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><p>持续时间，需要一个数字+单位，如<code>2s</code>，减少了单位理解上的歧义。它由两个部分组成，很容易理解</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Duration</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int64</span> seconds = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> nanos = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TimeStamp"><a href="#TimeStamp" class="headerlink" title="TimeStamp"></a>TimeStamp</h3><p>时间处理是一个很麻烦的方式，我们往往是采用<code>string</code>的方式传递、然后再次解析，相对来说比较折腾。</p><p>而官方提供了如下方式</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/timestamp.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EchoRequest</span> </span>&#123;</span><br><span class="line">  google.protobuf.Timestamp time_stamp = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以利用<code>AsTime()</code>方法，快速地转化到Go语言中的<code>time.Time</code>结构，非常省力。对与输入方来说，时间要遵循 rfc3339 格式，如 <code>2006-01-02T15:04:05Z</code>。</p><p>虽然我们更常用<code>YYYY-MM-DD HH:mm:ss</code>来表示，但rfc3339更具兼容性，建议尽可能地尝试替换。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>除了基础类型和枚举，我对今天谈到了8种类型进行了简单的概括：</p><table><thead><tr><th align="center">数据类型</th><th align="center">使用频率</th><th align="center">可读性</th></tr></thead><tbody><tr><td align="center">Any</td><td align="center">低</td><td align="center">低</td></tr><tr><td align="center">Oneof</td><td align="center">中</td><td align="center">高</td></tr><tr><td align="center">map</td><td align="center">高</td><td align="center">中</td></tr><tr><td align="center">Value</td><td align="center">中</td><td align="center">低</td></tr><tr><td align="center">Struct</td><td align="center">中</td><td align="center">低</td></tr><tr><td align="center">FieldMask</td><td align="center">低</td><td align="center">高</td></tr><tr><td align="center">Duration</td><td align="center">高</td><td align="center">高</td></tr><tr><td align="center">TimeStamp</td><td align="center">高</td><td align="center">高</td></tr></tbody></table><p>同时，文中对默认值问题的分析，也希望能对大家在接口设计上有一定的启发。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;gRPC-Gateway的相关方案我们已经在上一篇详细描述。为了更方面地方便大家理解，我这边整理了一个最简化的git项目：&lt;a href=&quot;https://github.com/Junedayday/grpc-gateway-buf-example/tree/v0.0.1&quot;&gt;https://github.com/Junedayday/grpc-gateway-buf-example/tree/v0.0.1&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;它主要包含两个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用buf工具构建项目&lt;/li&gt;
&lt;li&gt;同时启动了gRPC和gRPC-Gateway服务，支持两种协议的调用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天，我们先迈出第一步：探索RPC服务中的数据类型。掌握常见的数据类型，灵活地运用到接口设计中，能帮助我们快速地提供优雅的接口类服务。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习 - RPC篇:gRPC-Gateway示例代码概览</title>
    <link href="http://example.com/2022/10/27/go-study/go-rpc-3/"/>
    <id>http://example.com/2022/10/27/go-study/go-rpc-3/</id>
    <published>2022-10-27T04:00:00.000Z</published>
    <updated>2022-10-28T02:40:27.317Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>gRPC-Gateway是gRPC生态的一环，用于对HTTP协议的扩展，是一套高性能、高扩展的开源RPC框架。</p><p>因此，要掌握gRPC-Gateway，必须要对gRPC有一定的基础，才能明白它的定位与价值。</p><span id="more"></span><h2 id="方案概览"><a href="#方案概览" class="headerlink" title="方案概览"></a>方案概览</h2><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/grpc-gateway.png"></p><p>整个方案分为两个方向：</p><h3 id="纵向-RPC协议调用"><a href="#纵向-RPC协议调用" class="headerlink" title="纵向 - RPC协议调用"></a>纵向 - RPC协议调用</h3><p>三个模块：</p><ul><li>调用方 - API Client</li><li>HTTP服务 - Reverse Proxy</li><li>gRPC服务 - Your gRPC service</li></ul><p>两个协议：</p><ul><li>HTTP - 客户端发起的是HTTP协议，传输到反向代理</li><li>gRPC - 反向代理与gRPC服务之间的协议是gRPC</li></ul><p>关键点：</p><ol><li>Reverse Proxy实现了的关键能力是：将HTTP协议转化为gRPC协议</li><li>可同时提供2个服务：HTTP和gRPC，只是HTTP服务的最终实现还是调用到了gRPC</li></ol><h3 id="横向-Protobuf的代码生成"><a href="#横向-Protobuf的代码生成" class="headerlink" title="横向 - Protobuf的代码生成"></a>横向 - Protobuf的代码生成</h3><ul><li>gRPC-Gateway部分：自动生成反向代理</li><li>gRPC部分：自动生成stub</li></ul><p>stub这个单词很有意思，相对准确的翻译是存根、残端，和面向对象中的 <strong>接口</strong> 有异曲同工之妙：<strong>提供了实现的框架，但具体实现仍交由开发者</strong>。</p><h3 id="开发工作"><a href="#开发工作" class="headerlink" title="开发工作"></a>开发工作</h3><p>对开发者来说，整个方案的工作分为两部分：</p><ol><li>RPC部分 - 编写<code>proto</code>文件</li><li>业务逻辑部分 - 编写gRPC中的<code>stub</code>的实现</li></ol><h2 id="开发思路"><a href="#开发思路" class="headerlink" title="开发思路"></a>开发思路</h2><h3 id="1-RPC开发-proto文件的编写"><a href="#1-RPC开发-proto文件的编写" class="headerlink" title="1. RPC开发 - proto文件的编写"></a>1. RPC开发 - proto文件的编写</h3><p>我们看一个官方github上的示例<code>proto</code>文件：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> your.service.v1;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;github.com/yourorg/yourprotos/gen/go/your/service/v1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/api/annotations.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">StringMessage</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">YourService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Echo(StringMessage) <span class="keyword">returns</span> (StringMessage) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      post: <span class="string">&quot;/v1/example/echo&quot;</span></span><br><span class="line">      body: <span class="string">&quot;*&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从上到下，对里面的语法做简单的分析：</p><ul><li>proto3版本</li><li>proto的包名称</li><li>生成Go语言代码后的Go Package</li><li>导入依赖的proto文件</li><li>Message - 表示RPC的数据结构，按规则生成到各语言的代码</li><li>Service - 一组RPC的抽象</li><li>rpc - 一个具体方法，包括 方法名（请求Message） returns （返回Message）</li><li>google.api.http - HTTP协议的定义，如示例中的方法和URL</li></ul><h3 id="2-代码生成"><a href="#2-代码生成" class="headerlink" title="2. 代码生成"></a>2. 代码生成</h3><p>如何将proto文件生成为Go语言的<code>stub</code>代码，官方提供了两个路径：</p><ul><li>buf（新方式，配置简单，推荐）</li><li>protoc（经典方式，配置较为复杂）</li></ul><p>具体的操作方法可以参考： <a href="https://github.com/grpc-ecosystem/grpc-gateway#usage">https://github.com/grpc-ecosystem/grpc-gateway#usage</a> 。</p><h3 id="3-业务实现"><a href="#3-业务实现" class="headerlink" title="3. 业务实现"></a>3. 业务实现</h3><p>代码生成的只是一个<code>stub</code>，具体实现需要我们自己编码。上述方法生成的函数签名大致如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Echo</span><span class="params">(ctx context.Context, request *proto.StringMessage)</span> <span class="title">returns</span> <span class="params">(response *proto.StringMessage, err error)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 自己实现的业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于其中的context与error，我在上一讲已经讲过大致的规范。而在gRPC-Gateway中怎么使用呢？我们会在具体示例中再去讲。</p><h3 id="4-main函数框架"><a href="#4-main函数框架" class="headerlink" title="4. main函数框架"></a>4. main函数框架</h3><p>1~3步骤将一个RPC请求的开发过程串联了起来，作为web服务的高频迭代部分。</p><p>但如果要作为一个完整的服务，还需要包括基础的server启动代码，很少需要改动。我们接着看官方的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;context&quot;</span></span><br><span class="line">  <span class="string">&quot;flag&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/golang/glog&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/grpc-ecosystem/grpc-gateway/v2/runtime&quot;</span></span><br><span class="line">  <span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">  <span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line"></span><br><span class="line">  gw <span class="string">&quot;github.com/yourorg/yourrepo/proto/gen/go/your/service/v1/your_service&quot;</span>  <span class="comment">// Update</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// command-line options:</span></span><br><span class="line">  <span class="comment">// gRPC server endpoint</span></span><br><span class="line">  grpcServerEndpoint = flag.String(<span class="string">&quot;grpc-server-endpoint&quot;</span>,  <span class="string">&quot;localhost:9090&quot;</span>, <span class="string">&quot;gRPC server endpoint&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  ctx := context.Background()</span><br><span class="line">  ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">  <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register gRPC server endpoint</span></span><br><span class="line">  <span class="comment">// Note: Make sure the gRPC server is running properly and accessible</span></span><br><span class="line">  mux := runtime.NewServeMux()</span><br><span class="line">  opts := []grpc.DialOption&#123;grpc.WithTransportCredentials(insecure.NewCredentials())&#125;</span><br><span class="line">  err := gw.RegisterYourServiceHandlerFromEndpoint(ctx, mux,  *grpcServerEndpoint, opts)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start HTTP server (and proxy calls to gRPC server endpoint)</span></span><br><span class="line">  <span class="keyword">return</span> http.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line">  <span class="keyword">defer</span> glog.Flush()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    glog.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要明确一点：这部分代码并没有包括gRPC服务的启动代码，它已经默认在<code>grpcServerEndpoint</code>这个地址+端口上启动了。如果没有进程隔离的强要求，我们可以在<code>main</code>函数中同时启动 gRPC server和gRPC-Gateway server。</p><p>gRPC-Gateway启动时有4个重要参数：</p><ul><li>mux，多路复用，功能最为强大，可以添加各种自定义的拦截器等</li><li>grpcServerEndpoint，将HTTP转换成gRPC，再发给gRPC的地址</li><li>opts，服务的启动选项</li><li>:8081，启动地址</li></ul><blockquote><p>关于gRPC部分内容可以参考： <a href="https://grpc.io/docs/languages/go/quickstart/">https://grpc.io/docs/languages/go/quickstart/</a></p></blockquote><h2 id="参考示例"><a href="#参考示例" class="headerlink" title="参考示例"></a>参考示例</h2><p>整套框架的完整示例可以参考这个文件 - <a href="https://github.com/Junedayday/micro_web_service/blob/master/main.go">https://github.com/Junedayday/micro_web_service/blob/master/main.go</a></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本篇重点是对gRPC-Gateway最基础的原理和使用进行了分析。</p><p>如果你能通过本篇文章，对这个方案有一个基本认识，那么接下来我会带你玩转这个框架。你也无需担心无法实践到日常项目中：gRPC-Gateway中的能力与gin等框架都是共通的，可以轻松地举一反三。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;gRPC-Gateway是gRPC生态的一环，用于对HTTP协议的扩展，是一套高性能、高扩展的开源RPC框架。&lt;/p&gt;
&lt;p&gt;因此，要掌握gRPC-Gateway，必须要对gRPC有一定的基础，才能明白它的定位与价值。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习 - RPC篇:gin框架的基础能力剖析</title>
    <link href="http://example.com/2022/09/26/go-study/go-rpc-2/"/>
    <id>http://example.com/2022/09/26/go-study/go-rpc-2/</id>
    <published>2022-09-26T04:00:00.000Z</published>
    <updated>2022-09-30T04:26:16.964Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg"></p><h2 id="gin框架"><a href="#gin框架" class="headerlink" title="gin框架"></a>gin框架</h2><p>gin是非常流行的一款HTTP框架。相较于原生的HTTP server，gin有很多改进点，主要在于3点：</p><ol><li>上手简单，开发思路与原生HTTP基本一致</li><li>引入多个工具库，提高了开发效率</li><li>生态丰富，有许多开源的组件</li></ol><p>围绕着gin框架，我们将展开今天的话题。</p><span id="more"></span><h2 id="示例Gin代码"><a href="#示例Gin代码" class="headerlink" title="示例Gin代码"></a>示例Gin代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求结构体</span></span><br><span class="line"><span class="keyword">type</span> MyRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">MyInfo <span class="keyword">string</span> <span class="string">`form:&quot;my_info&quot; json:&quot;my_info&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应结构体</span></span><br><span class="line"><span class="keyword">type</span> MyResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">Errno  <span class="keyword">int</span>    <span class="string">`json:&quot;errno&quot;`</span></span><br><span class="line">Result <span class="keyword">string</span> <span class="string">`json:&quot;result&quot;`</span></span><br><span class="line">MyInfo <span class="keyword">string</span> <span class="string">`form:&quot;my_info&quot; json:&quot;my_info&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b MyRequest</span><br><span class="line">err := c.Bind(&amp;b)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, MyResponse&#123;</span><br><span class="line">Errno: <span class="number">1</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, MyResponse&#123;</span><br><span class="line">Result: <span class="string">&quot;my result&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// gin server</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"><span class="comment">// 中间件</span></span><br><span class="line">r.Use(gin.CustomRecovery(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context, recovered <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err, ok := recovered.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">c.String(http.StatusInternalServerError, fmt.Sprintf(<span class="string">&quot;error: %s&quot;</span>, err))</span><br><span class="line">&#125;</span><br><span class="line">c.AbortWithStatus(http.StatusInternalServerError)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/data&quot;</span>, GetData)</span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键函数分析"><a href="#关键函数分析" class="headerlink" title="关键函数分析"></a>关键函数分析</h2><h3 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">GET</span><span class="params">(relativePath <span class="keyword">string</span>, handlers ...HandlerFunc)</span> <span class="title">IRoutes</span></span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">POST</span><span class="params">(relativePath <span class="keyword">string</span>, handlers ...HandlerFunc)</span> <span class="title">IRoutes</span></span></span><br></pre></td></tr></table></figure><p>Gin支持不同HTTP方法的路由注册，这对RESTful风格的代码编写带来了很大帮助。对于阅读代码的同学，可以快速地通过路由注册的列表，如<code>r.GET(&quot;/data&quot;, GetData)</code>，找到对应的方法。</p><h3 id="Handler函数"><a href="#Handler函数" class="headerlink" title="Handler函数"></a>Handler函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(*Context)</span></span></span><br></pre></td></tr></table></figure><p>Handler函数相较于标准库，看似从2个参数<code>Request</code> 和 <code>ResponseWriter</code> 转变成了一个参数 <code>Context</code>，简化了调用，但其实对调用者来说，复杂度并没有降低：</p><ol><li><code>Context</code> 包含大量数据结构</li><li><code>Context</code> 包含了大量的方法</li></ol><p>对于一名新手，在摸索出一条最佳实践路径前，学习成本不增反减。这主要是因为<code>gin.Context</code>过重。从编程角度来看，这个对象包含了过多信息，是个大而杂的工具集。</p><p>但不可否认的是，<code>gin</code>里提供了很多工具都比原生库好用，例如参数绑定、返回JSON数据。</p><h3 id="绑定参数Bind"><a href="#绑定参数Bind" class="headerlink" title="绑定参数Bind"></a>绑定参数Bind</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Bind</span><span class="params">(obj any)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>Bind中引入了泛型中的<code>any</code>特性，但使用和原先的<code>interface&#123;&#125;</code>完全一致：</p><p>调用方可以填任意值。但实际上，Bind中必须为一个指针类型的数据结构，但由于interface{}对入参没有任何编译时的限制，导致传参问题在运行时才会报错。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b MyRequest</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">c.Bind(&amp;b)</span><br><span class="line"><span class="comment">// 错误：编译正确，但运行时异常</span></span><br><span class="line">c.Bind(b)</span><br><span class="line">c.Bind(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="返回JSON数据"><a href="#返回JSON数据" class="headerlink" title="返回JSON数据"></a>返回JSON数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">JSON</span><span class="params">(code <span class="keyword">int</span>, obj any)</span></span></span><br></pre></td></tr></table></figure><p>该方法是返回HTTP状态码为code，并且将obj数据进行JSON序列化。</p><p>它的问题同Bind函数，这里就不再赘述了。</p><h3 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h3><p>gin框架提供了middleware的能力，它可以为整个Server提供一个公共能力的封装。有了middleware，整个server处理请求变成了：</p><p>middleware预处理 -&gt; handler -&gt; middleware后处理</p><ul><li><p>常见的预处理如</p><ul><li>参数校验</li><li>用户认证</li><li>panic恢复</li></ul></li><li><p>常见的后处理则如</p><ul><li>定制HTTP状态码</li><li>异常数据封装</li></ul></li></ul><p>总体来说，middleware能帮助用户减少重复性代码的编写，沉淀为公共能力，堪称web编程的一大利器。</p><h2 id="gin能力剖析"><a href="#gin能力剖析" class="headerlink" title="gin能力剖析"></a>gin能力剖析</h2><p>我们先看看gin的改进点：</p><ol><li>mux支持RESTful风格的接口定义</li><li><code>gin.Context</code>提供了大量的工具，简化解析、返回的相关代码</li><li>middleware可解决大量重复性的代码</li></ol><p>这三点对开发者带来了不小的帮助。但是，我们在使用<code>gin</code>作为开发工具时，仍有一些问题：</p><ol><li>大量的参数类型都是<code>interface&#123;&#125;</code>类型的数据结构，需要调用方自行保证</li><li><code>gin.Context</code>过大，学习和理解的成本很高</li><li>不少问题要在运行时才能发现，编译期无能为力</li></ol><p>这些弊端汇总起来，依旧是和handler的函数定义相关：<strong>没有充分地利用Go强类型、编译检查的特点，来提高程序的质量、降低开发者的学习成本</strong>。</p><h2 id="更简单的Handler框架"><a href="#更简单的Handler框架" class="headerlink" title="更简单的Handler框架"></a>更简单的Handler框架</h2><p>那么，什么样的Handler框架对用户来说效果更好呢？我这边给出一个函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BetterHandler</span><span class="params">(ctx context.Context, req *MyRequest)</span> <span class="params">(rsp *MyResponse, err error)</span></span></span><br></pre></td></tr></table></figure><p>我们依次看一下这些参数及其使用场景：</p><ol><li>ctx - 上下文，传递公共参数以及超时控制</li><li>req - 请求的参数结构</li><li>rsp - 响应的参数结构</li><li>err - 错误信息</li></ol><p>从整个RPC框架来看，它重点做了2件事：</p><ol><li>自动将http参数解析到ctx和req中<ol><li>解析规则按标准约定，如HTTP RESTful</li><li>一般是将Header里的信息放到ctx中，将URL+Body里的信息匹配到req结构体</li></ol></li><li>自动将rsp和err对应到HTTP响应中<ol><li>err=nil时，认为请求成功，将rsp序列化后、填入到HTTP Body中</li><li>err!=nil时，认为请求去失败，返回约定的协议（如异常状态码、异常HTTP的Body）</li></ol></li></ol><p><code>BetterHandler</code>是一个很棒的编程体验：</p><ol><li>无需关心解析参数与返回响应这两步的具体实现，统一由框架封装</li><li>函数的输入和输出都是强类型的，开发者有了一个明确的“模板”</li><li>将handler中的业务逻辑与RPC框架中协议部分解耦</li></ol><p>也许你一下子无法快速理解，但反复对比下，你会逐渐体会到其中的精妙。但是，使用这个框架前，我们要解决以下两个问题：</p><ol><li>URL与Handler的匹配逻辑</li><li>怎么约定解析请求和返回响应的协议</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天，我们一起看了gin框架的相关示例，编程体验比原生http库有了明显提升。gin的生态也给出了不少的优化方案或者插件，但由于框架本身限制，很难治本。</p><p>下一讲，我们将来看一个我最为推荐的RPC框架，分析一下其相关利弊。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go_study.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;gin框架&quot;&gt;&lt;a href=&quot;#gin框架&quot; class=&quot;headerlink&quot; title=&quot;gin框架&quot;&gt;&lt;/a&gt;gin框架&lt;/h2&gt;&lt;p&gt;gin是非常流行的一款HTTP框架。相较于原生的HTTP server，gin有很多改进点，主要在于3点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上手简单，开发思路与原生HTTP基本一致&lt;/li&gt;
&lt;li&gt;引入多个工具库，提高了开发效率&lt;/li&gt;
&lt;li&gt;生态丰富，有许多开源的组件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;围绕着gin框架，我们将展开今天的话题。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
</feed>
