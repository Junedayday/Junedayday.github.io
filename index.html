<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"8.0.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="Blog信息">
<meta property="og:type" content="website">
<meta property="og:title" content="Junedayday Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Junedayday Blog">
<meta property="og:description" content="Blog信息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Junedayday">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Junedayday Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Junedayday Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">六月天天的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Junedayday</p>
  <div class="site-description" itemprop="description">Blog信息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/28/sharing-5min/2022-02/2022Week09/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/28/sharing-5min/2022-02/2022Week09/" class="post-title-link" itemprop="url">五分钟技术小分享 - 2022Week09</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-02-28 12:00:00 / 修改时间：22:12:19" itemprop="dateCreated datePublished" datetime="2022-02-28T12:00:00+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">每日技术分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57581641299795_.pic_hd.jpg" alt="2022-02"></p>
<h2 id="2022-02-28-CNCF-OpenTelemetry等"><a href="#2022-02-28-CNCF-OpenTelemetry等" class="headerlink" title="2022-02-28 CNCF-OpenTelemetry等"></a>2022-02-28 CNCF-OpenTelemetry等</h2><p>今天，我们会以OpenTelemetry的三个核心Metrics、Logs、Traces为切入点，来看看OpenMetrics、Fluentd、Jaeger这三个具有代表性的项目。</p>
<h3 id="OpenTelemetry"><a href="#OpenTelemetry" class="headerlink" title="OpenTelemetry"></a>OpenTelemetry</h3><p>OpenTelemetry主要分为三大块：Metrics、Logs、Traces。</p>
<ul>
<li>Metrics指标：程序将运行中关键的一些指标数据保存下来，常通过RPC的方式Pull/Push到统一的平台</li>
<li>Logs日志：依赖程序自身的打印。可通过ELK/EFK等工具采集到统一的平台并展示</li>
<li>Traces分布式追踪：遵循Dapper等协议，获取一个请求在整个系统中的调用链路</li>
</ul>
<p>OpenTelemetry有多语言的、具体落地的现成库，供业务方快速落地实践。</p>
<blockquote>
<p>更多可以参考 <a target="_blank" rel="noopener" href="https://junedayday.github.io/2021/10/14/readings/go-digest-2/">https://junedayday.github.io/2021/10/14/readings/go-digest-2/</a></p>
</blockquote>
<h3 id="Metrics-OpenMetrics"><a href="#Metrics-OpenMetrics" class="headerlink" title="Metrics - OpenMetrics"></a>Metrics - OpenMetrics</h3><blockquote>
<p>Evolving the Prometheus exposition format into a standard.</p>
</blockquote>
<p>这个项目更多地是一种规范性质，基本就是以Prometheus的指标为标准。</p>
<p>更多的信息可以参考 <a target="_blank" rel="noopener" href="https://prometheus.io/docs/instrumenting/exposition_formats/%E3%80%82">https://prometheus.io/docs/instrumenting/exposition_formats/。</a></p>
<h3 id="Logs-Fluentd"><a href="#Logs-Fluentd" class="headerlink" title="Logs - Fluentd"></a>Logs - Fluentd</h3><blockquote>
<p>unified logging layer 统一的日志层</p>
</blockquote>
<p>我们这里谈的Logs并不是指各编程语言的日志库，更多是指对日志产生后，<strong>如何进行解析与采集</strong>，而Fluentd就是一个代表性的项目。</p>
<p>当前主流的日志采集与分析方案，也由ELK转变成了EFK，也就是Logstash被Fluentd所替代。</p>
<p>Fluentd最核心的优势，在于它提供了大量的可供快速接入的插件 - <a target="_blank" rel="noopener" href="https://www.fluentd.org/plugins%E3%80%82">https://www.fluentd.org/plugins。</a></p>
<h3 id="Traces-Jaeger"><a href="#Traces-Jaeger" class="headerlink" title="Traces - Jaeger"></a>Traces - Jaeger</h3><blockquote>
<p>open source, end-to-end distributed tracing</p>
</blockquote>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/jaeger-architecture-v1.png" alt="jaeger"></p>
<p>Jaeger为OpenTracing提供了一套具体落地的方案，在Jaeger-Client侧也提供了多语言的SDK，我们就可以在分布式系统中查到请求的整个生命周期的具体数据。但落地到平台时，我们要重点思考以下两点：</p>
<ol>
<li>Traces与Logs的关联：两者的收集、推送、分析、展示的整个链路非常相似，而且我们也往往希望在Trace里查询信息时，能查到应用程序中自行打印的日志；</li>
<li>Traces与Service Mesh的关联：Jaeger-Agent与Service Mesh的Sidecar模式非常类似，两者该怎么配合实践</li>
</ol>
<p>我们可以独立建设Traces、Logs、Service Mesh这三块技术，但如果能将它们有机结合起来，有助于整个基础平台的统一化。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>OpenTelemetry提倡的可观测性在复杂工程中非常重要，能大幅提高程序的可维护性。如果有机会实践，建议大家应优先理解它的理念，再结合当前开源生态进行落地。</p>
<h2 id="2022-03-01-CNCF-Litmus-ChaosMesh"><a href="#2022-03-01-CNCF-Litmus-ChaosMesh" class="headerlink" title="2022-03-01 CNCF-Litmus/ChaosMesh"></a>2022-03-01 CNCF-Litmus/ChaosMesh</h2><p>随着Kubernetes的落地，混沌工程在近几年越来越流行，CNCF也将它作为重点项目。如果用一个词概括混沌工程，最常用的就是 <strong>故障注入</strong>。</p>
<p>今天我将针对其中两个重要项目 - Litmus 和 ChaosMesh 做简单介绍，让大家对混沌工程有基本理解。</p>
<h3 id="Litmus"><a href="#Litmus" class="headerlink" title="Litmus"></a>Litmus</h3><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/litmus-arch.png" alt="litmus"></p>
<p>Litmus的架构分为控制平面和执行平面。前者更多是提供可交互的web界面与整体的功能管理；而后者更专注于具体故障功能的实现。</p>
<p>整体来说，Litmus的架构是比较重量级的：</p>
<ol>
<li>平台组件复杂</li>
<li>和Argo/Prometheus等软件有一定的交叉</li>
</ol>
<h3 id="ChaosMesh"><a href="#ChaosMesh" class="headerlink" title="ChaosMesh"></a>ChaosMesh</h3><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/chaos-mesh-arch.png" alt="chaos-mesh"></p>
<p>相对而言，Chaos Mesh是一个比较轻量级的实现，整体的架构分为三块：</p>
<ol>
<li>Dashboard - 提供界面化交互能力</li>
<li>Controller Manager - 统一管理多种CRD</li>
<li>Daemon - 负责Pod端具体的故障注入</li>
</ol>
<p>我们可以仔细分析这里的三大块，都有不少的扩展点：</p>
<ol>
<li>可通过kubectl或自定义客户端下发指令</li>
<li>Controller Manager 可实现工作流等复杂CRD</li>
<li>Daemon可通过直接请求、容器运行时和Sidecar三种方式注入错误</li>
</ol>
<h3 id="故障注入能力"><a href="#故障注入能力" class="headerlink" title="故障注入能力"></a>故障注入能力</h3><p>我个人更看好ChaosMesh这个项目，它的架构图中所呈现的扩展性非常棒。那么，接下来我就以Chaos Mesh为例，看看它所提供的的故障注入能力：</p>
<ul>
<li>基本故障:<ul>
<li><a target="_blank" rel="noopener" href="https://chaos-mesh.org/docs/simulate-pod-chaos-on-kubernetes/">PodChaos</a>: Pod</li>
<li><a target="_blank" rel="noopener" href="https://chaos-mesh.org/docs/simulate-network-chaos-on-kubernetes/">NetworkChaos</a>: 网络</li>
<li><a target="_blank" rel="noopener" href="https://chaos-mesh.org/docs/simulate-dns-chaos-on-kubernetes/">DNSChaos</a>: DNS</li>
<li><a target="_blank" rel="noopener" href="https://chaos-mesh.org/docs/simulate-http-chaos-on-kubernetes/">HTTPChaos</a>: HTTP</li>
<li><a target="_blank" rel="noopener" href="https://chaos-mesh.org/docs/simulate-heavy-stress-on-kubernetes/">StressChaos</a>: CPU或内存</li>
<li><a target="_blank" rel="noopener" href="https://chaos-mesh.org/docs/simulate-io-chaos-on-kubernetes/">IOChaos</a>: IO</li>
<li><a target="_blank" rel="noopener" href="https://chaos-mesh.org/docs/simulate-time-chaos-on-kubernetes/">TimeChaos</a>: 时间</li>
<li><a target="_blank" rel="noopener" href="https://chaos-mesh.org/docs/simulate-kernel-chaos-on-kubernetes/">KernelChaos</a>: 内核</li>
</ul>
</li>
<li>平台故障:<ul>
<li><a target="_blank" rel="noopener" href="https://chaos-mesh.org/docs/simulate-aws-chaos/">AWSChaos</a>: AWS</li>
<li><a target="_blank" rel="noopener" href="https://chaos-mesh.org/docs/simulate-gcp-chaos/">GCPChaos</a>: GCP</li>
</ul>
</li>
<li>应用故障:<ul>
<li><a target="_blank" rel="noopener" href="https://chaos-mesh.org/docs/simulate-jvm-application-chaos/">JVMChaos</a>: JVM</li>
</ul>
</li>
</ul>
<p>要覆盖基本故障这些case，已经需要投入非常多的人力物力了。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>我个人认为，混沌工程更多地是面向Iaas/Paas/Saas这类通用服务而提供的能力：</p>
<ol>
<li>Iaas/Paas/Saas这类服务是大规模共用的，对稳定性要求极高，才能体现出混沌工程的价值；</li>
<li>在业务系统中引入混沌工程有两大问题：<ol>
<li>一方面，ROI是非常低的，业务变化多、迭代快，从业务开发的角度来看，更希望基础平台侧能覆盖这些异常情况</li>
<li>另一方面，混沌工程会带来很多不确定性，可能导致业务受损</li>
</ol>
</li>
</ol>
<p>对大部分的开发者来说，可以学习混沌工程的理念，提高自己设计系统时的健壮性，但不要过于追求完美。</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/22/go-tip/go-tip-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/22/go-tip/go-tip-15/" class="post-title-link" itemprop="url">Go语言技巧 - 15.【Go并发编程】自顶向下地写出优雅的Goroutine</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-02-22 12:00:00 / 修改时间：15:45:25" itemprop="dateCreated datePublished" datetime="2022-02-22T12:00:00+08:00">2022-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p><code>Go</code>语言的Goroutine特性广受好评，初学者也能快速地实现并发。但随着不断地学习与深入，有很多开发者都陷入了对<code>goroutine</code>、<code>channel</code>、<code>context</code>、<code>select</code>等并发机制的迷惑中。</p>
<p>这里，我将结合一个具体示例，自顶向下地介绍这部分的知识，帮助大家形成体系。具体代码以下面这段为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> SubFoo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>Foo()</code>为<strong>父Goroutine</strong>，内部开启了一个<strong>子Goroutine</strong> - <code>SubFoo()</code>。</p>
<h2 id="Part1-父子Goroutine的生命周期管理"><a href="#Part1-父子Goroutine的生命周期管理" class="headerlink" title="Part1 - 父子Goroutine的生命周期管理"></a>Part1 - 父子Goroutine的生命周期管理</h2><h3 id="聚焦核心"><a href="#聚焦核心" class="headerlink" title="聚焦核心"></a>聚焦核心</h3><p><strong>父Goroutine</strong> 与 <strong>子Goroutine</strong> 最重要的交集 - 是两者的生命周期管理。包括三种：</p>
<ol>
<li><strong>互不影响</strong> - 两者完全独立、各自运行</li>
<li><strong>parent控制children</strong> - 父Goroutine结束时，子Goroutine也能随即结束</li>
<li><strong>children控制parent</strong> - 子Goroutine结束时，父Goroutine也能随即结束</li>
</ol>
<p>这个生命周期的关系，重点体现的是两个协程之间的控制关系。</p>
<blockquote>
<p>注意，这时不要过于关注具体的代码实现，如数据传递，容易绕晕。</p>
</blockquote>
<h3 id="1-互不影响"><a href="#1-互不影响" class="headerlink" title="1-互不影响"></a>1-互不影响</h3><p>两个Goroutine互不影响的代码很简单，如同示例。</p>
<p>不过我们要注意一点，如果子goroutine需要context这个入参，尽量新建。更具体的内容我们看下一节。</p>
<h3 id="2-parent控制children"><a href="#2-parent控制children" class="headerlink" title="2-parent控制children"></a>2-parent控制children</h3><p>下面是一个最常见的用法，也就是利用了context：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="comment">// 退出前执行，表示parent执行完了</span></span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> SubFoo(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		<span class="comment">// parent完成后，就退出</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，context并不是唯一的解法，我们也可以自建一个channel用来通知关闭。但综合考虑整个Go语言的生态，更建议大家尽可能地使用context，这里不扩散了。</p>
<blockquote>
<p>延伸 - 如果1个parent要终止多个children时，context的这种方式依然适用，而channel就很麻烦了。</p>
</blockquote>
<h3 id="3-children控制parent"><a href="#3-children控制parent" class="headerlink" title="3-children控制parent"></a>3-children控制parent</h3><p>逻辑也比较直观，我们直接看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> SubFoo(ch)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 获取通知并退出</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ch:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 通知parent的channel</span></span><br><span class="line">	ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="情况3的延伸"><a href="#情况3的延伸" class="headerlink" title="情况3的延伸"></a>情况3的延伸</h4><p>如果1个parent产生了n个children时，又会有以下两种情况：</p>
<ol>
<li>n个children都结束了，才停止parent</li>
<li>n个children中有m个结束，就停止parent</li>
</ol>
<p>其中，前者的最常用的解决方案如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg = <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line">	wg.Add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> SubFoo(wg)</span><br><span class="line">	<span class="keyword">go</span> SubFoo(wg)</span><br><span class="line">	<span class="keyword">go</span> SubFoo(wg)</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种延伸情况有很多种解法，有兴趣的可以自行研究，网上也有不少实现。</p>
<h3 id="Par1小结"><a href="#Par1小结" class="headerlink" title="Par1小结"></a>Par1小结</h3><p>从生命周期入手，我们能在脑海中快速形成代码的基本结构：</p>
<ol>
<li>互不影响 - 注意context独立</li>
<li>parent控制children - 优先用context控制</li>
<li>children控制parent - 一对一时用channel，一对多时用sync.WaitGroup等</li>
</ol>
<p>但在实际的开发场景中，parent和children的处理逻辑会有很多复杂的情况，导致我们很难像示例那样写出优雅的<code>select</code>等方法，我们会在下节继续分析，但不会影响这里梳理出的框架。</p>
<h2 id="Part2-for-select的核心机制"><a href="#Part2-for-select的核心机制" class="headerlink" title="Part2 - for+select的核心机制"></a>Part2 - for+select的核心机制</h2><p>一次性的select机制的代码比较简单，单次执行后即退出，讨论的意义不大。接下来，我将重点讨论for+select相关的代码实现。</p>
<h3 id="for-select的核心机制"><a href="#for-select的核心机制" class="headerlink" title="for+select的核心机制"></a>for+select的核心机制</h3><p>我们看一个来自官方的斐波那契数列的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> c &lt;- x:</span><br><span class="line">			x, y = y, x+y</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			fmt.Println(&lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">		quit &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line">	fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很长，我们聚焦于for+select这块，它实现了两个功能：</p>
<ol>
<li><code>c</code>传递数据</li>
<li><code>quit</code>传递停止的信号</li>
</ol>
<p>这时，如果你花时间去理解这两个channel的传递机制，容易陷入对select理解的误区；而我们应该从更高的维度，去看这两个case中获取到数据后的操作、即case中的执行逻辑，才能更好地理解整块代码。</p>
<h3 id="分析select中的case"><a href="#分析select中的case" class="headerlink" title="分析select中的case"></a>分析select中的case</h3><p>我们要注意到，在case里代码运行的过程中，整块代码是无法再回到select、去判断各case的（这里不讨论panic，return，os.Exit()等情况）。</p>
<p>以上面的代码为例，如果<code>x, y = y, x+y</code>函数的处理耗时，远大于<code>x</code>这个通道中塞入数据的速度，那么这个<code>x</code>的写入处将长期处于排队的阻塞状态。这时，不适合采用select这种模式。</p>
<p>所以，<strong>select适合IO密集型逻辑，而不适合计算密集型</strong>。也就是说，select中的每个case（包括default），应消耗尽量少的时间，快速回到for循环、继续等待。IO密集型常指文件、网络等操作，它消耗的CPU很少、更多的时间是在等待返回，它能更好地体现出<strong>runtime调度Goroutine的价值</strong>。</p>
<blockquote>
<p>Go 的 select这个关键词，可以结合网络模型中的select进行理解。</p>
</blockquote>
<h3 id="父子进程中的长逻辑处理"><a href="#父子进程中的长逻辑处理" class="headerlink" title="父子进程中的长逻辑处理"></a>父子进程中的长逻辑处理</h3><p>这时，如果我们的父子进程里，就是有那么一长段的业务逻辑，那代码该怎么写呢？我们来看看下面这一段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">			LongLogic()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LongLogic</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如1累加到10000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>LongLogic()</code>会花费很长的运行时间，所以当外部的context取消了，也就是父Goroutine发出通知可以结束了，这个子Goroutine是无法快速触发到<code>&lt;-ctx.Done()</code>的，因为它还在跑<code>LongLogic()</code>里的代码。也就是说，子进程生命周期结束的时间点延长到<code>LongLogic()</code>之后了。</p>
<p>这个问题的原因在于违背了我们上面讨论的点，即在select的case里包含了计算密集型任务。</p>
<blockquote>
<p>补充一下，case里包含长逻辑不代表程序一定有问题，但或多或少地不符合for+select+channel的设计理念。</p>
</blockquote>
<h3 id="两个长逻辑处理"><a href="#两个长逻辑处理" class="headerlink" title="两个长逻辑处理"></a>两个长逻辑处理</h3><p>这时，我们再来写个长进程处理，整个代码结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">			LongLogic()</span><br><span class="line">		<span class="keyword">case</span> &lt;-dataCh2:</span><br><span class="line">			LongLogic()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>dataCh</code>和<code>dataCh2</code>会产生竞争，也就是两个通道的 <strong>写长期阻塞、读都在等待LongLogic执行完成</strong>。给channel加个buffer可以减轻这个问题，但无法根治，运行一段时间依旧会阻塞。</p>
<h3 id="改造思路"><a href="#改造思路" class="headerlink" title="改造思路"></a>改造思路</h3><p>有了上面代码的基础，改造思路比较直观了，将<code>LongLogic</code>异步化，我们先通过新建协程来简单实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">			<span class="keyword">go</span> LongLogic()</span><br><span class="line">		<span class="keyword">case</span> &lt;-finishedCh:</span><br><span class="line">			fmt.Println(<span class="string">&quot;LongLogic finished&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LongLogic</span><span class="params">()</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Minute)</span><br><span class="line">	finishedCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码里要注意一个点，如果<code>LongLogic()</code>是一段需要CPU密集计算的代码，比如计算1累加到10000，它是没有办法通过channel等其余方式突然中止的。它具备一定的原子性 - <strong>要么不跑，要么跑完，跑的过程中没有外部插手的地方</strong>。</p>
<p>而如果硬要中断<code>LongLogic()</code>，那就往往只能杀掉整个进程。</p>
<h3 id="Part2小结"><a href="#Part2小结" class="headerlink" title="Part2小结"></a>Part2小结</h3><p>我们记住for+select代码块设计的核心要领 - IO密集型。Go语言的goroutine特性，更多地是为了解决IO密集型程序的问题所设计的，对计算密集型的任务较其它语言没有太大优势。落到具体实践上，就是<strong>让每个case中代码的运行时间尽可能地短，快速回到for循环里的select去继续监听各个case中的channel</strong>。</p>
<p>上面这段代码比较粗糙，在具体工程中会遇到很多问题，比如无限制地开启了大量的<code>LongLogic()</code>协程。我们会在下一节继续来看。</p>
<h2 id="Part3-长耗时功能的优化"><a href="#Part3-长耗时功能的优化" class="headerlink" title="Part3 - 长耗时功能的优化"></a>Part3 - 长耗时功能的优化</h2><p>通过前面两篇的铺垫，我们对 <strong>父子Goroutine的生命周期管理</strong> 与 <strong>for+select的核心机制</strong> 有了基本的了解，把问题聚焦到了耗时较长的处理函数中。</p>
<p>今天，我们再接着看看在具体工程中的优化点。</p>
<h3 id="实时处理"><a href="#实时处理" class="headerlink" title="实时处理"></a>实时处理</h3><p>我们先回顾上一讲的这段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">	<span class="keyword">go</span> LongLogic()</span><br></pre></td></tr></table></figure>

<p>直觉会认为<code>go LongLogic()</code>这里会很容易出现性能问题：当<code>dataCh</code>的数据写入速度很快时，有大量的<code>LongLogic()</code>还未结束、仍在程序内运行，导致CPU超负荷。</p>
<p>但是，如果这些代码编写的逻辑问题确实就是业务逻辑，即：<strong>程序确确实实需要实时处理这么多的数据</strong>，那我们该怎么做呢？</p>
<p>常规思路中引入 <strong>排队机制</strong> 确实是一个方案，但很容易破坏原始需求 - <strong>实时计算处理</strong>，排队机制会导致延迟，这是业务无法接收的。在现实中，扩增资源是最直观的解决方案，最常见是利用Kubernetes平台的Pod水平扩容机制HPA，保证CPU使用率到达一定程度后自动扩容，而不用在程序中加上限制。</p>
<p>从本质上来说，这个问题是对<strong>实时计算资源</strong>的需求。</p>
<h3 id="非实时处理-程序外优化"><a href="#非实时处理-程序外优化" class="headerlink" title="非实时处理 - 程序外优化"></a>非实时处理 - 程序外优化</h3><p>在实际工程中，我们其实往往对实时性要求没有那么高，所以排队等限流机制带来的延时可以接受的，也就是准实时。而综合考虑到研发代码质量的不确定性，迭代过程可能中会引入bug导致调用量暴增，这时限流机制能大幅提升程序的健壮性。</p>
<p>在程序外部，我们可以依赖消息队列进行削峰填谷，如：</p>
<ul>
<li>配置消息积压的告警来保证生产能力与消费能力的匹配</li>
<li>配置限流参数来保证不要超过消费者程序的处理极限，避免雪崩</li>
</ul>
<p>这里的消息队列在软件架构中是一个 <strong>分离生产与消费程序</strong> 的设计，有利于两侧程序的健壮性。在计算密集型的场景中，意义尤为重大，只需要针对计算密集型的消费者进行快速地扩缩容。</p>
<h3 id="非实时处理-程序内优化"><a href="#非实时处理-程序内优化" class="headerlink" title="非实时处理 - 程序内优化"></a>非实时处理 - 程序内优化</h3><p>上面消息队列方案虽然很棒，但从系统来说引入了一个新的组件，在业务体量小的场景里，有一种杀鸡用牛刀的感觉，对部分没有消息队列的团队来说成本也较高。</p>
<p>那么，我们尝试在程序中做一下优化。首先，我们在上层要做一次抽象，将逻辑收敛到一个独立的package中(示例中为logic)，方便后续优化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">			<span class="comment">// logic包内部保证</span></span><br><span class="line">			logic.Run()</span><br><span class="line">		<span class="keyword">case</span> result := &lt;-logic.Finish():</span><br><span class="line">			fmt.Println(<span class="string">&quot;result&quot;</span>, result)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而logic包中的大致框架如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> logic</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> finishedCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在这里引入排队机制</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// long time process</span></span><br><span class="line">		</span><br><span class="line">		&lt;-finishedCh</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Finish</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> finishedCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以在这里加一个<code>error</code>返回，在排队满时返回给调用方，由调用方决定怎么处理，如丢弃或重新排队等。排队机制的代码是业务场景决定的，我就不具体写了。</p>
<p>这种解法，可以类比到一个线程池管理。而更上层的for+select维度来看，类似于一个负责调度任务的master+多个负责执行任务的worker。</p>
<h3 id="Part3小结"><a href="#Part3小结" class="headerlink" title="Part3小结"></a>Part3小结</h3><p>我们分别从三个场景分析了耗时较长的处理函数：</p>
<ul>
<li><strong>实时处理</strong> - 结合Paas平台进行资源扩容</li>
<li><strong>非实时处理 - 程序外优化</strong> - 引入消息队列</li>
<li><strong>非实时处理 - 程序内优化</strong> - 实现一个线程池控制资源</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分享的内容只是Go并发编程的冰山一角，希望能对大家有所启发，也欢迎与我讨论~</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/go-leetcode/go-leetcode-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/go-leetcode/go-leetcode-11/" class="post-title-link" itemprop="url">Go算法实战 - 11.【全排列LeetCode-46】</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-21 12:00:00" itemprop="dateCreated datePublished" datetime="2022-02-21T12:00:00+08:00">2022-02-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-02-20 21:33:17" itemprop="dateModified" datetime="2022-02-20T21:33:17+08:00">2022-02-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">算法实战</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="Leetcode-46-全排列"><a href="#Leetcode-46-全排列" class="headerlink" title="Leetcode-46 全排列"></a>Leetcode-46 全排列</h2><p>原题链接 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/21/go-leetcode/go-leetcode-11/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/sharing-5min/2022-02/2022Week08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/sharing-5min/2022-02/2022Week08/" class="post-title-link" itemprop="url">五分钟技术小分享 - 2022Week08</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-21 12:00:00" itemprop="dateCreated datePublished" datetime="2022-02-21T12:00:00+08:00">2022-02-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-02-27 19:15:23" itemprop="dateModified" datetime="2022-02-27T19:15:23+08:00">2022-02-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">每日技术分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57581641299795_.pic_hd.jpg" alt="2022-02"></p>
<h2 id="2022-02-21-自顶向下地写出优雅的Goroutine（下）"><a href="#2022-02-21-自顶向下地写出优雅的Goroutine（下）" class="headerlink" title="2022-02-21 自顶向下地写出优雅的Goroutine（下）"></a>2022-02-21 自顶向下地写出优雅的Goroutine（下）</h2><p>通过前面两篇的铺垫，我们对 <strong>父子进程的生命周期管理</strong> 与 <strong>select代码的核心机制</strong> 有了基本的了解。</p>
<p>今天我们再接着看看在具体工程中的优化点。注意，在上一篇，我们已经把问题聚焦到了耗时较长的处理函数中。</p>
<h3 id="实时处理"><a href="#实时处理" class="headerlink" title="实时处理"></a>实时处理</h3><p>我们先看回顾上一讲的这段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">	<span class="keyword">go</span> LongLogic()</span><br></pre></td></tr></table></figure>

<p>简单想一下，我们会觉得<code>LongLogic()</code>这里会很容易出现性能问题：当<code>dataCh</code>的数据写入速度很快时，有大量的<code>LongLogic()</code>还未结束、仍在程序内运行，导致CPU超负荷。</p>
<p>但是，如果这些代码编写的逻辑问题确实就是业务逻辑，即：<strong>程序确确实实需要实时处理这么多的数据</strong>，那我们该怎么做呢？</p>
<p>常规思路中引入 <strong>排队机制</strong> 确实是一个方案，但很容易破坏原始需求 - <strong>实时计算处理</strong>，排队机制会导致延迟，那这就是业务无法接收的。在现实中，扩增资源是最直观的解决方案，最常见是利用Kubernetes平台的Pod水平扩容机制，保证CPU使用率到达一定程度后自动扩容，而不用在程序中加上限制。</p>
<p>这个问题的本质上是实时计算资源的需求。</p>
<h3 id="非实时处理-程序外优化"><a href="#非实时处理-程序外优化" class="headerlink" title="非实时处理 - 程序外优化"></a>非实时处理 - 程序外优化</h3><p>在实际工程中，我们其实往往对实时性要求没有那么高，所以排队等限流机制带来的延时可以接受的。而综合考虑到研发代码质量的不确定性，迭代过程可能中会引入bug导致调用量暴增，这时限流机制能提升程序的健壮性。</p>
<p>在程序外部，我们可以依赖消息队列进行削峰填谷：</p>
<ul>
<li>配置消息积压的告警来保证生产者程序的监控</li>
<li>配置限流参数来保证不要超过消费者程序的处理极限</li>
</ul>
<p>在这里，消费队列在软件架构中是一个 <strong>分离生产与消费程序</strong> 的设计，有利于两侧程序的健壮性。在计算密集型的场景中，意义尤为重大。</p>
<h3 id="非实时处理-程序内优化"><a href="#非实时处理-程序内优化" class="headerlink" title="非实时处理 - 程序内优化"></a>非实时处理 - 程序内优化</h3><p>上面消息队列方案虽然很棒，但从系统来说引入了一个新的组件，有时一种杀鸡用牛刀的感觉，对部分没有消息队列的团队来说也比较难以接受。</p>
<p>那么，我们尝试在程序中做一下优化。首先，我们在上层要做一次抽象，将逻辑收敛到一个独立的package中(示例中为logic)，方便后续优化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">			<span class="comment">// logic包内部保证</span></span><br><span class="line">			logic.Run()</span><br><span class="line">		<span class="keyword">case</span> result := &lt;-logic.Finish():</span><br><span class="line">			fmt.Println(<span class="string">&quot;result&quot;</span>, result)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而logic包中的大致框架如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> logic</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> finishedCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在这里引入排队机制</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// long time process</span></span><br><span class="line">		</span><br><span class="line">		&lt;-finishedCh</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Finish</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> finishedCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以在这里加一个<code>error</code>返回，在排队满时返回给调用方，由调用方决定怎么处理，如丢弃或重新排队等。排队机制的代码是业务场景决定的，我就不具体写了，本质上类似于一个线程池管理。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从今天，我们分别从三个场景分析了耗时较长的处理函数：</p>
<ul>
<li><strong>实时处理</strong> - 结合Paas平台进行资源扩容</li>
<li><strong>非实时处理 - 程序外优化</strong> - 引入消息队列</li>
<li><strong>非实时处理 - 程序内优化</strong> - 程序内的线程池</li>
</ul>
<p>到这里，我们自顶向下地写出优雅的Goroutine的三讲已经完成了，希望对大家有所启发，也欢迎向我提问。</p>
<h2 id="2022-02-22-CNCF-Prometheus"><a href="#2022-02-22-CNCF-Prometheus" class="headerlink" title="2022-02-22 CNCF-Prometheus"></a>2022-02-22 CNCF-Prometheus</h2><p>看完了调度管理层与应用层的项目后，我们接下来了解可观察性和分析这块。提升可观察性和分析能力，非常有助于对整套系统的掌控。</p>
<p>今天的主角是CNCF中第二个毕业的项目 - Prometheus，它提供了软件系统核心的监控功能。我们今天就从核心架构入手，了解其特性。</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/prom-architecture.png" alt="prom-architecture"></p>
<p>这张图中的内容核心分为五块：</p>
<ul>
<li>指标收集端 - Exporters + Pushgateway<ul>
<li>Exporters 长生命周期的进程，将指标保存在内存，重启后清零</li>
<li>Pushgateway 作为短生命周期指标的“中转站”</li>
</ul>
</li>
<li>服务端 - Prometheus Server</li>
<li>服务发现 - Kubernetes等<ul>
<li>对接Kubernetes平台原生兼容</li>
<li>对接非k8s平台，可以选择consul或者直接采用静态文件配置</li>
</ul>
</li>
<li>告警 - Alertmanager</li>
<li>展示 - Prometheus web UI + Grafana等<ul>
<li>web ui可以用来查看简单的指标</li>
<li>Grafana是最主流的指标展示工具，没有之一</li>
</ul>
</li>
</ul>
<blockquote>
<p>文档写得比较粗糙，欢迎大家通过这个视频链接看看更详细的说明 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1PP4y1c7ps/">https://www.bilibili.com/video/BV1PP4y1c7ps/</a></p>
</blockquote>
<h3 id="八大特性"><a href="#八大特性" class="headerlink" title="八大特性"></a>八大特性</h3><ul>
<li>多维度数据Dimensional data - Prometheus implements a highly dimensional data model. Time series are identified by a metric name and a set of key-value pairs.</li>
<li>强力的查询Powerful queries - PromQL allows slicing and dicing of collected time series data in order to generate ad-hoc graphs, tables, and alerts.</li>
<li>很棒的可视化Great visualization - Prometheus has multiple modes for visualizing data: a built-in expression browser, Grafana integration, and a console template language.</li>
<li>高效存储Efficient storage - Prometheus stores time series in memory and on local disk in an efficient custom format. Scaling is achieved by functional sharding and federation.</li>
<li>简单操作Simple operation - Each server is independent for reliability, relying only on local storage. Written in Go, all binaries are statically linked and easy to deploy.</li>
<li>精确告警Precise alerting - Alerts are defined based on Prometheus’s flexible PromQL and maintain dimensional information. An alertmanager handles notifications and silencing.</li>
<li>很多客户端库Many client libraries - Client libraries allow easy instrumentation of services. Over ten languages are supported already and custom libraries are easy to implement.</li>
<li>大量现有集成Many integrations - Existing exporters allow bridging of third-party data into Prometheus. Examples: system statistics, as well as Docker, HAProxy, StatsD, and JMX metrics.</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><code>Prometheus</code>的官方文档 - <a target="_blank" rel="noopener" href="https://prometheus.io/docs/introduction/overview/">https://prometheus.io/docs/introduction/overview/</a> 提供了很多有价值的信息，尤其是原理和最佳实践。我也曾经实践过一套企业级的<code>Prometheus</code>平台，有机会的话会和大家分享分享。</p>
<h2 id="2022-02-23-CNCF-Cortex-Thanos"><a href="#2022-02-23-CNCF-Cortex-Thanos" class="headerlink" title="2022-02-23 CNCF-Cortex/Thanos"></a>2022-02-23 CNCF-Cortex/Thanos</h2><p>今天，我将串讲两个基于Prometheus的扩展的项目：Cortex和Thanos。</p>
<p>为了让大家更好地了解到大型监控系统的方案，我将结合Prometheus自带的联邦方案和大家聊聊。</p>
<h3 id="Prometheus的联邦模式"><a href="#Prometheus的联邦模式" class="headerlink" title="Prometheus的联邦模式"></a>Prometheus的联邦模式</h3><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/prometheus-federation.png" alt="prometheus-federation"></p>
<p>联邦模式是一种树状的级联模式，核心体现出了一个点：<code>Prometheus</code>本身就是一种Exporter，可以用来采集指标。</p>
<p>关于这个架构，我们还能发现以下特点：</p>
<ol>
<li>Prometheus高可用方案，是多个上层节点重复Pull下层数据，本质上仍然是单点保存全量数据</li>
<li>Prometheus提供远程存储方案，但远程存储的能力很有限，往往只能支持异常后数据恢复</li>
<li>Prometheus提供了record rule等指标加工能力，可以减少上层的数据存储</li>
<li>可以更好地保证网络的安全性，减少防火墙的配置</li>
</ol>
<p>联邦模式基本能支持大多数Prometheus的场景，一般建议优先考虑。</p>
<h3 id="Cortex"><a href="#Cortex" class="headerlink" title="Cortex"></a>Cortex</h3><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/cortex-architecture.png" alt="cortex-architecture"></p>
<p>对标到上面的Prometheus联邦模式，Cortex核心是依赖远程写的接口。写完数据后，Cortex就与Prometheus完全没有依赖了。也就是说，Cortex是构建在Prometheus之上的一套解决方案。</p>
<p>上面的架构有很多细节上的实现，但我不想在这里聊得太细，主要考虑到：作为使用方，我们不需要过于关注Cortex的实现，毕竟它只依赖Prometheus远程写的接口，完全可以独立于Prometheus、快速迭代自身的架构。</p>
<p>所以，如果你想使用Cortex，可以看看官方的介绍文档 - <a target="_blank" rel="noopener" href="https://cortexmetrics.io/%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%E6%98%AF%E4%BD%A0%E7%89%B9%E5%88%AB%E5%85%B3%E6%B3%A8%E7%9A%84%E3%80%82">https://cortexmetrics.io/，有什么特性是你特别关注的。</a></p>
<h3 id="Thanos"><a href="#Thanos" class="headerlink" title="Thanos"></a>Thanos</h3><p>Thanos提供了两种模式<code>Sidecar</code>和<code>Receive</code>，其中后者提出的时间不长，与Cortex的实现基本一致，我们就不细看了。我们重点看看边车的实现。</p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/thanos-architecture.png" alt="thanos-architecture"></p>
<p>我们重点聚焦到Thanos和Prometheus的交互：</p>
<ol>
<li>读 - 从Thanos传到Prometheus远程读的接口，再进行数据查询</li>
<li>写 - 由于是sidecar模式，两者共享Pod里的数据，所以Prometheus写入的数据可以由Thanos直接访问</li>
</ol>
<p>从这两点来看，Thanos好像什么都没做，那它的意义在哪呢？其实，Thanos的核心是：<strong>依赖图中的对象存储，实现出的一套分布式的解决方案</strong>。</p>
<p>我们上文提到，Prometheus本质上还是一个单体的架构，而Thanos提供的分布式方案，从理论上可以解决单点计算力的问题。所以，Thanos对标Prometheus和Cortex的差异性价值，非常依赖它在分布式上的表现。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>整体来说，关于Prometheus的扩展方案，我个人的倾向如下：</p>
<ol>
<li>联邦模式：使用Prometheus的必要基础，有很多优化技巧，建议优先考虑；</li>
<li>Cortex：对现有的Prometheus侵入小，适合快速解决问题，但长期来看很受限；</li>
<li>Thanos：是对Prometheus从单体到分布式的一种改造，发展前景很棒，但遇到的问题也自然更多；</li>
</ol>
<p>今天聊的这三种方案理解起来不难，我更希望对大家在软件架构上有所启发。</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/19/go-leetcode/go-leetcode-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/19/go-leetcode/go-leetcode-10/" class="post-title-link" itemprop="url">Go算法实战 - 10.【圆环回原点问题】</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-02-19 12:00:00 / 修改时间：21:32:23" itemprop="dateCreated datePublished" datetime="2022-02-19T12:00:00+08:00">2022-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">算法实战</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p>
<h2 id="经典面试题-圆环回原点问题"><a href="#经典面试题-圆环回原点问题" class="headerlink" title="经典面试题 圆环回原点问题"></a>经典面试题 圆环回原点问题</h2><p>0-12共13个数构成一个环，从0出发，每次走1步，走n步回到0共有多少种走法？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CircleToOrigin</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/19/go-leetcode/go-leetcode-10/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/14/sharing-5min/2022-02/2022Week07/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/14/sharing-5min/2022-02/2022Week07/" class="post-title-link" itemprop="url">五分钟技术小分享 - 2022Week07</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-14 12:00:00" itemprop="dateCreated datePublished" datetime="2022-02-14T12:00:00+08:00">2022-02-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-02-18 21:50:32" itemprop="dateModified" datetime="2022-02-18T21:50:32+08:00">2022-02-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">每日技术分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57581641299795_.pic_hd.jpg" alt="2022-02"></p>
<h2 id="2022-02-14-CNCF-Argo"><a href="#2022-02-14-CNCF-Argo" class="headerlink" title="2022-02-14 CNCF-Argo"></a>2022-02-14 CNCF-Argo</h2><p><code>Argo</code>是Kubernetes上最受欢迎的工作流引擎，已经有大量的用户群体与软件生态。围绕着Workflow这个关键词，我们来一起初步了解<code>Argo</code>。</p>
<blockquote>
<p>Workflow engine for Kubernetes</p>
</blockquote>
<ul>
<li>官网 - <a target="_blank" rel="noopener" href="https://argoproj.github.io/">https://argoproj.github.io/</a></li>
<li>Github - <a target="_blank" rel="noopener" href="https://github.com/argoproj/argo-workflows">https://github.com/argoproj/argo-workflows</a></li>
</ul>
<h3 id="Argo-Workflow"><a href="#Argo-Workflow" class="headerlink" title="Argo Workflow"></a>Argo Workflow</h3><p>官方的介绍分为四点（前两点描述的是基本原理，后两者描述的是特定应用的价值）：</p>
<ol>
<li>工作流的每一个步骤都是一个容器；</li>
<li>以DAG（有向无环图）来分析工作流的依赖；</li>
<li>对计算密集型任务（如机器学习、大数据处理），能充分利用k8s集群的相对空闲的碎片时间；</li>
<li>结合CICD流水线，让应用能运行在云原生环境里快速迭代；</li>
</ol>
<h3 id="为什么使用Argo-Workflow"><a href="#为什么使用Argo-Workflow" class="headerlink" title="为什么使用Argo Workflow"></a>为什么使用Argo Workflow</h3><p><code>Argo</code>的工作流对标传统的CICD有很多亮点，但如果谈论其核心价值，主要集中在两点：</p>
<ol>
<li>保证应用的整个生命周期都基于云原生生态，彻底抛弃原来的虚拟机等模式；</li>
<li>完全对接云原生，有利于充分利用Kubernetes实现更便捷的并行、扩缩容等操作；</li>
</ol>
<p>我们就以一个经典的CICD Workflow的发展历程来看：</p>
<ol>
<li>传统Jenkins为核心的CICD<ol>
<li>提交代码到Gitlab</li>
<li>触发Jenkins编译任务，某VM服务器编译出二进制文件并发布</li>
<li>触发Jenkins部署任务，将二进制文件发布到对应机器并重新运行程序</li>
</ol>
</li>
<li>改进版 - 容器化，将Gitlab/Jenkins/编译服务器等都改造到容器化平台中</li>
<li>云原生化 - 利用Argo Workflow</li>
</ol>
<blockquote>
<p>第二与第三阶段的区分并不清晰，我个人会从 <strong>配置是否集中化</strong> 这个特点进行分析。</p>
</blockquote>
<p>目前很多大公司的CICD仍处于第二阶段，但它们沉淀出了不少类似于<code>Argo</code>工作流的能力。我们可以从以下三点进行思考：</p>
<ol>
<li><strong>工作流是和公司强相关的</strong>：往往依赖公司内的各种平台，如OA；</li>
<li><strong>工作流的开发难度不高</strong>：只要规则清晰、要求严格，整体的开发量并不大，所以有能力、有资源的大公司，并不愿意太依赖开源生态；</li>
<li><strong>云原生的工作流价值仍比较有限</strong>：<code>Argo</code>体现出的价值，有不少类似的方案可以替代；</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>Argo</code>项目的用户在社区中日趋增长，这其实体现出了一个趋势 - <strong>互联网进入精耕细作的阶段</strong>。</p>
<p>在野蛮生长阶段遇到瓶颈时，公司会趋向于用扩增大量的人力或机器资源来解决问题；而在精耕细作阶段，随着Kubenetes为代表的基础平台能力的标准化，整个生态提供了丰富的能力集，技术人员更应重视遵循规范，把时间投入到合理的方向，来快速地迭代业务。</p>
<p>这时，以<code>Argo</code>为代表的工作流引擎，能帮助整个开发体系落地自动化的规范，自然越来越受到欢迎。</p>
<h2 id="2022-02-15-谈谈对Go接口断言的误区"><a href="#2022-02-15-谈谈对Go接口断言的误区" class="headerlink" title="2022-02-15 谈谈对Go接口断言的误区"></a>2022-02-15 谈谈对Go接口断言的误区</h2><p>最近有好几个朋友和我聊到Go语言里的接口interface相关的使用方法，发现了一个常见的误区。今天，我分享一下我的思考，希望能给大家带来启发。</p>
<h3 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">interface</span> &#123;</span><br><span class="line">  Pay() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">orderImpl1</span> <span class="title">struct</span></span>&#123;</span><br><span class="line">  Id <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(order *orderImpl1)</span><span class="title">Pay</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">orderImpl2</span> <span class="title">struct</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(order *orderImpl2)</span><span class="title">Pay</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很常见的接口与实现的示例。</p>
<h3 id="接口断言背后的真正问题"><a href="#接口断言背后的真正问题" class="headerlink" title="接口断言背后的真正问题"></a>接口断言背后的真正问题</h3><p>在代码中，我们经常会对抽象进行断言，来获取更详细的信息，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 在这里是一个接口</span></span><br><span class="line">  <span class="keyword">var</span> order Order</span><br><span class="line">  <span class="comment">// 断言是orderImpl1，并打印其中内容</span></span><br><span class="line">  <span class="keyword">if</span> o,ok := order.(orderImpl1); ok &#123;</span><br><span class="line">    fmt.Println(o.Id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很清晰，让我们层层递进，思考一下这段代码背后的真正逻辑：程序要使用 <strong>接口背后的具体实现</strong>（orderImpl1中的Id字段）。</p>
<p>这种做法，就和接口所要解决的问题背道而驰了：接口是为了屏蔽具体的实现细节，而这里的代码又回退成了具体实现。所以，这个现象的真正问题是：<strong>接口抽象得不够完全</strong>。</p>
<h3 id="解法1：新增获取方法"><a href="#解法1：新增获取方法" class="headerlink" title="解法1：新增获取方法"></a>解法1：新增获取方法</h3><p>这个解法很直接，我们增加一个接口方法即可，如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Order <span class="keyword">interface</span> &#123;</span><br><span class="line">  Pay() error</span><br><span class="line">  GetId() <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果要区分具体实现，即orderImpl2没有Id字段，我们最好采用一个error字段进行区分：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Order <span class="keyword">interface</span> &#123;</span><br><span class="line">  Pay() error</span><br><span class="line">  GetId() (<span class="keyword">int64</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：封装背后的真正逻辑"><a href="#解法2：封装背后的真正逻辑" class="headerlink" title="解法2：封装背后的真正逻辑"></a>解法2：封装背后的真正逻辑</h3><p>上面<code>GetId</code>这个方法，只是一个具体动作，按DDD的说法，这是一个贫血的模型。我们真正要关注的是 - <strong>获取Id后真正的业务逻辑，将其封装成一个方法</strong>。</p>
<p>比如说，我们要获取这个Id后，想要根据这个Id取消这个订单，那么完全可以封装到一个<code>Cancel()</code>函数中；</p>
<p>又比如说，我们仅仅想要打印具体实现的内部信息，那么完全可以实现一个<code>Debug() string</code>方法，将想要的内容都拼成字符串返回出来。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>今天讲的这个case在业务开发中非常常见，它是一种惯性思维解决问题的产物。我们无需苛求所有抽象都要到位，但心里一定要有明确的解决方案。</p>
<h2 id="2022-02-16-CNCF-Flux"><a href="#2022-02-16-CNCF-Flux" class="headerlink" title="2022-02-16 CNCF-Flux"></a>2022-02-16 CNCF-Flux</h2><p>今天我们来看CNCF中另一款持续交付的项目 - <code>Flux</code>。相对于<code>Argo</code>，<code>Flux</code>的应用范围不广，但它的功能更加简洁、使用起来也更为便捷。</p>
<ul>
<li>官网 - <a target="_blank" rel="noopener" href="https://fluxcd.io/">https://fluxcd.io/</a></li>
<li>Github - <a target="_blank" rel="noopener" href="https://github.com/fluxcd/flux2">https://github.com/fluxcd/flux2</a></li>
</ul>
<h3 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h3><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/gitops-toolkit.png" alt="gitops-toolkit"></p>
<p><code>Flux</code>的核心实现非常清晰，主要分为两块：</p>
<ol>
<li>Source controller用于监听Source的变化，如常见的github、gitlab、helm；</li>
<li>将部署任务，交由Kustomize controller 或 Helm controller进行实现；</li>
</ol>
<blockquote>
<p>这里有一个秀英语单词的技巧，在软件系统里经常会将定制化这个词，Customize用Kustomize代替。</p>
</blockquote>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>官方的核心概念如下：<a target="_blank" rel="noopener" href="https://fluxcd.io/docs/concepts/">https://fluxcd.io/docs/concepts/</a></p>
<ol>
<li>GitOps的理念有很多说法，可以简单认为就是：<strong>围绕着Git而展开的一套CICD机制</strong>。</li>
</ol>
<blockquote>
<p>GitOps is a way of managing your infrastructure and applications so that whole system is described declaratively and version controlled (most likely in a Git repository), and having an automated process that ensures that the deployed environment matches the state specified in a repository.</p>
</blockquote>
<ol start="2">
<li>Source源，包括期望状态与获取的途径。</li>
</ol>
<blockquote>
<p>A <em>Source</em> defines the origin of a repository containing the desired state of the system and the requirements to obtain it (e.g. credentials, version selectors). </p>
</blockquote>
<ol start="3">
<li>Reconciliation协调，重点是怎么协调、也就是Controller执行的逻辑，最常见的就是自己编写一个Operator。</li>
</ol>
<blockquote>
<p>Reconciliation refers to ensuring that a given state (e.g. application running in the cluster, infrastructure) matches a desired state declaratively defined somewhere (e.g. a Git repository).</p>
</blockquote>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>CICD相关软件目前的格局还不是很清晰，建议大家多花时间在选型上，尽可能地符合自己的业务场景，而不建议做过多的二次开发。<code>Flux</code>是一个非常轻量级的CD项目，对接起来很方便，很适合无历史包袱的研发团队快速落地。</p>
<h2 id="2022-02-17-自顶向下地写出优雅的Goroutine（上）"><a href="#2022-02-17-自顶向下地写出优雅的Goroutine（上）" class="headerlink" title="2022-02-17 自顶向下地写出优雅的Goroutine（上）"></a>2022-02-17 自顶向下地写出优雅的Goroutine（上）</h2><p><code>Go</code>语言的Goroutine特性广受好评，让初学者也能快速地实现并发。但随着不断地学习与深入，有很多开发者都陷入了对<code>goroutine</code>、<code>channel</code>、<code>context</code>、<code>select</code>等并发机制的迷惑中。</p>
<p>那么，我将自顶向下地介绍这部分的知识，帮助大家形成体系。具体的代码以下面这段为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> SubFoo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>Foo()</code>为<strong>父Goroutine</strong>，内部开启了一个<strong>子Goroutine</strong> - <code>SubFoo()</code>。</p>
<h3 id="聚焦核心"><a href="#聚焦核心" class="headerlink" title="聚焦核心"></a>聚焦核心</h3><p><strong>父Goroutine</strong> 与 <strong>子Goroutine</strong> 最重要的交集 - 是两者的生命周期管理。包括三种：</p>
<ol>
<li>互不影响 - 两者完全独立</li>
<li>parent控制children - 父Goroutine结束时，子Goroutine也能随即结束</li>
<li>children控制parent - 子Goroutine结束时，父Goroutine也能随即结束</li>
</ol>
<p>这个生命周期的关系，体现了一种控制流的思想。</p>
<blockquote>
<p>注意，这个时候不要去关注具体的数据或代码实现，初学者容易绕晕。</p>
</blockquote>
<h3 id="1-互不影响"><a href="#1-互不影响" class="headerlink" title="1-互不影响"></a>1-互不影响</h3><p>两个Goroutine互不影响的代码很简单，如同示例。</p>
<p>不过我们要注意一点，如果子goroutine需要context这个入参，尽量新建。这点我们看第二个例子就清楚了。</p>
<h3 id="2-parent控制children"><a href="#2-parent控制children" class="headerlink" title="2-parent控制children"></a>2-parent控制children</h3><p>下面是一个最常见的用法，也就是利用了context：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="comment">// 退出前执行，表示parent执行完了</span></span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> SubFoo(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		<span class="comment">// parent完成后，就退出</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，context并不是唯一的解法，我们也可以自建一个channel用来通知关闭。但综合考虑整个Go语言的生态，更建议大家尽可能地使用context，这里不扩散了。</p>
<blockquote>
<p>延伸 - 如果1个parent要终止多个children时，context的这种方式依然适用。</p>
</blockquote>
<h3 id="3-children控制parent"><a href="#3-children控制parent" class="headerlink" title="3-children控制parent"></a>3-children控制parent</h3><p>这部分的逻辑也比较直观：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> SubFoo(ch)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 获取通知并退出</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ch:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 通知parent的channel</span></span><br><span class="line">	ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="情况3的延伸"><a href="#情况3的延伸" class="headerlink" title="情况3的延伸"></a>情况3的延伸</h3><p>如果1个parent产生了n个children时，又会有以下两种情况：</p>
<ol>
<li>n个children都结束了，才停止parent</li>
<li>n个children中有m个结束，就停止parent</li>
</ol>
<p>其中，前者的最常用的解决方案如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg = <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line">	wg.Add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> SubFoo(wg)</span><br><span class="line">	<span class="keyword">go</span> SubFoo(wg)</span><br><span class="line">	<span class="keyword">go</span> SubFoo(wg)</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这两个延伸情况更多的解法，就留给大家自己去思考了，它们有不止一种解法。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>从生命周期入手，我们能快速地形成代码的基本结构：</p>
<ol>
<li>互不影响 - 注意context独立</li>
<li>parent控制children - 优先用context控制</li>
<li>children控制parent - 一对一时用channel，一对多时用sync.WaitGroup等</li>
</ol>
<p>但在实际的开发场景中，parent和children的处理逻辑会有很多复杂的情况，导致我们很难像示例那样写出优雅的<code>select</code>等方法，我们会在下期继续分析，但不会影响我们今天梳理出的框架。</p>
<h2 id="2022-02-18-自顶向下地写出优雅的Goroutine（中）"><a href="#2022-02-18-自顶向下地写出优雅的Goroutine（中）" class="headerlink" title="2022-02-18 自顶向下地写出优雅的Goroutine（中）"></a>2022-02-18 自顶向下地写出优雅的Goroutine（中）</h2><p>通过上一篇，我们通过生命周期管理了解了父子进程的大致模型。</p>
<p>今天，我们将更进一步，分析优雅的Goroutine的核心语法 - select。</p>
<h3 id="了解select的核心意义"><a href="#了解select的核心意义" class="headerlink" title="了解select的核心意义"></a>了解select的核心意义</h3><p>我们看一个官方的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> c &lt;- x:</span><br><span class="line">			x, y = y, x+y</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			fmt.Println(&lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">		quit &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line">	fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很长，我们聚焦于select这块，它实现了两个功能：</p>
<ol>
<li>传递数据</li>
<li>传递停止的信号</li>
</ol>
<p>这时，如果你深入去理解这两个channel的用法，容易陷入对select理解的误区；而我们应该从更高的维度，去看这两个case中获取到数据后的操作，才能真正掌握。</p>
<h3 id="分析select中的case"><a href="#分析select中的case" class="headerlink" title="分析select中的case"></a>分析select中的case</h3><p>我们要注意到，在case里代码运行的过程中，整个goroutine都是忙碌的（除非调用panic，return，os.Exit()等函数退出）。</p>
<p>以上面的代码为例，如果<code>x, y = y, x+y</code>函数的处理耗时，远大于<code>x</code>这个通道中塞入数据的速度，那么这个<code>x</code>的写入处，将长期处于排队的阻塞状态。这时，不适合采用select这种模式。</p>
<p>所以说，<strong>select适合IO密集型逻辑，而不适合计算密集型</strong>。也就是说，select中的每个case，应尽量花费少的时间。IO密集型常指文件、网络等操作，它消耗的CPU很少、更多的时间在等待返回。</p>
<blockquote>
<p>Go 的 select这个关键词，可以结合网络模型中的select进行理解。</p>
</blockquote>
<h3 id="父子进程中的长逻辑处理"><a href="#父子进程中的长逻辑处理" class="headerlink" title="父子进程中的长逻辑处理"></a>父子进程中的长逻辑处理</h3><p>这时，如果我们的父子进程里，就是有那么一长段的业务逻辑，那代码该怎么写呢？我们来看看下面这一段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">			LongLogic()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LongLogic</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如1累加到10000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>LongLogic()</code>会花费很长的运行时间，所以当外部的context取消了，也就是父Goroutine发出通知可以结束了，这个子Goroutine是无法快速触发到<code>&lt;-ctx.Done()</code>的，因为它还在跑<code>LongLogic()</code>里的代码。也就是说，子进程生命周期结束的时间点延长到<code>LongLogic()</code>之后了。</p>
<p>所以，根本原因在于违背了我们上面说的原则，即在select的case/default里包含了计算密集型任务。</p>
<blockquote>
<p>case里包含长逻辑不代表程序一定有问题，但或多或少地不符合select+channel的设计理念。</p>
</blockquote>
<h3 id="两个长逻辑处理"><a href="#两个长逻辑处理" class="headerlink" title="两个长逻辑处理"></a>两个长逻辑处理</h3><p>这时，我们再来写个长进程处理，整个代码结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">			LongLogic()</span><br><span class="line">		<span class="keyword">case</span> &lt;-dataCh2:</span><br><span class="line">			LongLogic()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，dataCh和dataCh2会产生竞争，也就是两个通道的 <strong>写长期阻塞、读都在等待LongLogic执行完成</strong>。给channel加个buffer可以减轻这个问题，但无法根治，运行一段时间依旧阻塞。</p>
<h3 id="改造思路"><a href="#改造思路" class="headerlink" title="改造思路"></a>改造思路</h3><p>有了上面代码的基础，改造思路比较直观了，将<code>LongLogic</code>异步化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// children goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubFoo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-dataCh:</span><br><span class="line">			<span class="keyword">go</span> LongLogic()</span><br><span class="line">		<span class="keyword">case</span> &lt;-finishedCh:</span><br><span class="line">			fmt.Println(<span class="string">&quot;LongLogic finished&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LongLogic</span><span class="params">()</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Minute)</span><br><span class="line">	finishedCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要注意一个点，如果<code>LongLogic()</code>是一段需要CPU密集计算的代码，比如计算1累加到10000，它是没有办法通过channel等其余方式突然中止的。它具备一定的原子性 - <strong>要么不跑，要么跑完，没有Channel的插手的地方</strong>。</p>
<p>而如果硬要中断<code>LongLogic()</code>，那就是杀掉整个进程。</p>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>今天的内容是围绕着select这个关键词展开的，我们记住select代码块设计的核心要领 - IO密集型。Go语言的goroutine特性，更多地是为了解决IO密集型程序的问题所设计的编程语言，对计算密集型的任务较其它语言很难体现出其价值。</p>
<p>落到具体实践上，就是让每个case中代码的运行时间尽可能地短，快速回到for循环里的select去继续监听各个case中的channel。</p>
<p>上面这段代码比较粗糙，在具体工程中会遇到很多问题，比如无脑地开启了大量的<code>LongLogic()</code>协程。我们会放在最后一讲再来细谈。</p>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/07/sharing-5min/2022-02/2022Week06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/07/sharing-5min/2022-02/2022Week06/" class="post-title-link" itemprop="url">五分钟技术小分享 - 2022Week06</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-07 12:00:00" itemprop="dateCreated datePublished" datetime="2022-02-07T12:00:00+08:00">2022-02-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-02-13 13:34:40" itemprop="dateModified" datetime="2022-02-13T13:34:40+08:00">2022-02-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">每日技术分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57581641299795_.pic_hd.jpg" alt="2022-02"></p>
<h2 id="2022-02-07-CNCF-CloudEvents"><a href="#2022-02-07-CNCF-CloudEvents" class="headerlink" title="2022-02-07 CNCF-CloudEvents"></a>2022-02-07 CNCF-CloudEvents</h2><p>今天，我们一起来看<code>CloudEvents</code>，并不是一款成熟的软件系统，而更像是一种协议与标准。不过，它提出的相关概念，对我们开发与设计软件系统时，很有参考意义。</p>
<ul>
<li>官网 - <a target="_blank" rel="noopener" href="https://cloudevents.io/">https://cloudevents.io/</a> </li>
<li>Github - <a target="_blank" rel="noopener" href="https://github.com/cloudevents/spec">https://github.com/cloudevents/spec</a></li>
</ul>
<h3 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h3><blockquote>
<p>CloudEvents is a vendor-neutral specification for defining the format of event data.</p>
</blockquote>
<p>顾名思义，<code>CloudEvents</code>项目旨在定义 <strong>云时代的事件</strong>。事件是一个很广的定义，在不同的软件系统里有不同的表现形式。</p>
<p>想要将所有软件系统里的事件进行标准化，这里面的工作量与难度可想而知，在很长一段时间内很难落地。在我看来，这个项目的意义是长期的 - <strong>先提供一套切实可行的标准与SDK，再尝试结合云原生生态的在核心项目中落地，最后再大规模推广</strong>。</p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>事件里涉及到了很多概念，我选择其中的核心概念，并将其分成了两类。</p>
<blockquote>
<p> 完整的内容可以参考： <a target="_blank" rel="noopener" href="https://github.com/cloudevents/spec/blob/v1.0.1/spec.md#notations-and-terminology">https://github.com/cloudevents/spec/blob/v1.0.1/spec.md#notations-and-terminology</a> </p>
</blockquote>
<p>数据类：</p>
<ol>
<li>Occurrence - 发生（客观事实）</li>
<li>Data - 数据</li>
<li>Context - 上下文</li>
<li>Event - 事件</li>
</ol>
<p>传输类：</p>
<ol>
<li>Producer - 生产者</li>
<li>Intermediary - 中介</li>
<li>Consumer - 消费者</li>
<li>Event Format - 事件格式</li>
<li>Message - 消息</li>
<li>Protocol - 协议</li>
</ol>
<h3 id="关键字段"><a href="#关键字段" class="headerlink" title="关键字段"></a>关键字段</h3><p><code>CloudEvents</code>给出了规范的同时，也给出了多语言的SDK。我们可以参考它的命名方式，引入到自己的开发系统中。</p>
<p>必填字段：</p>
<ol>
<li>id - string</li>
<li>source - URI-reference</li>
<li>specversion - string</li>
<li>type - string</li>
</ol>
<blockquote>
<p>保证 id+source 全局唯一</p>
</blockquote>
<p>可选字段：</p>
<ol>
<li>datacontenttype - string</li>
<li>dataschema - string</li>
<li>subject -string</li>
<li>time - timestamp，推荐RFC-3339</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>CloudEvents</code> 目前仍处于非常早期的阶段，有兴趣的朋友，可以尝试引入其SDK，将内部的RPC、MQ等通信数据统一起来。</p>
<p>从长期来看，将一个系统中的事件格式统一起来，对整个系统的帮助是很大的。比如说，我们完全可以将服务注册、服务发现等功能认为是一种事件，要求<code>Etcd</code>、<code>Zookeeper</code>、<code>Consul</code>等均支持该方式，就能有利于相关功能的标准化。</p>
<h2 id="2022-02-08-CNCF-NATS"><a href="#2022-02-08-CNCF-NATS" class="headerlink" title="2022-02-08 CNCF-NATS"></a>2022-02-08 CNCF-NATS</h2><p>作为CNCF中消息系统的核心项目，<code>NATS</code>受到了各大公司的青睐，近年来使用量也在逐步提升。有不少同学对消息系统的认识还比较模糊，今天我们就借<code>NATS</code>的核心模型，对消息系统有进一步的认识。</p>
<p>官网 - <a target="_blank" rel="noopener" href="https://nats.io/">https://nats.io/</a></p>
<p>Github - <a target="_blank" rel="noopener" href="https://github.com/nats-io/nats-server">https://github.com/nats-io/nats-server</a></p>
<h3 id="三种消息传递模型"><a href="#三种消息传递模型" class="headerlink" title="三种消息传递模型"></a>三种消息传递模型</h3><p><strong>发布-订阅模式</strong>：类似于广播模式</p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/publish-subscribe.png" alt="publish-subscribe"></p>
<p><strong>请求-响应模式</strong>：对应关系可自行调整，请求者必须等待到响应才认为是成功</p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/request-reply.png" alt="request-reply"></p>
<p><strong>队列-订阅模式</strong>：分布式系统中非常重要的消息队列功能，实现消息分发</p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/queue-groups.png" alt="queue-groups"></p>
<h3 id="分布式系统中的消息系统"><a href="#分布式系统中的消息系统" class="headerlink" title="分布式系统中的消息系统"></a>分布式系统中的消息系统</h3><p>了解上面三种消息传递模型后，你可能仍不清楚它们的适用场景。我建议大家深入地了解这三种模型的本质，这样更方便记忆与理解。其实，在分布式系统中，最核心的是 <strong>队列-订阅</strong> 模式，其余两种模式意义并不大。</p>
<ol>
<li><strong>发布订阅</strong> 只是 <strong>队列订阅</strong> 的一种特殊的广播模式；</li>
<li><strong>请求响应</strong> 更多地应结合服务发现能力，在RPC框架中进行实现；</li>
</ol>
<blockquote>
<p>第一点的使用场景不多见，举个例子：</p>
<p>服务2有多个实例，本地内存里保存了一些信息；现在服务1要更新所有服务2中内存的信息，就需要采用发布-订阅模式，否则会导致服务间数据不一致。</p>
<p>如果服务2引入了分布式缓存，那就是队列-订阅模式。</p>
</blockquote>
<p>那么，<strong>队列-订阅模式</strong> 对分布式系统来说有什么意义呢？这其实就是消息队列的价值，我这里列举最关键的两点：</p>
<ol>
<li>削峰填谷：针对分布式系统中的性能问题，通过队列的形式，将高峰期的msg积压到Queue中，在低峰期时交给消费者处理。</li>
<li>解耦强依赖：从调用关系可以看到，其实Publisher是要将信息传递给Subscriber；但增加了Queue后，Publisher只与Queue交互，Subscriber也只与Queue交互。可以想象，即便Subscriber短暂地挂了，重启后依旧可以正常使用。</li>
</ol>
<p>分布式的消息队列还有很多注意点，这里我就不一一列举了，更多的资料大家可以自行搜索。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>虽然从生产环境的应用范围来看，<code>NATS</code>仍与老牌的重量级消息队列Kafka有相当大的差距，尤其是在大数据的系统中。但对比RocketMQ、RabbitMQ等轻量级产品，<code>NATS</code>的优势已经越来越明显，尤其是在性能与多语言的SDK上，建议有条件的朋友可以尝试使用。</p>
<h2 id="2022-02-09-CNCF-Helm"><a href="#2022-02-09-CNCF-Helm" class="headerlink" title="2022-02-09 CNCF-Helm"></a>2022-02-09 CNCF-Helm</h2><p><code>Helm</code>在整个云原生平台中扮演了重要角色。值得注意的是，<code>Helm</code>自身的复杂度并不高，它更多依赖的是优秀的设计理念与当前包含大量软件的生态。</p>
<p>官方的定义很简洁，即Kubernetes中的包管理者，即一个公共的软件仓。</p>
<blockquote>
<p>The Kubernetes Package Manager</p>
</blockquote>
<ul>
<li>官网 - <a target="_blank" rel="noopener" href="https://helm.sh/">https://helm.sh/</a></li>
<li>Github - <a target="_blank" rel="noopener" href="https://github.com/helm/helm">https://github.com/helm/helm</a></li>
<li>仓库 - <a target="_blank" rel="noopener" href="https://artifacthub.io/packages">https://artifacthub.io/packages</a></li>
</ul>
<h3 id="使用Helm"><a href="#使用Helm" class="headerlink" title="使用Helm"></a>使用Helm</h3><p>类似于Dockerhub，<code>Helm</code>的一大特色就是使用起来非常简单，可快速地在Kubernetes环境中安装软件。</p>
<p>以Kubernetes中的证书管理为例，我们可以参考链接 - <a target="_blank" rel="noopener" href="https://artifacthub.io/packages/helm/cert-manager/cert-manager">https://artifacthub.io/packages/helm/cert-manager/cert-manager</a> ，可以快速地通过几个命令就能完成下载与部署。</p>
<p>我希望大家能注意到：<strong>低门槛是吸引用户的重要因素，但真正决定软件长期走向的，是它自身的核心功能</strong>。所以，<code>Helm</code>中的软件有三点需要特别关注：</p>
<ol>
<li>契合Kubernetes平台：许多软件原生并不支持Kubernetes，需要做一定的改造；</li>
<li>保证常规功能：如安装时要判断依赖项、卸载时清理哪些数据、升降版本兼容性等等，都是很琐碎、又是很重要的事情；</li>
<li>人工维护问题：软件是高频迭代的，尤其是在云原生环境下，核心项目往往要大量的人力投入到 FAQ、配置参数说明、兼容性问题的处理；</li>
</ol>
<p>这三点给<code>Helm</code>带来的是一种滚雪球效应，即越滚越大、越难以被替代；而这种雪球最终能支撑多大的市场，非常依赖<code>Helm</code>内部的核心设计，尤其是扩展性部分。</p>
<h3 id="Charts"><a href="#Charts" class="headerlink" title="Charts"></a>Charts</h3><p><code>Helm</code>称自己是Kubernetes平台中的包管理器，而这个包的格式被称为Charts，我们一起来看看一个官方示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wordpress/</span><br><span class="line">  Chart.yaml          # A YAML file containing information about the chart</span><br><span class="line">  LICENSE             # OPTIONAL: A plain text file containing the license for the chart</span><br><span class="line">  README.md           # OPTIONAL: A human-readable README file</span><br><span class="line">  values.yaml         # The default configuration values for this chart</span><br><span class="line">  values.schema.json  # OPTIONAL: A JSON Schema for imposing a structure on the values.yaml file</span><br><span class="line">  charts/             # A directory containing any charts upon which this chart depends.</span><br><span class="line">  crds/               # Custom Resource Definitions</span><br><span class="line">  templates/          # A directory of templates that, when combined with values,</span><br><span class="line">                      # will generate valid Kubernetes manifest files.</span><br><span class="line">  templates/NOTES.txt # OPTIONAL: A plain text file containing short usage notes</span><br></pre></td></tr></table></figure>

<p>关键在于三个目录：</p>
<ol>
<li>charts - 保存当前chart的依赖子chart</li>
<li>crds - 这是chart依赖Kubernetes实现软件运行的关键（CRD是k8s可扩展性的一大特色）</li>
<li>templates - 用来绑定chart自定义参数</li>
</ol>
<p>换一个视角，这三个文件夹体现了三种能力：</p>
<ol>
<li>charts - package能力复用</li>
<li>crds - 自定义对接Paas平台（k8s）</li>
<li>templates - 定制化参数</li>
</ol>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><code>Helm</code>是Kubernetes使用人员需要非常重视的一个产品，它能快速地帮助我们安装与部署软件。</p>
<p>不过，我不建议大家去阅读它的相关源码，它的代码并不优秀；相反地，我更建议大家可以去尝试自己做一个chart（最好能结合自己开发的程序+依赖的中间件，如go程序+redis），这样既能结合<code>Helm</code>实现应用程序的快速部署，又能去实践Kubernetes的CRD。</p>
<h2 id="2022-02-10-CNCF-Buildpacks"><a href="#2022-02-10-CNCF-Buildpacks" class="headerlink" title="2022-02-10 CNCF-Buildpacks"></a>2022-02-10 CNCF-Buildpacks</h2><p><code>Buildpacks</code>是一款对标<code>Docker</code>的镜像打包工具，虽然在CNCF中作为核心项目，但在目前的主流开发场景中用到的并不多。</p>
<ul>
<li>官网 - <a target="_blank" rel="noopener" href="https://buildpacks.io/">https://buildpacks.io/</a></li>
<li>Github - <a target="_blank" rel="noopener" href="https://github.com/buildpacks/pack">https://github.com/buildpacks/pack</a></li>
</ul>
<p>我们不妨来思考一下<code>Buildpacks</code>与竞品的核心优势：</p>
<p><code>Buildpacks</code>官网介绍自身的核心特性为3个：<code>Control</code>、<code>Compliance</code>和<code>Maintainability</code>。我们今天挑选两个关键性的特征来聊一聊。</p>
<h3 id="Control-Balanced-control-between-App-Devs-and-Operators"><a href="#Control-Balanced-control-between-App-Devs-and-Operators" class="headerlink" title="Control - Balanced control between App Devs and Operators."></a>Control - Balanced control between App Devs and Operators.</h3><p>平衡开发者与运维人员。这个也是<code>Buildpacks</code>对标<code>Docker</code>的最大优势。</p>
<p>刚熟悉Dockerfile的同学，会觉得体验很棒，只需要少数几行就能快速制作出一个镜像；但是，如果你是重度使用的用户，就会有不一样的体验：</p>
<ol>
<li>多应用的Dockerfile中有大量重复、但又有少量定制化的内容（如依赖的软件）</li>
<li>由于定制化的内容存在，往往需要开发工程师编写Dockerfile</li>
</ol>
<p>所以，维护Dockerfile成为了开发工程师很琐碎的工作，而<code>Buildpacks</code>则是希望将部分工作转移给运维人员。但在我看来，这个收益并不明显：</p>
<ol>
<li>现状：大部分的公司会封装一些基础镜像，在基础镜像上的Dockerfile所需要的命令已经很少了，整体的复杂度不会很高；</li>
<li>工作平衡：平衡的意义并没有减少整体的工作量，两种角色的人数总量仍不会有大的变化；</li>
<li>责任明确：目前大型公司的运维人员越来越少，更强调的是开发人员自己管理应用的整个生命周期；</li>
</ol>
<p>但换一个角度，<code>Buildpacks</code>理念是可以降低开发人员对Dockerfile这块的门槛，更专注于业务代码的开发。但是，编写Dockerfile这项技能本身难度不高，而且有利于研发自行排查问题，我个人是非常建议开发人员去学习的。</p>
<h3 id="Maintainability-Perform-upgrades-with-minimal-effort-and-intervention"><a href="#Maintainability-Perform-upgrades-with-minimal-effort-and-intervention" class="headerlink" title="Maintainability - Perform upgrades with minimal effort and intervention."></a>Maintainability - Perform upgrades with minimal effort and intervention.</h3><p>这一点是<code>Buildpacks</code>的一大特色。</p>
<p>如果你对Docker的镜像底层有一定的了解，会清楚一个镜像就是一层层layer的堆叠；从最上层来看，就是一个完整的操作系统。但如果只对某个layer进行更改，就得销毁老容器、再起一个新的。而<code>Buildpacks</code>则提供了rebase的能力，也就是在运行中的容器中做到快速替换某个layer，而不需要整个重建。</p>
<p>举一个例子，当前运行的容器有层layer是设置环境变量（参考Dockerfile中的ENV指令），我们要进行增加或者更改参数，就能快速实现rebase。当然，rebase肯定是有不少限制条件的，尤其是rebase中的内容不能影响到程序的运行。</p>
<p>我们不妨发散地思考这个特性的价值：由于它核心解决了无需重启整个容器的作用，所以对启动成本比较大的程序，它的意义是很大的，尤其是Java程序。</p>
<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p><code>Buildpacks</code>在社区中活跃度并不高，这也间接证明了<code>Docker</code>的统治地位，而它则需要一个合适的契机才可能得到大幅度的应用。这也提醒了我们，不要一味地追求新的技术，更应该结合现状理性分析。</p>
<h2 id="2022-02-11-CNCF-Operator-Framework"><a href="#2022-02-11-CNCF-Operator-Framework" class="headerlink" title="2022-02-11 CNCF-Operator Framework"></a>2022-02-11 CNCF-Operator Framework</h2><p><code>Operator Framework</code>是为了降低Kubernetes中Operator开发门槛，而由CNCF社区提供的一套框架。由于这一整套的解决方案门槛很高，需要使用者对Kubernetes的原理有相当的基础，所以今天我们不会深入其细节，而是通过借由这个项目更好地理解Kubernetes。</p>
<ul>
<li>官网 - <a target="_blank" rel="noopener" href="https://cloud.redhat.com/learn/topics/operators">https://cloud.redhat.com/learn/topics/operators</a></li>
<li>Github - <a target="_blank" rel="noopener" href="https://github.com/operator-framework/operator-sdk">https://github.com/operator-framework/operator-sdk</a></li>
<li>公开库 - <a target="_blank" rel="noopener" href="https://operatorhub.io/">https://operatorhub.io/</a></li>
</ul>
<h3 id="Controller的工作原理"><a href="#Controller的工作原理" class="headerlink" title="Controller的工作原理"></a>Controller的工作原理</h3><p><strong>Operator本质上，是一种定制化的Controller；而控制器的核心思想，是根据期望状态与当前状态，管理k8s中的资源。</strong>我们这边可以结合下面这张图，来了解Controller的工作原理。</p>
<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/k8s-controller.png" alt="k8s-controller"></p>
<ol>
<li>client-go是k8s提供的代码生成工具，相关的代码会自动生成；而controller-specific是自行开发的内容；</li>
<li>期望状态与当前状态的对比逻辑，决策的结果是 新增、更新、删除对应的资源，触发对应的callbacks；</li>
<li>具体的执行工作，交给Worker执行，而结果如果未达到预期，依然会再次触发整个流程；</li>
</ol>
<blockquote>
<p>关于k8s中的controller，源码分析可以参考我之前的一篇博客 <a target="_blank" rel="noopener" href="https://junedayday.github.io/2021/02/18/k8s/k8s-012/">https://junedayday.github.io/2021/02/18/k8s/k8s-012/</a> </p>
</blockquote>
<h3 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h3><ol>
<li>Operator SDK - 快速生成Operator相关代码</li>
<li>Operator Lifecycle Manager - k8s中的生命周期管理</li>
<li>Operator Metering - 监控</li>
</ol>
<p>其中监控部分很重要，能帮助使用人员在复杂的K8s系统中排查问题。</p>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>目前<code>Operator Framework</code>虽然在社区比较受欢迎，但使用者往往仅限于k8s的深度用户；而许多大型公司又往往会自行封装k8s，不能完美兼容<code>Operator Framework</code>，导致它的推广很受限。</p>
<p>我个人有三点建议：</p>
<ol>
<li>优先去Helm里搜索成熟应用，不要自行开发Operator；</li>
<li>如果有切实的使用需求，优先去公开库 - <a target="_blank" rel="noopener" href="https://operatorhub.io/">https://operatorhub.io/</a> 搜索；</li>
<li>k8s深度玩家可忽略以上两点~</li>
</ol>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/02/go-tip/go-tip-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/02/go-tip/go-tip-14/" class="post-title-link" itemprop="url">Go语言技巧 - 14.【浅析微服务框架】go-zero概览</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-02-02 12:00:00 / 修改时间：21:59:21" itemprop="dateCreated datePublished" datetime="2022-02-02T12:00:00+08:00">2022-02-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="go-zero概况"><a href="#go-zero概况" class="headerlink" title="go-zero概况"></a>go-zero概况</h2><p><code>go-zero</code>是当前处于CNCF孵化中的一个<code>Go</code>z语言框架项目，在Github上的star数目前达到14.3K。</p>
<p>作为一款起源于国内的项目，<code>go-zero</code>的中文资料比较齐全，对国内开发者相对友好。但前景如何，还需要进一步的观察。今天我们一起来了解这个项目。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/02/go-tip/go-tip-14/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/24/sharing-5min/2022-01/2022Week04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/sharing-5min/2022-01/2022Week04/" class="post-title-link" itemprop="url">五分钟技术小分享 - 2022Week04</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-24 12:00:00" itemprop="dateCreated datePublished" datetime="2022-01-24T12:00:00+08:00">2022-01-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-01-29 12:40:40" itemprop="dateModified" datetime="2022-01-29T12:40:40+08:00">2022-01-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">每日技术分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg" alt="2022-01"></p>
<h2 id="2022-01-24-CNCF-Linkerd"><a href="#2022-01-24-CNCF-Linkerd" class="headerlink" title="2022-01-24 CNCF-Linkerd"></a>2022-01-24 CNCF-Linkerd</h2><p>今天我们来看 <strong>Orchestration &amp; Management 编排和管理</strong> 层最后一个核心项目 - Linkerd。从严格意义上来说，我们应称它为Linkerd2，区别于原来的1.0版本。</p>
<blockquote>
<p>Linkerd是Service Mesh的第一个产品，但在Google的Istio入场后在功能与性能上完全超越。这一段的历史很有意思，大家可以自行搜索了解。</p>
</blockquote>
<p>关于Service Mesh，我们已经聊过两款CNCF中的软件了 - Envoy/Contour，这个Linkerd是两者的结合。我们来看一下它的架构示意图，整体来说分为三块：</p>
<img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/control-plane.png" alt="Linkerd2" style="zoom:50%;" />

<ol>
<li>CLI - 客户端，对Linkerd2进行管理</li>
<li>Control Plane 控制平面<ol>
<li>destination 获取各类信息，如服务发现、网络策略、性能和监控指标</li>
<li>indentity 主要是TLS安全相关</li>
<li>proxy-injector 是一种Kubernetes的Admission Controller，用于对初始化pod注入linkerd相关的信息</li>
</ol>
</li>
<li>Data Plane 数据平面<ol>
<li>linkerd-proxy 核心的功能实现，包括代理、路由、TLS、限流等等</li>
<li>linkerd-init 是一种Kubernetes的Init Containter，用iptables的特性将Pod的流量都导向linkerd-proxy</li>
</ol>
</li>
</ol>
<p>Linkerd的架构非常清晰明了，与Kubernetes的特性紧密结合。我们也不难看到，它的核心能力非常依赖linkerd-proxy这个组件。linkerd-proxy采用了Rust语言编写，而对应的Envoy使用的是C++，从性能来看两者相差无几，更多的是语言生态上的选择不同。</p>
<p>我们再一起读一段<a target="_blank" rel="noopener" href="https://linkerd.io/what-is-a-service-mesh/">Linkerd官方对Service Mesh的定义</a>：</p>
<blockquote>
<p>A service mesh like Linkerd is a tools for adding observability, security, and reliability features to “cloud native” applications by transparently inserting this functionality at the platform layer rather than the application layer.</p>
</blockquote>
<ul>
<li><p>observability - 可观察性：logging、metrics、tracing</p>
</li>
<li><p>security - 安全性：TLS等特性</p>
</li>
<li><p>reliability - 可靠性：体现在对网络层的统一管理</p>
</li>
</ul>
<p>从目前来看，Linkerd仍处于一个比较早期的阶段，对标Istio还有大量的功能缺失，我在短期内不太看好。不过它引入了Rust语言有可能吸引一批优秀的人才，成为突破口。</p>
<h2 id="2022-01-25-Go1-18的两个教程"><a href="#2022-01-25-Go1-18的两个教程" class="headerlink" title="2022-01-25 Go1.18的两个教程"></a>2022-01-25 Go1.18的两个教程</h2><p>在1月初，我们已经一起看了Go官方对1.18的新特性讲解，想回顾的朋友可以点击这个链接：<a target="_blank" rel="noopener" href="https://junedayday.github.io/2022/01/04/sharing-5min/2022-01/2022Week01/#2022-01-04-Go1-18%E6%A6%82%E8%A7%88">Go1.18概览</a>。前几天，官方又发布了对泛型和Fuzzing的两个教程，我们再一起浏览下，查漏补缺。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://go.dev/doc/tutorial/generics">Tutorial: Getting started with generics</a></li>
<li><a target="_blank" rel="noopener" href="https://go.dev/doc/tutorial/fuzz">Tutorial: Getting started with fuzzing</a></li>
</ul>
<h3 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumIntsOrFloats</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">int64</span> | <span class="title">float64</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span> <span class="title">V</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s V</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        s += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>comparable 是个关键词，指的是支持操作符<code>==</code> 和 <code>!=</code></li>
<li>int64 | float64 则用简洁的语法表示了两种支持的类型</li>
</ul>
<p>但第二点，如果支持的类型太多，就需要做一次抽象，如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Number <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int64</span> | <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumNumbers</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">Number</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span> <span class="title">V</span></span> &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言的泛型表示方法非常简单，其支持的能力也很有限。相对于C++与JAVA中的泛型，无疑逊色了很多。我们可以简单地归纳Go泛型的使用场景：用于 <strong>基础类型</strong> 的通用操作，如int/int32/int64/float64等这种重复性很高的基本运算。</p>
<p>作为一种标准，Go的泛型落地非常坎坷，短期内官方也不太可能在这块扩增新的特性，所以Go的泛型适用性会比较窄。</p>
<p>随着1.18的完全落地，我们可以在很多基础库中看到泛型的实践，到时候我们再可以根据具体case进行了解。</p>
<h3 id="Fuzzing"><a href="#Fuzzing" class="headerlink" title="Fuzzing"></a>Fuzzing</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuzzReverse</span><span class="params">(f *testing.F)</span></span> &#123;</span><br><span class="line">    testcases := []<span class="keyword">string</span>&#123;<span class="string">&quot;Hello, world&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;!12345&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, tc := <span class="keyword">range</span> testcases &#123;</span><br><span class="line">        f.Add(tc)  <span class="comment">// Use f.Add to provide a seed corpus</span></span><br><span class="line">    &#125;</span><br><span class="line">    f.Fuzz(<span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, orig <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        rev := Reverse(orig)</span><br><span class="line">        doubleRev := Reverse(rev)</span><br><span class="line">        <span class="keyword">if</span> orig != doubleRev &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;Before: %q, after: %q&quot;</span>, orig, doubleRev)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> utf8.ValidString(orig) &amp;&amp; !utf8.ValidString(rev) &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;Reverse produced invalid UTF-8 string %q&quot;</span>, rev)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对于传统的单元测试，Fuzzing Test更强调一种 <strong>不确定性的输入</strong> 理念 - 由于输入的数据是随机的，输出往往是不确定的，那我们最好可以通过一定的操作，<strong>减少甚至消除输出的不确定性</strong>，才能保证测试的完备性：</p>
<p>比如说，示例中对字符串的反转，转变成了两个测试点：</p>
<ol>
<li>Reversing a string twice preserves the original value 即两次反转后成为原字符串，</li>
<li>The reversed string preserves its state as valid UTF-8 字符串依然为UTF-8编码格式</li>
</ol>
<p>从输入和输出来看，如果每个输入都对应枚举出一个输出，那就是单元测试；而Fuzzing Test的理念是尽可能地将输出做到可控，更方便地写各种测试。</p>
<p>在实际工程中，能用到Fuzzing特性的地方很少，更多的还是依赖简单地单元测试保障我们的代码质量。</p>
<h2 id="2022-01-26-如何避免分布式事务"><a href="#2022-01-26-如何避免分布式事务" class="headerlink" title="2022-01-26 如何避免分布式事务"></a>2022-01-26 如何避免分布式事务</h2><p>最近，有朋友和我交流分布式事务的实践心得，而我的建议是：<strong>尽量避免分布式事务</strong>。</p>
<p>这里的避免并非完全的不要使用，毕竟像金融场景中，这还是一个必要的特性。但对于绝大多数系统，分布式事务带来的复杂度是非常高的，也需要很高的维护成本与理解成本，远超其收益，我不太建议大家刻意地使用这个技术。</p>
<p>举一个简单的case - 用户下了一个订单，经过如下步骤：</p>
<ol>
<li>订单服务生成订单</li>
<li>库存服务扣去库存</li>
<li>付费服务完成扣款</li>
<li>用户积分服务增加积分</li>
</ol>
<p>这时，最直观的解法是要有一套成熟的分布式事务的方案。但事实上，我更推荐在工程上采用下面两种解决方案，而其中的关键词就是 - <strong>补偿</strong>。</p>
<h3 id="在MQ中重试"><a href="#在MQ中重试" class="headerlink" title="在MQ中重试"></a>在MQ中重试</h3><p>我们经常会利用MQ来解耦服务，那么自然会用它来驱动大量的消息。</p>
<p>例如，我们将扣款请求放到MQ里，扣款服务处理成功后通过另一个MQ通知成功。而当扣款服务出现问题时、也就是扣款失败，常见的有2种选择：</p>
<ol>
<li>如果要求是必须成功的，消费时就不要返回成功，在服务中反复重试，即便MQ积压产生告警、再人工恢复；</li>
<li>如果允许失败，那就设置一个最大重试次数，超过最大重试次数则通知给对应的补偿服务；</li>
</ol>
<h3 id="利用trace-id-ELK"><a href="#利用trace-id-ELK" class="headerlink" title="利用trace-id+ELK"></a>利用trace-id+ELK</h3><p>trace-id是分布式链路追踪的关键信息，用于串联信息；而ELK又通过日志收集系统，将这块收集到了一个系统。</p>
<p>我们可以在生成订单时，同时记录这个关键性的trace-id，然后调用各个服务。有任何一个服务失败，我们就将订单状态修改为失败或超时；而数据不一致的问题，就由对应的补偿服务，根据这些有问题的订单的trace-id去分析。</p>
<blockquote>
<p>其实可以从这个方案延伸出类似的，比如直接将错误通过trace-id+信息发送给补偿服务，统一收集。</p>
</blockquote>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>补偿不代表只能手动，我们可以在补偿服务内根据错误码，实现一定的自动化；</li>
<li>补偿更多体现的是一种<strong>最终一致性</strong>的思想，会有延时，我们要保证中间状态的数据不会污染系统；</li>
</ol>
<p>在微服务+云原生时代，我们非常提倡 <strong>面向错误编程</strong>，正是为了能更好地面对各种不确定的异常case。分布式事务带来了大量的复杂度，目前也没有一套跨语言、跨组件的通用解决方案，目前主流几个方案对应用的侵入性很强，所以我不太建议大部分朋友在生产环境使用，而花更多时间学习相关理论、应付面试就行了。</p>
<h2 id="2022-01-27-CNCF-TiKV"><a href="#2022-01-27-CNCF-TiKV" class="headerlink" title="2022-01-27 CNCF-TiKV"></a>2022-01-27 CNCF-TiKV</h2><p>了解完核心的 <strong>调度与管理</strong> 相关的软件后，我们接下来开始接触 <strong>应用定义与开发</strong> 的相关软件，这部分与我们实际开发接触最为紧密，也更容易理解。</p>
<ul>
<li>官网 - <a target="_blank" rel="noopener" href="https://tikv.org/">https://tikv.org/</a></li>
<li>Github - <a target="_blank" rel="noopener" href="https://github.com/tikv/tikv">https://github.com/tikv/tikv</a></li>
</ul>
<p>官方的定义为：</p>
<blockquote>
<p>TiKV provides both raw and ACID-compliant transactional key-value API, which is widely used in online serving services, such as the metadata storage system for object storage service, the storage system for recommendation systems, the online feature store, etc.</p>
</blockquote>
<p>也就是TiKV支持 <strong>简单的与满足ACID事务性的KV存储</strong>，被应用在各种存储系统上，如关系型数据库、非关系型数据库、分布式文件系统，最具有代表性的即同属一个公司的TiDB。按官方的定义，我们可以将它对标Redis。</p>
<p>我们结合TiKV的核心特性来看看。</p>
<h3 id="Low-and-stable-latency"><a href="#Low-and-stable-latency" class="headerlink" title="Low and stable latency"></a>Low and stable latency</h3><blockquote>
<p>RawKV’s average response time less than 1 ms (P99=10 ms).</p>
</blockquote>
<p>延迟是IO相关的软件很重要的特性。但对于这个特性，我们要注意两点：</p>
<ol>
<li>只针对简单KV，而不针对事务</li>
<li>真实延迟很依赖存储介质</li>
</ol>
<p>从这点来看，在TiKV层面引入事务的特性前，需要我们要斟酌一下它对延迟的影响。</p>
<h3 id="High-scalabilit"><a href="#High-scalabilit" class="headerlink" title="High scalabilit"></a>High scalabilit</h3><blockquote>
<p>With the Placement Driver and carefully designed Raft groups, TiKV excels in horizontal scalability and can easily scale to 100+ terabytes of data. Scale-out your TiKV cluster to fit the data size growth without any impact on the application.</p>
</blockquote>
<p>强调了高扩展性，可支持100TB+的数据。</p>
<p>TiKV采用了Raft作为分布式一致性的协议，这一点与Etcd一致。关于Raft这块是目前工程化的主流，相对于Paxos更容易落地。不过，各家在实现Raft时都或多或少有一些变种，这块我们暂时不细聊。</p>
<h3 id="Consistent-distributed-transactions"><a href="#Consistent-distributed-transactions" class="headerlink" title="Consistent distributed transactions"></a>Consistent distributed transactions</h3><blockquote>
<p>Similar to Google’s Spanner, TiKV (TxnKV mode) supports externally consistent distributed transactions.</p>
</blockquote>
<p>支持一致性的分布式事务。</p>
<p>分布式事务对强一致性的业务非常有价值，但它的实现必然会带来一定的性能问题，尤其体现在延迟上。以金融服务为例，分布式事务能保证资金的一致性，不产生资损；但延迟问题又会带来一些异常case，所以需要做好权衡。</p>
<h3 id="Adjustable-consistency"><a href="#Adjustable-consistency" class="headerlink" title="Adjustable consistency"></a>Adjustable consistency</h3><blockquote>
<p>In RawKV and TxnKV modes, you can customize the balance between consistency and performance.</p>
</blockquote>
<p>对简单KV模式与事务性的KV模式，提供了可调节的一致性功能。</p>
<p>这就是一致性与性能上的权衡。关于这点，大家可以了解一下ACID与BASE对业务的价值。从我的观察来看，目前越来越多的服务倾向于最终一致性，主要有以下优点：</p>
<ol>
<li><strong>对外部服务来说视角清晰，更容易理解</strong> - 从外部服务视角来看，本服务最终会趋于一致，而不需要关心各种异常的中间状态，这非常有助于微服务的边界划分；</li>
<li><strong>服务更具健壮性</strong> - 软件系统的不稳定因素很多，最终一致性可以更好地处理这些异常。</li>
</ol>
<p>当然，对应的代价是该服务需要引入重试、幂等、异步校验、状态机、恢复日志等特性，自身的复杂度是比较高的。这些技术我也会在后面和大家分享。</p>
<h2 id="2022-01-28-CNCF-Vitess"><a href="#2022-01-28-CNCF-Vitess" class="headerlink" title="2022-01-28 CNCF-Vitess"></a>2022-01-28 CNCF-Vitess</h2><p>今天我们来聊聊一款和关系型数据库相关的产品 - <code>Vitess</code>。<code>Vitess</code>的定位很简洁：</p>
<blockquote>
<p>A database clustering system for horizontal scaling of MySQL</p>
</blockquote>
<p>我们直接从架构图入手，来了解它是怎么实现 <strong>MySQL横向扩展</strong> 的。</p>
<img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/20220127221720.png" style="zoom:50%;" />

<p>我们关注最核心的两个模块：</p>
<h3 id="VTTablet"><a href="#VTTablet" class="headerlink" title="VTTablet"></a>VTTablet</h3><blockquote>
<p>A <em>tablet</em> is a combination of a <code>mysqld</code> process and a corresponding <code>vttablet</code> process, usually running on the same machine. Each tablet is assigned a <em>tablet type</em>, which specifies what role it currently performs.</p>
</blockquote>
<p>一个<code>Tablet</code>对应到一个具体的<code>MySQL</code>实例，类似于sidecar模式。我之前基于VTTablet做过一定的二次开发，和大家分享一下我对这块的认识：</p>
<p><code>VTTablet</code>最核心实现，是 <strong>模拟一个MySQL，与真正的MySQL进行连接</strong>。所以，可以体现如下的特点：</p>
<ol>
<li>无侵入式 - 充分利用了MySQL集群间通信的协议，不会侵入原MySQL。这点能衍生出很多价值，例如兼容多版本的MySQL。</li>
<li>性能较优 - 通过MySQL内部通信的协议交互。</li>
<li>可扩展性强 - 从原先对大MySQL集群的维护，转变成了相对轻量级的<code>VTTablet</code>集群的维护</li>
</ol>
<h3 id="VTGate"><a href="#VTGate" class="headerlink" title="VTGate"></a>VTGate</h3><blockquote>
<p>VTGate is a lightweight proxy server that routes traffic to the correct VTTablet servers and returns consolidated results back to the client. It speaks both the MySQL Protocol and the Vitess gRPC protocol. Thus, your applications can connect to VTGate as if it is a MySQL Server.</p>
</blockquote>
<p><code>VTGate</code>是网关层的角色，主要分三块功能：</p>
<ol>
<li>对外暴露出原生的MySQL协议与gRPC协议；</li>
<li>对内维护与<code>VTTablet</code>集群的连接；</li>
<li>核心依赖Topology服务中的数据，主要是<code>VTTablet</code>的状态数据和Admin的配置数据</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>Vitess</code>是用Go语言编写的软件，我比较推荐对数据库原理感兴趣的朋友去阅读<code>VTTablet</code>相关的源码，从中你可以了解到很多MySQL的关键性功能，会比直接阅读MySQL的C++简单很多。比如我曾经做过的：</p>
<ol>
<li>SQL解析 - 用于自研的查询平台</li>
<li>Binlog同步 - 用于MySQL到异构数据库的同步平台</li>
</ol>
<blockquote>
<p>Github: <a target="_blank" rel="noopener" href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p>
<p>Blog: <a target="_blank" rel="noopener" href="http://junes.tech/">http://junes.tech/</a></p>
<p>Bilibili: <a target="_blank" rel="noopener" href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p>
<p>公众号: golangcoding</p>
<p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/23/go-tip/go-tip-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junedayday">
      <meta itemprop="description" content="Blog信息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junedayday Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/23/go-tip/go-tip-13/" class="post-title-link" itemprop="url">Go语言技巧 - 13.【浅析微服务框架】Go-Kit概览</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-23 12:00:00" itemprop="dateCreated datePublished" datetime="2022-01-23T12:00:00+08:00">2022-01-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-01-27 15:02:49" itemprop="dateModified" datetime="2022-01-27T15:02:49+08:00">2022-01-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">成长分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p>
<h2 id="Go-Kit概况"><a href="#Go-Kit概况" class="headerlink" title="Go-Kit概况"></a>Go-Kit概况</h2><p>截止到本文发布时，<code>Go-Kit</code>在github上的star数为22.2k，超过了我们已经一起看过的<code>Go-Micro</code>与<code>Kratos</code>。</p>
<p><code>Go-Kit</code>不同于前两者，它更像是一种Go语言的工具集，而不是一种统一化的框架。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/01/23/go-tip/go-tip-13/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junedayday</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<div class=BbeiAn-info">
  浙ICP备 -
  <a target="_blank" rel="noopener" href="http://www.miitbeian.gov.cn/">19051676号-1</a>
  </a>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  















  








  

  

</body>
</html>
