<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Junedayday Blog</title>
  
  <subtitle>六月天天的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-16T06:08:26.104Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Junedayday</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>五分钟技术小分享 - 2022Week03</title>
    <link href="http://example.com/2022/01/17/sharing-5min/2022-01/2022Week03/"/>
    <id>http://example.com/2022/01/17/sharing-5min/2022-01/2022Week03/</id>
    <published>2022-01-17T04:00:00.000Z</published>
    <updated>2022-01-16T06:08:26.104Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg" alt="2022-01"></p><h2 id="2022-01-17-CNCF-gRPC"><a href="#2022-01-17-CNCF-gRPC" class="headerlink" title="2022-01-17 CNCF-gRPC"></a>2022-01-17 CNCF-gRPC</h2><p>今天，我们一起来看CNCF的 <strong>Remote Procedure Call - RPC</strong> 模块中最具代表性的项目 - gRPC。</p><p>gRPC官网的定义很简洁，重点强调了其<strong>高性能</strong>的特点：</p><blockquote><p>A high performance, open source universal RPC framework.</p></blockquote><p>我们再看一段官方更详细的描述：</p><blockquote><p>gRPC is a modern open source high performance Remote Procedure Call (RPC) framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking and authentication. It is also applicable in last mile of distributed computing to connect devices, mobile applications and browsers to backend services.</p></blockquote><p>除了高性能，这里还提到了两个重要特性：</p><ul><li><strong>插件化的支持</strong>：负载均衡、tracing、健康监测、认证等</li><li><strong>最后一公里</strong>：将手机app、浏览器与后端服务器的联通</li></ul><p>第一点体现出了gRPC的高度可扩展性。这里的插件化不仅体现在上面列举的这些具体功能，甚至像序列化的方案、底层通信的协议，都可以做到快速替换与迭代。</p><p>第二点在实际生产上应用的case并不多，仍需要大量的实践与经验沉淀后，才建议大家尝试。目前，绝大多数的gRPC通信都是发生在后端服务之间。</p><p>接下来，我们来谈谈官网列举的四个特性：</p><h3 id="Simple-service-definition"><a href="#Simple-service-definition" class="headerlink" title="Simple service definition"></a>Simple service definition</h3><p>gRPC采用<code>Protocol Buffers</code>进行定义，从整体来说阅读体验确实是比较简洁的，但在实际工程中仍存在两个问题：</p><ol><li><strong>迁移成本大</strong>：gRPC没有提供从很多历史RPC解决方案中迁移的途径，如Thrift等，完全是另起炉灶，这对有历史包袱的团队来说很难接收；</li><li><strong>配套开发工具缺失</strong>：高频使用<code>Protocol Buffers</code>的朋友都有了解，主流IDE对<code>pb</code>文件的错误提示和文件格式化都有缺失，很多问题都无法在coding的过程中实时提示，而是需要运行二进制命令<code>protoc</code>后才能了解。</li></ol><h3 id="Start-quickly-and-scale"><a href="#Start-quickly-and-scale" class="headerlink" title="Start quickly and scale"></a>Start quickly and scale</h3><p><strong>快速启动</strong> - 强调的是通过<code>Protocol Buffers</code>生成的代码，可以在各语言内用简洁的代码就可运行（这部分与各语言强相关）</p><p><strong>快速扩容</strong> - 这个特性需要与<code>Kubernetes</code>的能力结合。</p><h3 id="Works-across-languages-and-platforms"><a href="#Works-across-languages-and-platforms" class="headerlink" title="Works across languages and platforms"></a>Works across languages and platforms</h3><p>跨语言与平台的特性，非常依赖背后的生态 - 需要大量的工作去兼容多语言，也要兼顾性能、稳定性等问题。</p><p>所以，这不仅仅是技术上的问题，更需要社区、资金等复杂因素的支持。</p><h3 id="Bi-directional-streaming-and-integrated-auth"><a href="#Bi-directional-streaming-and-integrated-auth" class="headerlink" title="Bi-directional streaming and integrated auth"></a>Bi-directional streaming and integrated auth</h3><ul><li><strong>双向流式通信</strong> - 这点是gRPC的核心特性，体现出了与其它RPC方案的差异</li><li><strong>集成认证功能</strong> - Auth是gRPC插件化生态中的重要一环，这部分其实与服务网格的功能存在一定的重叠</li></ul><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg&quot; alt=&quot;2022-01&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2022-01-17-C
      
    
    </summary>
    
      <category term="每日技术分享" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Daily-Sharing" scheme="http://example.com/tags/Daily-Sharing/"/>
    
  </entry>
  
  <entry>
    <title>五分钟技术小分享 - 2022Week02</title>
    <link href="http://example.com/2022/01/10/sharing-5min/2022-01/2022Week02/"/>
    <id>http://example.com/2022/01/10/sharing-5min/2022-01/2022Week02/</id>
    <published>2022-01-10T04:00:00.000Z</published>
    <updated>2022-01-15T13:28:52.005Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg" alt="2022-01"></p><h2 id="2022-01-10-Unix设计哲学概览"><a href="#2022-01-10-Unix设计哲学概览" class="headerlink" title="2022-01-10 Unix设计哲学概览"></a>2022-01-10 Unix设计哲学概览</h2><p>Unix设计哲学在程序员的圈子里经久不衰，备受追捧。而<code>Go</code>语言背后有很多<code>Unix</code>与<code>C语言</code>的影子，三位创始人Rob Pike（罗伯. 派克），Ken Thompson（肯. 汤普森）和Robert Griesemer（罗伯特. 格利茨默）都是这两块领域的泰山北斗。了解Unix的设计哲学，对写出优秀的代码很有帮助。</p><ul><li>英文资料 - <a href="https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html">https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html</a></li><li>中文wiki - <a href="https://zh.wikipedia.org/wiki/Unix%E5%93%B2%E5%AD%A6">https://zh.wikipedia.org/wiki/Unix%E5%93%B2%E5%AD%A6</a></li></ul><h3 id="Doug-McIlroy的总结"><a href="#Doug-McIlroy的总结" class="headerlink" title="Doug McIlroy的总结"></a>Doug McIlroy的总结</h3><blockquote><p>Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface.</p><p>做一件事，做好它。让程序能够互相协同工作。应该让程序处理文本数据流，因为这是一个通用的接口。</p></blockquote><p>作为管道机制的发明者，Doug McIlroy对这块的解释重点很具有管道特色。这里，我们聚焦于一个点：<strong>做好一件事</strong>。</p><p>将其拆分一下，主要分为两块：</p><ol><li><strong>做好。</strong>做一件事，可能只需要10分的能力；而做好，则需要100分的能力（但 <code>做好</code> 这个标准，尽可能地按照自己的认知上限去做，才可能有成长）。</li><li><strong>一件事。</strong>怎么定义一件事呢？边界的定义就难倒了很多人。这个非常考验能力，更具体可能需要<code>case by case</code>去看。</li></ol><h3 id="Rob-Pike的总结"><a href="#Rob-Pike的总结" class="headerlink" title="Rob Pike的总结"></a>Rob Pike的总结</h3><blockquote><ol><li>你永远不会知道你的程序会在什么地方耗费时间。程序的瓶颈常常出现在意想不到的地方，因此在你确信找到瓶颈后再动手优化代码吧。</li><li>测试代码。只有在你详细测试了代码，并且发现一部分代码耗费了绝大部分的运行时间时再对程序作速度优化。</li><li>功能全面的算法（fancy algorithm）在处理小规模问题时效率很低，这是因为算法时间效率中的常量很大，而问题往往规模很小。除非你知道你遇到的常常是复杂的情况，否则就让代码丑陋但是简单而高效吧。（即使问题规模确实很大，也首先尝试第二条规则。）</li><li>功能全面的算法比简单的算法更容易产生bug，更难实现。尽量使用简单的算法和数据结构。</li><li>数据决定一切。如果选择的数据结构能很好的管理数据，算法部分往往不言自明。记住，数据结构，而非算法，才是编程的关键。</li><li>没有第六条规则。</li></ol></blockquote><p>按照wiki上的说法，1、2可以归纳为 <strong>过早的优化是一切罪恶的根源</strong>，3、4可以理解为 <strong>疑惑不定之时最适合穷举</strong>。</p><p>而第五条就非常有意思，也就是 <strong>数据结构比算法更重要</strong>。</p><p>这点，和我们在刷算法题时认知相反 - 在做算法题目时，我们往往已经得到了一个具体的数据结构，要做的更多是根据这个数据结构选择合适的算法。当数据结构确定时，可选择的算法就很有限了，这也大大缩小了题解的范围。</p><p>在复杂的场景中，我们首先得确定数据结构，这一步尤为复杂：</p><ol><li>复合 - 数据结构往往是复合的、嵌套的，单一的数据结构很少见；</li><li>抓住核心 - 可用数据结构解往往有多种，关键是识别其中决定性的因素；</li><li>不确定性 - 最优解的数据结构，往往会根据时间变化而变化；</li><li>简单性 - 性能最优解并不一定是最终的解，实际工程中多考虑简单性；</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关于Unix的设计哲学还有很多优秀的见解，但综合起来，可以归纳为<code>KISS</code>原则，也就是<strong>简单性</strong>。希望大家能在工程实践中，多多思考怎么保证简单性，对做出优秀的设计会很有启发。</p><h2 id="2022-01-11-CNCF-CrossPlane"><a href="#2022-01-11-CNCF-CrossPlane" class="headerlink" title="2022-01-11 CNCF-CrossPlane"></a>2022-01-11 CNCF-CrossPlane</h2><p>今天我们一起来看CNCF中的第二个项目 - <code>CrossPlane</code> 。它位于CNCF全景图中<code>Kubernetes</code>旁，受众比较小。</p><p>先看一段来自官网 <a href="https://crossplane.io/">https://crossplane.io/</a> 的信息：</p><blockquote><p> Crossplane is an open source Kubernetes add-on that enables platform teams to assemble infrastructure from multiple vendors, and expose higher level self-service APIs for application teams to consume, without having to write any code.</p></blockquote><p>我们依旧抽取其中关键的词进行解析：</p><ul><li><code>Kubernetes add-on</code> CrossPlane的定位是<code>Kubernetes</code>的插件，并非一个独立的平台</li><li><code>assemble infrastructure from multiple vendors</code> 统一封装多个依赖方的基础设施</li><li><code>expose higher level self-service APIs</code> 暴露高层接口</li></ul><p>然后，官方描述了五个关键性的特征：</p><ul><li>Provision and manage cloud infrastructure and services using kubectl</li><li>There is a flavor of infrastructure for everyone on Crossplane</li><li>Publish simplified infrastructure abstractions for your applications</li><li>The Universal Cloud API</li><li>Run Crossplane anywhere</li></ul><p>概括起来，可以定义为：<strong>使用 kubectl 封装了各类云的API，来统一管理基础设施、服务和应用</strong>。</p><p>我们从具体的实践角度来看，统一封装接口往往只是加分项，而核心在于 <strong>支持的云基础设施与服务的范围</strong>。</p><p>从 <a href="https://crossplane.io/docs/v1.6/getting-started/provision-infrastructure.html">官方文档</a> 可以看到，<code>CrossPlane</code>主要支持了亚马逊云、谷歌云、微软云等厂商。可以看到，这款产品主要面向的是<strong>国外的公有云厂商</strong>。这其实也决定了<code>CrossPlane</code>更多面向的是国外开发者。</p><p>学习<code>CrossPlane</code>的更多细节，对我们来说暂时没有更大的意义。我们可以尝试着从其理念中得到以下启发：</p><ol><li><strong>对接各类云厂商是复杂的。</strong>尽管<code>CNCF</code>统一了大致上的理念，但细节上的实现各有不同；尤其是结合了账号、权限、资源分配等各类特性后，对接起来的复杂度很高。</li><li><strong>如果一层不能解决，那就加一层。</strong> 直接对接各类公有云复杂度很高，也会为<code>Kubernetes</code>这个核心项目带来大量侵入性极强的代码。这时，引入另一个项目作为<strong>防腐层</strong>，很具有扩展意义。</li><li><strong>一个核心项目不一定需要做成大型平台，更重要的是它的特性符合整个生态的发展理念。</strong></li></ol><h2 id="2022-01-12-微服务架构特征"><a href="#2022-01-12-微服务架构特征" class="headerlink" title="2022-01-12 微服务架构特征"></a>2022-01-12 微服务架构特征</h2><p>今天的话题将围绕着一篇谈论微服务架构的文章展开。下面给出原文链接，以及一个翻译的版本：</p><ul><li>原文 - <a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a></li><li>中文翻译 - <a href="https://blog.51cto.com/u_15127669/4175353">https://blog.51cto.com/u_15127669/4175353</a> </li></ul><p>文中给出了以下九个微服务特征：</p><ol><li>Componentization via Services 通过服务来实现组件化</li><li>Organized around Business Capabilities 围绕业务能力构建</li><li>Products not Projects 面向产品，而不是面向项目</li><li>Smart endpoints and dumb pipes 终端智能化，通讯轻量化</li><li>Decentralized Governance 分散治理</li><li>Decentralized Data Management 数据去中心化管理</li><li>Infrastructure Automation 基础设施自动化</li><li>Design for failure 容错性设计</li><li>Evolutionary Design 演进式设计</li></ol><p>这些点，每个抛出来都可以写一篇长文。建议有兴趣的各位可以阅读原文，结合自己的实践多多思考。</p><p>这里，我选择三个最近感触比较深的点，自己也曾经陷入过的认知误区，在这里和大家聊聊：</p><h3 id="围绕业务能力构建"><a href="#围绕业务能力构建" class="headerlink" title="围绕业务能力构建"></a>围绕业务能力构建</h3><p>业务能力的概念很抽象，虽然我们会经常提及，但在实践过程中又往往容易忽略。</p><p>从系统的角度来看，业务能力往往就是对外呈现的功能，对应到内部的技术模块，往往已经决定了七七八八。如何将这些技术模块做合理的拆分与合并，就是微服务架构需要考量的点。这里我谈谈最近比较有心得的三个考量点：</p><ul><li>拆分高频变化与低频变化</li><li>分离计算密集型和IO密集型</li><li>基础能力尽早引入业界的通用模块</li></ul><p>当然，还有更多的内容，需要大家在实践中摸索。</p><h3 id="终端智能化，通讯轻量化"><a href="#终端智能化，通讯轻量化" class="headerlink" title="终端智能化，通讯轻量化"></a>终端智能化，通讯轻量化</h3><p>这一点在云原生的服务中体现得淋漓尽致：以<strong>RPC</strong>、<strong>Service Mesh</strong>、<strong>服务发现</strong>等技术为代表。</p><p>终端体现在<code>Pod</code>这一层，也就是对一个具体运行的App来说，通过Istio、CoreDNS等技术将分布式的服务做到和单体应用一致，然后通过轻量级的通讯方案，如HTTP进行交互。这种方式的优点很明显：</p><ol><li>分布式服务之间的通讯复杂度最高的部分，由专用的、成熟的组件，引入到Pod层面完成；</li><li>开发者的代码实现只需要关心RPC的数据出入，复杂度大幅度降低；</li></ol><p>目前云原生的Service Mesh技术还未完全形成行业标准，相信很快随着它的落地，将迎来微服务的又一波热潮。</p><h3 id="容错性设计"><a href="#容错性设计" class="headerlink" title="容错性设计"></a>容错性设计</h3><p>容错性设计，也就是为错误而设计，这一点很反直觉。</p><p>作为一名开发者，我们实现功能的思路往往是按照顺序的逻辑步骤；一个一个步骤的串联，才能保证最后的功能实现。但这个时候，如果要我们去关注各类错误的发生，小到网络波动、程序崩溃，大到机房断电，很容易无所适从。</p><p>这里，我谈谈自己的理解：<strong>主要从发生的概率与影响的严重程度来思考，不要过度追求细节</strong>。这里有一个很重要的权衡点 - **健壮性 **与 <strong>简单性</strong> ：一般来说，要保证程序足够健壮，会引入各种异常的容错性设计，增加系统的复杂度，但这一点并不是绝对的。</p><p><strong>从系统整体功能的维度，虽然看起来增加了复杂度，但通过分层、模块化、服务拆分等方式，分而治之 - 一些简单的模块用简单的规则组合成一个大模块，可维护性远远高于一个复杂的模块。</strong></p><h2 id="2022-01-13-CNCF-CoreDNS"><a href="#2022-01-13-CNCF-CoreDNS" class="headerlink" title="2022-01-13 CNCF-CoreDNS"></a>2022-01-13 CNCF-CoreDNS</h2><p><code>CoreDNS</code>是CNCF全景图中 <strong>协调与服务发现</strong> 模块的核心项目，在<code>Kubernetes</code>1.12版本之后成为了默认的DNS服务。熟悉<code>CoreDNS</code>是掌握<code>Kubernetes</code>必不可少的技能。</p><p>照例，我们先一起看下其核心定义，非常简洁明了：</p><blockquote><p>官网 - CoreDNS: DNS and Service Discovery</p><p>CNCF - CoreDNS is a DNS server that chains plugins</p></blockquote><p>今天，我们将围绕一个关键词<code>chains plugins</code> - <strong>链式插件</strong> 展开，这也是<code>CoreDNS</code>实现的核心特性。</p><p>官方对这个特性的定义如下，</p><blockquote><p>CoreDNS chains plugins. Each plugin performs a DNS function, such as Kubernetes service discovery, prometheus metrics, rewriting queries, or just serving from zone files. And many more.</p></blockquote><p>从中不难看出，<code>CoreDNS</code>将各种<code>DNS</code>的功能抽象成一个插件，进行链式调用。</p><p>我们用 <a href="https://github.com/coredns/coredns">官方github上的Corefile</a> 来了解这个特性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example.org:1053 &#123;</span><br><span class="line">    file /var/lib/coredns/example.org.signed</span><br><span class="line">    transfer &#123;</span><br><span class="line">        to * 2001:500:8f::53</span><br><span class="line">    &#125;</span><br><span class="line">    errors</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. &#123;</span><br><span class="line">    any</span><br><span class="line">    forward . 8.8.8.8:53</span><br><span class="line">    errors</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>当访问<code>example.org:1053</code> 时，依次触发 file、transfer、errors、log四个插件</li><li>访问其余DNS时，依次触发 any、forward、errors、log四个插件</li></ol><p>上面的语法与<code>nginx</code>非常类似，而作者实际上是参考<code>Caddy</code>软件进行设计的，有兴趣的可以查阅相关资料，例如这个 <a href="https://mritd.com/2021/06/30/understand-caddyfile-syntax/">博客</a>。</p><p>链式调用是一种表述形式非常强的语法：<strong>它以一个大众容易接受的顺序逻辑，讲述了一个完整的调用过程，将各个细节也描述地很清晰</strong>。</p><p>既然链式调用的描述方式那么棒，为什么目前没有大规模地推广到各类工具上呢？这里，我谈谈个人的三个理解：</p><ol><li><strong>核心模块支持插件化</strong> - 链式调用需要动态加载各类插件，这一点对核心的模块要求很高，很多软件设计之初就决定了很难走插件化的道路；</li><li><strong>无需兼容历史问题</strong> - 很多的工具都存在大量的历史版本，很难做到完全兼容这种表达形式；而<code>CoreDNS</code>在设计之初就强制采用这种规范，没有历史包袱；</li><li><strong>每个插件的输入与输出保持一致</strong> - 作为一种链式调用，为了保证前者输入可以作为后者输出，两者支持的数据格式必须一样（可以参考Unix中的管道）。DNS服务的功能比较简单，可以保证一致；</li></ol><p>同样的，Corefile这种声明方式，也或多或少带来了一些问题，例如：</p><ol><li><strong>文件解析的复杂性</strong>（这点与链式调用本身无关） - 比如数据类型的问题，很难确定文件中的<code>5</code>是数字还是字符串；</li><li><strong>链式调用很难解决前后有依赖的情况</strong> - 如调用A插件的结果有个特别的输出，用于插件B的输入时，很难解决；</li><li><strong>长链式调用的复杂度</strong> - 如果链式调用过长，一方面带来了异常情况下排查问题的复杂度，另一方面很容易出现性能问题；</li></ol><p><code>CoreDNS</code>的成功，<strong>链式调用插件</strong> 这个特性只体现了简单性的理念，并不是关键性的原因，而更多地是依赖大量开箱即用的<a href="https://coredns.io/plugins/">插件</a>。</p><h2 id="2022-01-14-不可变基础设施"><a href="#2022-01-14-不可变基础设施" class="headerlink" title="2022-01-14 不可变基础设施"></a>2022-01-14 不可变基础设施</h2><p>看起来，这功能描述与<code>CICD</code>流程差不多，但使用体验差距很大。在传统的模式下，我们执行的是一个<strong>具体的动作</strong>，比如扩1个应用、升级2个程序等；而在k8s里，使用者只要<strong>声明最终的预期状态</strong>，比如5个应用运行v1.0版本的程序，那么整个系统该扩容还是缩容、该升级还是回滚，都由k8s自行根据当前状态进行判断。</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>ab4ea1c14f669e0e42040689da7aa074c4e479f3</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>云原生有五大代表性的技术 - <strong>容器、服务网格、微服务、不可变基础设施和声明式 API</strong>。相对于其余四种概念，不可变基础设施 - <code>Immutable Infrastructure</code> 更难理解，今天我们来一起看看。</p><blockquote><p>入门可以参考这篇文章 - <a href="https://zhuanlan.zhihu.com/p/382203966">https://zhuanlan.zhihu.com/p/382203966</a> </p></blockquote><p>网上可搜索到的<strong>不可变基础设施</strong>定义有很多，这里我选择一个比较有代表性的：</p><blockquote><p>Immutable infrastructure refers to servers (or VMs) that are never modified after deployment.</p></blockquote><p>从开发者的角度来看，不可变基础设施是一个很棒的概念。如果用一个词总结它的优点，那就是 <strong>时间与空间上的一致性</strong>。</p><p>如果有一个传统应用希望改造成适配 <strong>不可变基础设施</strong> 的场景，那么会有哪些常见的改造点呢？</p><ol><li>将传统应用的运行环境打造成一个具体的服务器，例如虚拟机、容器；</li><li>重点分析该应用的输出形式，让其与 <strong>服务器无关</strong>；</li></ol><p>第二点有些抽象，这里我举三个具体的例子：</p><ol><li>本地缓存 - 转移到分布式缓存服务；</li><li>本地保存的文件 - 转移到分布式存储服务中；</li><li>本地日志 - 将原来打印到本地文件的日志服务，重定向到标准输出，由日志采集的side-car收集后统一汇总；</li></ol><p>但在实际的工程中，追求 <strong>不可变基础设施</strong> 很难完全落地，我们可以适当地做一些权衡：</p><ol><li>如果日志不允许落盘对部分程序的改造成本很高，那么我们可以用ELK等一套日志收集方案做准实时的同步，保证日志可丢失；</li><li>如果完全依赖分布式缓存对性能压力过大，那么就建立一套分布式缓存与本地缓存的自动同步机制，保证重启后本地缓存丢失，仍可以恢复；</li></ol><p>不难看出，只要我们保证应用在基础设施上产生的数据 <strong>可在任意时间丢失</strong>，就能实现了一定程度上 <strong>应用无状态化</strong>，也能保证了<strong>不可变基础设施</strong>的落地。</p><p><strong>不可变基础设施</strong>是一种理念，具体落地的技术非常依赖容器或虚拟机，以及分布式存储等配套设施。我们没有必要把它作为一种技术标准去强制执行，而应该结合现状，选择性地朝着这个方向不断优化。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg&quot; alt=&quot;2022-01&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2022-01-10-U
      
    
    </summary>
    
      <category term="每日技术分享" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Daily-Sharing" scheme="http://example.com/tags/Daily-Sharing/"/>
    
  </entry>
  
  <entry>
    <title>五分钟技术小分享 - 2022Week01</title>
    <link href="http://example.com/2022/01/04/sharing-5min/2022-01/2022Week01/"/>
    <id>http://example.com/2022/01/04/sharing-5min/2022-01/2022Week01/</id>
    <published>2022-01-04T04:00:00.000Z</published>
    <updated>2022-01-11T06:50:57.175Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg" alt="2022-01"></p><h2 id="2022-01-04-Go1-18概览"><a href="#2022-01-04-Go1-18概览" class="headerlink" title="2022-01-04 Go1.18概览"></a>2022-01-04 Go1.18概览</h2><p>在2021年年底，<code>Go</code>推出了<code>1.18Beta</code>版本。由于正式版本没有完全敲定，普通开发人员没有必要研究到底层实现，但如果能先形成一个全局上的认知，能帮助我们领先一步。</p><p>关于1.18的核心改动，是 <strong>对泛型(Generics)的支持</strong>。Go语言的泛型语法比较简单，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> numeric <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="keyword">type</span> <span class="keyword">int</span>, <span class="keyword">int8</span>, <span class="keyword">int16</span>, <span class="keyword">int32</span>, <span class="keyword">int64</span>, <span class="keyword">uint</span>, <span class="keyword">uint8</span>, <span class="keyword">uint16</span>, <span class="keyword">uint32</span>, <span class="keyword">uint64</span>, <span class="keyword">float32</span>, <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span>[<span class="title">T</span> <span class="title">numeric</span>]<span class="params">(a, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要在实际工程上落地，还有很多考量点，我这边重点提三点：</p><ol><li><strong>主流IDE的支持</strong> - 包括Goland与VSCode，尽量帮助开发者能在编码时发现问题；</li><li><strong>历史库的迁移与兼容</strong> - 实现泛型后，许多主流库会有大量的冗余函数，如何提供迁移方案，值得我们去关注；</li><li><strong>泛型的最佳工程实践</strong> - 作为一种新特性，Go的泛型如何应用在工程中、尤其是复杂工程中，需要一定的实践摸索，并总结规律（可借鉴其余支持泛型的语言）；</li></ol><p>除了泛型，另外一个比较大的特性就是<code>Fuzzy Testing</code>。</p><p>这个特性是为<strong>单元测试提供更全面的数据输入</strong>，这样就能覆盖更多的case，提前发现问题。关键词<code>Fuzzy</code>支持的主要特性是将一个输入参数，<strong>从具体的值变成范围</strong>，如原先输入<code>a=1</code>，现在支持<code>a</code>输入范围为<code>[-10,10]</code>。在跑单元测试时，大量的<code>Fuzzy</code>肯定会带来一定的性能压力，这时可以引入一定的并发特性。</p><p>总体来说，<code>Go1.18</code>对工程侧的影响更多地是提高代码的 <strong>简洁性</strong>。新特性的学习成本很低，我们不用过于急着引入，可以多花时间学习底层原理。</p><blockquote><p><strong>Go Blog</strong> - <a href="https://go.dev/blog/go1.18beta1">https://go.dev/blog/go1.18beta1</a></p><p><strong>Medium</strong> - <a href="https://betterprogramming.pub/golang-1-18-what-you-need-to-know-a5701f7e14ab">https://betterprogramming.pub/golang-1-18-what-you-need-to-know-a5701f7e14ab</a></p></blockquote><h2 id="2022-01-05-CNCF-概览"><a href="#2022-01-05-CNCF-概览" class="headerlink" title="2022-01-05 CNCF-概览"></a>2022-01-05 CNCF-概览</h2><p>CNCF作为云原生的代表性组织，提供了大量开源的软件，以及配套的、开箱即用的解决方案。有很多朋友对CNCF和云原生的认识可能仍停留在新闻报道里。今天，我先带大家在整体上入个门，后续选择具有代表性的软件进行分析。</p><blockquote><p>由于篇幅所限，我的分享只会提重点知识，帮大家建立这部分的知识框架，更详细的内容需要大家自行学习。</p></blockquote><p>CNCF的概览可以参考这个全景图 - <a href="https://landscape.cncf.io/%EF%BC%8C%E6%9B%B4%E6%96%B0%E8%BF%AD%E4%BB%A3%E9%9D%9E%E5%B8%B8%E9%A2%91%E7%B9%81%E3%80%82%E5%85%B6%E4%B8%AD%EF%BC%8C%E6%9C%80%E6%A0%B8%E5%BF%83%E7%9A%84%E4%B8%BA%E4%B8%8B%E9%9D%A2%E4%BA%94%E5%9D%97%EF%BC%9A">https://landscape.cncf.io/，更新迭代非常频繁。其中，最核心的为下面五块：</a></p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/landscape.png" alt="landscape"></p><ul><li>App Definition and Development 应用定义与开发<ul><li>Database 数据库</li><li>Streaming &amp; Messaging 流处理和消息通信</li><li>Application Definition &amp; Image Build 应用定义与镜像构建</li><li>Continuous Integration &amp; Delivery 持续集成与交付</li></ul></li><li>Orchestration &amp; Management 编排和管理<ul><li>Scheduling &amp; Orchestration 调度与编排</li><li>Coordination &amp; Service Discovery 协调与服务发现</li><li>Remote Procedure Call 远程过程调用</li><li>Service Proxy 服务代理</li><li>API Gateway API网关</li><li>Service Mesh 服务网格</li></ul></li><li>RunTime 运行时<ul><li>Cloud Native Storage 云原生存储</li><li>Container Runtime 容器运行时</li><li>Cloud Native Network 云原生网络</li></ul></li><li>Provisioning 提供者<ul><li>Automation &amp; Configuration 自动化与配置</li><li>Container Registry 容器注册</li><li>Security &amp; Compliance 安全与合规</li><li>Key Management 密钥管理</li></ul></li><li>Observability and Analysis 可观察性和分析<ul><li>Monitoring 监控</li><li>Logging 日志</li><li>Tracing 跟踪</li><li>Chaos Engineering 混沌工程</li></ul></li></ul><p>其余还包括Kubernetes的平台提供商、Serverless、成员、认证的服务提供商等周边内容，并不在我们讨论的范围之内。但从基金会来看，它提供了一整套生态，非常有助于落地。</p><p>那么，如何认识这五块呢？其实Landscape提供了很好的图形效果，我们只要记住两点：</p><ol><li><strong>应用定义与开发</strong>、<strong>编排和管理</strong>、<strong>运行时</strong>、<strong>提供者</strong> 这四块是自上而下的核心链路，下层为上层提供能力支撑</li><li><strong>Observability and Analysis</strong> 是核心链路旁边的重要支撑</li></ol><p>相信到这里，你对CNCF已经有了初步认识。</p><h2 id="2022-01-06-《我做系统架构的一些原则》From-陈皓"><a href="#2022-01-06-《我做系统架构的一些原则》From-陈皓" class="headerlink" title="2022-01-06 《我做系统架构的一些原则》From 陈皓"></a>2022-01-06 《我做系统架构的一些原则》From 陈皓</h2><p>今天，给大家推荐一篇来自左耳朵耗子-陈皓的<a href="https://coolshell.cn/articles/21672.html">文章</a>。</p><ol><li>关注于真正的收益而不是技术本身</li><li>以应用服务和 API 为视角，而不是以资源和技术为视角</li><li>选择最主流和成熟的技术</li><li>完备性会比性能更重要</li><li>制定并遵循服从标准、规范和最佳实践</li><li>重视架构扩展性和可运维性</li><li>对控制逻辑进行全面收口</li><li>不要迁就老旧系统的技术债务</li><li>不要依赖自己的经验，要依赖于数据和学习</li><li>千万要小心 X – Y 问题，要追问原始需求</li><li>激进胜于保守，创新与实用并不冲突</li></ol><p>以上11点，理解会因人而异，我重点挑三个争议性比较大的聊聊，其余的内容建议大家阅读原文。</p><h3 id="完备性会比性能更重要"><a href="#完备性会比性能更重要" class="headerlink" title="完备性会比性能更重要"></a>完备性会比性能更重要</h3><p>借用书中的一句话：<strong>使用最科学严谨的技术模型为主，并以不严谨的模型作为补充</strong>，也就是先紧后松。</p><p>有不少开发者在实际工程中的实践往往相反：为了追求快速落地，会希望毕其功于一役，引入所谓的“一站式解决方案”（如例子中NoSQL），但实践下来引入大量的问题，让后人叫苦不迭。</p><p>关于这个问题，我个人有三个思考：</p><ul><li><strong>不断提高自己的基础能力</strong>。很多架构上的局限性，往往是设计者停留于自己的舒适区，不愿意往前一步。</li><li><strong>分清主次、合理分工。</strong> 在设计时，我们要分清楚核心功能和非核心功能，懂得取舍，将功能交由合适的模块或软件。</li><li><strong>功能的实现不是对应到单模块，而是整个系统的涌现。</strong>性能问题的解法不仅仅限于单个软件，而是有一整套生态，可以多去查一些大厂的分享。</li></ul><h3 id="不要迁就老旧系统的技术债务"><a href="#不要迁就老旧系统的技术债务" class="headerlink" title="不要迁就老旧系统的技术债务"></a>不要迁就老旧系统的技术债务</h3><p>为了缩小讨论范围，我对这里 <strong>技术债务</strong> 做一个收口：不仅仅是指有弊端的技术问题，更是需要投入时间精力等成本去维护。有技术债务，不代表就一定要去还，而需要一个契机 - <strong>维护的成本 &gt; 修复的收益</strong>。</p><p>举个例子，某个程序写得很烂，性能很差：</p><ul><li>前期可以通过扩容快速解决，上线后业务收益很高，那就是 成本大于收益，不需要排到最高优先级去修复；</li><li>但随着业务收益稳定下来，增长只有个位数，但发现在机器上投入的成本很高，通过优化预计能缩容50%，可以让总收益提升20%，那这时还技术债务的优先级就很高了。</li></ul><p>还技术债，技术能力只是一个基本，以下两点更为重要：</p><ul><li>评估成本与收益，尽可能地做到有数据支撑，有助于决策者下决心还债；</li><li>用更长远、更广维度地看待技术债务问题，不要拆东墙补西墙。</li></ul><h3 id="激进胜于保守，创新与实用并不冲突"><a href="#激进胜于保守，创新与实用并不冲突" class="headerlink" title="激进胜于保守，创新与实用并不冲突"></a>激进胜于保守，创新与实用并不冲突</h3><p>这个观点是很aggressive的，遇到这样的观念冲突时，决策者找不到客观标准去评估，就很难有二义性的定义：要么激进，要么保守；要么创新，要么实用。这种情况下，我遇到过的比较好的解法有两种：</p><ol><li>决策者自身技术能力强，能掌控团队技术的大致走向。</li><li>决策者和执行者之间培养出足够的信任，适当评审与把控，放权实践。</li></ol><p>第一种情况在实际工作场景中并不多见，尤其当团队规模很大时，就像CTO往往不是公司技术最强的那位。所以，我更倾向于大家多尝试第二种途径。</p><p>当然，我也遇到过很多效果不好的解法，比如说：决策者既然不清楚怎么做才好，那就找2个执行者进行battle，一个代表创新方，另一个代表保守方。也许在少数情况下，最后能帮助决策者找到正确的方向；但更多的实际场景中，会产生如下问题：</p><ul><li>两个执行者碰撞越来越激烈，但始终谁也说服不了谁</li><li>决策者越听越迷茫，不知道该如何抉择</li></ul><p>在我看来，这类决策者往往是偏管理，技术上的掌控力不足，导致在决策时没有足够的倾向性；同时，与执行者之间的信任也不足，就希望把决策这件事下移、尝试着走平衡之道。</p><p>我个人的想法是：先选择一个能力相对优秀的执行者，认真评估其方案，然后交由对方执行；最后哪怕失败了，也可以通过复盘改进，想想下次如何更好地决策，更好地把控方案；当然，如果你认为纯粹是执行者的问题，那就换个可信赖的人。</p><h2 id="2022-01-07-CNCF-Kubernetes"><a href="#2022-01-07-CNCF-Kubernetes" class="headerlink" title="2022-01-07 CNCF-Kubernetes"></a>2022-01-07 CNCF-Kubernetes</h2><p>今天，我们一起来看看CNCF中的最核心项目 - <code>Kubernetes</code>。<code>Kubernetes</code>相关内容非常庞大，我们依旧关注聚焦于核心能力。</p><p><code>Kubernetes</code> 位于CNCF核心的 <strong>调度与编排</strong> 模块，也就是整个解决方案的基石。在CNCF上的介绍为：</p><blockquote><p>Kubernetes is an open-source system for automating deployment, scaling, and management of containerized applications.</p></blockquote><p>对这个定义，我们关注两个点：</p><ul><li><code>automating deployment, scaling, and management</code> 自动化的部署、扩缩容和管理，这是k8s核心能力；</li><li><code>containerized applications</code> 容器化应用，这是k8s操作的基本对象；</li></ul><p>为了更好地介绍Kubernetes，我对<a href="https://kubernetes.io/">官方首页</a>描述中的关键特性再做一些更详细地说明：</p><h3 id="Automated-rollouts-and-rollbacks"><a href="#Automated-rollouts-and-rollbacks" class="headerlink" title="Automated rollouts and rollbacks"></a>Automated rollouts and rollbacks</h3><p>自动化扩缩容和升级回滚。这个特性是k8s最核心的，也是大规模推广的根本原因。</p><p>看起来，这功能描述与<code>CICD</code>流程差不多，但使用体验差距很大。在传统的模式下，我们执行的是一个<strong>具体的动作</strong>，比如扩1个机器、升级2个程序等；而在k8s里，使用者只要<strong>声明最终的预期状态</strong>，比如5台机器运行v1.0版本的程序，那么整个系统该扩容还是缩容、该升级还是回滚，都由k8s自行根据当前状态进行判断。</p><p>这个，就是云原生的一大特性：<strong>声明式API</strong> ，而不是传统上的<strong>命令式API</strong>。</p><blockquote><p>声明式API不一定比命令式API好。在应用程序开发时，命令式API更容易理解。</p></blockquote><h3 id="Service-discovery-and-load-balancing"><a href="#Service-discovery-and-load-balancing" class="headerlink" title="Service discovery and load balancing"></a>Service discovery and load balancing</h3><p>服务发现与负载均衡。这个功能很大程度上减少了分布式软件运行模式的复杂性。</p><p>服务发现，以前非常依赖<code>zookeeper</code>/<code>etcd</code>等这类注册中心，往往需要侵入到业务代码；而负载均衡，则很依赖<code>nginx</code>这类软件，并在上面做复杂配置。</p><p>当然，k8s给出的只是通用解法，对一些具备很强业务属性的服务发现与负载均衡，仍需要程序自行实现。</p><h3 id="Storage-orchestration"><a href="#Storage-orchestration" class="headerlink" title="Storage orchestration"></a>Storage orchestration</h3><p>存储编排。存储的编排是k8s重点演进的功能。</p><p>k8s抽象了存储概念，从传统的本地存储扩展为分布式云存储，对上层应用屏蔽了存储这块的复杂度。</p><h3 id="Designed-for-extensibility"><a href="#Designed-for-extensibility" class="headerlink" title="Designed for extensibility"></a>Designed for extensibility</h3><p>为扩展性而设计。</p><p>扩展性是k8s非常重视的点，无论是开放出容器、网络、存储等接口规范，还是像自定义资源(CRD)等插件的开放，都体现出了一种开放的精神，也是k8s如今能作为云原生标志性的软件的立足之本。</p><p>有一个点希望大家认识到：k8s的成功不是简单地因为开放性，更重要的是，它定义的这些开放性的规范与接口，都是<code>Google</code>经过实践总结出来的经验，符合主流厂商的趋势与开发者的需求。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57571641299795_.pic_hd.jpg&quot; alt=&quot;2022-01&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2022-01-04-G
      
    
    </summary>
    
      <category term="每日技术分享" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Daily-Sharing" scheme="http://example.com/tags/Daily-Sharing/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 12.【Go实体框架】Facebook开源ent概览</title>
    <link href="http://example.com/2021/12/31/go-tip/go-tip-12/"/>
    <id>http://example.com/2021/12/31/go-tip/go-tip-12/</id>
    <published>2021-12-31T04:00:00.000Z</published>
    <updated>2021-12-31T15:11:30.691Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="Ent概览"><a href="#Ent概览" class="headerlink" title="Ent概览"></a>Ent概览</h2><p><strong>Simple, yet powerful ORM for modeling and querying data.</strong></p><p><code>Ent</code>作为一款由<code>Facebook</code>开源的库，官方定义为<code>An entity framework for Go</code>。从整个微服务框架来看，它更准确的定位应是 <strong>数据模型层的工具库</strong>。了解<code>Ent</code>这款企业级工具的大致实现，不仅有助于我们在技术选型时拓宽视野，也能帮助我们能更好地认识数据模型层。</p><span id="more"></span><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="Schema-As-Code"><a href="#Schema-As-Code" class="headerlink" title="Schema As Code"></a>Schema As Code</h3><blockquote><p>Simple API for modeling any database schema as Go objects. </p></blockquote><p>从定义来看这个特性非常棒 - <code>Ent</code> 可以将各种异构数据库映射到Go语言的结构体。</p><p>但在实际的开发中，如果你对各类数据库有深入的理解，就会清楚地知道这个特性在对数据库特性有一定要求时，框架层面就很难满足了。</p><h3 id="Easily-Traverse-Any-Graph"><a href="#Easily-Traverse-Any-Graph" class="headerlink" title="Easily Traverse Any Graph"></a>Easily Traverse Any Graph</h3><blockquote><p>Run queries, aggregations and traverse any graph structure easily.</p></blockquote><p>强调对图结构的 <strong>查询、聚合和遍历</strong>。这里的图数据库和传统的关系型数据库差别不小，有兴趣的朋友可搜索<strong>图数据库</strong>的相关概念。</p><h3 id="Statically-Typed-And-Explicit-API"><a href="#Statically-Typed-And-Explicit-API" class="headerlink" title="Statically Typed And Explicit API"></a>Statically Typed And Explicit API</h3><blockquote><p>100% statically typed and explicit API using code generation.</p></blockquote><p>利用代码生成的能力，保证静态类型和显示声明的API。</p><h3 id="特性总结"><a href="#特性总结" class="headerlink" title="特性总结"></a>特性总结</h3><p>三大特性，分别从 <strong>支持的数据库能力集</strong>、<strong>针对图形数据处理能力</strong> 和 <strong>代码生成的输出形式</strong>，描述了<code>Ent</code>框架的优点。</p><p>这里，我会更聚焦于第二点中的关键词：<strong>图形数据</strong>。让我们带着对三个特性的初印象，开始了解相关官方示例。</p><h2 id="Ent实践"><a href="#Ent实践" class="headerlink" title="Ent实践"></a>Ent实践</h2><blockquote><p>Ent工具的使用方式并不是本篇的重点，具体的操作方法我会放在链接里，文中只给出关键性的内容</p></blockquote><h3 id="1-创建实体"><a href="#1-创建实体" class="headerlink" title="1.创建实体"></a>1.创建实体</h3><p>链接 - <a href="https://entgo.io/docs/getting-started/#create-your-first-entity">https://entgo.io/docs/getting-started/#create-your-first-entity</a> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u, err := client.User.</span><br><span class="line">        Create().</span><br><span class="line">        SetAge(<span class="number">30</span>).</span><br><span class="line">        SetName(<span class="string">&quot;a8m&quot;</span>).</span><br><span class="line">        Save(ctx)</span><br></pre></td></tr></table></figure><p>代码和<code>GORM</code>非常类似，但不支持复杂结构体的传入，面对大量参数时比较麻烦。</p><h3 id="2-查询实体"><a href="#2-查询实体" class="headerlink" title="2.查询实体"></a>2.查询实体</h3><p>链接 - <a href="https://entgo.io/docs/getting-started/#query-your-entities">https://entgo.io/docs/getting-started/#query-your-entities</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u, err := client.User.</span><br><span class="line">        Query().</span><br><span class="line">        Where(user.Name(<span class="string">&quot;a8m&quot;</span>)).</span><br><span class="line">        <span class="comment">// `Only` fails if no user found,</span></span><br><span class="line">        <span class="comment">// or more than 1 user returned.</span></span><br><span class="line">        Only(ctx)</span><br></pre></td></tr></table></figure><p>基本同上，表达方式还是很明确的。但对于<code>Only</code>这种新引入的关键词，对新人来说有学习成本。</p><h3 id="3-Edge相关"><a href="#3-Edge相关" class="headerlink" title="3.Edge相关"></a>3.Edge相关</h3><ul><li><a href="https://entgo.io/docs/getting-started/#add-your-first-edge-relation">https://entgo.io/docs/getting-started/#add-your-first-edge-relation</a></li><li><a href="https://entgo.io/docs/getting-started/#add-your-first-inverse-edge-backref">https://entgo.io/docs/getting-started/#add-your-first-inverse-edge-backref</a></li><li><a href="https://entgo.io/docs/getting-started/#create-your-second-edge">https://entgo.io/docs/getting-started/#create-your-second-edge</a></li></ul><p>我们以一个复杂Edge为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cars, err := client.Group.</span><br><span class="line">        Query().</span><br><span class="line">        Where(group.Name(<span class="string">&quot;GitHub&quot;</span>)). <span class="comment">// (Group(Name=GitHub),)</span></span><br><span class="line">        QueryUsers().                <span class="comment">// (User(Name=Ariel, Age=30),)</span></span><br><span class="line">        QueryCars().                 <span class="comment">// (Car(Model=Tesla, RegisteredAt=&lt;Time&gt;), Car(Model=Mazda, RegisteredAt=&lt;Time&gt;),)</span></span><br><span class="line">        All(ctx)</span><br></pre></td></tr></table></figure><p>从表达式上来看，就是查询Group、然后关联查询User、最后再查到Car。</p><p>首先，我们要认识到 - <strong>抛开背后的实现，这种表达方式很简洁</strong>。</p><p>如果底层是<code>MySQL</code>，这里至少关联了三张实体表（JOIN），很容易引起性能问题。这个问题也就是上面所说的，<strong>框架屏蔽了异构数据库</strong>而导致的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Github - <a href="https://github.com/ent/ent">https://github.com/ent/ent</a></p><p>官网 - <a href="https://entgo.io/">https://entgo.io/</a></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>通过相关资料和简单实操，我对于<code>Ent</code>框架的定位是 - <strong>一个面向图数据库的ORM框架</strong>。相信随着图数据库的逐渐成熟，<code>Ent</code>会更具价值。但考虑到以下两点：</p><ol><li>图数据库的成熟周期还需要一段时间，当前的维护成本高；</li><li>在非图数据库上使用<code>Ent</code>，对开发者的要求很高，既要了解<code>Ent</code>对不同数据库的底层实现，又要懂数据库原理。</li></ol><blockquote><p>举个例子，ent的部分Edge特性需要依赖数据库的外键，但如今主流数据库的实践，倡导去外键，而是将相关逻辑转移到程序代码里。</p></blockquote><p>所以，我不建议将<code>Ent</code>引入到项目中。关于<code>Ent</code>更多的细节需要大家自行阅读和实践。</p><p>这里，我抛出一个自己的理解：<strong>从编程语言框架层面，不应过度基础设施的复杂度。从异构数据库来说，它们的特性、维护方式、设计模式都各不相同，应寻找每种数据库对应的工具库，而不应期望毕其功于一役。</strong></p><p>换一句话，如果期望一个工具库能适配十种数据库，那么换一种角度，这十种数据库更应该被封装成一种数据库。<strong>通用性如果能沉淀在基础设施上，价值远大于在工具库上做适配。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Ent</code>能在Facebook等公司与Kratos框架上沉淀，证明了它具备实际工程落地的能力，但对使用者的要求很高，很难具备普适性。</p><p>前文为了表达个人想法，我在论述观点时会相对态度鲜明，但并非对<code>Ent</code>持有否定态度。相反地，从具体的实现细节来看，<code>Ent</code>给了我不少启发，尤其是强调静态类型，能看出它对性能的追求。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Ent概览&quot;&gt;&lt;a href=&quot;#Ent概览&quot; class=&quot;headerlink&quot; title=&quot;Ent概览&quot;&gt;&lt;/a&gt;Ent概览&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Simple, yet powerful ORM for modeling and querying data.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ent&lt;/code&gt;作为一款由&lt;code&gt;Facebook&lt;/code&gt;开源的库，官方定义为&lt;code&gt;An entity framework for Go&lt;/code&gt;。从整个微服务框架来看，它更准确的定位应是 &lt;strong&gt;数据模型层的工具库&lt;/strong&gt;。了解&lt;code&gt;Ent&lt;/code&gt;这款企业级工具的大致实现，不仅有助于我们在技术选型时拓宽视野，也能帮助我们能更好地认识数据模型层。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 11.【初始化代码生成】Wire进阶使用</title>
    <link href="http://example.com/2021/12/28/go-tip/go-tip-11/"/>
    <id>http://example.com/2021/12/28/go-tip/go-tip-11/</id>
    <published>2021-12-28T04:00:00.000Z</published>
    <updated>2021-12-30T05:45:34.823Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="Wire进阶"><a href="#Wire进阶" class="headerlink" title="Wire进阶"></a>Wire进阶</h2><p>通过上一篇的讲解，我们已经掌握<code>wire</code>工具的基本用法了。但应用在实际工程中，这些基本功能还是有很多局限性。</p><p>在这一篇，我们一起看看Google推出的<code>wire</code>的进阶使用方法，并总结出一套实践思路。</p><span id="more"></span><h2 id="进阶示例"><a href="#进阶示例" class="headerlink" title="进阶示例"></a>进阶示例</h2><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p><code>Set</code>特性比较直观：组合几个<code>Provider</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> BasicSet = wire.NewSet(NewGreeter, NewMessage)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">wire.Build(BasicSet)</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般应用在初始化对象比较多的情况下，减少<code>Injector</code>里的信息。</p><h3 id="绑定接口"><a href="#绑定接口" class="headerlink" title="绑定接口"></a>绑定接口</h3><p>接口这个特性在面向对象编程时非常有意义，我们来看一个具体的示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象出一个 Messager 的接口</span></span><br><span class="line"><span class="keyword">type</span> Messager <span class="keyword">interface</span> &#123;</span><br><span class="line">Name() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Message 是Messager的一个具体实现</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Message)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;message&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMessage</span><span class="params">()</span> *<span class="title">Message</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Message&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Greeter的初始化依赖的是Messager接口，而不是Message这个实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeter</span><span class="params">(m Messager)</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;Message: m&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Greeter <span class="keyword">struct</span> &#123;</span><br><span class="line">Message Messager</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Greeter)</span> <span class="title">Greet</span><span class="params">()</span> <span class="title">Messager</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> g.Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，我们要做的就是在<code>NewGreeter(m Messager)</code>初始化时，用<code>Message</code>这个具体实现来代替<code>Messager</code>接口。这里，我们就在<code>wire.go</code>里引入了 <strong>绑定</strong> 这个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wire.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> BasicSet = wire.NewSet(</span><br><span class="line">NewGreeter,</span><br><span class="line">wire.Bind(<span class="built_in">new</span>(Messager), <span class="built_in">new</span>(*Message)),</span><br><span class="line">NewMessage,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">wire.Build(BasicSet)</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire_gen.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">message := NewMessage()</span><br><span class="line">greeter := NewGreeter(message)</span><br><span class="line"><span class="keyword">return</span> greeter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造结构体"><a href="#构造结构体" class="headerlink" title="构造结构体"></a>构造结构体</h3><p>上面的例子里，我们都定义了具体的构造函数，也就是Provider。但实际开发过程中，我们经常会遇到只有一个具体的结构体，而没有定义具体的函数。这时我们可以采用 <strong>构造结构体的特性</strong>。例如，我们定义一个<code>MyGreeter</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyGreeter <span class="keyword">struct</span> &#123;</span><br><span class="line">Msg Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeMyGreeter</span><span class="params">()</span> *<span class="title">MyGreeter</span></span> &#123;</span><br><span class="line">wire.Build(</span><br><span class="line">NewMessage,</span><br><span class="line">wire.Struct(<span class="built_in">new</span>(MyGreeter), <span class="string">&quot;Msg&quot;</span>),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> &amp;MyGreeter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire_gen.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeMyGreeter</span><span class="params">()</span> *<span class="title">MyGreeter</span></span> &#123;</span><br><span class="line">message := NewMessage()</span><br><span class="line">myGreeter := &amp;MyGreeter&#123;</span><br><span class="line">Msg: message,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> myGreeter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定值"><a href="#绑定值" class="headerlink" title="绑定值"></a>绑定值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyGreeter <span class="keyword">struct</span> &#123;</span><br><span class="line">X   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeMyGreeter</span><span class="params">()</span> *<span class="title">MyGreeter</span></span> &#123;</span><br><span class="line">wire.Build(</span><br><span class="line">wire.Value(&amp;MyGreeter&#123;X: <span class="number">42</span>&#125;),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> &amp;MyGreeter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire_gen.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeMyGreeter</span><span class="params">()</span> *<span class="title">MyGreeter</span></span> &#123;</span><br><span class="line">myGreeter := _wireMyGreeterValue</span><br><span class="line"><span class="keyword">return</span> myGreeter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">_wireMyGreeterValue = &amp;MyGreeter&#123;X: <span class="number">42</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="获取结构体中的字段"><a href="#获取结构体中的字段" class="headerlink" title="获取结构体中的字段"></a>获取结构体中的字段</h3><p>这块比较简单，就是从一个结构体里提取一个Public的field，作为一个<code>Provider</code>，这里给出一个简单的示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    S <span class="keyword">string</span></span><br><span class="line">    N <span class="keyword">int</span></span><br><span class="line">    F <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire_gen.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">injectedMessage</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    wire.Build(</span><br><span class="line">        provideFoo,</span><br><span class="line">        wire.FieldsOf(<span class="built_in">new</span>(Foo), <span class="string">&quot;S&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清理函数"><a href="#清理函数" class="headerlink" title="清理函数"></a>清理函数</h3><p>清理函数利用了函数变量的特性，将资源释放函数抛出来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">provideFile</span><span class="params">(log Logger, path Path)</span> <span class="params">(*os.File, <span class="keyword">func</span>()</span>, <span class="title">error</span>)</span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="keyword">string</span>(path))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    cleanup := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Log(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f, cleanup, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="1-区别类型"><a href="#1-区别类型" class="headerlink" title="1.区别类型"></a>1.区别类型</h3><p>采用类型别名，和标准类型区分开来，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MySQLConnectionString <span class="keyword">string</span></span><br></pre></td></tr></table></figure><h3 id="2-可选结构体"><a href="#2-可选结构体" class="headerlink" title="2. 可选结构体"></a>2. 可选结构体</h3><p>当一个<code>Injector</code>需要多个<code>Provider</code>时，将这些<code>Provider</code>集中到一个<code>Option</code>的结构体，即组合多个参数，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Messages is the set of recommended greetings.</span></span><br><span class="line">    Messages []Message</span><br><span class="line">    <span class="comment">// Writer is the location to send greetings. nil goes to stdout.</span></span><br><span class="line">    Writer io.Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-合理使用Provider-Sets"><a href="#3-合理使用Provider-Sets" class="headerlink" title="3.合理使用Provider Sets"></a>3.合理使用Provider Sets</h3><p>Set集合了多个Provider效率很高，具体实践过程中要根据实际情况出发，参考 <a href="https://github.com/google/wire/blob/main/docs/best-practices.md#provider-sets-in-libraries%E3%80%82">https://github.com/google/wire/blob/main/docs/best-practices.md#provider-sets-in-libraries。</a></p><p>总体来说把握一个原则：<code>In general, prefer small provider sets in a library. </code> 即Set尽量小，多多考虑复合。</p><h3 id="4-Mocking"><a href="#4-Mocking" class="headerlink" title="4.Mocking"></a>4.Mocking</h3><p>Mock这块主要是用于测试，官方给出了两个途径：</p><ul><li>Pass mocks to the injector</li><li>Return the mocks from the injector</li></ul><p>初看可能不容易理解，我们结合实际代码就能了解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 途径1 - 即依赖项以参数注入，这样返回的app和正常的app完全一致</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMockedAppFromArgs</span><span class="params">(mt timer)</span> *<span class="title">app</span></span> &#123;</span><br><span class="line">wire.Build(appSetWithoutMocks)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 途径2 - 内部增加mock的具体field，会与app中的对应变量绑定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMockedApp</span><span class="params">()</span> *<span class="title">appWithMocks</span></span> &#123;</span><br><span class="line">wire.Build(mockAppSet)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> appWithMocks <span class="keyword">struct</span> &#123;</span><br><span class="line">app app</span><br><span class="line">mt  *mockTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体来说，我个人比较推荐使用方案1，它能保证mock对象的使用方式和真实对象完全一致，能屏蔽很多复杂度。在一个复杂系统中，底层的mock对象可以很容易应用到高层。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Github - <a href="https://github.com/google/wire">https://github.com/google/wire</a></p><p>Blog - <a href="https://go.dev/blog/wire">https://go.dev/blog/wire</a> </p><p>Package Doc - <a href="https://pkg.go.dev/github.com/google/wire">https://pkg.go.dev/github.com/google/wire</a></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>通过这一篇，我们能看到<code>wire</code>很多进阶的能力，其实还有一部分特性并未在文档中说明，可以参考package doc学习。</p><p>我更建议大家可以从单元测试的角度切入，去理解这个工具的实践：</p><ol><li><strong>自底向上地考虑wire的实践</strong>：尤其是db、redis这些基础工具，底层的mock会为上层的mock带来巨大便利；</li><li><strong>不断抽离和组合对象中的依赖</strong>：依赖小到某个关键变量、大到某个外部服务，也同时注意组合相似度高的依赖项到<code>Set</code>；</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>wire</code>的核心是依赖注入，对整个框架的可测试性来说是根基，对<code>Go</code>语言这类静态编译的语言尤为重要。</p><p><code>Java</code>语言有一整套强大的<code>JVM</code>引擎，可以在运行时做各种复杂操作；而静态语言在编写时就决定了程序的基本运行方式，从简单性来说很棒 - <strong>所见即所得</strong>，但也说明了不应有复杂的运行时。这时，一个良好的依赖注入机制对<code>Go</code>语言尤为重要。</p><p>那么，<code>Wire</code>引入的DI思想对<code>Go</code>语言来说可以称得上是<code>银弹</code>，但我们更应该重视基础库的<code>Mock</code>能力，毕竟没有底层能力、就没有高层建设。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Wire进阶&quot;&gt;&lt;a href=&quot;#Wire进阶&quot; class=&quot;headerlink&quot; title=&quot;Wire进阶&quot;&gt;&lt;/a&gt;Wire进阶&lt;/h2&gt;&lt;p&gt;通过上一篇的讲解，我们已经掌握&lt;code&gt;wire&lt;/code&gt;工具的基本用法了。但应用在实际工程中，这些基本功能还是有很多局限性。&lt;/p&gt;
&lt;p&gt;在这一篇，我们一起看看Google推出的&lt;code&gt;wire&lt;/code&gt;的进阶使用方法，并总结出一套实践思路。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 10.【初始化代码生成】Wire工具基础讲解</title>
    <link href="http://example.com/2021/12/25/go-tip/go-tip-10/"/>
    <id>http://example.com/2021/12/25/go-tip/go-tip-10/</id>
    <published>2021-12-25T04:00:00.000Z</published>
    <updated>2021-12-28T11:53:19.286Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="Wire概览"><a href="#Wire概览" class="headerlink" title="Wire概览"></a>Wire概览</h2><p>在讲解Kratos的过程中，我们引入了google推出的wire这个工具。我们先阅读一下官方的定义：</p><p><strong>Wire is a code generation tool that automates connecting components using dependency injection.</strong></p><p>从关键词入手：</p><ul><li><strong>code generation 代码生成</strong>，一方面说明了有学习成本，需要了解这个工具的原理；另一方面，也说明了它的目标是消除重复性的coding</li><li><strong>automates connecting components 自动连接组件</strong>，明确了wire工具的目标是将多个对象组合起来</li><li><strong>dependency injection 依赖注入</strong>，指明了wire实现自动连接组件的思想。依赖注入是一个很强大的功能，我会在下面结合具体的case聊一聊</li></ul><p>我们从具体的case着手，学习wire这个工具。</p><span id="more"></span><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><h3 id="常规实现"><a href="#常规实现" class="headerlink" title="常规实现"></a>常规实现</h3><p>我简化了官方的示例，给出一个注释后的代码，方便大家阅读：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// Part-1 Message对象</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMessage</span><span class="params">()</span> <span class="title">Message</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Message(<span class="string">&quot;Hi there!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Part-2 Greeter对象,依赖Message</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeter</span><span class="params">(m Message)</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;Message: m&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Greeter <span class="keyword">struct</span> &#123;</span><br><span class="line">Message Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Greeter)</span> <span class="title">Greet</span><span class="params">()</span> <span class="title">Message</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> g.Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">message := NewMessage()</span><br><span class="line">greeter := NewGreeter(message)</span><br><span class="line"></span><br><span class="line">greeter.Greet()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的调用很直观，分为3步：</p><ol><li>用<code>NewMessage</code>创建<code>Message</code>对象</li><li>通过<code>NewGreeter</code>方法，将<code>Message</code>对象注入到<code>Greeter</code>对象里</li><li>调用<code>Greeter</code>的方法，其实内部用到了前面注入的<code>Message</code>对象</li></ol><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入的详细定义可以参考链接 - <a href="https://en.wikipedia.org/wiki/Dependency_injection%EF%BC%8C%E6%88%91%E5%B0%B1%E4%B8%8D%E8%B5%98%E8%BF%B0%E4%BA%86%E3%80%82%E8%BF%99%E9%87%8C%E6%88%91%E7%94%A8%E5%85%B7%E4%BD%93%E7%9A%84case%E8%BF%9B%E8%A1%8C%E5%AF%B9%E6%AF%94%EF%BC%8C%E6%96%B9%E4%BE%BF%E5%A4%A7%E5%AE%B6%E7%90%86%E8%A7%A3%EF%BC%9A">https://en.wikipedia.org/wiki/Dependency_injection，我就不赘述了。这里我用具体的case进行对比，方便大家理解：</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Greeter <span class="keyword">struct</span> &#123;</span><br><span class="line">Message Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeter</span><span class="params">(m Message)</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;Message: m&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Greeter)</span> <span class="title">Greet</span><span class="params">()</span> <span class="title">Message</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> g.Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Greeter)</span> <span class="title">Greet</span><span class="params">()</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">g.Message = NewMessage()</span><br><span class="line"><span class="keyword">return</span> g.Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完例子，可能大家对DI已经有个初步的概念了，我这边再重复一下关键点：</p><ol><li><code>Greeter</code>的方法<code>Greet()</code>会依赖内部的<code>Message</code>对象，所以我们说 - <strong>Greeter的实现依赖Message</strong></li><li><code>Message</code>的初始化分为两种：创建Greeter对象前和调用Greet方法时，前者被称为<strong>依赖注入</strong>，相当于<strong>在初始化时把依赖项注入进去，而不是使用时再创建</strong>。</li><li>DI，最直接的好处就是可以很方便地调整这个注入项，比如Greet升级成GreetV2，或者单测的MockGreet。</li></ol><h3 id="使用wire生成代码"><a href="#使用wire生成代码" class="headerlink" title="使用wire生成代码"></a>使用wire生成代码</h3><p>我们先安装wire工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/google/wire/cmd/wire</span><br></pre></td></tr></table></figure><p>再编写一个<code>wire.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//+build wireinject</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/google/wire&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">wire.Build(NewGreeter, NewMessage)</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行命令<code>wire gen</code>生成wire_gen.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code generated by Wire. DO NOT EDIT.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate go run github.com/google/wire/cmd/wire</span></span><br><span class="line"><span class="comment">//+build !wireinject</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// Injectors from wire.go:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="title">Greeter</span></span> &#123;</span><br><span class="line">message := NewMessage()</span><br><span class="line">greeter := NewGreeter(message)</span><br><span class="line"><span class="keyword">return</span> greeter</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，可以在<code>main</code>函数里使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">greeter := InitializeGreeter()</span><br><span class="line"></span><br><span class="line">greeter.Greet()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wire的大致实现"><a href="#wire的大致实现" class="headerlink" title="wire的大致实现"></a>wire的大致实现</h3><p>可以看到，wire这个工具基本能力就体现在<code>wire.Build(NewGreeter, NewMessage)</code>里，把这里面的两个初始化函数串联了起来，形成了一个整体的InitializeGreeter。</p><h2 id="基本扩展"><a href="#基本扩展" class="headerlink" title="基本扩展"></a>基本扩展</h2><h3 id="带error的处理"><a href="#带error的处理" class="headerlink" title="带error的处理"></a>带error的处理</h3><p>我们新增一个方法，初始化结果里增加一个error返回值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Part-3 Greeter对象,依赖Message,并且返回error方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeterV2</span><span class="params">(m Message)</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> m == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;, errors.New(<span class="string">&quot;empty message&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;Message: m&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>wire.go</code>里调整函数返回值增加一个error</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeter</span><span class="params">()</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line">wire.Build(NewGreeterV2, NewMessage)</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在<code>wire_gen.go</code>里生成了带error的新方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeterV2</span><span class="params">()</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line">message := NewMessage()</span><br><span class="line">greeter, err := NewGreeterV2(message)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> greeter, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增加一个入参"><a href="#增加一个入参" class="headerlink" title="增加一个入参"></a>增加一个入参</h3><p>我们新增一个方法，增加一个name的入参</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Part-3 Greeter对象,依赖Message和参数name,并且返回error方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeterV3</span><span class="params">(m Message, name <span class="keyword">string</span>)</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;, errors.New(<span class="string">&quot;empty name&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;Message: m&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wire.go</code>里也增加一个<code>string</code>类型的入参（变量名可以任意）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeterV3</span><span class="params">(greetName <span class="keyword">string</span>)</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line">wire.Build(NewGreeterV3, NewMessage)</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后生成对应的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeGreeterV3</span><span class="params">(greetName <span class="keyword">string</span>)</span> <span class="params">(Greeter, error)</span></span> &#123;</span><br><span class="line">message := NewMessage()</span><br><span class="line">greeter, err := NewGreeterV3(message, greetName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Greeter&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> greeter, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Provider和Injector"><a href="#Provider和Injector" class="headerlink" title="Provider和Injector"></a>Provider和Injector</h2><p>Wire里面提了两个关键性的概念，为了方便大家阅读文档时能快速理解，我这里再专门说明下：</p><ul><li><strong>Provider</strong> - 即各个初始化函数，如<code>NewXXX</code></li><li><strong>Injector</strong> - 即Initial的函数，将各个Provider注入到wire中，生成一个新的初始化函数</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Github - <a href="https://github.com/google/wire">https://github.com/google/wire</a></p><p>DI - <a href="https://en.wikipedia.org/wiki/Dependency_injection">https://en.wikipedia.org/wiki/Dependency_injection</a></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><code>wire</code>工具的实现逻辑很清晰 - <strong>按一定规则组装多个Provider到Injector中</strong>。</p><p>生成的代码 <strong>结构简单而具有规律</strong>，所以用代码生成技术很有价值，既减少了重复性工作，又能引入DI的思想方便程序的扩展。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，我们对wire的基础用法已经了然于胸，但更多的价值需要深入理解DI这个概念，最好能结合到具体的工程实践上。如果你对这块还没有太深刻的理解，建议结合网上的相关资料了解DI在工程中的价值，会让你使用wire这个工具时更有感触。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Wire概览&quot;&gt;&lt;a href=&quot;#Wire概览&quot; class=&quot;headerlink&quot; title=&quot;Wire概览&quot;&gt;&lt;/a&gt;Wire概览&lt;/h2&gt;&lt;p&gt;在讲解Kratos的过程中，我们引入了google推出的wire这个工具。我们先阅读一下官方的定义：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Wire is a code generation tool that automates connecting components using dependency injection.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从关键词入手：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;code generation 代码生成&lt;/strong&gt;，一方面说明了有学习成本，需要了解这个工具的原理；另一方面，也说明了它的目标是消除重复性的coding&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;automates connecting components 自动连接组件&lt;/strong&gt;，明确了wire工具的目标是将多个对象组合起来&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dependency injection 依赖注入&lt;/strong&gt;，指明了wire实现自动连接组件的思想。依赖注入是一个很强大的功能，我会在下面结合具体的case聊一聊&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们从具体的case着手，学习wire这个工具。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 8.【浅析微服务框架】Go-Micro概览</title>
    <link href="http://example.com/2021/12/20/go-tip/go-tip-8/"/>
    <id>http://example.com/2021/12/20/go-tip/go-tip-8/</id>
    <published>2021-12-20T04:00:00.000Z</published>
    <updated>2021-12-20T11:27:55.226Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="Go-Micro框架概况"><a href="#Go-Micro框架概况" class="headerlink" title="Go Micro框架概况"></a>Go Micro框架概况</h2><p>截止到本文发布时，Go-Micro在github上的star数达到了10.8k，也已经累计发布了v1、v2、v3这三个大版本，目前前两个已经停止维护。</p><p>本文主要以最新的技术视角去看待这个框架，所以会集中目光在v3版本。本文包含大量个人的主观观点，请大家选择性听取，更欢迎与我讨论。</p><span id="more"></span><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><strong>Micro is a distributed cloud operating system built for real world programming.</strong></p><p>Micro框架的定义里有个关键词：distributed cloud operating system - 分布式云操作系统。这是一个很<strong>重量级</strong>的定义，我们根据它的官方介绍了解，从这10个核心模块入手，理解这个框架的功能。</p><blockquote><p>本人对这个框架研究不深，主要参考官方提供的资料，如果有认知偏差，欢迎大家多多指正~</p></blockquote><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/micro-3.0.png" alt="micro"></p><h2 id="Micro的十大核心模块"><a href="#Micro的十大核心模块" class="headerlink" title="Micro的十大核心模块"></a>Micro的十大核心模块</h2><h3 id="1-Auth-认证授权"><a href="#1-Auth-认证授权" class="headerlink" title="1. Auth 认证授权"></a>1. Auth 认证授权</h3><p>认证授权是一个很基础的模块，但放在一个微服务的框架里，我个人认为不太合适。为什么呢？</p><ol><li><strong>大部分的微服务的Auth模块，往往是网关层的一种能力</strong>。也就是说，一般我们在请求入口处做一次Auth即可，接下来我们就认为消息可靠、无需检查；</li><li><strong>如果Auth模块必须嵌入到每个服务，更应该采用Service Mesh的side-car模式</strong>。借用Istio的能力，尽可能不要侵入应用的代码；</li><li><strong>Auth</strong>会有很多方式，ACL/RBAC/ABAC，往往会和公司内部的系统强结合（如人员管理），抽象为一个组件很难满足通用性和扩展性；</li></ol><p>所以，常规的微服务框架中，会有个专门的Auth服务，管理权限、认证等功能。</p><h3 id="2-Build编译模块"><a href="#2-Build编译模块" class="headerlink" title="2.Build编译模块"></a>2.Build编译模块</h3><p>编译功能放在微服务框架不合适，它更应该与CICD结合起来，交由专门的编译部署平台，实现快速交付。</p><h3 id="3-Broker消息管道"><a href="#3-Broker消息管道" class="headerlink" title="3.Broker消息管道"></a>3.Broker消息管道</h3><p>从官方的介绍来看，Broker基本与MQ的功能一致，即发布和订阅消息。</p><p>作为跨服务异步通信的主流方式，MQ在中大型工程中被广泛使用，Broker概念的抽象可以让使用者不用过于关心底层具体采用的技术。</p><h3 id="4-Config动态配置"><a href="#4-Config动态配置" class="headerlink" title="4.Config动态配置"></a>4.Config动态配置</h3><p>Config定义为动态配置和密码，可类比为配置中心，或者K8s中的ConfigMap与Secret。这个模块的功能更多的是对配置能力的抽象。</p><h3 id="5-Events事件流"><a href="#5-Events事件流" class="headerlink" title="5.Events事件流"></a>5.Events事件流</h3><p>事件流中有三个关键词：<strong>顺序、重放和持久化</strong>。这三个特性与MQ的特性基本一致，可以认为是Broker一个具体的实践。</p><p>这里抽象出一个事件流的概念，主要强调的是 <strong>可靠性</strong>。</p><h3 id="6-Network网络"><a href="#6-Network网络" class="headerlink" title="6.Network网络"></a>6.Network网络</h3><p>网络是计算机中很大的一块，这里特指服务内的网络隔离与路由。我个人认为个定义过于宽泛，很容易引起误解。</p><p>从云原生的划分来看，这块更应该放在Service Mesh部分。</p><h3 id="7-Registry注册"><a href="#7-Registry注册" class="headerlink" title="7.Registry注册"></a>7.Registry注册</h3><p>服务注册这部分包括两块：</p><ol><li>服务提供方把服务信息注册到中心节点</li><li>服务调用方从中心节点获取服务提供方的信息进行调用</li></ol><p>这服务注册与发现的工作，K8s等这类Paas平台已经封装得很完善了；而如果公司没有提供Paas平台，也可以通过etcd等注册中心快速实现。这部分也不建议重复建设。</p><h3 id="8-Runtime运行时"><a href="#8-Runtime运行时" class="headerlink" title="8.Runtime运行时"></a>8.Runtime运行时</h3><p>云时代以容器为核心构建服务，进程的声明周期就可以通过Pod快捷管理。官方对Runtime的描述，更像是CICD+K8s调度服务的综合描述。</p><h3 id="9-Store存储"><a href="#9-Store存储" class="headerlink" title="9.Store存储"></a>9.Store存储</h3><p>官方定义为支持过期+CRUD的K-V存储，用来保证无状态性。</p><p>我们可以很直接与Redis类比，相当于<strong>把有状态的数据放在公共的缓存里</strong>。</p><h3 id="10-Plugins插件化"><a href="#10-Plugins插件化" class="headerlink" title="10.Plugins插件化"></a>10.Plugins插件化</h3><p>插件化的概念很宽，框架并没有明确说明。</p><p>从实现来说，任何一个组件最好都可以支持插件化，如router、存储、消息通知等，可以支持自定义log plugins。</p><h2 id="模块总览"><a href="#模块总览" class="headerlink" title="模块总览"></a>模块总览</h2><p>前面的十大模块有很多与云平台的基础功能重合。为了更具有针对性地讨论，我们先聊清楚前提，这样才能更聚焦于框架上。</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>从当前主流与未来趋势来看，<strong>微服务框架应基于基础云平台能力，不应有过多的交集</strong>。基础平台能力主要包括两块：</p><ul><li><p>整套Devops流程（如代码版本管理、编译、部署、运行）</p></li><li><p>基础的云Paas平台（以k8s为代表）</p></li></ul><blockquote><p>虽然对很多基础建设不完善的团队来说，上面两者的落地会有挑战，但从长远发展来看，不应将由基础平台的维护的功能交由微服务框架。</p><p>而如果追求短期内快速落地项目，我更建议这些团队借主流公有云服务的能力。</p></blockquote><h3 id="三大分类"><a href="#三大分类" class="headerlink" title="三大分类"></a>三大分类</h3><ol><li>不合适引入到微服务框架中：Build、Config、Runtime</li><li>通过Service Mesh实现：Auth、Network、Registry</li><li>微服务框架的关键特性：Broker、Events、Store、Plugins</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>Micro框架提供了二进制工具micro，可以查看server、config、store等信息。虽然看起来使用起来很方便，但其实有诸多限制；比如说，线上环境的服务器，开发者往往没有权限登录。</p><p>从整体来说，Micro是一个限制性很大的框架，主要特点是：</p><ol><li>适合基础平台不完善的团队，框架提供了很多基础平台的功能；</li><li>使用框架的初始成本低，但后续切换成本、排查问题成本极高，高度依赖micro的生态；</li><li>Micro屏蔽了底层实现细节，虽然能在一定程度上提效，但遇到性能、扩展性、底层原理等问题时，很难解决。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整体来说，我不建议以Micro作为新项目切入时的框架。如果用一个词概括原因，我会用 - <strong>不够透明</strong>。一方面，Micro的门槛不低、需要了解它一整套特有的概念；另一方面，后续团队的维护成本也很高，对个人提升也很有限。</p><p>维护成本这个概念也许有的同学不能理解，我以Store为例（假设背后选用Redis作为存储）</p><ul><li>如果采用Micro框架，我们必须阅读相关代码（重点是封装部分），了解它的封装与底层，结合micro+redis工具排查</li><li>如果调用的是Redis的官方库，那只要保证调用方式正确，那就只需要你掌握Redis的原理即可</li></ul><p>前者的排查链路需要框架+redis，后者只需要排查redis。我个人对编程语言框架有一个认知：<strong>不应过度屏蔽通用中间件的细节，如Redis、Kafka、MySQL等，往往直接在中间件查询问题，比通过框架查询问题更为高效</strong>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Github - <a href="https://github.com/micro/micro">https://github.com/micro/micro</a></p><p>文档 - <a href="https://micro.mu/introduction">https://micro.mu/introduction</a></p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Go-Micro框架概况&quot;&gt;&lt;a href=&quot;#Go-Micro框架概况&quot; class=&quot;headerlink&quot; title=&quot;Go Micro框架概况&quot;&gt;&lt;/a&gt;Go Micro框架概况&lt;/h2&gt;&lt;p&gt;截止到本文发布时，Go-Micro在github上的star数达到了10.8k，也已经累计发布了v1、v2、v3这三个大版本，目前前两个已经停止维护。&lt;/p&gt;
&lt;p&gt;本文主要以最新的技术视角去看待这个框架，所以会集中目光在v3版本。本文包含大量个人的主观观点，请大家选择性听取，更欢迎与我讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 9.【浅析微服务框架】Kratos概览</title>
    <link href="http://example.com/2021/12/20/go-tip/go-tip-9/"/>
    <id>http://example.com/2021/12/20/go-tip/go-tip-9/</id>
    <published>2021-12-20T04:00:00.000Z</published>
    <updated>2021-12-27T12:50:20.363Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="Kratos框架概况"><a href="#Kratos框架概况" class="headerlink" title="Kratos框架概况"></a>Kratos框架概况</h2><p>截止到本文发布时，Kratos在github上的star数达到了15.9k。其中，在2021年7月，也正式推出了v2这个大版本。</p><p>本人并不是Kratos的重度使用者，主要会通过官方介绍对它的特性进行剖析。接下来的内容依旧包含大量主观认知，可能会对官方文档有理解上的偏差，欢迎大家与我讨论。</p><span id="more"></span><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><strong>Kratos is a web application framework with expressive, elegant syntax. We’ve already laid the foundation.</strong></p><p>Kratos的官网上的介绍比较朴实，但有两个词值得我们关注 - <strong>富有表现力的</strong>、<strong>优雅的</strong>。一般在微服务框架里，我们看到最多的形容词，往往来自下面两个维度：</p><ul><li>开发者维度：比如简单易用、组件丰富</li><li>工程化维度：比如高效、通用性强</li></ul><p>但Kratos的切入点是框架层面的能力，尤其是<code>elegant</code>这个词，隐含了作者对代码洁癖的追求。接下来，我们具体剖析这个框架。</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/kratos.png" alt="Kratos"></p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p> 参考 <a href="https://go-kratos.dev/docs/intro/layout%EF%BC%8C%E6%88%91%E4%BB%AC%E5%AF%B9%E5%85%B3%E9%94%AE%E7%9B%AE%E5%BD%95%E5%81%9A%E4%B8%80%E4%B8%8B%E5%88%86%E6%9E%90%E3%80%82">https://go-kratos.dev/docs/intro/layout，我们对关键目录做一下分析。</a></p><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── api // 下面维护了微服务使用的proto文件以及根据它们所生成的go文件</span><br><span class="line">│  └── helloworld</span><br><span class="line">│      └── v1</span><br><span class="line">│          ├── error_reason.pb.go</span><br><span class="line">│          ├── error_reason.proto</span><br><span class="line">│          ├── error_reason.swagger.json</span><br><span class="line">│          ├── greeter.pb.go</span><br><span class="line">│          ├── greeter.proto</span><br><span class="line">│          ├── greeter.swagger.json</span><br><span class="line">│          ├── greeter_grpc.pb.go</span><br><span class="line">│          └── greeter_http.pb.go</span><br></pre></td></tr></table></figure><p>从目录结构看到，里面包含了三类文件：</p><ul><li><code>*.proto</code> 原始IDL文件</li><li><code>*.go</code> 利用protoc工具生成的go文件，包括http和grpc的服务相关代码</li><li><code>*.swagger.json</code> 利用工具生成的swagger接口文档</li></ul><p>这部分的实现全是基于开源的<code>protobuf</code>解决方案，对开发者很友好。这里提一个点：<strong>尽可能地用目录区分原始IDL文件与生成的文件</strong>。我简单列举两个优点：</p><ol><li>让开发者更聚焦于原始IDL文件 - 其余文件均是从proto文件自动生成出来的，不应过多关注。</li><li>有利于IDL文件的传播 - proto文件可以快速生成其余语言的代码，独立文件夹更有利于扩散给外部调用者。</li></ol><h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── cmd  // 整个项目启动的入口文件</span><br><span class="line">│  └── server</span><br><span class="line">│      ├── main.go</span><br><span class="line">│      ├── wire.go  // 我们使用wire来维护依赖注入</span><br><span class="line">│      └── wire_gen.go</span><br></pre></td></tr></table></figure><p>cmd简单来说就是main函数入口。</p><h3 id="internal-biz"><a href="#internal-biz" class="headerlink" title="internal/biz"></a>internal/biz</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── internal  // 该服务所有不对外暴露的代码，通常的业务逻辑都在这下面，使用internal避免错误引用</span><br><span class="line">│   ├── biz   // 业务逻辑的组装层，类似 DDD 的 domain 层，data 类似 DDD 的 repo，而 repo 接口在这里定义，使用依赖倒置的原则。</span><br><span class="line">│  │  ├── README.md</span><br><span class="line">│  │  ├── biz.go</span><br><span class="line">│  │  └── greeter.go</span><br></pre></td></tr></table></figure><p>internal目录是go语言的一个特性，内部代码不会暴露给外部。</p><p>biz被理解为业务逻辑的组装层，如果能正确地理解这个概念，就能把握整个框架的分层设计了。我们从两个关键词来理解这个biz目录的设计：</p><ol><li>业务逻辑 - 业务逻辑包括但不限于单个对象的增删改查，会处理很多进阶的内容，例如：<ol><li>复合对象操作，如操作对象A后，再操作对象B</li><li>特殊逻辑，如创建A对象失败时，等待10s后再创建</li><li>并发策略，如并发访问对象A和对象B</li></ol></li><li>组装层 - 重点在于组装底层基础的代码，如CRUD，而不是在biz层直接去操作数据库等</li></ol><p>整体来说，biz这一层应重点考虑<strong>业务逻辑的信息密度</strong>，让业务开发者的重点放在这一层，把基础实现往下沉。</p><h3 id="internal-data"><a href="#internal-data" class="headerlink" title="internal/data"></a>internal/data</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── internal  // 该服务所有不对外暴露的代码，通常的业务逻辑都在这下面，使用internal避免错误引用</span><br><span class="line">│  ├── data  // 业务数据访问，包含 cache、db 等封装，实现了 biz 的 repo 接口。我们可能会把 data 与 dao 混淆在一起，data 偏重业务的含义，它所要做的是将领域对象重新拿出来，我们去掉了 DDD 的 infra层。</span><br><span class="line">│  │  ├── README.md</span><br><span class="line">│  │  ├── data.go</span><br><span class="line">│  │  └── greeter.go</span><br></pre></td></tr></table></figure><p>data被理解为缓存与数据库的封装，与底层数据存储相关，一般都是跟着数据库的类型适配。</p><h3 id="internal-server"><a href="#internal-server" class="headerlink" title="internal/server"></a>internal/server</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── internal  // 该服务所有不对外暴露的代码，通常的业务逻辑都在这下面，使用internal避免错误引用</span><br><span class="line">│  ├── server  // http和grpc实例的创建和配置</span><br><span class="line">│  │  ├── grpc.go</span><br><span class="line">│  │  ├── http.go</span><br><span class="line">│  │  └── server.go</span><br></pre></td></tr></table></figure><p>前面IDL文件（protobuf）生成了RPC方法的接口（interface），这里就是RPC方法的具体实现。</p><h3 id="internal-service"><a href="#internal-service" class="headerlink" title="internal/service"></a>internal/service</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── internal  // 该服务所有不对外暴露的代码，通常的业务逻辑都在这下面，使用internal避免错误引用</span><br><span class="line">│  └── service  // 实现了 api 定义的服务层，类似 DDD 的 application 层，处理 DTO 到 biz 领域实体的转换(DTO -&gt; DO)，同时协同各类 biz 交互，但是不应处理复杂逻辑</span><br><span class="line">│      ├── README.md</span><br><span class="line">│      ├── greeter.go</span><br><span class="line">│      └── service.go</span><br></pre></td></tr></table></figure><p>service被定义成对数据结构的处理层。</p><h2 id="架构概览"><a href="#架构概览" class="headerlink" title="架构概览"></a>架构概览</h2><p>Kratos里包含了大量组件，很多模块都与前面Go-Micro的有共同之处，我就不再赘述了。而且通过上面的目录层面的划分，重点是api -&gt; server -&gt; service -&gt; biz -&gt; data 的调用逻辑。</p><p>这里，我们关注两个重要特性：</p><ol><li>wire - <a href="https://go-kratos.dev/docs/guide/wire">https://go-kratos.dev/docs/guide/wire</a></li><li>ent - <a href="https://go-kratos.dev/docs/guide/ent">https://go-kratos.dev/docs/guide/ent</a></li></ol><p>这两块内容比较多，我会单独出两篇文章进行分享。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Github - <a href="https://github.com/go-kratos/kratos">https://github.com/go-kratos/kratos</a> </p><p>文档 - <a href="https://go-kratos.dev/docs/">https://go-kratos.dev/docs/</a></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>Kratos是一个典型的 <strong>基于完善的基建</strong> 而成的Go语言开发框架，可以发现它有3个关键点：</p><ol><li>RPC层复用protobuf的能力</li><li>底层依赖Kubernetes的能力</li><li>各类工具复用开源库的能力</li></ol><p>很多中大型公司的内部框架都是按照这种思路实现的，只是会封装一些公司通用能力，比如通用的RPC能力。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整体来说，Kratos的实现与我推崇的理念基本一致，即复用生态+平台的能力。</p><p>在一些细节的技术选型上会存在差异，例如Kratos更注重Bilibili公司的历史沉淀，而我会更关注社区的当前主流实现，并抛开包袱、尽可能地实现自动化。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Kratos框架概况&quot;&gt;&lt;a href=&quot;#Kratos框架概况&quot; class=&quot;headerlink&quot; title=&quot;Kratos框架概况&quot;&gt;&lt;/a&gt;Kratos框架概况&lt;/h2&gt;&lt;p&gt;截止到本文发布时，Kratos在github上的star数达到了15.9k。其中，在2021年7月，也正式推出了v2这个大版本。&lt;/p&gt;
&lt;p&gt;本人并不是Kratos的重度使用者，主要会通过官方介绍对它的特性进行剖析。接下来的内容依旧包含大量主观认知，可能会对官方文档有理解上的偏差，欢迎大家与我讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 13.监控组件Prometheus的引入</title>
    <link href="http://example.com/2021/12/12/go-framework/go-framework-13/"/>
    <id>http://example.com/2021/12/12/go-framework/go-framework-13/</id>
    <published>2021-12-12T04:00:00.000Z</published>
    <updated>2021-12-14T11:02:59.538Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>作为云原生程序监控的标准组件，Prometheus支持了各类Paas、Saas平台，并提供了一整套采集+存储+展示的解决方案。</p><p>今天我们专注于自定义服务中的Prometheus的监控，在框架中引入Prometheus相关的组件。关于更细致的使用方式，我会给出相关的链接，有兴趣进一步学习Prometheus的同学可以边参考资料边实践。</p><span id="more"></span><h2 id="v0-8-0：监控组件Prometheus的引入"><a href="#v0-8-0：监控组件Prometheus的引入" class="headerlink" title="v0.8.0：监控组件Prometheus的引入"></a>v0.8.0：监控组件Prometheus的引入</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.8.0">https://github.com/Junedayday/micro_web_service/tree/v0.8.0</a> </p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>引入prometheus组件，提供标准与自定义的metrics。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>metrics接口的开放</li><li>示例counter的初始化</li><li>示例counter的计数</li><li>学习Prometheus监控使用方法</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">    |-- order                            对应idl/order服务，同上</span><br><span class="line">     |-- swagger.json                    openapiv2的接口文档</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">   |-- order                           业务order定义，同时干</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">   |-- metrics                         新增：自定义监控指标</span><br><span class="line">   |-- model                           model层基本定义由gormer自动生成</span><br><span class="line">   |-- mysql                           MySQL连接，支持日志打印</span><br><span class="line">   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义，新增参数校验逻辑</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- format.sh                      新增：格式化代码的脚本</span><br><span class="line">|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- gormer.yaml                    将gormer中的参数移动到这里</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br><span class="line">|-- swagger.sh                     生成openapiv2的相关脚本</span><br></pre></td></tr></table></figure><h2 id="1-metrics接口的开放"><a href="#1-metrics接口的开放" class="headerlink" title="1.metrics接口的开放"></a>1.metrics接口的开放</h2><p>Prometheus官方推荐的metrics开放方式为http。将它引入到程序中的代码如下面几行，不过有几个点值得注意：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  mux := http.NewServeMux()</span><br><span class="line">  mux.Handle(<span class="string">&quot;/metrics&quot;</span>, promhttp.Handler())</span><br><span class="line">  http.ListenAndServe(fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, config.Viper.GetInt(<span class="string">&quot;server.prometheus.port&quot;</span>)), mux)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><ol><li><code>http.ListenAndServe</code> 函数是阻塞的，所以需要开一个goroutine。</li><li>为了保证Prometheus的指标监控不与应用的http服务冲突，这里采用了端口隔离，也就是另起一个http服务。</li><li><code>Go</code> 的 <code>http</code> 库如果要支持多port的运行，需要引入<code>mux</code>的概念；默认会注册到http库中的<code>DefaultServeMux</code>。</li></ol><p>为了验证我们的metrics已经正常running，我们可以调用一个curl请求查看一下（具体返回结果不细讲）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例的metrics起在8083端口</span></span><br><span class="line">curl --request GET &#x27;http://127.0.0.1:8083/metrics&#x27;</span><br></pre></td></tr></table></figure><h2 id="2-示例counter的初始化"><a href="#2-示例counter的初始化" class="headerlink" title="2.示例counter的初始化"></a>2.示例counter的初始化</h2><p>我们先以一个最简单的counter累加器为例，实现一个自定的指标监控。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> metrics</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/prometheus/client_golang/prometheus&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">prometheus.MustRegister(OrderList)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> OrderList = prometheus.NewCounterVec(</span><br><span class="line">prometheus.CounterOpts&#123;</span><br><span class="line">Name: <span class="string">&quot;order_list_counter&quot;</span>,</span><br><span class="line">Help: <span class="string">&quot;List Order Count&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">&quot;service&quot;</span>&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>代码的逻辑比较简单，我们注意以下三个关键点：</p><ol><li><code>OrderLis</code>t 是一个全局变量，方便使用方调用；</li><li><code>NewCounterVec</code> 表示这个Counter是一个向量，包括了两块 - opts和labels<ol><li>opts包括Name和Help，Name是metrics唯一的名称，Help是metrics的帮助信息</li><li>labels是用来过滤、聚合功能的关键参数，提前声明有利于存储端进行优化（可类比数据库索引）</li></ol></li><li><code>prometheus.MustRegister(OrderList)</code> 是将metrics注册到prometheus的全局变量里，与main函数里的注册对应</li></ol><h2 id="3-示例counter的计数"><a href="#3-示例counter的计数" class="headerlink" title="3.示例counter的计数"></a>3.示例counter的计数</h2><p>从指标的定义可以看到，我们设计的这个metrics是为了统计订单查询接口的次数，于是我们在代码侧引入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">ListOrders</span><span class="params">(ctx context.Context, req *order.ListOrdersRequest)</span> <span class="params">(*order.ListOrdersResponse, error)</span></span> &#123;</span><br><span class="line">metrics.OrderList.With(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;service&quot;</span>: <span class="string">&quot;example&quot;</span>&#125;).Inc()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是一个链式调用，包括两块：</p><ol><li>With，也就是label信息，用一个map[string]string填入，是个通用功能；</li><li>Inc，即计数+1，这个方法和具体的metrics类型相关。</li></ol><p>接着，我们调用两次对应的接口，可以从metrics信息中看到下面的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># HELP order_list_counter List Order Count</span><br><span class="line"># TYPE order_list_counter counter</span><br><span class="line">order_list_counter&#123;service=&quot;example&quot;&#125; 2</span><br></pre></td></tr></table></figure><p>除非程序重启，否则这个Counter会不断累加。</p><h2 id="4-学习Prometheus监控使用方法"><a href="#4-学习Prometheus监控使用方法" class="headerlink" title="4.学习Prometheus监控使用方法"></a>4.学习Prometheus监控使用方法</h2><p>Prometheus监控埋点的使用方式比较直观，上手难度不大。如果你希望进一步了解这块，我推荐两个核心的资料：</p><ul><li>Prometheus官网 - <a href="https://prometheus.io/docs/introduction/overview/">https://prometheus.io/docs/introduction/overview/</a></li><li>Prometheus的Go语言官方库 - <a href="https://github.com/prometheus/client_golang">https://github.com/prometheus/client_golang</a></li></ul><p>这两份资料是英文的，可能对部分同学来说学成本比较高，可以考虑先去搜索一些中文翻译文档、了解梗概后，再回过头来看这两篇。如果你希望深入了解Prometheus，必须要仔细看这两块内容，保证实时性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对接Prometheus的自定义metrics是一个应用程序很常见的功能，例如业务指标埋点。在埋点的过程中，有一个大误区需要刚接触Prometheus的同学注意：把计算的工作交给Prometheus引擎，而不要放在你开发的程序里。</p><p>例如，你希望计算某个订单的成功率，你不应该用一个metrics对应成功率，而应该给出两个指标，即订单总量和成功的订单量（也可以放在一个指标中，用label区分成功与否），交由Prometheus进行计算，方便后续的各种metrics的扩展。</p><p>更多Prometheus的实践，需要大家边学习边实践。如果反响热烈，我也会抽几讲谈谈Prometheus。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;作为云原生程序监控的标准组件，Prometheus支持了各类Paas、Saas平台，并提供了一整套采集+存储+展示的解决方案。&lt;/p&gt;
&lt;p&gt;今天我们专注于自定义服务中的Prometheus的监控，在框架中引入Prometheus相关的组件。关于更细致的使用方式，我会给出相关的链接，有兴趣进一步学习Prometheus的同学可以边参考资料边实践。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 12.ORM层的自动抽象与自定义方法的扩展</title>
    <link href="http://example.com/2021/12/02/go-framework/go-framework-12/"/>
    <id>http://example.com/2021/12/02/go-framework/go-framework-12/</id>
    <published>2021-12-02T04:00:00.000Z</published>
    <updated>2021-12-06T09:35:34.914Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>随着接口参数校验功能的完善，我们能快速定位到接口层面的参数问题；而应用服务的分层代码，也可以通过log的trace-id发现常见的业务逻辑问题。</p><p>但在最底层与数据库的操作，也就是对GORM的使用，经常会因为我们不了解ORM的一些细节，导致对数据的CRUD失败，或者没有达到预期效果。这时，我们希望能在ORM这一层也有一个通用的解决方案，来加速问题的排查。</p><p>趁这个机会，我们也对<code>gormer</code>这个工具再做一次迭代，添加新的功能。</p><span id="more"></span><h2 id="v0-7-2：ORM层的自动抽象与自定义方法的扩展"><a href="#v0-7-2：ORM层的自动抽象与自定义方法的扩展" class="headerlink" title="v0.7.2：ORM层的自动抽象与自定义方法的扩展"></a>v0.7.2：ORM层的自动抽象与自定义方法的扩展</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.7.2">https://github.com/Junedayday/micro_web_service/tree/v0.7.2</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>gormer工具支持interface的抽象与自定义方法的扩展，并具备日志打印功能。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>model层的自动抽象方案</li><li>dao层的代码实现</li><li>MySQL的SQL打印</li><li>关于gormer工具的迭代</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">    |-- order                            对应idl/order服务，同上</span><br><span class="line">     |-- swagger.json                    openapiv2的接口文档</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">   |-- order                           业务order定义，同时干</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">   |-- model                           修改：model层基本定义由gormer自动生成</span><br><span class="line">   |-- mysql                           修改：MySQL连接，支持日志打印</span><br><span class="line">   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义，新增参数校验逻辑</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- gormer.yaml                    将gormer中的参数移动到这里</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br><span class="line">|-- swagger.sh                     生成openapiv2的相关脚本</span><br></pre></td></tr></table></figure><h2 id="1-model层的自动抽象方案"><a href="#1-model层的自动抽象方案" class="headerlink" title="1.model层的自动抽象方案"></a>1.model层的自动抽象方案</h2><p>之前，我们在dao层已经实现了基本的CRUD相关代码，所以实现一个model层的定义很简单。但考虑到扩展性，也就是这个model层不仅仅需要简单的CRUD代码，还可能需要一些类似于<code>group by</code>等复杂sql，甚至包括子查询。</p><p>这时候，如果考虑全部用<code>gormer</code>工具自动生成的方案，那成本会很高，所以更建议分开维护的方案：简单的CRUD用自动代码生成的方式，而复杂SQL调用GORM库自行实现。我们来阅读代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *.go 自动生成的代码，标准方法</span></span><br><span class="line"><span class="keyword">type</span> OrderModel <span class="keyword">interface</span> &#123;</span><br><span class="line">AddOrder(ctx context.Context, order *gormer.Order) (err error)</span><br><span class="line">QueryOrders(ctx context.Context, pageNumber, pageSize <span class="keyword">int</span>, condition *gormer.OrderOptions) (orders []gormer.Order, err error)</span><br><span class="line">CountOrders(ctx context.Context, condition *gormer.OrderOptions) (count <span class="keyword">int64</span>, err error)</span><br><span class="line">UpdateOrder(ctx context.Context, updated, condition *gormer.OrderOptions) (err error)</span><br><span class="line">DeleteOrder(ctx context.Context, condition *gormer.OrderOptions) (err error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement Your Method in ext model</span></span><br><span class="line">OrderExtModel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *_ext.go 扩展方法</span></span><br><span class="line"><span class="keyword">type</span> OrderExtModel <span class="keyword">interface</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保证自定义的ext代码不被覆盖，在gormer的代码里添加如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果extFile已经存在，则不要覆盖</span></span><br><span class="line"><span class="keyword">if</span> _, err = os.Stat(extFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// 创建ext文件的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-dao层的代码实现"><a href="#2-dao层的代码实现" class="headerlink" title="2.dao层的代码实现"></a>2.dao层的代码实现</h2><p>dao层的代码基本同model层，分为<code>*.go</code>和<code>*_ext.go</code>两个。</p><p>为了保证dao层实现了model层的代码，我们也增加了一行代码，方便我们在编译期保证实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ model.OrderModel = NewOrderRepo(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h2 id="3-MySQL的SQL打印"><a href="#3-MySQL的SQL打印" class="headerlink" title="3.MySQL的SQL打印"></a>3.MySQL的SQL打印</h2><p>在GORM工具中，提供了一个callback的方式，让用户添加自定义的插件。具体可以参考 <a href="https://gorm.io/zh_CN/docs/write_plugins.html%E3%80%82%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%88%86%E4%B8%8B%E9%9D%A2%E4%B8%A4%E6%AD%A5%EF%BC%9A">https://gorm.io/zh_CN/docs/write_plugins.html。主要实现分下面两步：</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 - 操作SQL时，将ctx传入其中，用来传递一些通用参数，如traceid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">AddOrder</span><span class="params">(ctx context.Context, order *gormer.Order)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">repo.db.WithContext(ctx).</span><br><span class="line">Table(gormer.OrderTableName).</span><br><span class="line">Create(order)</span><br><span class="line">err = repo.db.Error</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 - 在操作数据库后，注册对应的插件afterLog，用来打印SQL日志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitGorm</span><span class="params">(user, password, addr <span class="keyword">string</span>, dbname <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">dsn := fmt.Sprintf(<span class="string">&quot;%s:%s@tcp(%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>,</span><br><span class="line">user, password, addr, dbname)</span><br><span class="line">GormDB, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束后</span></span><br><span class="line">_ = GormDB.Callback().Create().After(<span class="string">&quot;gorm:after_create&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line">_ = GormDB.Callback().Query().After(<span class="string">&quot;gorm:after_query&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line">_ = GormDB.Callback().Delete().After(<span class="string">&quot;gorm:after_delete&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line">_ = GormDB.Callback().Update().After(<span class="string">&quot;gorm:after_update&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line">_ = GormDB.Callback().Row().After(<span class="string">&quot;gorm:row&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line">_ = GormDB.Callback().Raw().After(<span class="string">&quot;gorm:raw&quot;</span>).Register(callBackLogName, afterLog)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callBackLogName = <span class="string">&quot;zlog&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">afterLog</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line">err := db.Error</span><br><span class="line">ctx := db.Statement.Context</span><br><span class="line"></span><br><span class="line">sql := db.Dialector.Explain(db.Statement.SQL.String(), db.Statement.Vars...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">zlog.WithTrace(ctx).Errorf(<span class="string">&quot;sql=%s || error=%v&quot;</span>, sql, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">zlog.WithTrace(ctx).Infof(<span class="string">&quot;sql=%s&quot;</span>, sql)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>afterLog</code>这里，我们引用了插件，实现了自定义日志组件的打印。</p><h2 id="4-关于gormer工具的迭代"><a href="#4-关于gormer工具的迭代" class="headerlink" title="4.关于gormer工具的迭代"></a>4.关于gormer工具的迭代</h2><p>在这个小版本中，我们又对gormer工具做了一次迭代。从整个框架的维度来看，我们不仅仅是把它作为一种代码生成的工具，而是一种模块化的抽象能力，关注分层能力的建设。从SQL的log打印来看，我们可以区分出前后的差异：</p><p><strong>原先</strong> - 通过调用一个<code>公共函数</code>来打印，需要侵入到每个dao层的具体代码</p><p><strong>修改后</strong> - 通过插件注册到组件中，<strong>无需侵入到具体实现的代码</strong></p><p><strong>无侵入地实现自定义功能</strong>，这个特性对每个工具组件都非常重要，GORM这里就提供了一个很好的实现思路 - 注册插件，自定义hook。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次迭代的意义很大 - <strong>标志着<code>gormer</code>这个组件实现了自定义方法的可扩展</strong>（ext文件）。</p><p>接下来，我们还会持续地对<code>gormer</code>等low code工具持续优化，实现更多的功能。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着接口参数校验功能的完善，我们能快速定位到接口层面的参数问题；而应用服务的分层代码，也可以通过log的trace-id发现常见的业务逻辑问题。&lt;/p&gt;
&lt;p&gt;但在最底层与数据库的操作，也就是对GORM的使用，经常会因为我们不了解ORM的一些细节，导致对数据的CRUD失败，或者没有达到预期效果。这时，我们希望能在ORM这一层也有一个通用的解决方案，来加速问题的排查。&lt;/p&gt;
&lt;p&gt;趁这个机会，我们也对&lt;code&gt;gormer&lt;/code&gt;这个工具再做一次迭代，添加新的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 11.接口的参数校验功能-buf中引入PGV</title>
    <link href="http://example.com/2021/11/11/go-framework/go-framework-11/"/>
    <id>http://example.com/2021/11/11/go-framework/go-framework-11/</id>
    <published>2021-11-11T04:00:00.000Z</published>
    <updated>2021-11-15T11:45:20.470Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>随着API在线文档的发布，服务的接口将会被开放给各种各样的调用方。</p><p>大量开发接口的朋友会经常遇到<strong>接口参数校验</strong>的问题。举个例子，我们希望将某个字段是必填的，如<code>name</code>，我们经常会需要做两步：</p><ol><li>在程序中加一个<strong>判断逻辑</strong>，当这个字段为空时返回错误给调用方</li><li>在接口文档中加上<strong>注释</strong>，告诉调用方这个参数必填</li></ol><p>一旦某项工作被拆分为两步，就很容易出现<strong>不一致性</strong>：对应到参数检查，我们会经常遇到文档和具体实现不一致，从而导致双方研发的沟通成本增加。那么，今天我将引入一个方案，实现两者的一致性。</p><blockquote><p>为了缩小讨论范围，我们将 <strong>参数校验</strong> 限定为简单规则。</p><p>而复合条件的检查（逻辑组合等），不在本次的讨论范围内，主要考虑到2点：</p><ol><li>要生成跨语言的方案，技术上比较难实现</li><li>复合条件往往是一种业务逻辑的检查，放在接口层面不合适</li></ol></blockquote><span id="more"></span><h2 id="v0-7-1：接口的参数校验功能"><a href="#v0-7-1：接口的参数校验功能" class="headerlink" title="v0.7.1：接口的参数校验功能"></a>v0.7.1：接口的参数校验功能</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.7.1">https://github.com/Junedayday/micro_web_service/tree/v0.7.1</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>在线接口文档提供参数校验的逻辑，并自动生成相关代码。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>参数校验的技术选型</li><li>在buf中引入PGV</li><li>在框架中引入参数检查</li><li>buf格式检查</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">    |-- order                            对应idl/order服务，同上</span><br><span class="line">     |-- swagger.json                    openapiv2的接口文档</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">   |-- order                           业务order定义，同时干</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">   |-- model                           model层，定义对象的接口方法，具体实现在dao层</span><br><span class="line">   |-- mysql                           MySQL连接</span><br><span class="line">   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">|-- buf.gen.yaml                   修改：buf生成代码的定义，新增参数校验逻辑</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- gormer.yaml                    将gormer中的参数移动到这里</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br><span class="line">|-- swagger.sh                     生成openapiv2的相关脚本</span><br></pre></td></tr></table></figure><h2 id="1-参数校验的技术选型"><a href="#1-参数校验的技术选型" class="headerlink" title="1.参数校验的技术选型"></a>1.参数校验的技术选型</h2><p>从搜索引擎可知，protobuf的主流参数校验采用两者：</p><ol><li>go-proto-validators <a href="https://github.com/mwitkow/go-proto-validators">https://github.com/mwitkow/go-proto-validators</a></li><li>protoc-gen-validate <a href="https://github.com/envoyproxy/protoc-gen-validate">https://github.com/envoyproxy/protoc-gen-validate</a></li></ol><p>这里，我们最终选用的是protoc-gen-validate（PGV），决定性的理由有两个：</p><ol><li>buf的官方文档更倾向于PGV - <a href="https://docs.buf.build/lint/rules/#custom-options">https://docs.buf.build/lint/rules/#custom-options</a></li><li>PGV由envoy背书，长期来看更具维护性</li></ol><h2 id="2-在buf中引入PGV"><a href="#2-在buf中引入PGV" class="headerlink" title="2.在buf中引入PGV"></a>2.在buf中引入PGV</h2><p>protoc-gen-validate（PGV）作为一款插件，它已经被集成在了buf工具中。这次，我们就从其调用的顺序，来理解一下buf里的重要文件：</p><h3 id="2-1-核心文件-buf-yaml"><a href="#2-1-核心文件-buf-yaml" class="headerlink" title="2.1 核心文件 - buf.yaml"></a>2.1 核心文件 - buf.yaml</h3><p>具体引用路径可以在buf库 - <a href="https://buf.build/">https://buf.build/</a> 搜索找到，然后在文件中里添加一个依赖项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">buf.build/envoyproxy/protoc-gen-validate</span></span><br></pre></td></tr></table></figure><h3 id="2-2-生成的定义文件-buf-gen-yaml"><a href="#2-2-生成的定义文件-buf-gen-yaml" class="headerlink" title="2.2 生成的定义文件 - buf.gen.yaml"></a>2.2 生成的定义文件 - buf.gen.yaml</h3><p>这个文件定义了我们要生成什么样的代码，具体增加如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">validate</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">gen</span></span><br><span class="line">    <span class="attr">opt:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">paths=source_relative</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lang=go</span></span><br></pre></td></tr></table></figure><p>其中，要注意opt选项要增加一个参数<code>lang=go</code>，类似的，我们也可以生成其余语言的代码。</p><h3 id="2-3-proto定义文件"><a href="#2-3-proto定义文件" class="headerlink" title="2.3 proto定义文件"></a>2.3 proto定义文件</h3><p>我们以分页参数为例，添加2条规则，即要求页码、每页数量均大于0。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;validate/validate.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ListOrdersRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">1</span> [(validate.rules).<span class="built_in">int32</span> = &#123;gt: <span class="number">0</span>&#125;];</span><br><span class="line">  <span class="built_in">int32</span> page_size = <span class="number">2</span>   [(validate.rules).<span class="built_in">int32</span> = &#123;gt: <span class="number">0</span>&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-生成相关代码"><a href="#2-4-生成相关代码" class="headerlink" title="2.4 生成相关代码"></a>2.4 生成相关代码</h3><p>因为我们引入了一个新的模块，所以先需要更新依赖，用来下载新模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf mod update</span><br><span class="line">buf generate</span><br></pre></td></tr></table></figure><h3 id="2-5-参数校验的代码"><a href="#2-5-参数校验的代码" class="headerlink" title="2.5 参数校验的代码"></a>2.5 参数校验的代码</h3><p>在2.3引入validate的数据结构定义，会生成一个<code>*.pb.validate.go</code>文件，我们截取两个关键函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ListOrdersRequest)</span> <span class="title">Validate</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> m.validate(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ListOrdersRequest)</span> <span class="title">ValidateAll</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> m.validate(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从命名不难看出，<code>Validate</code>是检查到有一个不符合规则就立刻返回，<code>ValidateAll</code>是校验完所有的参数后、将不符合的规则一起返回。这两种处理方式的差异主要在于：</p><ol><li>耗时：全量检查相对会花费更多的时间</li><li>返回的信息量：全量检查的error会包含更多信息</li></ol><p>从服务端的视角，更推荐全量检查，将所有字段的检查结果返回给调用方，方便对方一次性修正。</p><h2 id="3-在框架中引入参数检查"><a href="#3-在框架中引入参数检查" class="headerlink" title="3.在框架中引入参数检查"></a>3.在框架中引入参数检查</h2><h3 id="3-1-grpc拦截器"><a href="#3-1-grpc拦截器" class="headerlink" title="3.1 grpc拦截器"></a>3.1 grpc拦截器</h3><p>grpc提供了一套拦截器Interceptor的机制，类似于http router中的middleware。之前，我们已经引入了一个拦截器，用于打印trace相关的日志。那么这次又新增了一个拦截器，该如何处理呢？</p><p>参考grpc的代码，我们可以看到下面两个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnaryInterceptor</span><span class="params">(i UnaryServerInterceptor)</span> <span class="title">ServerOption</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ChainUnaryInterceptor</span><span class="params">(interceptors ...UnaryServerInterceptor)</span> <span class="title">ServerOption</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中前者是单个拦截器，而后者是一种链式拦截器的概念。毫无疑问，我们需要扩充成多个拦截器。</p><h3 id="3-2-实现参数校验的拦截"><a href="#3-2-实现参数校验的拦截" class="headerlink" title="3.2 实现参数校验的拦截"></a>3.2 实现参数校验的拦截</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ValidateAll 对应 protoc-gen-validate 生成的 *.pb.validate.go 中的代码</span></span><br><span class="line"><span class="keyword">type</span> Validator <span class="keyword">interface</span> &#123;</span><br><span class="line">ValidateAll() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerValidationUnaryInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r, ok := req.(Validator); ok &#123;</span><br><span class="line"><span class="keyword">if</span> err := r.ValidateAll(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.InvalidArgument, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在拦截器中引入我们定义的插件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := grpc.NewServer(</span><br><span class="line">  grpc.ChainUnaryInterceptor(</span><br><span class="line">    grpc_opentracing.UnaryServerInterceptor(</span><br><span class="line">      grpc_opentracing.WithTracer(opentracing.GlobalTracer()),</span><br><span class="line">    ),</span><br><span class="line">    ServerValidationUnaryInterceptor,</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="3-3-具体调用示例"><a href="#3-3-具体调用示例" class="headerlink" title="3.3 具体调用示例"></a>3.3 具体调用示例</h3><p>我们尝试着传一个错误的接口参数，看看返回结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;invalid ListOrdersRequest.PageNumber: value must be greater than 0; invalid ListOrdersRequest.PageSize: value must be greater than 0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，结果中清晰地说明了不合规的两个参数，以及具体的规则，对调用方来说非常直观。</p><h2 id="4-buf格式检查"><a href="#4-buf格式检查" class="headerlink" title="4.buf格式检查"></a>4.buf格式检查</h2><p>随着buf工具的推进，我们引入了越来越多的内容，protobuf文件也新增了很多东西。这时，我们会希望能将protobuf的格式也能有一定的规范化。在buf之前，已经有prototool等工具，buf对此做了集成。</p><p>由于buf的lint检查有很多细节，建议酌情选用。以项目中我选择的为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lint:</span></span><br><span class="line">  <span class="attr">use:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">DEFAULT</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PACKAGE_VERSION_SUFFIX</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PACKAGE_DIRECTORY_MATCH</span></span><br><span class="line">  <span class="attr">rpc_allow_google_protobuf_empty_requests:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">rpc_allow_google_protobuf_empty_responses:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>包括两块：</p><ul><li>except排除了两个检查项，即要求protobuf的package带上版本后缀、与代码路径匹配</li><li>允许request和response设置为empty格式</li></ul><p>接下来，运行<code>buf lint</code>，会提示你需要修正的地方，逐一修改即可（很多是命名上的规范，增加可读性，推荐按插件的建议进行修改）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次框架的小迭代高度依赖了buf的生态体系，建议有时间的朋友可以再看看buf的文档链接 - <a href="https://docs.buf.build/introduction%E3%80%82buf%E5%B7%A5%E5%85%B7%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%A2%91%E7%8E%87%E6%AF%94%E8%BE%83%E9%AB%98%EF%BC%8C%E5%AF%B9%E5%85%B6%E6%96%B0%E7%89%B9%E6%80%A7%E4%BB%8D%E5%A4%84%E4%BA%8E%E8%A7%82%E6%9C%9B%E7%8A%B6%E6%80%81%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%B2%A1%E6%9C%89%E5%AE%8C%E5%85%A8%E6%8C%89%E7%85%A7%E5%85%B6Best">https://docs.buf.build/introduction。buf工具的迭代频率比较高，对其新特性仍处于观望状态，目前没有完全按照其Best</a> Practice推进。</p><p>回过头来，我们的参数检查方案依然存在一个明显问题：生成的swagger文档中没有对应的参数要求（Issue - <a href="https://github.com/grpc-ecosystem/grpc-gateway/issues/1093%EF%BC%89%E3%80%82%E5%A6%82%E6%9E%9C%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E9%95%BF%E6%9C%9F%E6%97%A0%E6%B3%95%E8%A7%A3%E5%86%B3%EF%BC%8C%E6%88%91%E4%B9%9F%E4%BC%9A%E7%BB%99%E5%87%BA%E4%B8%80%E5%A5%97%E8%87%AA%E5%B7%B1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82">https://github.com/grpc-ecosystem/grpc-gateway/issues/1093）。如果这个问题长期无法解决，我也会给出一套自己的解决方案。</a></p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着API在线文档的发布，服务的接口将会被开放给各种各样的调用方。&lt;/p&gt;
&lt;p&gt;大量开发接口的朋友会经常遇到&lt;strong&gt;接口参数校验&lt;/strong&gt;的问题。举个例子，我们希望将某个字段是必填的，如&lt;code&gt;name&lt;/code&gt;，我们经常会需要做两步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在程序中加一个&lt;strong&gt;判断逻辑&lt;/strong&gt;，当这个字段为空时返回错误给调用方&lt;/li&gt;
&lt;li&gt;在接口文档中加上&lt;strong&gt;注释&lt;/strong&gt;，告诉调用方这个参数必填&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一旦某项工作被拆分为两步，就很容易出现&lt;strong&gt;不一致性&lt;/strong&gt;：对应到参数检查，我们会经常遇到文档和具体实现不一致，从而导致双方研发的沟通成本增加。那么，今天我将引入一个方案，实现两者的一致性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了缩小讨论范围，我们将 &lt;strong&gt;参数校验&lt;/strong&gt; 限定为简单规则。&lt;/p&gt;
&lt;p&gt;而复合条件的检查（逻辑组合等），不在本次的讨论范围内，主要考虑到2点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要生成跨语言的方案，技术上比较难实现&lt;/li&gt;
&lt;li&gt;复合条件往往是一种业务逻辑的检查，放在接口层面不合适&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 10.接口文档-openapiv2的在线文档方案</title>
    <link href="http://example.com/2021/11/01/go-framework/go-framework-10/"/>
    <id>http://example.com/2021/11/01/go-framework/go-framework-10/</id>
    <published>2021-11-01T04:00:00.000Z</published>
    <updated>2021-11-02T10:08:07.124Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>随着项目的迭代，一个服务会开放出越来越多的接口供第三方调用。</p><p>虽然<code>protobuf</code>已经是通用性很广的IDL文件了，但对于未接触过这块的程序员来说，还是有很大的学习成本。在综合可读性和维护性之后，我个人比较倾向于使用oepnapiv2的方案，提供在线接口文档。</p><p>接下来，我们一起来看看这部分的实现。</p><span id="more"></span><h2 id="v0-7-0：接口文档-openapiv2的在线文档方案"><a href="#v0-7-0：接口文档-openapiv2的在线文档方案" class="headerlink" title="v0.7.0：接口文档-openapiv2的在线文档方案"></a>v0.7.0：接口文档-openapiv2的在线文档方案</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.7.0">https://github.com/Junedayday/micro_web_service/tree/v0.7.0</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>项目提供在线接口文档，供第三方快速地了解接口细节。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>了解buf的openapiv2的插件</li><li>用swagger工具合并文档</li><li>利用swagger相关容器提供在线文档</li></ol><blockquote><p>swagger 是 openapiv2 的一种具体实现，在下文可等同于一个概念。</p><p>可以参考swagger官网了解详情：<a href="https://swagger.io/specification/v2/">https://swagger.io/specification/v2/</a></p></blockquote><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">    |-- order                            对应idl/order服务，同上</span><br><span class="line">     |-- swagger.json                    新增：openapiv2的接口文档</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">   |-- order                           业务order定义，同时干</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">   |-- model                           model层，定义对象的接口方法，具体实现在dao层</span><br><span class="line">   |-- mysql                           MySQL连接</span><br><span class="line">   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义，从v1beta升到v1</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- gormer.yaml                    将gormer中的参数移动到这里</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br><span class="line">|-- swagger.sh                     新增：生成openapiv2的相关脚本</span><br></pre></td></tr></table></figure><h2 id="1-了解buf的openapiv2的插件"><a href="#1-了解buf的openapiv2的插件" class="headerlink" title="1.了解buf的openapiv2的插件"></a>1.了解buf的openapiv2的插件</h2><p>从<a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/mapping/customizing_openapi_output/#other-plugin-options">gRPC-Gateway的文档</a>中，我们可以找到对应的buf插件使用方式：在<code>buf.gen.yaml</code>文件中，我们添加如下插件内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">openapiv2</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">gen/openapiv2</span></span><br></pre></td></tr></table></figure><p>运行<code>buf generate</code>后，在<code>gen/openapiv2</code>目录下会根据我们在<code>idl</code>文件中的目录结构，生成多个接口文档。</p><h2 id="2-用swagger工具合并文档"><a href="#2-用swagger工具合并文档" class="headerlink" title="2.用swagger工具合并文档"></a>2.用swagger工具合并文档</h2><p>用buf标准的openapiv2插件会生成多份swagger文档，管理多个文件对使用方来说并不方便。最佳的使用体验，就是能将多个文档合并起来，用一个API文档统一交付。</p><p>这里，我们借助goswagger工具，合并文档。工具具体的安装方式可参考链接：<a href="https://goswagger.io/install.html%E3%80%82">https://goswagger.io/install.html。</a></p><p>安装后，运行如下命令，生成到文件 gen/swagger.json：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 合并swagger文档</span></span><br><span class="line">swagger mixin gen/openapiv2/idl/*/*.json -o gen/swagger.json</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除原始文档</span></span><br><span class="line">rm -rf gen/openapiv2</span><br></pre></td></tr></table></figure><h2 id="3-利用swagger相关容器提供在线文档"><a href="#3-利用swagger相关容器提供在线文档" class="headerlink" title="3.利用swagger相关容器提供在线文档"></a>3.利用swagger相关容器提供在线文档</h2><p>在统一了swagger文件后，在线接口文档的实现方案有很多，例如swagger官网就可以提供简单的渲染。</p><p>这里，我用了个人比较常用的docker镜像redoc为例，搭建一个在线接口文档平台。</p><blockquote><p>该镜像更多的使用方式可参考：<a href="https://hub.docker.com/r/redocly/redoc/">https://hub.docker.com/r/redocly/redoc/</a> </p></blockquote><p>运行如下命令，即将swagger.json加载到镜像中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name swagger -it --rm -d -p 80:80 -v $(pwd)/gen/swagger.json:/usr/share/nginx/html/swagger.json -e SPEC_URL=swagger.json redocly/redoc</span><br></pre></td></tr></table></figure><p>我们在本地打开浏览器，输入 <a href="http://127.0.0.1/">http://127.0.0.1:80/</a> 就能看到文档。</p><blockquote><p>扩展点 - 公共的文档服务器：</p><p>我们往往更希望把文档放在一个公共的服务器上，可以简单地利用这两个关键技术实现：</p><ol><li><a href="https://hub.docker.com/r/redocly/redoc/">https://hub.docker.com/r/redocly/redoc/</a> 中的watch方案，即watch某个目录下的文件，根据文件变化实时更新接口</li><li>利用scp命令，将本地swagger.json上传到远端服务器</li></ol><p>更复杂点的方案，可以考虑结合git流程来实现。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们实现了一个关键性的功能：<strong>代码即接口文档</strong>，保证了接口文档随着代码更新的实时性。</p><p>同时，希望大家能够认识到接口文档的价值，最好能做到<strong>接口文档即代码</strong>，也就是将相关程序的逻辑尽可能地通过接口文档表达清楚。哪怕前期接口文档问题很多，只要我们不断迭代，后续总能趋于稳定，降低维护接口的成本。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着项目的迭代，一个服务会开放出越来越多的接口供第三方调用。&lt;/p&gt;
&lt;p&gt;虽然&lt;code&gt;protobuf&lt;/code&gt;已经是通用性很广的IDL文件了，但对于未接触过这块的程序员来说，还是有很大的学习成本。在综合可读性和维护性之后，我个人比较倾向于使用oepnapiv2的方案，提供在线接口文档。&lt;/p&gt;
&lt;p&gt;接下来，我们一起来看看这部分的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 9.分布式链路追踪-OpenTracing的初步引入</title>
    <link href="http://example.com/2021/10/26/go-framework/go-framework-9/"/>
    <id>http://example.com/2021/10/26/go-framework/go-framework-9/</id>
    <published>2021-10-26T04:00:00.000Z</published>
    <updated>2021-11-01T08:11:18.225Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>我们从API层到数据库层的链路已经打通，简单的CRUD功能已经可以快速实现。</p><p>随着模块的增加，我们会越发感受到系统的复杂性，开始关注系统的可维护性。这时，有个名词会进入我们的视野：<strong>分布式链路追踪</strong>。相关的内容可以参考这我的两篇文章：</p><ul><li>OpenTelemetry <a href="https://junedayday.github.io/2021/10/14/readings/go-digest-2/">https://junedayday.github.io/2021/10/14/readings/go-digest-2/</a></li><li>Jaeger <a href="https://junedayday.github.io/2021/10/20/readings/go-digest-3/">https://junedayday.github.io/2021/10/20/readings/go-digest-3/</a></li></ul><p>我们接下来直接进入实战。</p><span id="more"></span><h2 id="v0-6-0：分布式链路追踪-OpenTracing的初步引入"><a href="#v0-6-0：分布式链路追踪-OpenTracing的初步引入" class="headerlink" title="v0.6.0：分布式链路追踪-OpenTracing的初步引入"></a>v0.6.0：分布式链路追踪-OpenTracing的初步引入</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.6.0">https://github.com/Junedayday/micro_web_service/tree/v0.6.0</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>在项目中引入Jaeger为代表的OpenTracing，用一个traceid串联整个请求的链路。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>trace的初始化</li><li>将opentracing的设置到grpc和grpc-gateway中</li><li>将traceid引入到log组件中</li><li>HTTP请求返回traceid</li></ol><blockquote><p>前两点我将一笔带过，在 <a href="https://junedayday.github.io/2021/10/20/readings/go-digest-3/">https://junedayday.github.io/2021/10/20/readings/go-digest-3/</a> 这篇中已有详细的讲解</p></blockquote><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">    |-- order                            对应idl/order服务，同上</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">   |-- order                           业务order定义，同时干</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">   |-- model                           model层，定义对象的接口方法，具体实现在dao层</span><br><span class="line">   |-- mysql                           MySQL连接</span><br><span class="line">   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义，从v1beta升到v1</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- gormer.yaml                    将gormer中的参数移动到这里</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-trace的初始化"><a href="#1-trace的初始化" class="headerlink" title="1.trace的初始化"></a>1.trace的初始化</h2><p>创建了一个jaeger的trace并设置到opentracing包里的全局变量中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">traceCfg := &amp;jaegerconfig.Configuration&#123;</span><br><span class="line">  ServiceName: <span class="string">&quot;MyService&quot;</span>,</span><br><span class="line">  Sampler: &amp;jaegerconfig.SamplerConfig&#123;</span><br><span class="line">    Type:  jaeger.SamplerTypeConst,</span><br><span class="line">    Param: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  Reporter: &amp;jaegerconfig.ReporterConfig&#123;</span><br><span class="line">    LocalAgentHostPort: <span class="string">&quot;127.0.0.1:6831&quot;</span>,</span><br><span class="line">    LogSpans:           <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">tracer, closer, err := traceCfg.NewTracer(jaegerconfig.Logger(jaeger.StdLogger))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> closer.Close()</span><br><span class="line">opentracing.SetGlobalTracer(tracer)</span><br></pre></td></tr></table></figure><h2 id="2-将opentracing的设置到grpc和grpc-gateway中"><a href="#2-将opentracing的设置到grpc和grpc-gateway中" class="headerlink" title="2.将opentracing的设置到grpc和grpc-gateway中"></a>2.将opentracing的设置到grpc和grpc-gateway中</h2><p>利用了拦截器的特性，类似于middleware。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// grpc-gateway</span></span><br><span class="line">opts := []grpc.DialOption&#123;</span><br><span class="line">  grpc.WithInsecure(),</span><br><span class="line">  grpc.WithUnaryInterceptor(</span><br><span class="line">    grpc_opentracing.UnaryClientInterceptor(</span><br><span class="line">      grpc_opentracing.WithTracer(opentracing.GlobalTracer()),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := demo.RegisterDemoServiceHandlerFromEndpoint(ctx, mux, fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, config.Viper.GetInt(<span class="string">&quot;server.grpc.port&quot;</span>)), opts); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;RegisterDemoServiceHandlerFromEndpoint error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grpc</span></span><br><span class="line">s := grpc.NewServer(grpc.UnaryInterceptor(grpc_opentracing.UnaryServerInterceptor(grpc_opentracing.WithTracer(opentracing.GlobalTracer()))))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-将traceid引入到log组件中"><a href="#3-将traceid引入到log组件中" class="headerlink" title="3.将traceid引入到log组件中"></a>3.将traceid引入到log组件中</h2><p>从Opentracing对Go语言的相关介绍可以得知，trace信息被放在go语言的context里。于是，就有了下面这一段提取traceid的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了使用方便，不修改zap源码，这里利用With函数返回一个SugaredLogger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTrace</span><span class="params">(ctx context.Context)</span> *<span class="title">zap</span>.<span class="title">SugaredLogger</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> jTraceId jaeger.TraceID</span><br><span class="line"><span class="keyword">if</span> parent := opentracing.SpanFromContext(ctx); parent != <span class="literal">nil</span> &#123;</span><br><span class="line">parentCtx := parent.Context()</span><br><span class="line"><span class="keyword">if</span> tracer := opentracing.GlobalTracer(); tracer != <span class="literal">nil</span> &#123;</span><br><span class="line">mySpan := tracer.StartSpan(<span class="string">&quot;my info&quot;</span>, opentracing.ChildOf(parentCtx))</span><br><span class="line">      <span class="comment">// 提取出一个jaeger的traceid</span></span><br><span class="line"><span class="keyword">if</span> sc, ok := mySpan.Context().(jaeger.SpanContext); ok &#123;</span><br><span class="line">jTraceId = sc.TraceID()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> mySpan.Finish()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Sugar.With(zap.String(jaeger.TraceContextHeaderName, fmt.Sprint(jTraceId)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-HTTP请求返回traceid"><a href="#4-HTTP请求返回traceid" class="headerlink" title="4.HTTP请求返回traceid"></a>4.HTTP请求返回traceid</h2><p>在拦截器里，解析出trace信息，设置到http的头里。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">trace, ok := serverSpan.Context().(jaeger.SpanContext)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">  w.Header().Set(jaeger.TraceContextHeaderName, fmt.Sprint(trace.TraceID()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们模拟一个简单的请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --request GET &#x27;http://127.0.0.1:8081/v1/orders&#x27;</span><br></pre></td></tr></table></figure><p>从返回的结果来看，可以看到<code>Uber-Trace-Id</code>头里有个具体的trace-id，例如5fd1fc3ba1715909。</p><p>而在应用代码中，我们添加了一行日志：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(orderSvc *OrderService)</span> <span class="title">List</span><span class="params">(ctx context.Context, pageNumber, pageSize <span class="keyword">int</span>, condition *gormer.OrderOptions)</span> <span class="params">([]gormer.Order, <span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">zlog.WithTrace(ctx).Infof(<span class="string">&quot;page number is %d&quot;</span>, pageNumber)</span><br><span class="line"><span class="comment">// zlog信息</span></span><br><span class="line"><span class="keyword">return</span> orders, count, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的打印如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-10-22T17:25:05.591+0800infoservice/order.go:26page number is 0&#123;&quot;uber-trace-id&quot;: &quot;5fd1fc3ba1715909&quot;&#125;</span><br></pre></td></tr></table></figure><p>虽然格式还不是那么优美，但traceid信息已经填入到了日志中。</p><p>至此，调用方只要提供返回的trace-id，我们就可以在程序日志中查找到相应的日志信息，方便针对性地排查问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OpenTracing是服务治理非常关键的一环。利用traceid串联一个请求的整个生命周期，能帮助我们快速地排查问题，在实际生产环境上能更快地定位问题。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们从API层到数据库层的链路已经打通，简单的CRUD功能已经可以快速实现。&lt;/p&gt;
&lt;p&gt;随着模块的增加，我们会越发感受到系统的复杂性，开始关注系统的可维护性。这时，有个名词会进入我们的视野：&lt;strong&gt;分布式链路追踪&lt;/strong&gt;。相关的内容可以参考这我的两篇文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OpenTelemetry &lt;a href=&quot;https://junedayday.github.io/2021/10/14/readings/go-digest-2/&quot;&gt;https://junedayday.github.io/2021/10/14/readings/go-digest-2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jaeger &lt;a href=&quot;https://junedayday.github.io/2021/10/20/readings/go-digest-3/&quot;&gt;https://junedayday.github.io/2021/10/20/readings/go-digest-3/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们接下来直接进入实战。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>技术阅读摘要 - 3.Jaeger技术分析</title>
    <link href="http://example.com/2021/10/20/readings/go-digest-3/"/>
    <id>http://example.com/2021/10/20/readings/go-digest-3/</id>
    <published>2021-10-20T04:00:00.000Z</published>
    <updated>2021-10-22T06:38:03.297Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QZ3lGpkvgdfXW7R.jpg" alt="Go-Framework"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>通过上一次技术阅读摘要，我们了解了分布式链路追踪这项技术，Jaeger是其主流的实现方案。</p><p>今天，我们就一起来看看Jaeger的相关资料，初步掌握这门技术。</p><span id="more"></span><h2 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h2><ul><li>Jaeger官网 <a href="https://www.jaegertracing.io/">https://www.jaegertracing.io/</a></li><li>Github <a href="https://github.com/jaegertracing/jaeger">https://github.com/jaegertracing/jaeger</a></li><li>Dapper <a href="https://research.google/pubs/pub36356/">https://research.google/pubs/pub36356/</a></li><li>OpenZipkin <a href="https://zipkin.io/">https://zipkin.io/</a></li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Jaeger的官方定义非常简洁 - <strong>Jaeger: open source, end-to-end distributed tracing</strong>。</p><p>关键词是<strong>端到端的分布式追踪</strong>。怎么理解这个端到端呢？它更多地是关注分布式系统中的<strong>入和出</strong>。从一个HTTP服务来看，它关注的是请求和响应的具体数据。对应到如今k8s中盛行的sidecar模式，就是一个网络的sidecar，将所有的请求进行标注（如带上traceId）。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Jaeger的官方文档上资料很丰富，更新也比较频繁。有些朋友会觉得阅读官方文档非常累，常常通篇阅读后发现抓不到重点、也没有什么印象。这里，我推荐一个页面 - <a href="https://www.jaegertracing.io/docs/1.27/architecture/">https://www.jaegertracing.io/docs/1.27/architecture/</a> ，并结合我的理解，方便大家快速理解。</p><h3 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h3><p>Span是分布式链路追踪中一个通用的术语，字面翻译为 <strong>带名称的Jaeger逻辑单元</strong>。</p><p>这里对逻辑单元的定义比较有争论，在我看来，逻辑单元的定义因具体场景而变化：</p><ul><li>在单体架构中，需要拆分成多个模块，每个模块定义成一个逻辑单元</li><li>在一个简单的微服务中，可以将服务定义成一个逻辑单元</li><li>在一个复杂的微服务中，可能需要根据更细的领域定义成一个逻辑单元</li></ul><h3 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h3><p>一个具体消息在整个分布式系统中的流转。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>Jaeger提供了2种架构的解决方案。我们先看看通用的部分：</p><ul><li>jaeger-client作为具体语言的内部库，嵌入到应用程序中</li><li>jaeger-agent作为sidecar，部署在容器或机器上，用来从jaeger收集数据，并推送到jaeger collector</li><li>jaeger collector负责将数据保存到数据库或MQ中</li><li>jaeger-query + UI 查询并显示数据</li></ul><p>而差异点就在于保存和分析数据的技术方案：</p><ul><li>简单方案：直接保存到数据库中，用Spark Jobs进行分析</li><li>高性能方案：用Kafka来削峰填谷，用Flink流式计算提高性能</li></ul><h2 id="Jaeger-Go"><a href="#Jaeger-Go" class="headerlink" title="Jaeger Go"></a>Jaeger Go</h2><h3 id="Trace的初始化"><a href="#Trace的初始化" class="headerlink" title="Trace的初始化"></a>Trace的初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">traceCfg := &amp;jaegerconfig.Configuration&#123;</span><br><span class="line">  <span class="comment">// 服务名</span></span><br><span class="line">  ServiceName: <span class="string">&quot;MyService&quot;</span>,</span><br><span class="line">  <span class="comment">// 采样参数</span></span><br><span class="line">  Sampler: &amp;jaegerconfig.SamplerConfig&#123;</span><br><span class="line">    Type:  jaeger.SamplerTypeConst,</span><br><span class="line">    Param: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 上报，这里通过jaeger sidecar的端口来上报日志</span></span><br><span class="line">  Reporter: &amp;jaegerconfig.ReporterConfig&#123;</span><br><span class="line">    LocalAgentHostPort: <span class="string">&quot;127.0.0.1:6831&quot;</span>,</span><br><span class="line">    LogSpans:           <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化tracer</span></span><br><span class="line">tracer, closer, err := traceCfg.NewTracer(jaegerconfig.Logger(jaeger.StdLogger))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> closer.Close()</span><br><span class="line"><span class="comment">// 将tracer设置到opentracing的全局变量中</span></span><br><span class="line">opentracing.SetGlobalTracer(tracer)</span><br></pre></td></tr></table></figure><p>上面这段逻辑描述了 <strong>创建jaeger的tracer并保存到opentracing的全局变量中</strong>。</p><p>这里强调一点：opentracing是一套标准，包括jaeger、zipkin等具体实现。我们可以深入看看<code>NewTracer</code>这个函数。它的注释很好地说明了这一点。具体的细节实现，我们暂时无需关注。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tracer implements opentracing.Tracer.</span></span><br><span class="line"><span class="keyword">type</span> Tracer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="技术组件引入Opentracing"><a href="#技术组件引入Opentracing" class="headerlink" title="技术组件引入Opentracing"></a>技术组件引入Opentracing</h3><p>通过上面的工作，我们已经在程序中引入了jaeger。但在实际的开发过程中，我们程序内部会有一些组件也需要引入jaeger的链路追踪，来实现更精细化的监控。</p><p>以gRPC-Gateway为例，引入Opentracing的链接如下： <a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/operations/tracing/#opentracing-support">https://grpc-ecosystem.github.io/grpc-gateway/docs/operations/tracing/#opentracing-support</a> 。这里面的代码可以直接引用，就不细看了。</p><p>目前，支持原生的Opentracing的组件越来越多。在引入一个复杂的组件时，我们要先了解清楚是否可以集成Opentracing，降低后续的运维复杂度。</p><h3 id="提取TraceId信息"><a href="#提取TraceId信息" class="headerlink" title="提取TraceId信息"></a>提取TraceId信息</h3><p>整个jaeger的引入并不复杂，就已经能很好地实现链路监控了。但在实际的开发过程中，我们仍有一个非常关键的需求：<strong>如何将一个请求的trace信息，引入到业务代码中，跟踪业务代码的处理过程</strong>。这一点，在debug问题时非常有意义，尤其是面对一些自己不太熟悉的代码。</p><p>开发人员面对这个场景，最常用的逻辑就是log，那就意味着我们要将traceid注入到日志中。那么怎么获取traceid呢？下面看一段示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从ctx获取span</span></span><br><span class="line"><span class="keyword">if</span> parent := opentracing.SpanFromContext(ctx); parent != <span class="literal">nil</span> &#123;</span><br><span class="line">  parentCtx := parent.Context()</span><br><span class="line">  <span class="comment">// 获取opentracing中的全局tracer</span></span><br><span class="line">  <span class="keyword">if</span> tracer := opentracing.GlobalTracer(); tracer != <span class="literal">nil</span> &#123;</span><br><span class="line">    mySpan := tracer.StartSpan(<span class="string">&quot;my info&quot;</span>, opentracing.ChildOf(parentCtx))</span><br><span class="line">    <span class="comment">// 由于前面opentracing中的tracer是jaeger的，所以你这里转化为jaeger.SpanContext</span></span><br><span class="line">    <span class="keyword">if</span> sc, ok := mySpan.Context().(jaeger.SpanContext); ok &#123;</span><br><span class="line">      <span class="comment">// 这里，就能获取traceid等信息了，可以放在日志里</span></span><br><span class="line">      _ = sc.TraceID()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> mySpan.Finish()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑就是从go语言的上下文context信息中，用Opentracing里定义的全局tracer，提取出traceId等信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于Jaeger内容有很多延伸点，但本文只作入门，点到即可。</p><p>如果只能记住一点，我希望大家能认识到：<strong>Jaeger是Opentracing标准的一个实现</strong>。从本文能看到，在标准统一后，具体实现的变更会变得非常简单：例如要将Jaeger替换成Zipkin，只需要初始化tracer处做到替换即可。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QZ3lGpkvgdfXW7R.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;通过上一次技术阅读摘要，我们了解了分布式链路追踪这项技术，Jaeger是其主流的实现方案。&lt;/p&gt;
&lt;p&gt;今天，我们就一起来看看Jaeger的相关资料，初步掌握这门技术。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Digest" scheme="http://example.com/tags/Digest/"/>
    
  </entry>
  
  <entry>
    <title>技术阅读摘要 - 2.OpenTelemetry技术概览</title>
    <link href="http://example.com/2021/10/14/readings/go-digest-2/"/>
    <id>http://example.com/2021/10/14/readings/go-digest-2/</id>
    <published>2021-10-14T04:00:00.000Z</published>
    <updated>2021-10-22T06:37:58.436Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QZ3lGpkvgdfXW7R.jpg" alt="Go-Framework"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>本系列的第二讲，我原先计划聊一下OpenTracing这个技术，但计划赶不上变化，我发现OpenTracing的官网上已经声明:这部分的技术将迁移到OpenTelemetry。</p><p>从OpenTelemetry的官方定义来看： <strong>An observability framework for cloud-native software</strong>，它的重点在于两块：</p><ol><li>可观察性：通过metrics、logs和traces数据，观察软件的运行情况</li><li>云原生：适配云原生理念</li></ol><p>OpenTelemetry的图标采用了一个<strong>望远镜</strong>，可见其核心在于可观察性。</p><span id="more"></span><h2 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h2><ul><li>OpenTelemetry <a href="https://opentelemetry.io/">https://opentelemetry.io/</a> </li><li>OpenTe4lemetry中文文档 <a href="https://github.com/open-telemetry/docs-cn">https://github.com/open-telemetry/docs-cn</a> </li><li>OpenTracing <a href="https://opentracing.io/">https://opentracing.io/</a> </li><li>OpenCensus <a href="https://opencensus.io/">https://opencensus.io/</a> </li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>我们先引用官方对自身的定义：<strong>OpenTelemetry is a set of APIs, SDKs, tooling and integrations that are designed for the creation and management of <em>telemetry data</em> such as traces, metrics, and logs.</strong></p><p>这句话指明了OpenTelemetry实现的3个重点数据：traces、metrics、logs。我们从简单到复杂，逐个讲述一下：</p><h3 id="Logs"><a href="#Logs" class="headerlink" title="Logs"></a>Logs</h3><p>日志：依赖程序自身的打印。可通过ELK/EFK等工具采集到统一的平台并展示。</p><h3 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h3><p>指标：程序将运行中关键的一些指标数据保存下来，常通过RPC的方式Pull/Push到统一的平台。</p><p>常见的如请求数、请求延迟、请求成功率等，也可进行一定的计算后获得更复杂的复合指标。</p><h3 id="Traces"><a href="#Traces" class="headerlink" title="Traces"></a>Traces</h3><p>分布式追踪：遵循Dapper等协议，获取一个请求在整个系统中的调用链路。</p><p>常见的如根据一个HTTP请求的requestID，获取其各个RPC、数据库、缓存等关键链路中的详情。</p><h2 id="技术标准"><a href="#技术标准" class="headerlink" title="技术标准"></a>技术标准</h2><p>到今天，OpenTelemetry还没有完全落地，但这不妨碍我们看清未来的发展方向。</p><p><strong>Metrics以Prometheus为标准，Traces以Jaeger为标准，而Logs暂时还没有明确的标准</strong>，但业界基本以ELK或EFK为技术实现。而我们常会把Traces和Logs这两点结合起来，通过在应用程序的打印日志中添加对应的Traces，来更好地排查整个数据链路。</p><p>但这样还不够，Opentelemetry期望的是将三者都关联起来，而引入了Context这个概念。熟悉Go语言的同学都清楚，context被定义为上下文，用于程序中传递数据。而Opentelemetry将这个概念进一步扩大，包括了RPC请求、多线程、跨语言、异步调用等各种复杂场景。</p><p>OpenTelemetry的推进工作非常困难，但其带来的价值是不言而喻的。今天，我们依旧以Go语言为例，试试窥一斑而见全豹，对这个技术有个基本掌握。</p><h2 id="Go语言示例"><a href="#Go语言示例" class="headerlink" title="Go语言示例"></a>Go语言示例</h2><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>参考官方在Go Package上的声明，Traces处于稳定状态，Metrics处于Alpha测试版本，而Logs则处于冻结状态。</p><blockquote><p>可见日志的优先级放在了Traces和Metrics之后。从最终实现来说，只要确定了Traces和Metrics的具体标准，Logs的实现并没有那么复杂。</p></blockquote><h3 id="1-创建Exporter"><a href="#1-创建Exporter" class="headerlink" title="1. 创建Exporter"></a>1. 创建Exporter</h3><p>OpenTelemetry要求程序中收集到的数据，都通过一定的途径发送给外部，如控制台、外部存储、端口等，所以就有了Exporter这个概念。</p><p>这里以一个简单的控制台Exporter为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">traceExporter, err := stdouttrace.New(</span><br><span class="line">  stdouttrace.WithPrettyPrint(),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">&quot;failed to initialize stdouttrace export pipeline: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-创建Trace-Provider"><a href="#2-创建Trace-Provider" class="headerlink" title="2. 创建Trace Provider"></a>2. 创建Trace Provider</h3><p>Traces这部分的概念比较多，这里先只讲解一个 - span。在分布式系统中，存在上下游的概念、也就是调用和被调用的关系，在分布式追踪系统中就将它们区分为不同的span。</p><p>示例代码初始化了Traces Provider，用于Traces相关的功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx := context.Background()</span><br><span class="line">bsp := sdktrace.NewBatchSpanProcessor(traceExporter)</span><br><span class="line">tp := sdktrace.NewTracerProvider(sdktrace.WithSpanProcessor(bsp))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle this error in a sensible manner </span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _ = tp.Shutdown(ctx) &#125;()</span><br></pre></td></tr></table></figure><blockquote><p>如果要深入了解分布式追踪技术，建议搜索Dapper论文或网上的相关资料。</p></blockquote><h3 id="3-创建Meter-Provider"><a href="#3-创建Meter-Provider" class="headerlink" title="3. 创建Meter Provider"></a>3. 创建Meter Provider</h3><p>类似Traces，Metrics也需要一个Provider，但它的名字叫做Meter Provider。</p><p>我们看一下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">metricExporter, err := stdoutmetric.New(</span><br><span class="line">  stdoutmetric.WithPrettyPrint(),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pusher := controller.New(</span><br><span class="line">  processor.New(</span><br><span class="line">    simple.NewWithExactDistribution(),</span><br><span class="line">    metricExporter,</span><br><span class="line">  ),</span><br><span class="line">  controller.WithExporter(metricExporter),</span><br><span class="line">  controller.WithCollectPeriod(<span class="number">5</span>*time.Second),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">err = pusher.Start(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle this error in a sensible manner where possible</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _ = pusher.Stop(ctx) &#125;()</span><br></pre></td></tr></table></figure><p>抛开初始化部分，其中还包含了2个关键性的内容：</p><ol><li>程序指标的计算部分</li><li>metrics的发送方式采用了push，周期为5s</li></ol><h3 id="4-设置全局选项"><a href="#4-设置全局选项" class="headerlink" title="4. 设置全局选项"></a>4. 设置全局选项</h3><p>这部分的内容不多，也很容易理解，但在实际工程中的价值很大：<strong>让调用者更方便！</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">otel.SetTracerProvider(tp)</span><br><span class="line">global.SetMeterProvider(pusher.MeterProvider())</span><br><span class="line">propagator := propagation.NewCompositeTextMapPropagator(propagation.Baggage&#123;&#125;,propagation.TraceContext&#123;&#125;)</span><br><span class="line">otel.SetTextMapPropagator(propagator)</span><br></pre></td></tr></table></figure><p>这里面做的事情很简单，就是将我们程序中自己创建的trace provider和meter provider设置到官方包中，也就是替换了官方包中的全局变量。接下来，我们想使用provider时，就统一调用官方包即可，<strong>不再需要引用本地的变量</strong>。</p><blockquote><p> 并不是所有的场景都适合把变量存放到统一的package下，可以延伸思考下~</p><p>举个例子，github.com/spf13/viper配置库只支持全局单个对象Viper，而我们程序中要创建多个对象，这时就不适用。</p></blockquote><h3 id="5-创建Metric-Instruments"><a href="#5-创建Metric-Instruments" class="headerlink" title="5. 创建Metric Instruments"></a>5. 创建Metric Instruments</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置关键属性</span></span><br><span class="line">lemonsKey := attribute.Key(<span class="string">&quot;ex.com/lemons&quot;</span>)</span><br><span class="line">anotherKey := attribute.Key(<span class="string">&quot;ex.com/another&quot;</span>)</span><br><span class="line"></span><br><span class="line">commonAttributes := []attribute.KeyValue&#123;lemonsKey.Int(<span class="number">10</span>), attribute.String(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>), attribute.String(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;2&quot;</span>), attribute.String(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;3&quot;</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Meter实例</span></span><br><span class="line">meter := global.Meter(<span class="string">&quot;ex.com/basic&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步的Observer：通过函数回调</span></span><br><span class="line">observerCallback := <span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, result metric.Float64ObserverResult)</span></span> &#123;</span><br><span class="line">  result.Observe(<span class="number">1</span>, commonAttributes...)</span><br><span class="line">&#125;</span><br><span class="line">_ = metric.Must(meter).NewFloat64ValueObserver(<span class="string">&quot;ex.com.one&quot;</span>, observerCallback,metric.WithDescription(<span class="string">&quot;A ValueObserver set to 1.0&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步的Recorder：创建一个变量，按需使用</span></span><br><span class="line">valueRecorder := metric.Must(meter).NewFloat64ValueRecorder(<span class="string">&quot;ex.com.two&quot;</span>)</span><br><span class="line">boundRecorder := valueRecorder.Bind(commonAttributes...)</span><br><span class="line"><span class="keyword">defer</span> boundRecorder.Unbind()</span><br></pre></td></tr></table></figure><h3 id="6-综合示例"><a href="#6-综合示例" class="headerlink" title="6. 综合示例"></a>6. 综合示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Tracer</span></span><br><span class="line">tracer := otel.Tracer(<span class="string">&quot;ex.com/basic&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了一个包含2个member的baggage，并结合到Go里的context</span></span><br><span class="line">foo, _ := baggage.NewMember(<span class="string">&quot;ex.com.foo&quot;</span>, <span class="string">&quot;foo1&quot;</span>)</span><br><span class="line">bar, _ := baggage.NewMember(<span class="string">&quot;ex.com.bar&quot;</span>, <span class="string">&quot;bar1&quot;</span>)</span><br><span class="line">bag, _ := baggage.New(foo, bar)</span><br><span class="line">ctx = baggage.ContextWithBaggage(ctx, bag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下为一个具体调用的示例，多层嵌套</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 根据传入的ctx，创建一个span</span></span><br><span class="line">  <span class="keyword">var</span> span trace.Span</span><br><span class="line">  ctx, span = tracer.Start(ctx, <span class="string">&quot;operation&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> span.End()</span><br><span class="line"></span><br><span class="line">  span.AddEvent(<span class="string">&quot;Nice operation!&quot;</span>, trace.WithAttributes(attribute.Int(<span class="string">&quot;bogons&quot;</span>, <span class="number">100</span>)))</span><br><span class="line">  span.SetAttributes(anotherKey.String(<span class="string">&quot;yes&quot;</span>))</span><br><span class="line"></span><br><span class="line">  meter.RecordBatch(</span><br><span class="line">    ctx,</span><br><span class="line">    commonAttributes,</span><br><span class="line">    valueRecorder.Measurement(<span class="number">2.0</span>),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 根据传入的ctx，创建一个子span</span></span><br><span class="line">    <span class="keyword">var</span> span trace.Span</span><br><span class="line">    ctx, span = tracer.Start(ctx, <span class="string">&quot;Sub operation...&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> span.End()</span><br><span class="line"></span><br><span class="line">    span.SetAttributes(lemonsKey.String(<span class="string">&quot;five&quot;</span>))</span><br><span class="line">    span.AddEvent(<span class="string">&quot;Sub span event&quot;</span>)</span><br><span class="line">    boundRecorder.Record(ctx, <span class="number">1.3</span>)</span><br><span class="line">  &#125;(ctx)</span><br><span class="line">&#125;(ctx)</span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li>文档 - <a href="https://opentelemetry.io/docs/go/">https://opentelemetry.io/docs/go/</a></li><li>Go Package - <a href="https://pkg.go.dev/go.opentelemetry.io/otel#section-readme">https://pkg.go.dev/go.opentelemetry.io/otel#section-readme</a></li><li>Github - <a href="https://github.com/open-telemetry/opentelemetry-go">https://github.com/open-telemetry/opentelemetry-go</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从现状来看，OpenTelemetry仍处于初期阶段，使用起来并不那么方便。我们应该把重点放在标准上：</p><p>从官方文档 - <a href="https://opentelemetry.io/docs/go/exporting_data/">https://opentelemetry.io/docs/go/exporting_data/</a> 中可以看出，OpenTelemetry有标准的OTLP Exporter，但目前这块更多的是一个标准，而不是一个具体实践。</p><p>针对当前已落地的技术，重要参考就是Jaeger和Prometheus。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QZ3lGpkvgdfXW7R.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;本系列的第二讲，我原先计划聊一下OpenTracing这个技术，但计划赶不上变化，我发现OpenTracing的官网上已经声明:这部分的技术将迁移到OpenTelemetry。&lt;/p&gt;
&lt;p&gt;从OpenTelemetry的官方定义来看： &lt;strong&gt;An observability framework for cloud-native software&lt;/strong&gt;，它的重点在于两块：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可观察性：通过metrics、logs和traces数据，观察软件的运行情况&lt;/li&gt;
&lt;li&gt;云原生：适配云原生理念&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OpenTelemetry的图标采用了一个&lt;strong&gt;望远镜&lt;/strong&gt;，可见其核心在于可观察性。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Digest" scheme="http://example.com/tags/Digest/"/>
    
  </entry>
  
  <entry>
    <title>技术阅读摘要 - 1.十二要素应用原则</title>
    <link href="http://example.com/2021/10/12/readings/go-digest-1/"/>
    <id>http://example.com/2021/10/12/readings/go-digest-1/</id>
    <published>2021-10-12T04:00:00.000Z</published>
    <updated>2021-10-22T06:37:50.496Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QZ3lGpkvgdfXW7R.jpg" alt="Go-Framework"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><strong>十二要素应用原则（The Twelve-Factor App）</strong> 在如今的微服务领域非常流行，相信大家或多或少有所耳闻，但了解其中细节的并不多。</p><p>今天，我将对这12个原则做一个概要分析，结合Go语言中的相关例子，根据开源与大厂的具体实践，和大家一起看看个中究竟。</p><span id="more"></span><h2 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h2><ul><li>英文链接 <a href="https://12factor.net/">https://12factor.net/</a></li><li>中文链接 <a href="https://12factor.net/zh_cn/">https://12factor.net/zh_cn/</a></li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>先对12个概念做一个简单的讲解，让不熟悉的朋友心中有个初步概念。</p><h3 id="1-Codebase-基准代码-一份基准代码，多份部署"><a href="#1-Codebase-基准代码-一份基准代码，多份部署" class="headerlink" title="1. Codebase 基准代码 - 一份基准代码，多份部署"></a>1. Codebase 基准代码 - 一份基准代码，多份部署</h3><p>示例：一个应用程序的代码，放在一个Git仓库里。</p><blockquote><p>分支算不算一个仓库呢？</p><p>这点常有不同的理解。我个人会把一个分支认为是一个轻量级的仓库，每个分支对应一个具体的业务场景。</p></blockquote><p>痛点：在分布式的环境下，保证多个机器上运行的应用程序源代码一致，提升排查问题的效率。</p><h3 id="2-Dependencies-依赖-显式声明依赖关系"><a href="#2-Dependencies-依赖-显式声明依赖关系" class="headerlink" title="2. Dependencies 依赖 - 显式声明依赖关系"></a>2. Dependencies 依赖 - 显式声明依赖关系</h3><p>示例：Go语言的go module就显式地声明了项目依赖库与版本，方便维护。</p><p>痛点：以前Go vendor模式，将依赖代码都放在本地，没有一个文件集中说明项目的依赖，这就导致想找依赖关系必须去看代码细节。如果某个库的v1.0版本有bug，需要升级到1.1，go module只需查看一个文件，而vendor模式得遍历具体的项目，甚至多次递归。</p><h3 id="3-Config-配置-在环境中存储配置"><a href="#3-Config-配置-在环境中存储配置" class="headerlink" title="3. Config 配置 - 在环境中存储配置"></a>3. Config 配置 - 在环境中存储配置</h3><p>示例：将配置信息（端口、数据库、外部服务等）放在环境中，而不要硬编码。</p><blockquote><p>环境定义的扩展：在微服务中，这个环境指的是代码具体的运行环境，包括配置文件、环境变量、配置中心的数据。</p><p>值得一提的是，按照这种实践，配置文件不应该和应用程序代码放在一个代码仓库中，而是单独管理。</p></blockquote><p>痛点：保证多机器上运行的代码一致后，把变化点转移到配置中，避免硬编码到代码仓库中、导致更新需要整体升级。</p><h3 id="4-Backing-Services-后端服务-把后端服务当作附加资源"><a href="#4-Backing-Services-后端服务-把后端服务当作附加资源" class="headerlink" title="4. Backing Services 后端服务 - 把后端服务当作附加资源"></a>4. Backing Services 后端服务 - 把后端服务当作附加资源</h3><p>示例：当前的数据库选型为MySQL，有一天突然转变成了阿里云的RDS，只需要修改一个配置。</p><p>痛点：这是一种面向标准接口编程的模式，重点是让非业务相关的代码变得灵活可替代，如数据库、缓存、第三方服务。从被调用方的角度来看，过于理想化，很多重量级的组件很难被替代；而从调用方来看，这一切又显得理所当然，谁都希望外部系统的变化是无感知的。</p><blockquote><p>这一点，非常考验每个服务的设计者的能力，尤其是API接口。</p></blockquote><h3 id="5-Build-release-run-构建，发布，运行-严格分离构建和运行"><a href="#5-Build-release-run-构建，发布，运行-严格分离构建和运行" class="headerlink" title="5. Build, release, run 构建，发布，运行 - 严格分离构建和运行"></a>5. Build, release, run 构建，发布，运行 - 严格分离构建和运行</h3><p>示例：Go程序在一个构建机器上用 go build命令生成二进制文件，在发布阶段将这个二进制文件分发到各个待运行的机器上，最后在各个机器上运行这个二进制文件。</p><p>痛点：强调了CICD一整套流水线，不要让构建和运行强绑定。举个极端的例子，如果有一台centos和一台ubuntu的机器，我们去两个机器上各自编译+运行，可能因为内核不同而发生奇怪的现象；而如果采用在一台专用的centos机器上编译成统一的可执行文件，再分发到这两台机器上，更加合理。</p><blockquote><p> 如果centos上可执行文件无法在ubuntu机器上运行，就在部署阶段报错，提醒我们去修复。我们更应该去把部署的机器改成centos统一管理，而不是去花大量精力兼容ubuntu。</p><p>随着Docker技术的推广，大量简化了这一步骤。</p></blockquote><h3 id="6-Processes-进程-以一个或多个无状态进程运行应用"><a href="#6-Processes-进程-以一个或多个无状态进程运行应用" class="headerlink" title="6. Processes 进程 - 以一个或多个无状态进程运行应用"></a>6. Processes 进程 - 以一个或多个无状态进程运行应用</h3><p>示例：程序的内存中不保存具体业务相关的数据，而应该保存在共享存储上。</p><p>痛点：程序有状态是横向扩容的一大阻碍。想要完全去掉有状态的数据过于理想化，毕竟放在共享存储上肯定不如本地内存访问快，这对一些性能敏感的应用来说影响很大；但微服务架构强调要面向失败编程，这些有状态的数据在程序崩溃时无法恢复，可能导致级联雪崩的等更可怕情况。这一点，需要服务的负责人仔细权衡。</p><h3 id="7-Port-Binding-端口绑定-通过端口绑定提供服务"><a href="#7-Port-Binding-端口绑定-通过端口绑定提供服务" class="headerlink" title="7. Port Binding 端口绑定 - 通过端口绑定提供服务"></a>7. Port Binding 端口绑定 - 通过端口绑定提供服务</h3><p>示例：通过开放端口、以RPC形式提供服务</p><p>痛点：历史上有些程序以unix socket的本地形式提供服务，维护成本比较高。目前微服务以HTTP为代表的RPC方式提供服务，适合横向扩展。</p><h3 id="8-Concurrency-并发-通过进程模型进行扩展"><a href="#8-Concurrency-并发-通过进程模型进行扩展" class="headerlink" title="8. Concurrency 并发 - 通过进程模型进行扩展"></a>8. Concurrency 并发 - 通过进程模型进行扩展</h3><p>示例：当并发量达到一定程度，通过横向扩容进程（Docker实例）来满足需求</p><p>痛点：在并发度比较小时，最简单的提升方式是纵向扩容 - 即提高机器的配置。但当并发程度达到一定级别后，无法再通过提升硬件配置来解决。如果进程做到了无状态，利用外部的调度平台（如k8s）进行扩缩容，更适合长期发展。</p><h3 id="9-Disposability-易处理-快速启动和优雅终止可最大化健壮性"><a href="#9-Disposability-易处理-快速启动和优雅终止可最大化健壮性" class="headerlink" title="9. Disposability 易处理 - 快速启动和优雅终止可最大化健壮性"></a>9. Disposability 易处理 - 快速启动和优雅终止可最大化健壮性</h3><p>示例：程序能够快速启动，遇到严重异常时也能尽可能地完成现有的任务，优雅终止。</p><p>痛点：启动时间少能让程序遇到问题后快速恢复，也可以更快速地横向扩容；而优雅终止更多地是为了保障数据的一致性。</p><h3 id="10-Dev-prod-parity-开发环境与线上环境等价-尽可能的保持开发，预发布，线上环境相同"><a href="#10-Dev-prod-parity-开发环境与线上环境等价-尽可能的保持开发，预发布，线上环境相同" class="headerlink" title="10. Dev/prod parity 开发环境与线上环境等价 - 尽可能的保持开发，预发布，线上环境相同"></a>10. Dev/prod parity 开发环境与线上环境等价 - 尽可能的保持开发，预发布，线上环境相同</h3><p>示例：开发、预发布、线上等环境上部署的代码、配置、第三方服务等，尽可能地保证一致，让故障提前在测试环境发生。</p><p>痛点：尽可能地保证线上环境的稳定性，让问题尽可能地在开发环境中暴露出来，结合CICD工作保障环境的一致性。</p><h3 id="11-Logs-日志-把日志当作事件流"><a href="#11-Logs-日志-把日志当作事件流" class="headerlink" title="11. Logs 日志 - 把日志当作事件流"></a>11. Logs 日志 - 把日志当作事件流</h3><p>示例：在微服务架构中，通过日志将一个事件（如一个RPC请求）串联起来。</p><p>痛点：利用格式化的日志+ELK，将日志收集到统一的管理平台，用于分析数据。</p><h3 id="12-Admin-processes-管理进程-后台管理任务当作一次性进程运行"><a href="#12-Admin-processes-管理进程-后台管理任务当作一次性进程运行" class="headerlink" title="12. Admin processes 管理进程 - 后台管理任务当作一次性进程运行"></a>12. Admin processes 管理进程 - 后台管理任务当作一次性进程运行</h3><p>示例：将脚本、定时任务等，也作为一个应用程序提交，由k8s等调度平台执行</p><p>痛点：手动执行脚本或任务往往会有两个严重问题：误操作与可追溯性差。更合理的方式是走一个正式的发布流程，方便管理。</p><h2 id="案例串讲"><a href="#案例串讲" class="headerlink" title="案例串讲"></a>案例串讲</h2><h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><p>你（研发人员）收到了一个需求，要实现一个分布式的订单服务。于是，你新建了一个git仓库（<strong>1.基准代码</strong>），准备用go语言编写，部署在多个机器上（<strong>8.并发</strong>）。开发期间引用了大量的开源库，用Go Module将这些依赖都管理了起来（<strong>2.依赖</strong>）。</p><p>开发过程中，由于测试和线上的数据库地址不同，所以你把这些信息放在了配置中心（<strong>3.配置</strong>），如Etcd、k8s的ConfigMap中。</p><p>由于外部服务会依赖这个订单服务，所以要求研发提供的API接口必须向前兼容，所以选用了经典的RESTful风格的HTTP接口作为对外的协议（<strong>7.端口绑定</strong>）。这样，即便订单服务后续不断迭代，对外部来说也只是修改一个调用地址即可（<strong>4.后端服务</strong>）。</p><h3 id="上线阶段"><a href="#上线阶段" class="headerlink" title="上线阶段"></a>上线阶段</h3><p>在测试、预发布环境，为了开发与测试人员更好地验证功能，绝大部分的配置参数都保证与线上一致（<strong>10.开发环境与线上环境等价</strong>）。</p><p>整个上线流程包括了测试、预发布、线上三个环境的部署和验证，统一采用CICD的技术自动化执行（<strong>5.构建，发布，运行</strong>）。</p><h3 id="维护阶段"><a href="#维护阶段" class="headerlink" title="维护阶段"></a>维护阶段</h3><p>订单服务很复杂，经常会发生崩溃，导致很多数据恢复不了。于是，研发组长决定把关键的数据都放在Redis集群中（<strong>6.进程</strong>），保证应用的无状态化。</p><p>数据不丢了，但程序崩溃后恢复很慢，发现花大量的时间在加载初始数据上。于是又做了一次优化，利用Lazy Load的思路，按需加载（<strong>9.易处理</strong>）。</p><p>程序正常运行了，但用户反馈有个请求经常失败。这时，你利用ELK收集上的日志，排查了整个链路中的信息（<strong>11.日志</strong>），发现某处代码逻辑搞混了。当前的问题修复了，你还需要去数据库修复历史数据，就又写了个sql脚本提交到专门用来维护修改数据的代码仓库，提交给平台自动运行（<strong>12.管理进程</strong>）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>业界对这12个原则的理解并不完全一致，这也是因为<strong>不同角色处于不同的阶段所导致的视野差异性</strong>。</p><p>总体来说，这12个原则强调了简单性、可维护性，我们可以把它们作为微服务架构设计的指导性原则。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QZ3lGpkvgdfXW7R.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;十二要素应用原则（The Twelve-Factor App）&lt;/strong&gt; 在如今的微服务领域非常流行，相信大家或多或少有所耳闻，但了解其中细节的并不多。&lt;/p&gt;
&lt;p&gt;今天，我将对这12个原则做一个概要分析，结合Go语言中的相关例子，根据开源与大厂的具体实践，和大家一起看看个中究竟。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Digest" scheme="http://example.com/tags/Digest/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 8.Gormer迭代-定制专属的ORM代码生成工具</title>
    <link href="http://example.com/2021/10/10/go-framework/go-framework-8/"/>
    <id>http://example.com/2021/10/10/go-framework/go-framework-8/</id>
    <published>2021-10-10T04:00:00.000Z</published>
    <updated>2021-10-25T03:08:24.698Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>在上一篇，我们写一个<code>gormer</code>工具库，支持了简单的CRUD。但是，在实际的开发场景中，这部分的功能仍显得非常单薄。</p><p>例如，我们对比一下GORM库提供的<code>gorm.Model</code>，它在新增、修改时，会自动修改对应的时间，这个可以帮我们减少很多重复性的代码编写。这里，我就针对现有的gormer工具做一个示例性的迭代。</p><span id="more"></span><h2 id="v0-5-2：Gormer迭代-定制更智能的代码生成工具"><a href="#v0-5-2：Gormer迭代-定制更智能的代码生成工具" class="headerlink" title="v0.5.2：Gormer迭代-定制更智能的代码生成工具"></a>v0.5.2：Gormer迭代-定制更智能的代码生成工具</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.5.2">https://github.com/Junedayday/micro_web_service/tree/v0.5.2</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>生成一套智能化的Dao层代码，兼容软删除和硬删除。</p><blockquote><p>这里提一下软删除的概念，就是指在数据库中用某个字段标记为删除，但这行数据仍存在；而硬删除就是直接删除整条数据。</p><p>软删除虽然增加了一定的复杂度，但带来的收益很大。最直接的好处就是能保留记录，方便查原始记录。</p></blockquote><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>gormer.yaml的文件</li><li>模板文件的修改</li><li>核心结构体梳理</li><li>API调用示例</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><p>为了方便理解，我简化对应的目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">    |-- order                            对应idl/order服务，同上</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">   |-- order                           业务order定义，同时干</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">   |-- model                           model层，定义对象的接口方法，具体实现在dao层</span><br><span class="line">   |-- mysql                           MySQL连接</span><br><span class="line">   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          修改：gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义，从v1beta升到v1</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- gormer.yaml                    新增：将gormer中的参数移动到这里</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-gormer-yaml的文件"><a href="#1-gormer-yaml的文件" class="headerlink" title="1.gormer.yaml的文件"></a>1.gormer.yaml的文件</h2><p>这里先给出具体的建表语句，可以清晰地看到orders表6个字段的具体含义：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders</span><br><span class="line">(</span><br><span class="line">id <span class="type">bigint</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">255</span>) COMMENT <span class="string">&#x27;名称，建议唯一&#x27;</span>,</span><br><span class="line">price <span class="type">decimal</span>(<span class="number">15</span>,<span class="number">3</span>) COMMENT <span class="string">&#x27;订单价格&#x27;</span>,</span><br><span class="line">create_time <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">update_time <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">delete_status tinyint(<span class="number">3</span>) COMMENT <span class="string">&#x27;删除状态，1表示软删除&#x27;</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;订单信息表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>我们回顾一下之前的gormer程序，它采用了<code>flag</code>参数解析的方式。但随着复杂度提升，命令行参数包含了大量的内容，很难维护。这时，就建议采用<strong>配置文件</strong>的方式，保证可读性、可维护性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库相关的信息</span></span><br><span class="line"><span class="attr">database:</span></span><br><span class="line">  <span class="comment"># 数据库连接</span></span><br><span class="line">  <span class="attr">dsn:</span> <span class="string">&quot;root:123456@tcp(127.0.0.1:3306)/demo&quot;</span></span><br><span class="line">  <span class="comment"># 所有要生成到Go结构体中的表</span></span><br><span class="line">  <span class="attr">tables:</span></span><br><span class="line">    <span class="comment"># name-表名</span></span><br><span class="line">    <span class="comment"># goStruct-Go中结构体名</span></span><br><span class="line">    <span class="comment"># createTime-创建时间的数据库字段，必须为时间格式</span></span><br><span class="line">    <span class="comment"># updateTime-更新时间的数据库字段，必须为时间格式</span></span><br><span class="line">    <span class="comment"># softDeleteKey-软删除的数据库字段，必须为整数型，不填则为硬删除</span></span><br><span class="line">    <span class="comment"># softDeleteValue-表示为软删除的对应值</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;orders&quot;</span></span><br><span class="line">      <span class="attr">goStruct:</span> <span class="string">&quot;Order&quot;</span></span><br><span class="line">      <span class="attr">createTime:</span> <span class="string">&quot;create_time&quot;</span></span><br><span class="line">      <span class="attr">updateTime:</span> <span class="string">&quot;update_time&quot;</span></span><br><span class="line">      <span class="attr">softDeleteKey:</span> <span class="string">&quot;delete_status&quot;</span></span><br><span class="line">      <span class="attr">softDeleteValue:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目相关的信息</span></span><br><span class="line"><span class="attr">project:</span></span><br><span class="line">  <span class="comment"># 项目的路径</span></span><br><span class="line">  <span class="attr">base:</span> <span class="string">&quot;./&quot;</span></span><br><span class="line">  <span class="comment"># gorm相关核心结构的代码路径</span></span><br><span class="line">  <span class="attr">gorm:</span> <span class="string">&quot;internal/gormer/&quot;</span></span><br><span class="line">  <span class="comment"># dao层CRUD核心结构的代码路径</span></span><br><span class="line">  <span class="attr">dao:</span> <span class="string">&quot;internal/dao/&quot;</span></span><br><span class="line">  <span class="comment"># 项目的go module信息</span></span><br><span class="line">  <span class="attr">go_mod:</span> <span class="string">&quot;github.com/Junedayday/micro_web_service&quot;</span></span><br></pre></td></tr></table></figure><h2 id="2-模板文件的修改"><a href="#2-模板文件的修改" class="headerlink" title="2.模板文件的修改"></a>2.模板文件的修改</h2><p>这里以两个具有代表性的操作为例，一起来看看具体代码。</p><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><p>利用了go template的特性，填充了create_time和update_time字段。这里包含两层if语句：</p><ul><li>第一层：在<code>gormer.yaml</code>里必须指定了createTime代码，否则不要生成这段代码</li><li>第二层：如果外部传进来的字段里没有指定时间，才填充最新的时间；否则以外部传入为准</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">daoTmplAdd = <span class="string">`func (repo *&#123;&#123;.StructName&#125;&#125;Repo) Add&#123;&#123;.StructName&#125;&#125;(&#123;&#123;.StructSmallCamelName&#125;&#125; *gormer.&#123;&#123;.StructName&#125;&#125;) (err error) &#123;</span></span><br><span class="line"><span class="string">&#123;&#123;if ne .FieldCreateTime &quot;&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">    if &#123;&#123;.StructSmallCamelName&#125;&#125;.&#123;&#123;.FieldCreateTime&#125;&#125;.IsZero() &#123;</span></span><br><span class="line"><span class="string">&#123;&#123;.StructSmallCamelName&#125;&#125;.&#123;&#123;.FieldCreateTime&#125;&#125; = time.Now()</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;if ne .FieldUpdateTime &quot;&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">    if &#123;&#123;.StructSmallCamelName&#125;&#125;.&#123;&#123;.FieldUpdateTime&#125;&#125;.IsZero() &#123;</span></span><br><span class="line"><span class="string">&#123;&#123;.StructSmallCamelName&#125;&#125;.&#123;&#123;.FieldUpdateTime&#125;&#125; = time.Now()</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">err = repo.db.</span></span><br><span class="line"><span class="string">Table(gormer.&#123;&#123;.StructName&#125;&#125;TableName).</span></span><br><span class="line"><span class="string">Create(&#123;&#123;.StructSmallCamelName&#125;&#125;).</span></span><br><span class="line"><span class="string">Error</span></span><br><span class="line"><span class="string">return</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">AddOrder</span><span class="params">(order *gormer.Order)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> order.CreateTime.IsZero() &#123;</span><br><span class="line">order.CreateTime = time.Now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> order.UpdateTime.IsZero() &#123;</span><br><span class="line">order.UpdateTime = time.Now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = repo.db.</span><br><span class="line">Table(gormer.OrderTableName).</span><br><span class="line">Create(order).</span><br><span class="line">Error</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除的逻辑主要区分了一个字段，即是否在<code>gormer.yaml</code>里指定了软删除的字段。</p><ul><li>指定了软删除的字段，则将这个字段更新为设定的值、并且更新updateTime字段；</li><li>未指定软删除的字段，则直接硬删除对应的记录；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">daoTmplDelete = <span class="string">`func (repo *&#123;&#123;.StructName&#125;&#125;Repo) Delete&#123;&#123;.StructName&#125;&#125;(condition *gormer.&#123;&#123;.StructName&#125;&#125;Options) (err error) &#123;</span></span><br><span class="line"><span class="string">if condition == nil &#123;</span></span><br><span class="line"><span class="string">return errors.New(&quot;delete must include where condition&quot;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">err = repo.db.</span></span><br><span class="line"><span class="string">        Table(gormer.&#123;&#123;.StructName&#125;&#125;TableName).</span></span><br><span class="line"><span class="string">Where(condition.&#123;&#123;.StructName&#125;&#125;, condition.Fields).</span></span><br><span class="line"><span class="string">&#123;&#123;if eq .FieldSoftDeleteKey &quot;&quot; &#125;&#125; Delete(&amp;gormer.&#123;&#123;.StructName&#125;&#125;&#123;&#125;).</span></span><br><span class="line"><span class="string">&#123;&#123; else &#125;&#125;  &#123;&#123;if eq .FieldUpdateTime &quot;&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">Select(&quot;&#123;&#123;.TableSoftDeleteKey&#125;&#125;&quot;).</span></span><br><span class="line"><span class="string">Updates(&amp;gormer.&#123;&#123;.StructName&#125;&#125;&#123;</span></span><br><span class="line"><span class="string">&#123;&#123;.FieldSoftDeleteKey&#125;&#125;:&#123;&#123;.TableSoftDeleteValue&#125;&#125;,</span></span><br><span class="line"><span class="string">&#125;).</span></span><br><span class="line"><span class="string">            &#123;&#123; else &#125;&#125;</span></span><br><span class="line"><span class="string">                Select(&quot;&#123;&#123;.TableSoftDeleteKey&#125;&#125;&quot;,&quot;&#123;&#123;.TableUpdateTime&#125;&#125;&quot;).</span></span><br><span class="line"><span class="string">Updates(&amp;gormer.&#123;&#123;.StructName&#125;&#125;&#123;</span></span><br><span class="line"><span class="string">&#123;&#123;.FieldSoftDeleteKey&#125;&#125;:&#123;&#123;.TableSoftDeleteValue&#125;&#125;,</span></span><br><span class="line"><span class="string">&#123;&#123;.FieldUpdateTime&#125;&#125; : time.Now(),</span></span><br><span class="line"><span class="string">&#125;).</span></span><br><span class="line"><span class="string">            &#123;&#123; end &#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123; end &#125;&#125;</span></span><br><span class="line"><span class="string">Error</span></span><br><span class="line"><span class="string">return</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">DeleteOrder</span><span class="params">(condition *gormer.OrderOptions)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> condition == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;delete must include where condition&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = repo.db.</span><br><span class="line">Table(gormer.OrderTableName).</span><br><span class="line">Where(condition.Order, condition.Fields).</span><br><span class="line">Select(<span class="string">&quot;delete_status&quot;</span>, <span class="string">&quot;update_time&quot;</span>).</span><br><span class="line">Updates(&amp;gormer.Order&#123;</span><br><span class="line">DeleteStatus: <span class="number">1</span>,</span><br><span class="line">UpdateTime:   time.Now(),</span><br><span class="line">&#125;).</span><br><span class="line">Error</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-核心结构体梳理"><a href="#3-核心结构体梳理" class="headerlink" title="3.核心结构体梳理"></a>3.核心结构体梳理</h2><p>我们再一起看看表结构对应到Go结构体的一个关键结构体，这里分成了4个重要的部分：</p><ol><li>表名、结构体名</li><li>表中的列信息、结构体中的Field字段信息</li><li>创建时间、更新时间</li><li>软删除的字段</li></ol><p>这个数据结构体，其实是将两个数据源进行了关联映射：</p><ul><li>原始信息：从MySQL表中查询</li><li>自定义字段信息：从gormer.yaml查询</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StructLevel <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// table -&gt; struct</span></span><br><span class="line">TableName            <span class="keyword">string</span></span><br><span class="line">StructName           <span class="keyword">string</span></span><br><span class="line">StructSmallCamelName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// table column -&gt; struct field</span></span><br><span class="line">Columns []FieldLevel</span><br><span class="line"></span><br><span class="line"><span class="comment">// create time</span></span><br><span class="line">TableCreateTime <span class="keyword">string</span></span><br><span class="line">FieldCreateTime <span class="keyword">string</span></span><br><span class="line"><span class="comment">// update time</span></span><br><span class="line">TableUpdateTime <span class="keyword">string</span></span><br><span class="line">FieldUpdateTime <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// soft delete</span></span><br><span class="line">TableSoftDeleteKey   <span class="keyword">string</span></span><br><span class="line">TableSoftDeleteValue <span class="keyword">int</span></span><br><span class="line">FieldSoftDeleteKey   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FieldLevel <span class="keyword">struct</span> &#123;</span><br><span class="line">FieldName <span class="keyword">string</span></span><br><span class="line">FieldType <span class="keyword">string</span></span><br><span class="line"><span class="comment">// gorm tag for field</span></span><br><span class="line">GormName <span class="keyword">string</span></span><br><span class="line"><span class="comment">// comment from create table sql</span></span><br><span class="line">Comment <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-API调用示例"><a href="#4-API调用示例" class="headerlink" title="4.API调用示例"></a>4.API调用示例</h2><p>从API调用的角度来看，程序对外接口如下。有兴趣的可以体验下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// List</span><br><span class="line">curl --location --request GET &#x27;http://127.0.0.1:8081/v1/orders&#x27;</span><br><span class="line"></span><br><span class="line">// Create</span><br><span class="line">curl --location --request POST &#x27;http://127.0.0.1:8081/v1/orders&#x27; \</span><br><span class="line">--header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">--data-raw &#x27;&#123;</span><br><span class="line">    &quot;name&quot;: &quot;order4&quot;,</span><br><span class="line">    &quot;price&quot;: 100.3</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br><span class="line">// Update</span><br><span class="line">curl --location --request PATCH &#x27;http://127.0.0.1:8081/v1/orders&#x27; \</span><br><span class="line">--header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">--data-raw &#x27;&#123;</span><br><span class="line">    &quot;order&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;order1&quot;,</span><br><span class="line">        &quot;price&quot;: 110.8</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;update_mask&quot;: &quot;price&quot;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br><span class="line">// Get</span><br><span class="line">curl --location --request GET &#x27;http://127.0.0.1:8081/v1/orders/order1&#x27;</span><br><span class="line"></span><br><span class="line">// Delete</span><br><span class="line">curl --location --request DELETE &#x27;http://127.0.0.1:8081/v1/orders/order1&#x27;</span><br></pre></td></tr></table></figure><h2 id="延伸思考"><a href="#延伸思考" class="headerlink" title="延伸思考"></a>延伸思考</h2><p>修改到这个版本，gormer工具已经达到了基本可用的阶段。我们回顾一下重点功能：<strong>根据数据库表结构，自动化生成dao层的CRUD代码</strong>，并扩展了两特性：</p><ol><li>支持创建时间、修改时间的字段，自动填充</li><li>支持软删除与硬删除</li></ol><p>从更远的角度来看，还有许多MySQL的特性可以添加，尤其是对事务的支持，有兴趣的可以自行探索。限于篇幅与复杂度，目前就迭代到这个版本。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Gormer是一个我们根据日常CRUD需求自行实现的工具，是框架实现高度自动化的重要环节。它的核心思想是 - <strong>在重复的日常开发过程中找到可自动化的环节，实现Generate Code</strong>。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一篇，我们写一个&lt;code&gt;gormer&lt;/code&gt;工具库，支持了简单的CRUD。但是，在实际的开发场景中，这部分的功能仍显得非常单薄。&lt;/p&gt;
&lt;p&gt;例如，我们对比一下GORM库提供的&lt;code&gt;gorm.Model&lt;/code&gt;，它在新增、修改时，会自动修改对应的时间，这个可以帮我们减少很多重复性的代码编写。这里，我就针对现有的gormer工具做一个示例性的迭代。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 7.Gormer-自动生成代码的初体验</title>
    <link href="http://example.com/2021/09/27/go-framework/go-framework-7/"/>
    <id>http://example.com/2021/09/27/go-framework/go-framework-7/</id>
    <published>2021-09-27T04:00:00.000Z</published>
    <updated>2021-10-11T09:33:37.212Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>CRUD是贯穿整个程序员日常开发的基本工作，占据了我们绝大多数的coding时间。</p><p>作为一名程序员，我们总是希望能有更简单的开发方式来解决重复性的工作问题。在这个小版本中，我将结合自己的工作，来给出一套自动生成代码的完整方案，供大家借鉴。</p><span id="more"></span><h2 id="v0-5-1：Gormer-自动生成代码的初体验"><a href="#v0-5-1：Gormer-自动生成代码的初体验" class="headerlink" title="v0.5.1：Gormer-自动生成代码的初体验"></a>v0.5.1：Gormer-自动生成代码的初体验</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.5.1">https://github.com/Junedayday/micro_web_service/tree/v0.5.1</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>自动生成一套可用的Dao层代码，兼容原始版本。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>Go Template技术概览</li><li>gormer工具核心思路</li><li>gormer的模板填充</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务</span><br><span class="line">         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">    |-- order                            对应idl/order服务</span><br><span class="line">         |-- order.pb.go                       order.proto的基础结构</span><br><span class="line">         |-- order.pb.gw.go                    order.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- order_grpc.pb.go                  order.proto的gRPC接口代码</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义</span><br><span class="line">      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">   |-- order                           业务order定义</span><br><span class="line">      |-- order.proto                      protobuffer的原始定义</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹</span><br><span class="line">      |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层</span><br><span class="line">      |-- order.go                         Order对象，订单表，实现model层的OrderRepository</span><br><span class="line">      |-- order_test.go                    Order的单元测试</span><br><span class="line">   |-- gormer                          新增：从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">      |-- order.go                         新增：gormer从orders表中获取的真实Gorm结构体</span><br><span class="line">   |-- model                           model层，定义对象的接口方法</span><br><span class="line">      |-- order.go                         OrderRepository接口，具体实现在dao层</span><br><span class="line">   |-- mysql                           MySQL连接</span><br><span class="line">      |-- init.go                          初始化连接到MySQL的工作</span><br><span class="line">   |-- server                          服务器的实现</span><br><span class="line">      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">      |-- order.go                         Order相关的服务，目前仅简单的CRUD</span><br><span class="line">     |-- zlog                            封装日志的文件夹</span><br><span class="line">        |-- zap.go                           zap封装的代码实现</span><br><span class="line">  |-- pkg                            新增：开放给第三方的工具库</span><br><span class="line">     |-- gormer                          新增：gormer工具，用于生成Gorm相关Dao层代码</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义，从v1beta升到v1</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- gen.sh                         更新：生成代码的脚本：buf+gormer</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-Go-Template技术概览"><a href="#1-Go-Template技术概览" class="headerlink" title="1.Go Template技术概览"></a>1.Go Template技术概览</h2><p>Go的标准库提供了Template功能，但网上的介绍很零散，我建议大家可以阅读以下两篇资料：</p><ul><li>原理性：官方文档 - <a href="https://pkg.go.dev/text/template">https://pkg.go.dev/text/template</a> </li><li>实践性：Blog - <a href="https://blog.gopheracademy.com/advent-2017/using-go-templates/">https://blog.gopheracademy.com/advent-2017/using-go-templates/</a> </li></ul><p>这里，为了方便大家阅读下面的内容，我简要概括下：</p><ol><li>结构体中字段填充 <code>&#123;&#123; .FieldName &#125;&#125;</code></li><li>条件语句 <code>&#123;&#123;if .FieldName&#125;&#125; // action &#123;&#123; else &#125;&#125; // action 2 &#123;&#123; end &#125;&#125;</code></li><li>循环 <code>&#123;&#123;range .Member&#125;&#125; ... &#123;&#123;end&#125;&#125;</code></li><li>流水线 <code>&#123;&#123; with $x := <^>result-of-some-action<^> &#125;&#125; &#123;&#123; $x &#125;&#125; &#123;&#123; end &#125;&#125;</code></li></ol><blockquote><p>很多资料会很自然地将Go Template和HTML结合起来，但这只是模板的其中一个用法。</p><p>HTML的结构用模板化的方式可以减少大量重复性的代码，但这种思路是前后单不分离的，个人不太推荐。</p></blockquote><h2 id="2-gormer工具核心思路"><a href="#2-gormer工具核心思路" class="headerlink" title="2.gormer工具核心思路"></a>2.gormer工具核心思路</h2><p>在pkg/gormer目录下提供了一个gormer工具，用于自动生成代码，我对主流程进行简单地讲解：</p><ol><li>解析各种关键性的参数</li><li>连接测试数据库，获取表信息</li><li>逐个处理每个表<ol><li>读取数据库中的表结构</li><li>根据表结构生成对应的Go语言结构体，放在internal/gormer下</li><li>生成相关的Dao层代码，放在internal/dao下</li></ol></li><li>执行go fmt格式化代码</li></ol><p>其中最关键的是3-b与3-c，它们是生成代码的最关键步骤。我们来看一个关键性的结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体名称，对应MySQL表级别的信息</span></span><br><span class="line"><span class="keyword">type</span> StructLevel <span class="keyword">struct</span> &#123;</span><br><span class="line">TableName      <span class="keyword">string</span></span><br><span class="line">Name           <span class="keyword">string</span></span><br><span class="line">SmallCamelName <span class="keyword">string</span></span><br><span class="line">Columns        []FieldLevel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Field字段名称，对应MySQL表里Column</span></span><br><span class="line"><span class="keyword">type</span> FieldLevel <span class="keyword">struct</span> &#123;</span><br><span class="line">FieldName <span class="keyword">string</span></span><br><span class="line">FieldType <span class="keyword">string</span></span><br><span class="line">GormName  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-gormer的模板填充"><a href="#3-gormer的模板填充" class="headerlink" title="3.gormer的模板填充"></a>3.gormer的模板填充</h2><p>结合1、2，我们可以开始生成模板的部分，具体的Template代码如下，它会将StructLevel这个结构体中的字段填充到下面内容中，生成go文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gormerTmpl = <span class="string">`</span></span><br><span class="line"><span class="string">// Table Level Info</span></span><br><span class="line"><span class="string">const &#123;&#123;.Name&#125;&#125;TableName = &quot;&#123;&#123;.TableName&#125;&#125;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Field Level Info</span></span><br><span class="line"><span class="string">type &#123;&#123;.Name&#125;&#125;Field string</span></span><br><span class="line"><span class="string">const (</span></span><br><span class="line"><span class="string">&#123;&#123;range $item := .Columns&#125;&#125;</span></span><br><span class="line"><span class="string">    &#123;&#123;$.Name&#125;&#125;Field&#123;&#123;$item.FieldName&#125;&#125; &#123;&#123;$.Name&#125;&#125;Field = &quot;&#123;&#123;$item.GormName&#125;&#125;&quot; &#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var &#123;&#123;$.Name&#125;&#125;FieldAll = []&#123;&#123;$.Name&#125;&#125;Field&#123; &#123;&#123;range $k,$item := .Columns&#125;&#125;&quot;&#123;&#123;$item.GormName&#125;&#125;&quot;, &#123;&#123;end&#125;&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Kernel struct for table for one row</span></span><br><span class="line"><span class="string">type &#123;&#123;.Name&#125;&#125; struct &#123; &#123;&#123;range $item := .Columns&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;$item.FieldName&#125;&#125;&#123;&#123;$item.FieldType&#125;&#125;`</span> + <span class="string">&quot;`&quot;</span> + <span class="string">`gorm:&quot;column:&#123;&#123;$item.GormName&#125;&#125;&quot;`</span> + <span class="string">&quot;`&quot;</span> + <span class="string">` &#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Kernel struct for table operation</span></span><br><span class="line"><span class="string">type &#123;&#123;.Name&#125;&#125;Options struct &#123;</span></span><br><span class="line"><span class="string">    &#123;&#123;.Name&#125;&#125; *&#123;&#123;.Name&#125;&#125;</span></span><br><span class="line"><span class="string">    Fields []string</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Match: case insensitive</span></span><br><span class="line"><span class="string">var &#123;&#123;$.Name&#125;&#125;FieldMap = map[string]string&#123;</span></span><br><span class="line"><span class="string">&#123;&#123;range $item := .Columns&#125;&#125;&quot;&#123;&#123;$item.FieldName&#125;&#125;&quot;:&quot;&#123;&#123;$item.GormName&#125;&#125;&quot;,&quot;&#123;&#123;$item.GormName&#125;&#125;&quot;:&quot;&#123;&#123;$item.GormName&#125;&#125;&quot;,</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func New&#123;&#123;.Name&#125;&#125;Options(target *&#123;&#123;.Name&#125;&#125;, fields ...&#123;&#123;$.Name&#125;&#125;Field) *&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">    options := &amp;&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">        &#123;&#123;.Name&#125;&#125;: target,</span></span><br><span class="line"><span class="string">        Fields: make([]string, len(fields)),</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    for index, field := range fields &#123;</span></span><br><span class="line"><span class="string">        options.Fields[index] = string(field)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return options</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func New&#123;&#123;.Name&#125;&#125;OptionsAll(target *&#123;&#123;.Name&#125;&#125;) *&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">    return New&#123;&#123;.Name&#125;&#125;Options(target, &#123;&#123;$.Name&#125;&#125;FieldAll...)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func New&#123;&#123;.Name&#125;&#125;OptionsRawString(target *&#123;&#123;.Name&#125;&#125;, fields ...string) *&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">    options := &amp;&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">        &#123;&#123;.Name&#125;&#125;: target,</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    for _, field := range fields &#123;</span></span><br><span class="line"><span class="string">        if f,ok := &#123;&#123;$.Name&#125;&#125;FieldMap[field];ok &#123;</span></span><br><span class="line"><span class="string">             options.Fields = append(options.Fields, f)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return options</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>生成的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code generated by gormer. DO NOT EDIT.</span></span><br><span class="line"><span class="keyword">package</span> gormer</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Table Level Info</span></span><br><span class="line"><span class="keyword">const</span> OrderTableName = <span class="string">&quot;orders&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field Level Info</span></span><br><span class="line"><span class="keyword">type</span> OrderField <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">OrderFieldId         OrderField = <span class="string">&quot;id&quot;</span></span><br><span class="line">OrderFieldName       OrderField = <span class="string">&quot;name&quot;</span></span><br><span class="line">OrderFieldPrice      OrderField = <span class="string">&quot;price&quot;</span></span><br><span class="line">OrderFieldCreateTime OrderField = <span class="string">&quot;create_time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> OrderFieldAll = []OrderField&#123;<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;price&quot;</span>, <span class="string">&quot;create_time&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kernel struct for table for one row</span></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">Id         <span class="keyword">int64</span>     <span class="string">`gorm:&quot;column:id&quot;`</span></span><br><span class="line">Name       <span class="keyword">string</span>    <span class="string">`gorm:&quot;column:name&quot;`</span></span><br><span class="line">Price      <span class="keyword">float64</span>   <span class="string">`gorm:&quot;column:price&quot;`</span></span><br><span class="line">CreateTime time.Time <span class="string">`gorm:&quot;column:create_time&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kernel struct for table operation</span></span><br><span class="line"><span class="keyword">type</span> OrderOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">Order  *Order</span><br><span class="line">Fields []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Match: case insensitive</span></span><br><span class="line"><span class="keyword">var</span> OrderFieldMap = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;Id&quot;</span>: <span class="string">&quot;id&quot;</span>, <span class="string">&quot;id&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line"><span class="string">&quot;Name&quot;</span>: <span class="string">&quot;name&quot;</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line"><span class="string">&quot;Price&quot;</span>: <span class="string">&quot;price&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="string">&quot;price&quot;</span>,</span><br><span class="line"><span class="string">&quot;CreateTime&quot;</span>: <span class="string">&quot;create_time&quot;</span>, <span class="string">&quot;create_time&quot;</span>: <span class="string">&quot;create_time&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderOptions</span><span class="params">(target *Order, fields ...OrderField)</span> *<span class="title">OrderOptions</span></span> &#123;</span><br><span class="line">options := &amp;OrderOptions&#123;</span><br><span class="line">Order:  target,</span><br><span class="line">Fields: <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(fields)),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, field := <span class="keyword">range</span> fields &#123;</span><br><span class="line">options.Fields[index] = <span class="keyword">string</span>(field)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderOptionsAll</span><span class="params">(target *Order)</span> *<span class="title">OrderOptions</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> NewOrderOptions(target, OrderFieldAll...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderOptionsRawString</span><span class="params">(target *Order, fields ...<span class="keyword">string</span>)</span> *<span class="title">OrderOptions</span></span> &#123;</span><br><span class="line">options := &amp;OrderOptions&#123;</span><br><span class="line">Order: target,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, field := <span class="keyword">range</span> fields &#123;</span><br><span class="line"><span class="keyword">if</span> f, ok := OrderFieldMap[field]; ok &#123;</span><br><span class="line">options.Fields = <span class="built_in">append</span>(options.Fields, f)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dao层的代码逻辑类似，我就不重复填写了。</p><p>这里，我将代码拆分成了gormer与dao两层，主要是：</p><ul><li>internal/gormer整个目录是不可变的、只能自动生成，对应基础的数据库表结构</li><li>internal/dao层会添加其余的文件，如定制化的sql。</li></ul><p>至此，再将引用的相关代码简单修改，就实现了这一整块功能.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章重点介绍了Go Template在高度重复的代码模块中的应用，结合数据库实现了一个高度自动化的工具gormer。</p><p>gormer目前实现的功能比较单一，但只要有了初步自动化的思路，我们可以在后续迭代中慢慢优化，让它适应更多的场景。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;CRUD是贯穿整个程序员日常开发的基本工作，占据了我们绝大多数的coding时间。&lt;/p&gt;
&lt;p&gt;作为一名程序员，我们总是希望能有更简单的开发方式来解决重复性的工作问题。在这个小版本中，我将结合自己的工作，来给出一套自动生成代码的完整方案，供大家借鉴。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 6.用Google风格的API接口打通MySQL操作</title>
    <link href="http://example.com/2021/09/19/go-framework/go-framework-6/"/>
    <id>http://example.com/2021/09/19/go-framework/go-framework-6/</id>
    <published>2021-09-19T04:00:00.000Z</published>
    <updated>2021-09-26T02:52:38.499Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>随着RPC与MySQL的打通，整个框架已经开始打通了数据的出入口。</p><p>接下来，我们就尝试着实现通过RPC请求操作MySQL数据库，打通整个链路，真正地让这个平台实现可用。</p><span id="more"></span><h2 id="v0-5-0：用Google风格的API接口打通MySQL操作"><a href="#v0-5-0：用Google风格的API接口打通MySQL操作" class="headerlink" title="v0.5.0：用Google风格的API接口打通MySQL操作"></a>v0.5.0：用Google风格的API接口打通MySQL操作</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.5.0">https://github.com/Junedayday/micro_web_service/tree/v0.5.0</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>从API出发，实现一个数据库表的增删改查。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>Google风格的API定义</li><li>model与dao的定义</li><li>service层的实现</li></ol><blockquote><p>注意，最近buf工具进行了一次不兼容的升级，从v1beta升级到了v1，可通过如下链接下载 <a href="https://github.com/bufbuild/buf/releases">https://github.com/bufbuild/buf/releases</a></p></blockquote><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务</span><br><span class="line">         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">    |-- order                            新增：对应idl/order服务</span><br><span class="line">         |-- order.pb.go                       新增：order.proto的基础结构</span><br><span class="line">         |-- order.pb.gw.go                    新增：order.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- order_grpc.pb.go                  新增：order.proto的gRPC接口代码</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义</span><br><span class="line">      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">   |-- order                           新增：业务order定义</span><br><span class="line">      |-- order.proto                      新增：protobuffer的原始定义</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹</span><br><span class="line">      |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层</span><br><span class="line">      |-- order.go                         更新：Order对象，订单表，实现model层的OrderRepository</span><br><span class="line">      |-- order_test.go                    Order的单元测试</span><br><span class="line">   |-- model                           新增：model层，定义对象的接口方法</span><br><span class="line">      |-- order.go                         新增：OrderRepository接口，具体实现在dao层</span><br><span class="line">   |-- mysql                           MySQL连接</span><br><span class="line">      |-- init.go                          初始化连接到MySQL的工作</span><br><span class="line">   |-- server                          服务器的实现</span><br><span class="line">      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">   |-- service                         新增：service层，作为领域实现的核心部分</span><br><span class="line">      |-- order.go                         新增：Order相关的服务，目前仅简单的CRUD</span><br><span class="line">     |-- zlog                            封装日志的文件夹</span><br><span class="line">        |-- zap.go                           zap封装的代码实现</span><br><span class="line">|-- buf.gen.yaml                   更新：buf生成代码的定义，从v1beta升到v1</span><br><span class="line">|-- buf.yaml                       更新：buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-Google风格的API定义"><a href="#1-Google风格的API定义" class="headerlink" title="1.Google风格的API定义"></a>1.Google风格的API定义</h2><p>由于整体的定义比较多，这里就以</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">CreateOrderRequest</span> </span>&#123;</span><br><span class="line">  Order order = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UpdateOrderRequest</span> </span>&#123;</span><br><span class="line">  Order order = <span class="number">1</span>;</span><br><span class="line">  google.protobuf.FieldMask update_mask = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">GetOrderRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order服务</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ListOrders(ListOrdersRequest) <span class="keyword">returns</span> (ListOrdersResponse) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      get: <span class="string">&quot;/v1/orders&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里body中的order表示HTTP的body里的数据填充到CreateOrderRequest结构中的order对象</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> CreateOrder(CreateOrderRequest) <span class="keyword">returns</span> (Order) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      post: <span class="string">&quot;/v1/orders&quot;</span></span><br><span class="line">      body: <span class="string">&quot;order&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> UpdateOrder(UpdateOrderRequest) <span class="keyword">returns</span> (google.protobuf.Empty) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      patch: <span class="string">&quot;/v1/orders&quot;</span></span><br><span class="line">      body: <span class="string">&quot;*&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里&#123;name=*&#125;表示这个字段填充到GetOrderRequest里的name字段</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetOrder(GetOrderRequest) <span class="keyword">returns</span> (Order) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      get: <span class="string">&quot;/v1/orders/&#123;name=*&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> DeleteBook(DeleteBookRequest) <span class="keyword">returns</span> (google.protobuf.Empty) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      delete: <span class="string">&quot;/v1/books&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们重点关注以下几个方法：</p><ol><li>List - 查询列表，对应HTTP的GET方法</li><li>Get - 查询单个对象，对应HTTP的GET方法</li><li>Create - 创建对象，对应HTTP的POST方法</li><li>Update - 更新对象，对应HTTP的PATCH方法</li><li>Delete - 删除对象，对应HTTP的DELETE方法（本次暂未实现，后续添加软删除时加上）</li></ol><blockquote><p>关于Google定义的标准方法细节，可以参考<a href="https://cloud.google.com/apis/design/standard_methods">Google Cloud API链接</a>，了解对资源、字段等命名的逻辑。</p><p>而对于gRPC-Gateway中对于proto3的语法，可以参考<a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/mapping/patch_feature/">gRPC-Gateway链接</a>。</p><p>以上两块内容比较多，建议边实践边学习，不要一开始就钻细节。</p></blockquote><h2 id="2-model与dao的定义"><a href="#2-model与dao的定义" class="headerlink" title="2.model与dao的定义"></a>2.model与dao的定义</h2><p>为了将模型的定义与数据库的实现分离，我将两者进行了拆分，分别放置在model与dao目录下，定位的简单介绍如下：</p><ul><li>model，数据模型的定义，更关注对业务层的数据格式统一，底层可以对应各种存储形式，如mysql、redis</li><li>dao，真实数据存储的操作，也就是model层的实现，目前实现了一种mysql的操作</li></ul><h3 id="Model层"><a href="#Model层" class="headerlink" title="Model层"></a>Model层</h3><p>重点是统一的数据结构定义<code>Order</code>，以及关键接口<code>OrderRepository</code>的定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Order针对的是 orders 表中的一行数据</span></span><br><span class="line"><span class="comment">// 在这里定义，是为了分离Model与Dao</span></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">Id    <span class="keyword">int64</span></span><br><span class="line">Name  <span class="keyword">string</span></span><br><span class="line">Price <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderFields 作为一个 数据库Order对象+fields字段的组合</span></span><br><span class="line"><span class="comment">// fields用来指定Order中的哪些字段生效</span></span><br><span class="line"><span class="keyword">type</span> OrderFields <span class="keyword">struct</span> &#123;</span><br><span class="line">Order  *Order</span><br><span class="line">Fields []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderRepository <span class="keyword">interface</span> &#123;</span><br><span class="line">AddOrder(order *Order) (err error)</span><br><span class="line">QueryOrders(pageNumber, pageSize <span class="keyword">int</span>, condition *OrderFields) (orders []Order, err error)</span><br><span class="line">UpdateOrder(updated, condition *OrderFields) (err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h3><p>Dao层代码基本与之前一致，重点关注结构体<code>OrderRepo</code>，它是Model层<code>OrderRepository</code>的一种MySQL实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OrderRepo <span class="keyword">struct</span> &#123;</span><br><span class="line">db *gorm.DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将gorm.DB作为一个参数，在初始化时赋值：方便测试时，放一个mock的db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderRepo</span><span class="params">(db *gorm.DB)</span> *<span class="title">OrderRepo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;OrderRepo&#123;db: db&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-service层的实现"><a href="#3-service层的实现" class="headerlink" title="3.service层的实现"></a>3.service层的实现</h2><p>service是核心业务实现，但目前的示例代码比较简单，基本就是透传CRUD。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Service的实现，注意orderRepo的定义是model层的interface</span></span><br><span class="line"><span class="keyword">type</span> OrderService <span class="keyword">struct</span> &#123;</span><br><span class="line">orderRepo model.OrderRepository</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象，注意orderRepo的实现为dao层代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderService</span><span class="params">()</span> *<span class="title">OrderService</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;OrderService&#123;</span><br><span class="line">orderRepo: dao.NewOrderRepo(mysql.GormDB),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以List为例，透传查询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(orderSvc *OrderService)</span> <span class="title">List</span><span class="params">(ctx context.Context, pageNumber, pageSize <span class="keyword">int</span>, condition *model.OrderFields)</span> <span class="params">([]model.Order, error)</span></span> &#123;</span><br><span class="line">orders, err := orderSvc.orderRepo.QueryOrders(pageNumber, pageSize, condition)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;OrderService List pageNumber %d pageSize %d&quot;</span>, pageNumber, pageSize)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> orders, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-模拟HTTP接口访问"><a href="#4-模拟HTTP接口访问" class="headerlink" title="4.模拟HTTP接口访问"></a>4.模拟HTTP接口访问</h2><p>本服务支持gRPC和HTTP访问，但由于gRPC不方便用工具模拟，我们这里就以HTTP对本服务进行访问</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List</span></span><br><span class="line">curl --request GET <span class="string">&#x27;http://127.0.0.1:8081/v1/orders&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create</span></span><br><span class="line">curl --request POST <span class="string">&#x27;http://127.0.0.1:8081/v1/orders&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">--data-raw <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;order1&quot;,</span></span><br><span class="line"><span class="string">    &quot;price&quot;: 100.3</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update 这里 order 表示数据，update_mask表示更新的字段是price</span></span><br><span class="line">curl --request PATCH <span class="string">&#x27;http://127.0.0.1:8081/v1/orders&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">--data-raw <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;order&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;id&quot;: &quot;1&quot;,</span></span><br><span class="line"><span class="string">        &quot;name&quot;: &quot;order1&quot;,</span></span><br><span class="line"><span class="string">        &quot;price&quot;: 110.9</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;update_mask&quot;: &quot;price&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 查询name=order1的对象</span></span><br><span class="line">curl --request GET <span class="string">&#x27;http://127.0.0.1:8081/v1/orders/order1&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="关于Google风格的API总结"><a href="#关于Google风格的API总结" class="headerlink" title="关于Google风格的API总结"></a>关于Google风格的API总结</h2><p>Google风格的API和目前的主流RESTful标准的API有很多相似点、也存在一定的区别。</p><p>我们没有必要去抠API风格的细节实现、一定要与Google风格完全一致。API接口是一个通用协议，不同团队有自己的理解，就像RESTful标准的细节实现都有差异。</p><p>作为对外协议，最重要的是可读性，每个人都可以根据实际项目情况，对接口风格做一些适配性调整。这里介绍Google风格，主要是为了扩展大家的视野、拥有更多的技术实现方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这个版本，我们打通了API接口到MySQL数据库操作的全流程，是对整个框架的一次初步整合。接下来，我们会对这一流程进行精雕细琢，使其更具通用性和易用性。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着RPC与MySQL的打通，整个框架已经开始打通了数据的出入口。&lt;/p&gt;
&lt;p&gt;接下来，我们就尝试着实现通过RPC请求操作MySQL数据库，打通整个链路，真正地让这个平台实现可用。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 7.【GORM实战剖析】基本用法和原理解析</title>
    <link href="http://example.com/2021/09/15/go-tip/go-tip-7/"/>
    <id>http://example.com/2021/09/15/go-tip/go-tip-7/</id>
    <published>2021-09-15T04:00:00.000Z</published>
    <updated>2021-12-16T06:58:27.415Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="GORM库的官方文档"><a href="#GORM库的官方文档" class="headerlink" title="GORM库的官方文档"></a>GORM库的官方文档</h2><p>GORM库作为Go语言最受欢迎的ORM框架，提供了非常丰富的功能，大家可以通过阅读<a href="https://gorm.io/zh_CN/docs/index.html">中文官网</a>了解详情。</p><p>这里，先着重介绍一个背景：<strong>GORM内部会区分v1与v2两个版本</strong>，其中</p><ul><li>v1的包导入路径为 <code>github.com/jinzhu/gorm</code></li><li>v2的包导入路径为 <code>gorm.io/gorm</code></li></ul><p>v1与v2对使用者来说体验相差不大，今天就主要针对v2版本进行讲解。</p><span id="more"></span><h2 id="Talk-is-Cheap-Show-me-the-code"><a href="#Talk-is-Cheap-Show-me-the-code" class="headerlink" title="Talk is Cheap. Show me the code."></a>Talk is Cheap. Show me the code.</h2><p>接下来，我先给出一套个人比较推荐的CRUD代码。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><a href="https://gorm.io/zh_CN/docs/create.html">官方链接 - 创建</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;</span><br><span class="line"><span class="comment">// 直接创建</span></span><br><span class="line">result := db.Create(&amp;user)</span><br><span class="line"><span class="comment">// 指定字段创建</span></span><br><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量创建</span></span><br><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu3&quot;</span>&#125;&#125;</span><br><span class="line">db.Create(&amp;users)</span><br></pre></td></tr></table></figure><p>推荐：</p><ol><li>通常：直接用<strong>结构体</strong>或<strong>结构体的切片</strong>进行创建；</li><li>特殊：加上指定的字段，也就是其余字段不生效，如上面的<code>Birthday</code>。</li></ol><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><a href="https://gorm.io/zh_CN/docs/query.html">官方链接 - 查询</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有对象</span></span><br><span class="line"><span class="keyword">var</span> users []User  </span><br><span class="line">result := db.Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定查询条件（where）</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制返回数量</span></span><br><span class="line">db.Limit(<span class="number">10</span>).Offset(<span class="number">5</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询部分字段（即从select * 改造为 select name, age）</span></span><br><span class="line">db.Select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其余扩展</span></span><br><span class="line">db.Order(<span class="string">&quot;age desc, name&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure><p>推荐：</p><ol><li>普通场景：简单查询用<code>Find+Where</code>的函数结合实现，结合<code>Limit+Offset+Order</code>实现分页等高频功能；</li><li>追求性能：可以引入<code>Select</code>避免查询所有字段，但会导致返回结果部分字段不存在的奇怪现象，需要权衡；</li><li>复杂查询：例如<code>Join+子查询</code>等，推荐使用下面的原生SQL，用GORM拼接的体验并不好。</li></ol><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><a href="https://gorm.io/zh_CN/docs/update.html">官方链接 - 更新</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新通常包含两块，一个是要更新的字段Select+Updates，另一个是被更新数据的条件Where</span></span><br><span class="line">db.Model(&amp;user).Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;new_name&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>零值问题：参考<a href="https://gorm.io/zh_CN/docs/update.html#%E6%9B%B4%E6%96%B0%E5%A4%9A%E5%88%97">https://gorm.io/zh_CN/docs/update.html#%E6%9B%B4%E6%96%B0%E5%A4%9A%E5%88%97</a> 下的注释</p></blockquote><p>推荐：</p><ol><li>普通场景：利用<code>Select+Updates</code>指定更新字段，利用<code>Where</code>指定更新条件；</li><li>特殊场景：复杂SQL用原生SQL。</li></ol><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><a href="https://gorm.io/zh_CN/docs/delete.html">官方链接 - 删除</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除条件不建议太复杂，所以可以用简单的Where条件来拼接</span></span><br><span class="line">db.Where(<span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>).Delete(Email&#123;&#125;)</span><br></pre></td></tr></table></figure><p>推荐：</p><ol><li>普通场景：利用<code>Where</code>限定删除条件，不建议太复杂；</li><li>软删除：在实际项目中，不太建议用<code>硬删除</code>的方式，而是用<code>软删除</code>，即更新一个标记字段。</li></ol><h3 id="原生SQL"><a href="#原生SQL" class="headerlink" title="原生SQL"></a>原生SQL</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生SQL，推荐在复杂sql场景下使用</span></span><br><span class="line">db.Raw(<span class="string">&quot;SELECT id, name, age FROM users WHERE name = ?&quot;</span>, <span class="number">3</span>).Scan(&amp;result)</span><br></pre></td></tr></table></figure><h2 id="使用GORM的核心思路梳理"><a href="#使用GORM的核心思路梳理" class="headerlink" title="使用GORM的核心思路梳理"></a>使用GORM的核心思路梳理</h2><h3 id="一个对象-一行数据"><a href="#一个对象-一行数据" class="headerlink" title="一个对象 = 一行数据"></a>一个对象 = 一行数据</h3><p>示例中的一个<code>User</code>对象，完整地对应到具体<code>users</code>表中的一行数据，让整个框架更加清晰明了。每当数据库增加了一列，就对应地在结构体中加一个字段。这里有两个注意点：</p><ol><li>不要在核心结构体<code>User</code>中加入非表中的数据，如一些计算的中间值，引起二义性；</li><li><a href="https://gorm.io/zh_CN/docs/models.html#gorm-Model">gorm.Model</a>可以提升编码效率（会减少重复编码），但会限制数据库表中字段的定义，慎用（个人更希望它能开放成一个接口）；</li></ol><h3 id="选择生效字段-核心结构体-字段数组"><a href="#选择生效字段-核心结构体-字段数组" class="headerlink" title="选择生效字段 = 核心结构体 + 字段数组"></a>选择生效字段 = 核心结构体 + 字段数组</h3><p>在 <strong>查询</strong> 和 <strong>更新</strong> 接口里，我推荐的使用方法是采用核心结构体<code>User</code>+一个fields的数组，前者保存具体的数据、也实现了结构体复用，后者则选择生效的字段。</p><p>这种风格代码和Google推荐的<a href="https://cloud.google.com/apis/design/standard_methods#update">API风格</a>非常像，可读性很棒。</p><blockquote><p>这里还遗留了一个问题，就是fields数组里的字符串必须手输，可以考虑结合go generate自动生成这些fields的字符串常量，减少出错的概率。</p></blockquote><h3 id="缩短链式调用"><a href="#缩短链式调用" class="headerlink" title="缩短链式调用"></a>缩短链式调用</h3><p>GORM的主要风格是<a href="https://gorm.io/zh_CN/docs/method_chaining.html">链式调用</a>，类似于Builder设计模式、串联堆起一个SQL语句。这种调用方式扩展性很强，但会带来了一个很严重的问题：容易写出一个超长的链式调用，可维护成本大幅度提高。</p><p>所以，在我的推荐使用方式里，区分了两种场景：</p><ol><li>简单场景 - <strong>核心结构体 + 字段数组</strong></li><li>复杂场景 - <strong>原生SQL</strong></li></ol><h3 id="聚焦微服务的场景"><a href="#聚焦微服务的场景" class="headerlink" title="聚焦微服务的场景"></a>聚焦微服务的场景</h3><p>作为一个<code>ORM</code>工具，GORM要考虑兼容各种SQL语句，内部非常庞大的。但如今更多地是考虑微服务的场景，这就能抛开大量的历史包袱，实现得更加简洁。这里我简单列举三个不太推荐使用的SQL特性：</p><ol><li>减少group by - 考虑将聚合字段再单独放在一个表中</li><li>抛弃join - 多表关联采用多次查询（先查A表，然后用In语句去B表查）、或做一定的字段冗余（即同时放在A、B两个表里）</li><li>抛弃子查询，将相关逻辑放在代码里</li></ol><p>当然，真实业务研发过程中无法完全避免复杂SQL，我们只能有意识地减少引入复杂度。</p><h3 id="避免引入非原生MySQL的特性"><a href="#避免引入非原生MySQL的特性" class="headerlink" title="避免引入非原生MySQL的特性"></a>避免引入非原生MySQL的特性</h3><p>GORM除了常规的SQL功能，还提供了一些<a href="https://gorm.io/zh_CN/docs/models.html#%E9%AB%98%E7%BA%A7%E9%80%89%E9%A1%B9">高级特性</a>、<a href="https://gorm.io/zh_CN/docs/belongs_to.html">模型关联</a>、<a href="https://gorm.io/zh_CN/docs/hooks.html">钩子</a>等，非常炫酷。</p><p>但我不推荐大家在实际项目中使用这些特性。只有尽可能地保证这个框架简洁，才能保证代码后续的可维护性。</p><p>熟悉MySQL历史的朋友都知道，<strong>存储过程</strong>在以前相当一段时间都是很好的工具，但如今都倡导<strong>去存储过程</strong>。GORM的这些特性和存储过程有异曲同工之处：一个将业务逻辑放在了数据库，另一个则放到了ORM框架里，会导致后续的迁移成本变高。</p><blockquote><p>这也是我不推荐使用 gorm.Model的重要原因。</p></blockquote><h2 id="从查询接口了解GORM的核心实现"><a href="#从查询接口了解GORM的核心实现" class="headerlink" title="从查询接口了解GORM的核心实现"></a>从查询接口了解GORM的核心实现</h2><h3 id="两个核心文件"><a href="#两个核心文件" class="headerlink" title="两个核心文件"></a>两个核心文件</h3><p>在GORM库中，有两个核心的文件，也是我们调用频率最高的函数所在：<strong>chainable_api.go</strong>和 <strong>finisher_api.go</strong>。顾名思义，前者是整个链式调用的中间部分，后者则是最终获取结果的函数。以查询为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure><p>其中<code>Where</code>是chainable，也就是还在拼接SQL条件，<code>Find</code>则是触发真正查询的finisher。</p><p>如果一开始过于关注chainable调用，很容易陷入构造SQL的细节，所以这块代码建议从finisher入手，深入看看一个SQL的到底是怎么在GORM中拼接并执行的。</p><h3 id="Find的调用链路"><a href="#Find的调用链路" class="headerlink" title="Find的调用链路"></a>Find的调用链路</h3><h4 id="1-Find的主要代码"><a href="#1-Find的主要代码" class="headerlink" title="1. Find的主要代码"></a>1. Find的主要代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Find</span><span class="params">(dest <span class="keyword">interface</span>&#123;&#125;, conds ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(tx *DB)</span></span> &#123;</span><br><span class="line">tx = db.getInstance()</span><br><span class="line">  <span class="comment">// conds是查询的条件，这里忽略，我们默认已经在前面的Chainable中完成了所有参数的拼接</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(conds) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> exprs := tx.Statement.BuildCondition(conds[<span class="number">0</span>], conds[<span class="number">1</span>:]...); <span class="built_in">len</span>(exprs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">tx.Statement.AddClause(clause.Where&#123;Exprs: exprs&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tx.Statement.Dest = dest</span><br><span class="line">  <span class="comment">// 关键的执行逻辑</span></span><br><span class="line"><span class="keyword">return</span> tx.callbacks.Query().Execute(tx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-tx-callbacks-Query-的实现"><a href="#2-tx-callbacks-Query-的实现" class="headerlink" title="2. tx.callbacks.Query()的实现"></a>2. tx.callbacks.Query()的实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *callbacks)</span> <span class="title">Query</span><span class="params">()</span> *<span class="title">processor</span></span> &#123;</span><br><span class="line">  <span class="comment">// Query 是从processors的 map 中取出 query</span></span><br><span class="line"><span class="keyword">return</span> cs.processors[<span class="string">&quot;query&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个对应的processor是 gorm.DB，也就是执行DB的Execute</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initializeCallbacks</span><span class="params">(db *DB)</span> *<span class="title">callbacks</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;callbacks&#123;</span><br><span class="line">processors: <span class="keyword">map</span>[<span class="keyword">string</span>]*processor&#123;</span><br><span class="line"><span class="string">&quot;create&quot;</span>: &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;query&quot;</span>:  &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;update&quot;</span>: &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;delete&quot;</span>: &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;row&quot;</span>:    &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;raw&quot;</span>:    &#123;db: db&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Execute的执行逻辑"><a href="#3-Execute的执行逻辑" class="headerlink" title="3. Execute的执行逻辑"></a>3. Execute的执行逻辑</h4><p>抛开一些周边逻辑，我们聚焦于下面的核心逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processor)</span> <span class="title">Execute</span><span class="params">(db *DB)</span> *<span class="title">DB</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// processor中注册了多个函数，按顺序执行。</span></span><br><span class="line">  <span class="comment">// 核心的查询逻辑也在这里面</span></span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> p.fns &#123;</span><br><span class="line">f(db)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而fns又是来自callbacks</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processor)</span> <span class="title">compile</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 对 callbacks 会做排序</span></span><br><span class="line"><span class="keyword">if</span> p.fns, err = sortCallbacks(p.callbacks); err != <span class="literal">nil</span> &#123;</span><br><span class="line">p.db.Logger.Error(context.Background(), <span class="string">&quot;Got error when compile callbacks, got %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Callback的注册"><a href="#4-Callback的注册" class="headerlink" title="4. Callback的注册"></a>4. Callback的注册</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterDefaultCallbacks</span><span class="params">(db *gorm.DB, config *Config)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 默认注册了create/query/delete/update/raw 五种 callback 大类，这里以query为例</span></span><br><span class="line">queryCallback := db.Callback().Query()</span><br><span class="line">queryCallback.Register(<span class="string">&quot;gorm:query&quot;</span>, Query)</span><br><span class="line">queryCallback.Register(<span class="string">&quot;gorm:preload&quot;</span>, Preload)</span><br><span class="line">queryCallback.Register(<span class="string">&quot;gorm:after_query&quot;</span>, AfterQuery)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(config.QueryClauses) == <span class="number">0</span> &#123;</span><br><span class="line">config.QueryClauses = queryClauses</span><br><span class="line">&#125;</span><br><span class="line">queryCallback.Clauses = config.QueryClauses</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-Query函数的实现"><a href="#5-Query函数的实现" class="headerlink" title="5. Query函数的实现"></a>5. Query函数的实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Query</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> db.Error == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 构建查询的 SQL 语句</span></span><br><span class="line">BuildQuerySQL(db)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询数据</span></span><br><span class="line"><span class="keyword">if</span> !db.DryRun &amp;&amp; db.Error == <span class="literal">nil</span> &#123;</span><br><span class="line">rows, err := db.Statement.ConnPool.QueryContext(db.Statement.Context, db.Statement.SQL.String(), db.Statement.Vars...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">db.AddError(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将结果输出到目标结构体中</span></span><br><span class="line">gorm.Scan(rows, db, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-核心-构建SQL的实现"><a href="#6-核心-构建SQL的实现" class="headerlink" title="6.核心-构建SQL的实现"></a>6.核心-构建SQL的实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildQuerySQL</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line">  <span class="comment">// SQL为空，表示需要自己构建</span></span><br><span class="line"><span class="keyword">if</span> db.Statement.SQL.String() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">db.Statement.SQL.Grow(<span class="number">100</span>) <span class="comment">// 分配初始空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(db.Statement.Selects) &gt; <span class="number">0</span> &#123; </span><br><span class="line">      <span class="comment">// 表示只select某几个字段，而不是select *</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> db.Statement.Schema != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(db.Statement.Omits) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// Omit表示忽略特定字段</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> db.Statement.Schema != <span class="literal">nil</span> &amp;&amp; db.Statement.ReflectValue.IsValid() &#123;</span><br><span class="line">      <span class="comment">// 查询到指定结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对join的处理，涉及到多表关联，暂时忽略</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(db.Statement.Joins) != <span class="number">0</span> &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">db.Statement.AddClauseIfNotExists(clause.From&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用一个map去重，符合名字中的 IfNotExists 含义</span></span><br><span class="line">db.Statement.AddClauseIfNotExists(clauseSelect)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后拼接出完整 SQL 的地方</span></span><br><span class="line">db.Statement.Build(db.Statement.BuildClauses...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文旨在介绍GORM的推荐使用方式，并简单阅读对接数据库的相关代码。这里分享我的四个观点：</p><ol><li><strong>Builder设计模式</strong> - 在面对复杂场景中，Builder设计模式扩展性很好，可分为两个阶段：存储数据+处理数据；GORM的调用就是采用了chainable+finisher的两段实现，前者保存SQL相关元数据，后者拼接SQL并执行；</li><li><strong>负重前行</strong> - GORM是一个负重前行的框架：它不仅支持了所有原生SQL的特性，也增加了很多类似Hook的高级特性，导致这个框架非常庞大。如果团队没有历史包袱，更推荐<strong>节制</strong>地使用GORM特性，适当封装一层；</li><li><strong>interface{}问题</strong> - GORM中许多函数入参的数据类型都是<code>interface&#123;&#125;</code>，底层又用reflect支持了多种类型，这种实现会导致两个问题：<ol><li>reflect导致的底层的性能不高（这点还能接受）</li><li>interface{}如果传入了不支持的复杂数据类型时，排查问题麻烦，往往要运行程序时才会报错</li></ol></li><li><strong>高频拼接重复SQL</strong> - 在一个程序运行过程中，执行的SQL语句都比较固定，而变化的往往是参数；从GORM的实现来看，每次执行都需要重新拼接一次SQL语句，是有不小的优化空间的，比如引入一定的cache。</li></ol><p>希望这四点能对大家的日常工作有所启发~</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;GORM库的官方文档&quot;&gt;&lt;a href=&quot;#GORM库的官方文档&quot; class=&quot;headerlink&quot; title=&quot;GORM库的官方文档&quot;&gt;&lt;/a&gt;GORM库的官方文档&lt;/h2&gt;&lt;p&gt;GORM库作为Go语言最受欢迎的ORM框架，提供了非常丰富的功能，大家可以通过阅读&lt;a href=&quot;https://gorm.io/zh_CN/docs/index.html&quot;&gt;中文官网&lt;/a&gt;了解详情。&lt;/p&gt;
&lt;p&gt;这里，先着重介绍一个背景：&lt;strong&gt;GORM内部会区分v1与v2两个版本&lt;/strong&gt;，其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v1的包导入路径为 &lt;code&gt;github.com/jinzhu/gorm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;v2的包导入路径为 &lt;code&gt;gorm.io/gorm&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;v1与v2对使用者来说体验相差不大，今天就主要针对v2版本进行讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
</feed>
