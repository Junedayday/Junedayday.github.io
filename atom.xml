<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Junedayday Blog</title>
  
  <subtitle>六月天天的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-11T08:58:13.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Junedayday</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言微服务框架 - 8.Gormer迭代-定制专属的ORM代码生成工具</title>
    <link href="http://example.com/2021/10/10/go-framework/go-framework-8/"/>
    <id>http://example.com/2021/10/10/go-framework/go-framework-8/</id>
    <published>2021-10-10T04:00:00.000Z</published>
    <updated>2021-10-11T08:58:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>在上一篇，我们写一个<code>gormer</code>工具库，支持了简单的CRUD。但是，在实际的开发场景中，这部分的功能仍显得非常单薄。</p><p>例如，我们对比一下GORM库提供的<code>gorm.Model</code>，它在新增、修改时，会自动修改对应的时间，这个可以帮我们减少很多重复性的代码编写。这里，我就针对现有的gormer工具做一个示例性的迭代。</p><span id="more"></span><h2 id="v0-5-2：Gormer迭代-定制更智能的代码生成工具"><a href="#v0-5-2：Gormer迭代-定制更智能的代码生成工具" class="headerlink" title="v0.5.2：Gormer迭代-定制更智能的代码生成工具"></a>v0.5.2：Gormer迭代-定制更智能的代码生成工具</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.5.2">https://github.com/Junedayday/micro_web_service/tree/v0.5.2</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>生成一套智能化的Dao层代码，兼容软删除和硬删除。</p><blockquote><p>这里提一下软删除的概念，就是指在数据库中用某个字段标记为删除，但这行数据仍存在；而硬删除就是直接删除整条数据。</p><p>软删除虽然增加了一定的复杂度，但带来的收益很大。最直接的好处就是能保留记录，方便查原始记录。</p></blockquote><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>gormer.yaml的文件</li><li>模板文件的修改</li><li>核心结构体梳理</li><li>API调用示例</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><p>为了方便理解，我将简化对应的目录结构一层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务，包括基础结构、HTTP接口、gRPC接口</span><br><span class="line">    |-- order                            对应idl/order服务，同上</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义，protobuffer的原始定义</span><br><span class="line">   |-- order                           业务order定义，同时干</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹，viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层，是model层的实现</span><br><span class="line">   |-- gormer                          从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">   |-- model                           model层，定义对象的接口方法，具体实现在dao层</span><br><span class="line">   |-- mysql                           MySQL连接</span><br><span class="line">   |-- server                          服务器的实现，对idl中定义服务的具体实现</span><br><span class="line">   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">     |-- zlog                            封装zap日志的代码实现</span><br><span class="line">  |-- pkg                            开放给第三方的工具库</span><br><span class="line">     |-- gormer                          修改：gormer二进制工具，用于生成Gorm相关Dao层代码</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义，从v1beta升到v1</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- gen.sh                         生成代码的脚本：buf+gormer</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- gormer.yaml                    新增：将gormer中的参数移动到这里</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-gormer-yaml的文件"><a href="#1-gormer-yaml的文件" class="headerlink" title="1.gormer.yaml的文件"></a>1.gormer.yaml的文件</h2><p>这里先给出具体的建表语句，可以清晰地看到orders表6个字段的具体含义：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders</span><br><span class="line">(</span><br><span class="line">id <span class="type">bigint</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">255</span>) COMMENT <span class="string">&#x27;名称，建议唯一&#x27;</span>,</span><br><span class="line">price <span class="type">decimal</span>(<span class="number">15</span>,<span class="number">3</span>) COMMENT <span class="string">&#x27;订单价格&#x27;</span>,</span><br><span class="line">create_time <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">update_time <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">delete_status tinyint(<span class="number">3</span>) COMMENT <span class="string">&#x27;删除状态，1表示软删除&#x27;</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;订单信息表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>我们回顾一下之前的gormer程序，它采用了<code>flag</code>参数解析的方式。但随着复杂度提升，命令行参数包含了大量的内容，很难维护。这时，就建议采用<strong>配置文件</strong>的方式，保证可读性、可维护性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库相关的信息</span></span><br><span class="line"><span class="attr">database:</span></span><br><span class="line">  <span class="comment"># 数据库连接</span></span><br><span class="line">  <span class="attr">dsn:</span> <span class="string">&quot;root:123456@tcp(127.0.0.1:3306)/demo&quot;</span></span><br><span class="line">  <span class="comment"># 所有要生成到Go结构体中的表</span></span><br><span class="line">  <span class="attr">tables:</span></span><br><span class="line">    <span class="comment"># name-表名</span></span><br><span class="line">    <span class="comment"># goStruct-Go中结构体名</span></span><br><span class="line">    <span class="comment"># createTime-创建时间的数据库字段，必须为时间格式</span></span><br><span class="line">    <span class="comment"># updateTime-更新时间的数据库字段，必须为时间格式</span></span><br><span class="line">    <span class="comment"># softDeleteKey-软删除的数据库字段，必须为整数型，不填则为硬删除</span></span><br><span class="line">    <span class="comment"># softDeleteValue-表示为软删除的对应值</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;orders&quot;</span></span><br><span class="line">      <span class="attr">goStruct:</span> <span class="string">&quot;Order&quot;</span></span><br><span class="line">      <span class="attr">createTime:</span> <span class="string">&quot;create_time&quot;</span></span><br><span class="line">      <span class="attr">updateTime:</span> <span class="string">&quot;update_time&quot;</span></span><br><span class="line">      <span class="attr">softDeleteKey:</span> <span class="string">&quot;delete_status&quot;</span></span><br><span class="line">      <span class="attr">softDeleteValue:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目相关的信息</span></span><br><span class="line"><span class="attr">project:</span></span><br><span class="line">  <span class="comment"># 项目的路径</span></span><br><span class="line">  <span class="attr">base:</span> <span class="string">&quot;./&quot;</span></span><br><span class="line">  <span class="comment"># gorm相关核心结构的代码路径</span></span><br><span class="line">  <span class="attr">gorm:</span> <span class="string">&quot;internal/gormer/&quot;</span></span><br><span class="line">  <span class="comment"># dao层CRUD核心结构的代码路径</span></span><br><span class="line">  <span class="attr">dao:</span> <span class="string">&quot;internal/dao/&quot;</span></span><br><span class="line">  <span class="comment"># 项目的go module信息</span></span><br><span class="line">  <span class="attr">go_mod:</span> <span class="string">&quot;github.com/Junedayday/micro_web_service&quot;</span></span><br></pre></td></tr></table></figure><h2 id="2-模板文件的修改"><a href="#2-模板文件的修改" class="headerlink" title="2.模板文件的修改"></a>2.模板文件的修改</h2><p>这里以两个具有代表性的操作为例，一起来看看具体代码。</p><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><p>利用了go template的特性，填充了create_time和update_time字段。这里包含两层if语句：</p><ul><li>第一层：在<code>gormer.yaml</code>里必须指定了createTime代码，否则不要生成这段代码</li><li>第二层：如果外部传进来的字段里没有指定时间，才填充最新的时间；否则以外部传入为准</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">daoTmplAdd = <span class="string">`func (repo *&#123;&#123;.StructName&#125;&#125;Repo) Add&#123;&#123;.StructName&#125;&#125;(&#123;&#123;.StructSmallCamelName&#125;&#125; *gormer.&#123;&#123;.StructName&#125;&#125;) (err error) &#123;</span></span><br><span class="line"><span class="string">&#123;&#123;if ne .FieldCreateTime &quot;&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">    if &#123;&#123;.StructSmallCamelName&#125;&#125;.&#123;&#123;.FieldCreateTime&#125;&#125;.IsZero() &#123;</span></span><br><span class="line"><span class="string">&#123;&#123;.StructSmallCamelName&#125;&#125;.&#123;&#123;.FieldCreateTime&#125;&#125; = time.Now()</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;if ne .FieldUpdateTime &quot;&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">    if &#123;&#123;.StructSmallCamelName&#125;&#125;.&#123;&#123;.FieldUpdateTime&#125;&#125;.IsZero() &#123;</span></span><br><span class="line"><span class="string">&#123;&#123;.StructSmallCamelName&#125;&#125;.&#123;&#123;.FieldUpdateTime&#125;&#125; = time.Now()</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">err = repo.db.</span></span><br><span class="line"><span class="string">Table(gormer.&#123;&#123;.StructName&#125;&#125;TableName).</span></span><br><span class="line"><span class="string">Create(&#123;&#123;.StructSmallCamelName&#125;&#125;).</span></span><br><span class="line"><span class="string">Error</span></span><br><span class="line"><span class="string">return</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">AddOrder</span><span class="params">(order *gormer.Order)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> order.CreateTime.IsZero() &#123;</span><br><span class="line">order.CreateTime = time.Now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> order.UpdateTime.IsZero() &#123;</span><br><span class="line">order.UpdateTime = time.Now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = repo.db.</span><br><span class="line">Table(gormer.OrderTableName).</span><br><span class="line">Create(order).</span><br><span class="line">Error</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除的逻辑主要区分了一个字段，即是否在<code>gormer.yaml</code>里指定了软删除的字段。</p><ul><li>指定了软删除的字段，则将这个字段更新为设定的值、并且更新updateTime字段；</li><li>未指定软删除的字段，则直接硬删除对应的记录；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">daoTmplDelete = <span class="string">`func (repo *&#123;&#123;.StructName&#125;&#125;Repo) Delete&#123;&#123;.StructName&#125;&#125;(condition *gormer.&#123;&#123;.StructName&#125;&#125;Options) (err error) &#123;</span></span><br><span class="line"><span class="string">if condition == nil &#123;</span></span><br><span class="line"><span class="string">return errors.New(&quot;delete must include where condition&quot;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">err = repo.db.</span></span><br><span class="line"><span class="string">        Table(gormer.&#123;&#123;.StructName&#125;&#125;TableName).</span></span><br><span class="line"><span class="string">Where(condition.&#123;&#123;.StructName&#125;&#125;, condition.Fields).</span></span><br><span class="line"><span class="string">&#123;&#123;if eq .FieldSoftDeleteKey &quot;&quot; &#125;&#125; Delete(&amp;gormer.&#123;&#123;.StructName&#125;&#125;&#123;&#125;).</span></span><br><span class="line"><span class="string">&#123;&#123; else &#125;&#125;  &#123;&#123;if eq .FieldUpdateTime &quot;&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">Select(&quot;&#123;&#123;.TableSoftDeleteKey&#125;&#125;&quot;).</span></span><br><span class="line"><span class="string">Updates(&amp;gormer.&#123;&#123;.StructName&#125;&#125;&#123;</span></span><br><span class="line"><span class="string">&#123;&#123;.FieldSoftDeleteKey&#125;&#125;:&#123;&#123;.TableSoftDeleteValue&#125;&#125;,</span></span><br><span class="line"><span class="string">&#125;).</span></span><br><span class="line"><span class="string">            &#123;&#123; else &#125;&#125;</span></span><br><span class="line"><span class="string">                Select(&quot;&#123;&#123;.TableSoftDeleteKey&#125;&#125;&quot;,&quot;&#123;&#123;.TableUpdateTime&#125;&#125;&quot;).</span></span><br><span class="line"><span class="string">Updates(&amp;gormer.&#123;&#123;.StructName&#125;&#125;&#123;</span></span><br><span class="line"><span class="string">&#123;&#123;.FieldSoftDeleteKey&#125;&#125;:&#123;&#123;.TableSoftDeleteValue&#125;&#125;,</span></span><br><span class="line"><span class="string">&#123;&#123;.FieldUpdateTime&#125;&#125; : time.Now(),</span></span><br><span class="line"><span class="string">&#125;).</span></span><br><span class="line"><span class="string">            &#123;&#123; end &#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123; end &#125;&#125;</span></span><br><span class="line"><span class="string">Error</span></span><br><span class="line"><span class="string">return</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">DeleteOrder</span><span class="params">(condition *gormer.OrderOptions)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> condition == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;delete must include where condition&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = repo.db.</span><br><span class="line">Table(gormer.OrderTableName).</span><br><span class="line">Where(condition.Order, condition.Fields).</span><br><span class="line">Select(<span class="string">&quot;delete_status&quot;</span>, <span class="string">&quot;update_time&quot;</span>).</span><br><span class="line">Updates(&amp;gormer.Order&#123;</span><br><span class="line">DeleteStatus: <span class="number">1</span>,</span><br><span class="line">UpdateTime:   time.Now(),</span><br><span class="line">&#125;).</span><br><span class="line">Error</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-核心结构体梳理"><a href="#3-核心结构体梳理" class="headerlink" title="3.核心结构体梳理"></a>3.核心结构体梳理</h2><p>我们再一起看看表结构对应到Go结构体的一个关键结构体，这里分成了4个重要的部分：</p><ol><li>表名、结构体名</li><li>表中的列信息、结构体中的Field字段信息</li><li>创建时间、更新时间</li><li>软删除的字段</li></ol><p>这个数据结构体，其实是将两个数据源进行了关联映射：</p><ul><li>原始信息：从MySQL表中查询</li><li>自定义字段信息：从gormer.yaml查询</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StructLevel <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// table -&gt; struct</span></span><br><span class="line">TableName            <span class="keyword">string</span></span><br><span class="line">StructName           <span class="keyword">string</span></span><br><span class="line">StructSmallCamelName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// table column -&gt; struct field</span></span><br><span class="line">Columns []FieldLevel</span><br><span class="line"></span><br><span class="line"><span class="comment">// create time</span></span><br><span class="line">TableCreateTime <span class="keyword">string</span></span><br><span class="line">FieldCreateTime <span class="keyword">string</span></span><br><span class="line"><span class="comment">// update time</span></span><br><span class="line">TableUpdateTime <span class="keyword">string</span></span><br><span class="line">FieldUpdateTime <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// soft delete</span></span><br><span class="line">TableSoftDeleteKey   <span class="keyword">string</span></span><br><span class="line">TableSoftDeleteValue <span class="keyword">int</span></span><br><span class="line">FieldSoftDeleteKey   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FieldLevel <span class="keyword">struct</span> &#123;</span><br><span class="line">FieldName <span class="keyword">string</span></span><br><span class="line">FieldType <span class="keyword">string</span></span><br><span class="line"><span class="comment">// gorm tag for field</span></span><br><span class="line">GormName <span class="keyword">string</span></span><br><span class="line"><span class="comment">// comment from create table sql</span></span><br><span class="line">Comment <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-API调用示例"><a href="#4-API调用示例" class="headerlink" title="4.API调用示例"></a>4.API调用示例</h2><p>从API调用的角度来看，程序对外接口如下。有兴趣的可以体验下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// List</span><br><span class="line">curl --location --request GET &#x27;http://127.0.0.1:8081/v1/orders&#x27;</span><br><span class="line"></span><br><span class="line">// Create</span><br><span class="line">curl --location --request POST &#x27;http://127.0.0.1:8081/v1/orders&#x27; \</span><br><span class="line">--header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">--data-raw &#x27;&#123;</span><br><span class="line">    &quot;name&quot;: &quot;order4&quot;,</span><br><span class="line">    &quot;price&quot;: 100.3</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br><span class="line">// Update</span><br><span class="line">curl --location --request PATCH &#x27;http://127.0.0.1:8081/v1/orders&#x27; \</span><br><span class="line">--header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">--data-raw &#x27;&#123;</span><br><span class="line">    &quot;order&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;order1&quot;,</span><br><span class="line">        &quot;price&quot;: 110.8</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;update_mask&quot;: &quot;price&quot;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br><span class="line">// Get</span><br><span class="line">curl --location --request GET &#x27;http://127.0.0.1:8081/v1/orders/order1&#x27;</span><br><span class="line"></span><br><span class="line">// Delete</span><br><span class="line">curl --location --request DELETE &#x27;http://127.0.0.1:8081/v1/orders/order1&#x27;</span><br></pre></td></tr></table></figure><h2 id="延伸思考"><a href="#延伸思考" class="headerlink" title="延伸思考"></a>延伸思考</h2><p>修改到这个版本，gormer工具已经达到了基本可用的阶段。我们回顾一下重点功能：<strong>根据数据库表结构，自动化生成dao层的CRUD代码</strong>，并扩展了两特性：</p><ol><li>支持创建时间、修改时间的字段，自动填充</li><li>支持软删除与硬删除</li></ol><p>从更远的角度来看，还有许多MySQL的特性可以添加，尤其是对事务的支持，有兴趣的可以自行探索。限于篇幅与复杂度，目前就迭代到这个版本。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Gormer是一个我们根据日常CRUD需求自行实现的工具，是框架实现高度自动化的重要环节。它的核心思想是 - <strong>在重复的日常开发过程中找到可自动化的环节，实现Generate Code</strong>。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一篇，我们写一个&lt;code&gt;gormer&lt;/code&gt;工具库，支持了简单的CRUD。但是，在实际的开发场景中，这部分的功能仍显得非常单薄。&lt;/p&gt;
&lt;p&gt;例如，我们对比一下GORM库提供的&lt;code&gt;gorm.Model&lt;/code&gt;，它在新增、修改时，会自动修改对应的时间，这个可以帮我们减少很多重复性的代码编写。这里，我就针对现有的gormer工具做一个示例性的迭代。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 7.Gormer-自动生成代码的初体验</title>
    <link href="http://example.com/2021/09/27/go-framework/go-framework-7/"/>
    <id>http://example.com/2021/09/27/go-framework/go-framework-7/</id>
    <published>2021-09-27T04:00:00.000Z</published>
    <updated>2021-10-11T09:33:37.212Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>CRUD是贯穿整个程序员日常开发的基本工作，占据了我们绝大多数的coding时间。</p><p>作为一名程序员，我们总是希望能有更简单的开发方式来解决重复性的工作问题。在这个小版本中，我将结合自己的工作，来给出一套自动生成代码的完整方案，供大家借鉴。</p><span id="more"></span><h2 id="v0-5-1：Gormer-自动生成代码的初体验"><a href="#v0-5-1：Gormer-自动生成代码的初体验" class="headerlink" title="v0.5.1：Gormer-自动生成代码的初体验"></a>v0.5.1：Gormer-自动生成代码的初体验</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.5.1">https://github.com/Junedayday/micro_web_service/tree/v0.5.1</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>自动生成一套可用的Dao层代码，兼容原始版本。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>Go Template技术概览</li><li>gormer工具核心思路</li><li>gormer的模板填充</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务</span><br><span class="line">         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">    |-- order                            对应idl/order服务</span><br><span class="line">         |-- order.pb.go                       order.proto的基础结构</span><br><span class="line">         |-- order.pb.gw.go                    order.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- order_grpc.pb.go                  order.proto的gRPC接口代码</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义</span><br><span class="line">      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">   |-- order                           业务order定义</span><br><span class="line">      |-- order.proto                      protobuffer的原始定义</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹</span><br><span class="line">      |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层</span><br><span class="line">      |-- order.go                         Order对象，订单表，实现model层的OrderRepository</span><br><span class="line">      |-- order_test.go                    Order的单元测试</span><br><span class="line">   |-- gormer                          新增：从pkg/gormer中生成的相关代码，不允许更改</span><br><span class="line">      |-- order.go                         新增：gormer从orders表中获取的真实Gorm结构体</span><br><span class="line">   |-- model                           model层，定义对象的接口方法</span><br><span class="line">      |-- order.go                         OrderRepository接口，具体实现在dao层</span><br><span class="line">   |-- mysql                           MySQL连接</span><br><span class="line">      |-- init.go                          初始化连接到MySQL的工作</span><br><span class="line">   |-- server                          服务器的实现</span><br><span class="line">      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">   |-- service                         service层，作为领域实现的核心部分</span><br><span class="line">      |-- order.go                         Order相关的服务，目前仅简单的CRUD</span><br><span class="line">     |-- zlog                            封装日志的文件夹</span><br><span class="line">        |-- zap.go                           zap封装的代码实现</span><br><span class="line">  |-- pkg                            新增：开放给第三方的工具库</span><br><span class="line">     |-- gormer                          新增：gormer工具，用于生成Gorm相关Dao层代码</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义，从v1beta升到v1</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- gen.sh                         更新：生成代码的脚本：buf+gormer</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-Go-Template技术概览"><a href="#1-Go-Template技术概览" class="headerlink" title="1.Go Template技术概览"></a>1.Go Template技术概览</h2><p>Go的标准库提供了Template功能，但网上的介绍很零散，我建议大家可以阅读以下两篇资料：</p><ul><li>原理性：官方文档 - <a href="https://pkg.go.dev/text/template">https://pkg.go.dev/text/template</a> </li><li>实践性：Blog - <a href="https://blog.gopheracademy.com/advent-2017/using-go-templates/">https://blog.gopheracademy.com/advent-2017/using-go-templates/</a> </li></ul><p>这里，为了方便大家阅读下面的内容，我简要概括下：</p><ol><li>结构体中字段填充 <code>&#123;&#123; .FieldName &#125;&#125;</code></li><li>条件语句 <code>&#123;&#123;if .FieldName&#125;&#125; // action &#123;&#123; else &#125;&#125; // action 2 &#123;&#123; end &#125;&#125;</code></li><li>循环 <code>&#123;&#123;range .Member&#125;&#125; ... &#123;&#123;end&#125;&#125;</code></li><li>流水线 <code>&#123;&#123; with $x := <^>result-of-some-action<^> &#125;&#125; &#123;&#123; $x &#125;&#125; &#123;&#123; end &#125;&#125;</code></li></ol><blockquote><p>很多资料会很自然地将Go Template和HTML结合起来，但这只是模板的其中一个用法。</p><p>HTML的结构用模板化的方式可以减少大量重复性的代码，但这种思路是前后单不分离的，个人不太推荐。</p></blockquote><h2 id="2-gormer工具核心思路"><a href="#2-gormer工具核心思路" class="headerlink" title="2.gormer工具核心思路"></a>2.gormer工具核心思路</h2><p>在pkg/gormer目录下提供了一个gormer工具，用于自动生成代码，我对主流程进行简单地讲解：</p><ol><li>解析各种关键性的参数</li><li>连接测试数据库，获取表信息</li><li>逐个处理每个表<ol><li>读取数据库中的表结构</li><li>根据表结构生成对应的Go语言结构体，放在internal/gormer下</li><li>生成相关的Dao层代码，放在internal/dao下</li></ol></li><li>执行go fmt格式化代码</li></ol><p>其中最关键的是3-b与3-c，它们是生成代码的最关键步骤。我们来看一个关键性的结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体名称，对应MySQL表级别的信息</span></span><br><span class="line"><span class="keyword">type</span> StructLevel <span class="keyword">struct</span> &#123;</span><br><span class="line">TableName      <span class="keyword">string</span></span><br><span class="line">Name           <span class="keyword">string</span></span><br><span class="line">SmallCamelName <span class="keyword">string</span></span><br><span class="line">Columns        []FieldLevel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Field字段名称，对应MySQL表里Column</span></span><br><span class="line"><span class="keyword">type</span> FieldLevel <span class="keyword">struct</span> &#123;</span><br><span class="line">FieldName <span class="keyword">string</span></span><br><span class="line">FieldType <span class="keyword">string</span></span><br><span class="line">GormName  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-gormer的模板填充"><a href="#3-gormer的模板填充" class="headerlink" title="3.gormer的模板填充"></a>3.gormer的模板填充</h2><p>结合1、2，我们可以开始生成模板的部分，具体的Template代码如下，它会将StructLevel这个结构体中的字段填充到下面内容中，生成go文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gormerTmpl = <span class="string">`</span></span><br><span class="line"><span class="string">// Table Level Info</span></span><br><span class="line"><span class="string">const &#123;&#123;.Name&#125;&#125;TableName = &quot;&#123;&#123;.TableName&#125;&#125;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Field Level Info</span></span><br><span class="line"><span class="string">type &#123;&#123;.Name&#125;&#125;Field string</span></span><br><span class="line"><span class="string">const (</span></span><br><span class="line"><span class="string">&#123;&#123;range $item := .Columns&#125;&#125;</span></span><br><span class="line"><span class="string">    &#123;&#123;$.Name&#125;&#125;Field&#123;&#123;$item.FieldName&#125;&#125; &#123;&#123;$.Name&#125;&#125;Field = &quot;&#123;&#123;$item.GormName&#125;&#125;&quot; &#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var &#123;&#123;$.Name&#125;&#125;FieldAll = []&#123;&#123;$.Name&#125;&#125;Field&#123; &#123;&#123;range $k,$item := .Columns&#125;&#125;&quot;&#123;&#123;$item.GormName&#125;&#125;&quot;, &#123;&#123;end&#125;&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Kernel struct for table for one row</span></span><br><span class="line"><span class="string">type &#123;&#123;.Name&#125;&#125; struct &#123; &#123;&#123;range $item := .Columns&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;$item.FieldName&#125;&#125;&#123;&#123;$item.FieldType&#125;&#125;`</span> + <span class="string">&quot;`&quot;</span> + <span class="string">`gorm:&quot;column:&#123;&#123;$item.GormName&#125;&#125;&quot;`</span> + <span class="string">&quot;`&quot;</span> + <span class="string">` &#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Kernel struct for table operation</span></span><br><span class="line"><span class="string">type &#123;&#123;.Name&#125;&#125;Options struct &#123;</span></span><br><span class="line"><span class="string">    &#123;&#123;.Name&#125;&#125; *&#123;&#123;.Name&#125;&#125;</span></span><br><span class="line"><span class="string">    Fields []string</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Match: case insensitive</span></span><br><span class="line"><span class="string">var &#123;&#123;$.Name&#125;&#125;FieldMap = map[string]string&#123;</span></span><br><span class="line"><span class="string">&#123;&#123;range $item := .Columns&#125;&#125;&quot;&#123;&#123;$item.FieldName&#125;&#125;&quot;:&quot;&#123;&#123;$item.GormName&#125;&#125;&quot;,&quot;&#123;&#123;$item.GormName&#125;&#125;&quot;:&quot;&#123;&#123;$item.GormName&#125;&#125;&quot;,</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func New&#123;&#123;.Name&#125;&#125;Options(target *&#123;&#123;.Name&#125;&#125;, fields ...&#123;&#123;$.Name&#125;&#125;Field) *&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">    options := &amp;&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">        &#123;&#123;.Name&#125;&#125;: target,</span></span><br><span class="line"><span class="string">        Fields: make([]string, len(fields)),</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    for index, field := range fields &#123;</span></span><br><span class="line"><span class="string">        options.Fields[index] = string(field)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return options</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func New&#123;&#123;.Name&#125;&#125;OptionsAll(target *&#123;&#123;.Name&#125;&#125;) *&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">    return New&#123;&#123;.Name&#125;&#125;Options(target, &#123;&#123;$.Name&#125;&#125;FieldAll...)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func New&#123;&#123;.Name&#125;&#125;OptionsRawString(target *&#123;&#123;.Name&#125;&#125;, fields ...string) *&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">    options := &amp;&#123;&#123;.Name&#125;&#125;Options&#123;</span></span><br><span class="line"><span class="string">        &#123;&#123;.Name&#125;&#125;: target,</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    for _, field := range fields &#123;</span></span><br><span class="line"><span class="string">        if f,ok := &#123;&#123;$.Name&#125;&#125;FieldMap[field];ok &#123;</span></span><br><span class="line"><span class="string">             options.Fields = append(options.Fields, f)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return options</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>生成的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code generated by gormer. DO NOT EDIT.</span></span><br><span class="line"><span class="keyword">package</span> gormer</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Table Level Info</span></span><br><span class="line"><span class="keyword">const</span> OrderTableName = <span class="string">&quot;orders&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field Level Info</span></span><br><span class="line"><span class="keyword">type</span> OrderField <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">OrderFieldId         OrderField = <span class="string">&quot;id&quot;</span></span><br><span class="line">OrderFieldName       OrderField = <span class="string">&quot;name&quot;</span></span><br><span class="line">OrderFieldPrice      OrderField = <span class="string">&quot;price&quot;</span></span><br><span class="line">OrderFieldCreateTime OrderField = <span class="string">&quot;create_time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> OrderFieldAll = []OrderField&#123;<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;price&quot;</span>, <span class="string">&quot;create_time&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kernel struct for table for one row</span></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">Id         <span class="keyword">int64</span>     <span class="string">`gorm:&quot;column:id&quot;`</span></span><br><span class="line">Name       <span class="keyword">string</span>    <span class="string">`gorm:&quot;column:name&quot;`</span></span><br><span class="line">Price      <span class="keyword">float64</span>   <span class="string">`gorm:&quot;column:price&quot;`</span></span><br><span class="line">CreateTime time.Time <span class="string">`gorm:&quot;column:create_time&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kernel struct for table operation</span></span><br><span class="line"><span class="keyword">type</span> OrderOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">Order  *Order</span><br><span class="line">Fields []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Match: case insensitive</span></span><br><span class="line"><span class="keyword">var</span> OrderFieldMap = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;Id&quot;</span>: <span class="string">&quot;id&quot;</span>, <span class="string">&quot;id&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line"><span class="string">&quot;Name&quot;</span>: <span class="string">&quot;name&quot;</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line"><span class="string">&quot;Price&quot;</span>: <span class="string">&quot;price&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="string">&quot;price&quot;</span>,</span><br><span class="line"><span class="string">&quot;CreateTime&quot;</span>: <span class="string">&quot;create_time&quot;</span>, <span class="string">&quot;create_time&quot;</span>: <span class="string">&quot;create_time&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderOptions</span><span class="params">(target *Order, fields ...OrderField)</span> *<span class="title">OrderOptions</span></span> &#123;</span><br><span class="line">options := &amp;OrderOptions&#123;</span><br><span class="line">Order:  target,</span><br><span class="line">Fields: <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(fields)),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, field := <span class="keyword">range</span> fields &#123;</span><br><span class="line">options.Fields[index] = <span class="keyword">string</span>(field)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderOptionsAll</span><span class="params">(target *Order)</span> *<span class="title">OrderOptions</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> NewOrderOptions(target, OrderFieldAll...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderOptionsRawString</span><span class="params">(target *Order, fields ...<span class="keyword">string</span>)</span> *<span class="title">OrderOptions</span></span> &#123;</span><br><span class="line">options := &amp;OrderOptions&#123;</span><br><span class="line">Order: target,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, field := <span class="keyword">range</span> fields &#123;</span><br><span class="line"><span class="keyword">if</span> f, ok := OrderFieldMap[field]; ok &#123;</span><br><span class="line">options.Fields = <span class="built_in">append</span>(options.Fields, f)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dao层的代码逻辑类似，我就不重复填写了。</p><p>这里，我将代码拆分成了gormer与dao两层，主要是：</p><ul><li>internal/gormer整个目录是不可变的、只能自动生成，对应基础的数据库表结构</li><li>internal/dao层会添加其余的文件，如定制化的sql。</li></ul><p>至此，再将引用的相关代码简单修改，就实现了这一整块功能.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章重点介绍了Go Template在高度重复的代码模块中的应用，结合数据库实现了一个高度自动化的工具gormer。</p><p>gormer目前实现的功能比较单一，但只要有了初步自动化的思路，我们可以在后续迭代中慢慢优化，让它适应更多的场景。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;CRUD是贯穿整个程序员日常开发的基本工作，占据了我们绝大多数的coding时间。&lt;/p&gt;
&lt;p&gt;作为一名程序员，我们总是希望能有更简单的开发方式来解决重复性的工作问题。在这个小版本中，我将结合自己的工作，来给出一套自动生成代码的完整方案，供大家借鉴。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 6.用Google风格的API接口打通MySQL操作</title>
    <link href="http://example.com/2021/09/19/go-framework/go-framework-6/"/>
    <id>http://example.com/2021/09/19/go-framework/go-framework-6/</id>
    <published>2021-09-19T04:00:00.000Z</published>
    <updated>2021-09-26T02:52:38.499Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>随着RPC与MySQL的打通，整个框架已经开始打通了数据的出入口。</p><p>接下来，我们就尝试着实现通过RPC请求操作MySQL数据库，打通整个链路，真正地让这个平台实现可用。</p><span id="more"></span><h2 id="v0-5-0：用Google风格的API接口打通MySQL操作"><a href="#v0-5-0：用Google风格的API接口打通MySQL操作" class="headerlink" title="v0.5.0：用Google风格的API接口打通MySQL操作"></a>v0.5.0：用Google风格的API接口打通MySQL操作</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.5.0">https://github.com/Junedayday/micro_web_service/tree/v0.5.0</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>从API出发，实现一个数据库表的增删改查。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>Google风格的API定义</li><li>model与dao的定义</li><li>service层的实现</li></ol><blockquote><p>注意，最近buf工具进行了一次不兼容的升级，从v1beta升级到了v1，可通过如下链接下载 <a href="https://github.com/bufbuild/buf/releases">https://github.com/bufbuild/buf/releases</a></p></blockquote><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务</span><br><span class="line">         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">    |-- order                            新增：对应idl/order服务</span><br><span class="line">         |-- order.pb.go                       新增：order.proto的基础结构</span><br><span class="line">         |-- order.pb.gw.go                    新增：order.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- order_grpc.pb.go                  新增：order.proto的gRPC接口代码</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义</span><br><span class="line">      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">   |-- order                           新增：业务order定义</span><br><span class="line">      |-- order.proto                      新增：protobuffer的原始定义</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹</span><br><span class="line">      |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层</span><br><span class="line">      |-- order.go                         更新：Order对象，订单表，实现model层的OrderRepository</span><br><span class="line">      |-- order_test.go                    Order的单元测试</span><br><span class="line">   |-- model                           新增：model层，定义对象的接口方法</span><br><span class="line">      |-- order.go                         新增：OrderRepository接口，具体实现在dao层</span><br><span class="line">   |-- mysql                           MySQL连接</span><br><span class="line">      |-- init.go                          初始化连接到MySQL的工作</span><br><span class="line">   |-- server                          服务器的实现</span><br><span class="line">      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">   |-- service                         新增：service层，作为领域实现的核心部分</span><br><span class="line">      |-- order.go                         新增：Order相关的服务，目前仅简单的CRUD</span><br><span class="line">     |-- zlog                            封装日志的文件夹</span><br><span class="line">        |-- zap.go                           zap封装的代码实现</span><br><span class="line">|-- buf.gen.yaml                   更新：buf生成代码的定义，从v1beta升到v1</span><br><span class="line">|-- buf.yaml                       更新：buf工具安装所需的工具，从v1beta升到v1</span><br><span class="line">|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-Google风格的API定义"><a href="#1-Google风格的API定义" class="headerlink" title="1.Google风格的API定义"></a>1.Google风格的API定义</h2><p>由于整体的定义比较多，这里就以</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">CreateOrderRequest</span> </span>&#123;</span><br><span class="line">  Order order = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UpdateOrderRequest</span> </span>&#123;</span><br><span class="line">  Order order = <span class="number">1</span>;</span><br><span class="line">  google.protobuf.FieldMask update_mask = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">GetOrderRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order服务</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ListOrders(ListOrdersRequest) <span class="keyword">returns</span> (ListOrdersResponse) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      get: <span class="string">&quot;/v1/orders&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里body中的order表示HTTP的body里的数据填充到CreateOrderRequest结构中的order对象</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> CreateOrder(CreateOrderRequest) <span class="keyword">returns</span> (Order) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      post: <span class="string">&quot;/v1/orders&quot;</span></span><br><span class="line">      body: <span class="string">&quot;order&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> UpdateOrder(UpdateOrderRequest) <span class="keyword">returns</span> (google.protobuf.Empty) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      patch: <span class="string">&quot;/v1/orders&quot;</span></span><br><span class="line">      body: <span class="string">&quot;*&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里&#123;name=*&#125;表示这个字段填充到GetOrderRequest里的name字段</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetOrder(GetOrderRequest) <span class="keyword">returns</span> (Order) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      get: <span class="string">&quot;/v1/orders/&#123;name=*&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> DeleteBook(DeleteBookRequest) <span class="keyword">returns</span> (google.protobuf.Empty) </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">      delete: <span class="string">&quot;/v1/books&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们重点关注以下几个方法：</p><ol><li>List - 查询列表，对应HTTP的GET方法</li><li>Get - 查询单个对象，对应HTTP的GET方法</li><li>Create - 创建对象，对应HTTP的POST方法</li><li>Update - 更新对象，对应HTTP的PATCH方法</li><li>Delete - 删除对象，对应HTTP的DELETE方法（本次暂未实现，后续添加软删除时加上）</li></ol><blockquote><p>关于Google定义的标准方法细节，可以参考<a href="https://cloud.google.com/apis/design/standard_methods">Google Cloud API链接</a>，了解对资源、字段等命名的逻辑。</p><p>而对于gRPC-Gateway中对于proto3的语法，可以参考<a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/mapping/patch_feature/">gRPC-Gateway链接</a>。</p><p>以上两块内容比较多，建议边实践边学习，不要一开始就钻细节。</p></blockquote><h2 id="2-model与dao的定义"><a href="#2-model与dao的定义" class="headerlink" title="2.model与dao的定义"></a>2.model与dao的定义</h2><p>为了将模型的定义与数据库的实现分离，我将两者进行了拆分，分别放置在model与dao目录下，定位的简单介绍如下：</p><ul><li>model，数据模型的定义，更关注对业务层的数据格式统一，底层可以对应各种存储形式，如mysql、redis</li><li>dao，真实数据存储的操作，也就是model层的实现，目前实现了一种mysql的操作</li></ul><h3 id="Model层"><a href="#Model层" class="headerlink" title="Model层"></a>Model层</h3><p>重点是统一的数据结构定义<code>Order</code>，以及关键接口<code>OrderRepository</code>的定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Order针对的是 orders 表中的一行数据</span></span><br><span class="line"><span class="comment">// 在这里定义，是为了分离Model与Dao</span></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">Id    <span class="keyword">int64</span></span><br><span class="line">Name  <span class="keyword">string</span></span><br><span class="line">Price <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderFields 作为一个 数据库Order对象+fields字段的组合</span></span><br><span class="line"><span class="comment">// fields用来指定Order中的哪些字段生效</span></span><br><span class="line"><span class="keyword">type</span> OrderFields <span class="keyword">struct</span> &#123;</span><br><span class="line">Order  *Order</span><br><span class="line">Fields []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderRepository <span class="keyword">interface</span> &#123;</span><br><span class="line">AddOrder(order *Order) (err error)</span><br><span class="line">QueryOrders(pageNumber, pageSize <span class="keyword">int</span>, condition *OrderFields) (orders []Order, err error)</span><br><span class="line">UpdateOrder(updated, condition *OrderFields) (err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h3><p>Dao层代码基本与之前一致，重点关注结构体<code>OrderRepo</code>，它是Model层<code>OrderRepository</code>的一种MySQL实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OrderRepo <span class="keyword">struct</span> &#123;</span><br><span class="line">db *gorm.DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将gorm.DB作为一个参数，在初始化时赋值：方便测试时，放一个mock的db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderRepo</span><span class="params">(db *gorm.DB)</span> *<span class="title">OrderRepo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;OrderRepo&#123;db: db&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-service层的实现"><a href="#3-service层的实现" class="headerlink" title="3.service层的实现"></a>3.service层的实现</h2><p>service是核心业务实现，但目前的示例代码比较简单，基本就是透传CRUD。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Service的实现，注意orderRepo的定义是model层的interface</span></span><br><span class="line"><span class="keyword">type</span> OrderService <span class="keyword">struct</span> &#123;</span><br><span class="line">orderRepo model.OrderRepository</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象，注意orderRepo的实现为dao层代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderService</span><span class="params">()</span> *<span class="title">OrderService</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;OrderService&#123;</span><br><span class="line">orderRepo: dao.NewOrderRepo(mysql.GormDB),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以List为例，透传查询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(orderSvc *OrderService)</span> <span class="title">List</span><span class="params">(ctx context.Context, pageNumber, pageSize <span class="keyword">int</span>, condition *model.OrderFields)</span> <span class="params">([]model.Order, error)</span></span> &#123;</span><br><span class="line">orders, err := orderSvc.orderRepo.QueryOrders(pageNumber, pageSize, condition)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;OrderService List pageNumber %d pageSize %d&quot;</span>, pageNumber, pageSize)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> orders, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-模拟HTTP接口访问"><a href="#4-模拟HTTP接口访问" class="headerlink" title="4.模拟HTTP接口访问"></a>4.模拟HTTP接口访问</h2><p>本服务支持gRPC和HTTP访问，但由于gRPC不方便用工具模拟，我们这里就以HTTP对本服务进行访问</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List</span></span><br><span class="line">curl --request GET <span class="string">&#x27;http://127.0.0.1:8081/v1/orders&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create</span></span><br><span class="line">curl --request POST <span class="string">&#x27;http://127.0.0.1:8081/v1/orders&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">--data-raw <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;order1&quot;,</span></span><br><span class="line"><span class="string">    &quot;price&quot;: 100.3</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update 这里 order 表示数据，update_mask表示更新的字段是price</span></span><br><span class="line">curl --request PATCH <span class="string">&#x27;http://127.0.0.1:8081/v1/orders&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">--data-raw <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;order&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;id&quot;: &quot;1&quot;,</span></span><br><span class="line"><span class="string">        &quot;name&quot;: &quot;order1&quot;,</span></span><br><span class="line"><span class="string">        &quot;price&quot;: 110.9</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;update_mask&quot;: &quot;price&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 查询name=order1的对象</span></span><br><span class="line">curl --request GET <span class="string">&#x27;http://127.0.0.1:8081/v1/orders/order1&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="关于Google风格的API总结"><a href="#关于Google风格的API总结" class="headerlink" title="关于Google风格的API总结"></a>关于Google风格的API总结</h2><p>Google风格的API和目前的主流RESTful标准的API有很多相似点、也存在一定的区别。</p><p>我们没有必要去抠API风格的细节实现、一定要与Google风格完全一致。API接口是一个通用协议，不同团队有自己的理解，就像RESTful标准的细节实现都有差异。</p><p>作为对外协议，最重要的是可读性，每个人都可以根据实际项目情况，对接口风格做一些适配性调整。这里介绍Google风格，主要是为了扩展大家的视野、拥有更多的技术实现方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这个版本，我们打通了API接口到MySQL数据库操作的全流程，是对整个框架的一次初步整合。接下来，我们会对这一流程进行精雕细琢，使其更具通用性和易用性。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着RPC与MySQL的打通，整个框架已经开始打通了数据的出入口。&lt;/p&gt;
&lt;p&gt;接下来，我们就尝试着实现通过RPC请求操作MySQL数据库，打通整个链路，真正地让这个平台实现可用。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 7.【GORM实战剖析】基本用法和原理解析</title>
    <link href="http://example.com/2021/09/15/go-tip/go-tip-7/"/>
    <id>http://example.com/2021/09/15/go-tip/go-tip-7/</id>
    <published>2021-09-15T04:00:00.000Z</published>
    <updated>2021-09-16T03:02:44.448Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg" alt="Go-Study"></p><h2 id="GORM库的官方文档"><a href="#GORM库的官方文档" class="headerlink" title="GORM库的官方文档"></a>GORM库的官方文档</h2><p>GORM库作为Go语言最受欢迎的ORM框架，提供了非常丰富的功能，大家可以通过阅读<a href="https://gorm.io/zh_CN/docs/index.html">中文官网</a>了解详情。</p><p>这里，先着重介绍一个背景：<strong>GORM内部会区分v1与v2两个版本</strong>，其中</p><ul><li>v1的包导入路径为 <code>github.com/jinzhu/gorm</code></li><li>v2的包导入路径为 <code>gorm.io/gorm</code></li></ul><p>v1与v2对使用者来说体验相差不大，今天就主要针对v2版本进行讲解。</p><span id="more"></span><h2 id="Talk-is-Cheap-Show-me-the-code"><a href="#Talk-is-Cheap-Show-me-the-code" class="headerlink" title="Talk is Cheap. Show me the code."></a>Talk is Cheap. Show me the code.</h2><p>接下来，我先给出一套个人比较推荐的CRUD代码。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><a href="https://gorm.io/zh_CN/docs/create.html">官方链接 - 创建</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;</span><br><span class="line"><span class="comment">// 直接创建</span></span><br><span class="line">result := db.Create(&amp;user)</span><br><span class="line"><span class="comment">// 指定字段创建</span></span><br><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量创建</span></span><br><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu3&quot;</span>&#125;&#125;</span><br><span class="line">db.Create(&amp;users)</span><br></pre></td></tr></table></figure><p>推荐：</p><ol><li>通常：直接用<strong>结构体</strong>或<strong>结构体的切片</strong>进行创建；</li><li>特殊：加上指定的字段，也就是其余字段不生效，如上面的<code>Birthday</code>。</li></ol><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><a href="https://gorm.io/zh_CN/docs/query.html">官方链接 - 查询</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有对象</span></span><br><span class="line"><span class="keyword">var</span> users []User  </span><br><span class="line">result := db.Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定查询条件（where）</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制返回数量</span></span><br><span class="line">db.Limit(<span class="number">10</span>).Offset(<span class="number">5</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询部分字段（即从select * 改造为 select name, age）</span></span><br><span class="line">db.Select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其余扩展</span></span><br><span class="line">db.Order(<span class="string">&quot;age desc, name&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure><p>推荐：</p><ol><li>普通场景：简单查询用<code>Find+Where</code>的函数结合实现，结合<code>Limit+Offset+Order</code>实现分页等高频功能；</li><li>追求性能：可以引入<code>Select</code>避免查询所有字段，但会导致返回结果部分字段不存在的奇怪现象，需要权衡；</li><li>复杂查询：例如<code>Join+子查询</code>等，推荐使用下面的原生SQL，用GORM拼接的体验并不好。</li></ol><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><a href="https://gorm.io/zh_CN/docs/update.html">官方链接 - 更新</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新通常包含两块，一个是要更新的字段Select+Updates，另一个是被更新数据的条件Where</span></span><br><span class="line">db.Model(&amp;user).Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;new_name&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>零值问题：参考<a href="https://gorm.io/zh_CN/docs/update.html#%E6%9B%B4%E6%96%B0%E5%A4%9A%E5%88%97">https://gorm.io/zh_CN/docs/update.html#%E6%9B%B4%E6%96%B0%E5%A4%9A%E5%88%97</a> 下的注释</p></blockquote><p>推荐：</p><ol><li>普通场景：利用<code>Select+Updates</code>指定更新字段，利用<code>Where</code>指定更新条件；</li><li>特殊场景：复杂SQL用原生SQL。</li></ol><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><a href="https://gorm.io/zh_CN/docs/delete.html">官方链接 - 删除</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除条件不建议太复杂，所以可以用简单的Where条件来拼接</span></span><br><span class="line">db.Where(<span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>).Delete(Email&#123;&#125;)</span><br></pre></td></tr></table></figure><p>推荐：</p><ol><li>普通场景：利用<code>Where</code>限定删除条件，不建议太复杂；</li><li>软删除：在实际项目中，不太建议用<code>硬删除</code>的方式，而是用<code>软删除</code>，即更新一个标记字段。</li></ol><h3 id="原生SQL"><a href="#原生SQL" class="headerlink" title="原生SQL"></a>原生SQL</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生SQL，推荐在复杂sql场景下使用</span></span><br><span class="line">db.Raw(<span class="string">&quot;SELECT id, name, age FROM users WHERE name = ?&quot;</span>, <span class="number">3</span>).Scan(&amp;result)</span><br></pre></td></tr></table></figure><h2 id="使用GORM的核心思路梳理"><a href="#使用GORM的核心思路梳理" class="headerlink" title="使用GORM的核心思路梳理"></a>使用GORM的核心思路梳理</h2><h3 id="一个对象-一行数据"><a href="#一个对象-一行数据" class="headerlink" title="一个对象 = 一行数据"></a>一个对象 = 一行数据</h3><p>示例中的一个<code>User</code>对象，完整地对应到具体<code>users</code>表中的一行数据，让整个框架更加清晰明了。每当数据库增加了一列，就对应地在结构体中加一个字段。这里有两个注意点：</p><ol><li>不要在核心结构体<code>User</code>中加入非表中的数据，如一些计算的中间值，引起二义性；</li><li><a href="https://gorm.io/zh_CN/docs/models.html#gorm-Model">gorm.Model</a>可以提升编码效率（会减少重复编码），但会限制数据库表中字段的定义，慎用（个人更希望它能开放成一个接口）；</li></ol><h3 id="选择生效字段-核心结构体-字段数组"><a href="#选择生效字段-核心结构体-字段数组" class="headerlink" title="选择生效字段 = 核心结构体 + 字段数组"></a>选择生效字段 = 核心结构体 + 字段数组</h3><p>在 <strong>查询</strong> 和 <strong>更新</strong> 接口里，我推荐的使用方法是采用核心结构体<code>User</code>+一个fields的数组，前者保存具体的数据、也实现了结构体复用，后者则选择生效的字段。</p><p>这种风格代码和Google推荐的<a href="https://cloud.google.com/apis/design/standard_methods#update">API风格</a>非常像，可读性很棒。</p><blockquote><p>这里还遗留了一个问题，就是fields数组里的字符串必须手输，可以考虑结合go generate自动生成这些fields的字符串常量，减少出错的概率。</p></blockquote><h3 id="缩短链式调用"><a href="#缩短链式调用" class="headerlink" title="缩短链式调用"></a>缩短链式调用</h3><p>GORM的主要风格是<a href="https://gorm.io/zh_CN/docs/method_chaining.html">链式调用</a>，类似于Builder设计模式、串联堆起一个SQL语句。这种调用方式扩展性很强，但会带来了一个很严重的问题：容易写出一个超长的链式调用，可维护成本大幅度提高。</p><p>所以，在我的推荐使用方式里，区分了两种场景：</p><ol><li>简单场景 - <strong>核心结构体 + 字段数组</strong></li><li>复杂场景 - <strong>原生SQL</strong></li></ol><h3 id="聚焦微服务的场景"><a href="#聚焦微服务的场景" class="headerlink" title="聚焦微服务的场景"></a>聚焦微服务的场景</h3><p>作为一个<code>ORM</code>工具，GORM要考虑兼容各种SQL语句，内部非常庞大的。但如今更多地是考虑微服务的场景，这就能抛开大量的历史包袱，实现得更加简洁。这里我简单列举三个不太推荐使用的SQL特性：</p><ol><li>减少group by - 考虑将聚合字段再单独放在一个表中</li><li>抛弃join - 多表关联采用多次查询（先查A表，然后用In语句去B表查）、或做一定的字段冗余（即同时放在A、B两个表里）</li><li>抛弃子查询，将相关逻辑放在代码里</li></ol><p>当然，真实业务研发过程中无法完全避免复杂SQL，我们只能有意识地减少引入复杂度。</p><h3 id="避免引入非原生MySQL的特性"><a href="#避免引入非原生MySQL的特性" class="headerlink" title="避免引入非原生MySQL的特性"></a>避免引入非原生MySQL的特性</h3><p>GORM除了常规的SQL功能，还提供了一些<a href="https://gorm.io/zh_CN/docs/models.html#%E9%AB%98%E7%BA%A7%E9%80%89%E9%A1%B9">高级特性</a>、<a href="https://gorm.io/zh_CN/docs/belongs_to.html">模型关联</a>、<a href="https://gorm.io/zh_CN/docs/hooks.html">钩子</a>等，非常炫酷。</p><p>但我不推荐大家在实际项目中使用这些特性。只有尽可能地保证这个框架简洁，才能保证代码后续的可维护性。</p><p>熟悉MySQL历史的朋友都知道，<strong>存储过程</strong>在以前相当一段时间都是很好的工具，但如今都倡导<strong>去存储过程</strong>。GORM的这些特性和存储过程有异曲同工之处：一个将业务逻辑放在了数据库，另一个则放到了ORM框架里，会导致后续的迁移成本变高。</p><blockquote><p>这也是我不推荐使用 gorm.Model的重要原因。</p></blockquote><h2 id="从查询接口了解GORM的核心实现"><a href="#从查询接口了解GORM的核心实现" class="headerlink" title="从查询接口了解GORM的核心实现"></a>从查询接口了解GORM的核心实现</h2><h3 id="两个核心文件"><a href="#两个核心文件" class="headerlink" title="两个核心文件"></a>两个核心文件</h3><p>在GORM库中，有两个核心的文件，也是我们调用频率最高的函数所在：<strong>chainable_api.go</strong>和 <strong>finisher_api.go</strong>。顾名思义，前者是整个链式调用的中间部分，后者则是最终获取结果的函数。以查询为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure><p>其中<code>Where</code>是chainable，也就是还在拼接SQL条件，<code>Find</code>则是触发真正查询的finisher。</p><p>如果一开始过于关注chainable调用，很容易陷入构造SQL的细节，所以这块代码建议从finisher入手，深入看看一个SQL的到底是怎么在GORM中拼接并执行的。</p><h3 id="Find的调用链路"><a href="#Find的调用链路" class="headerlink" title="Find的调用链路"></a>Find的调用链路</h3><h4 id="1-Find的主要代码"><a href="#1-Find的主要代码" class="headerlink" title="1. Find的主要代码"></a>1. Find的主要代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Find</span><span class="params">(dest <span class="keyword">interface</span>&#123;&#125;, conds ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(tx *DB)</span></span> &#123;</span><br><span class="line">tx = db.getInstance()</span><br><span class="line">  <span class="comment">// conds是查询的条件，这里忽略，我们默认已经在前面的Chainable中完成了所有参数的拼接</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(conds) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> exprs := tx.Statement.BuildCondition(conds[<span class="number">0</span>], conds[<span class="number">1</span>:]...); <span class="built_in">len</span>(exprs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">tx.Statement.AddClause(clause.Where&#123;Exprs: exprs&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tx.Statement.Dest = dest</span><br><span class="line">  <span class="comment">// 关键的执行逻辑</span></span><br><span class="line"><span class="keyword">return</span> tx.callbacks.Query().Execute(tx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-tx-callbacks-Query-的实现"><a href="#2-tx-callbacks-Query-的实现" class="headerlink" title="2. tx.callbacks.Query()的实现"></a>2. tx.callbacks.Query()的实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *callbacks)</span> <span class="title">Query</span><span class="params">()</span> *<span class="title">processor</span></span> &#123;</span><br><span class="line">  <span class="comment">// Query 是从processors的 map 中取出 query</span></span><br><span class="line"><span class="keyword">return</span> cs.processors[<span class="string">&quot;query&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个对应的processor是 gorm.DB，也就是执行DB的Execute</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initializeCallbacks</span><span class="params">(db *DB)</span> *<span class="title">callbacks</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;callbacks&#123;</span><br><span class="line">processors: <span class="keyword">map</span>[<span class="keyword">string</span>]*processor&#123;</span><br><span class="line"><span class="string">&quot;create&quot;</span>: &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;query&quot;</span>:  &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;update&quot;</span>: &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;delete&quot;</span>: &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;row&quot;</span>:    &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;raw&quot;</span>:    &#123;db: db&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Execute的执行逻辑"><a href="#3-Execute的执行逻辑" class="headerlink" title="3. Execute的执行逻辑"></a>3. Execute的执行逻辑</h4><p>抛开一些周边逻辑，我们聚焦于下面的核心逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processor)</span> <span class="title">Execute</span><span class="params">(db *DB)</span> *<span class="title">DB</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// processor中注册了多个函数，按顺序执行。</span></span><br><span class="line">  <span class="comment">// 核心的查询逻辑也在这里面</span></span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> p.fns &#123;</span><br><span class="line">f(db)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而fns又是来自callbacks</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processor)</span> <span class="title">compile</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 对 callbacks 会做排序</span></span><br><span class="line"><span class="keyword">if</span> p.fns, err = sortCallbacks(p.callbacks); err != <span class="literal">nil</span> &#123;</span><br><span class="line">p.db.Logger.Error(context.Background(), <span class="string">&quot;Got error when compile callbacks, got %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Callback的注册"><a href="#4-Callback的注册" class="headerlink" title="4. Callback的注册"></a>4. Callback的注册</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterDefaultCallbacks</span><span class="params">(db *gorm.DB, config *Config)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 默认注册了create/query/delete/update/raw 五种 callback 大类，这里以query为例</span></span><br><span class="line">queryCallback := db.Callback().Query()</span><br><span class="line">queryCallback.Register(<span class="string">&quot;gorm:query&quot;</span>, Query)</span><br><span class="line">queryCallback.Register(<span class="string">&quot;gorm:preload&quot;</span>, Preload)</span><br><span class="line">queryCallback.Register(<span class="string">&quot;gorm:after_query&quot;</span>, AfterQuery)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(config.QueryClauses) == <span class="number">0</span> &#123;</span><br><span class="line">config.QueryClauses = queryClauses</span><br><span class="line">&#125;</span><br><span class="line">queryCallback.Clauses = config.QueryClauses</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-Query函数的实现"><a href="#5-Query函数的实现" class="headerlink" title="5. Query函数的实现"></a>5. Query函数的实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Query</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> db.Error == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 构建查询的 SQL 语句</span></span><br><span class="line">BuildQuerySQL(db)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询数据</span></span><br><span class="line"><span class="keyword">if</span> !db.DryRun &amp;&amp; db.Error == <span class="literal">nil</span> &#123;</span><br><span class="line">rows, err := db.Statement.ConnPool.QueryContext(db.Statement.Context, db.Statement.SQL.String(), db.Statement.Vars...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">db.AddError(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将结果输出到目标结构体中</span></span><br><span class="line">gorm.Scan(rows, db, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-核心-构建SQL的实现"><a href="#6-核心-构建SQL的实现" class="headerlink" title="6.核心-构建SQL的实现"></a>6.核心-构建SQL的实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildQuerySQL</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line">  <span class="comment">// SQL为空，表示需要自己构建</span></span><br><span class="line"><span class="keyword">if</span> db.Statement.SQL.String() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">db.Statement.SQL.Grow(<span class="number">100</span>) <span class="comment">// 分配初始空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(db.Statement.Selects) &gt; <span class="number">0</span> &#123; </span><br><span class="line">      <span class="comment">// 表示只select某几个字段，而不是select *</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> db.Statement.Schema != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(db.Statement.Omits) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// Omit表示忽略特定字段</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> db.Statement.Schema != <span class="literal">nil</span> &amp;&amp; db.Statement.ReflectValue.IsValid() &#123;</span><br><span class="line">      <span class="comment">// 查询到指定结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对join的处理，涉及到多表关联，暂时忽略</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(db.Statement.Joins) != <span class="number">0</span> &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">db.Statement.AddClauseIfNotExists(clause.From&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用一个map去重，符合名字中的 IfNotExists 含义</span></span><br><span class="line">db.Statement.AddClauseIfNotExists(clauseSelect)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后拼接出完整 SQL 的地方</span></span><br><span class="line">db.Statement.Build(db.Statement.BuildClauses...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文旨在介绍GORM的推荐使用方式，并简单阅读对接数据库的相关代码。这里分享我的四个观点：</p><ol><li><strong>Builder设计模式</strong> - 在面对复杂场景中，Builder设计模式扩展性很好，可分为两个阶段：存储数据+处理数据；GORM的调用就是采用了chainable+finisher的两段实现，前者保存SQL相关元数据，后者拼接SQL并执行；</li><li><strong>负重前行</strong> - GORM是一个负重前行的框架：它不仅支持了所有原生SQL的特性，也增加了很多类似Hook的高级特性，导致这个框架非常庞大。如果团队没有历史包袱，更推荐<strong>节制</strong>地使用GORM特性，适当封装一层；</li><li><strong>interface{}问题</strong> - GORM中许多函数入参的数据类型都是<code>interface&#123;&#125;</code>，底层又用reflect支持了多种类型，这种实现会导致两个问题：<ol><li>reflect导致的底层的性能不高（这点还能接受）</li><li>interface{}如果传入了不支持的复杂数据类型时，排查问题麻烦，往往要运行程序时才会报错</li></ol></li><li><strong>高频拼接重复SQL</strong> - 在一个程序运行过程中，执行的SQL语句都比较固定，而变化的往往是参数；从GORM的实现来看，每次执行都需要重新拼接一次SQL语句，是有不小的优化空间的，比如引入一定的cache。</li></ol><p>希望这四点能对大家的日常工作有所启发~</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/05/05/2bmr98tG3xDneL5.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;GORM库的官方文档&quot;&gt;&lt;a href=&quot;#GORM库的官方文档&quot; class=&quot;headerlink&quot; title=&quot;GORM库的官方文档&quot;&gt;&lt;/a&gt;GORM库的官方文档&lt;/h2&gt;&lt;p&gt;GORM库作为Go语言最受欢迎的ORM框架，提供了非常丰富的功能，大家可以通过阅读&lt;a href=&quot;https://gorm.io/zh_CN/docs/index.html&quot;&gt;中文官网&lt;/a&gt;了解详情。&lt;/p&gt;
&lt;p&gt;这里，先着重介绍一个背景：&lt;strong&gt;GORM内部会区分v1与v2两个版本&lt;/strong&gt;，其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v1的包导入路径为 &lt;code&gt;github.com/jinzhu/gorm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;v2的包导入路径为 &lt;code&gt;gorm.io/gorm&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;v1与v2对使用者来说体验相差不大，今天就主要针对v2版本进行讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 5.GORM库的适配sqlmock的单元测试</title>
    <link href="http://example.com/2021/09/05/go-framework/go-framework-5/"/>
    <id>http://example.com/2021/09/05/go-framework/go-framework-5/</id>
    <published>2021-09-05T04:00:00.000Z</published>
    <updated>2021-09-26T02:52:26.553Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>随着<code>GORM</code>库的引入，我们在数据库持久化上已经有了解决方案。但上一篇我们使用的<code>GORM</code>过于简单，应用到实际的项目中局限性很大。</p><p>与此同时，我们也缺乏一个有效的手段来验证自己编写的相关代码。如果依靠连接到真实的<code>MySQL</code>去验证功能，那成本实在太高。那么，这里我们就引入一个经典的<code>sqlmock</code>框架，并配合对数据库相关代码的修改，来实现相关代码的可测试性。</p><span id="more"></span><h2 id="v0-4-1：GORM库的适配sqlmock的单元测试"><a href="#v0-4-1：GORM库的适配sqlmock的单元测试" class="headerlink" title="v0.4.1：GORM库的适配sqlmock的单元测试"></a>v0.4.1：GORM库的适配sqlmock的单元测试</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.4.1">https://github.com/Junedayday/micro_web_service/tree/v0.4.1</a></p><blockquote><p>由于主要是针对GORM的小改动，所以增加了一个小版本号</p></blockquote><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>利用sqlmock工具，并对数据库相关代码进行修改，实现单元测试。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>Order相关代码的改造</li><li>引入sqlmock到测试代码</li><li>注意点讲解</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务</span><br><span class="line">         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义</span><br><span class="line">      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹</span><br><span class="line">      |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">   |-- dao                             Data Access Object层</span><br><span class="line">      |-- order.go                         更新：OrderO对象，订单表</span><br><span class="line">      |-- order_test.go                    新增：Order的单元测试</span><br><span class="line">   |-- mysql                           MySQL连接</span><br><span class="line">      |-- init.go                          初始化连接到MySQL的工作</span><br><span class="line">   |-- server                          服务器的实现</span><br><span class="line">      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">     |-- zlog                            封装日志的文件夹</span><br><span class="line">        |-- zap.go                           zap封装的代码实现</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具</span><br><span class="line">|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-Order相关代码的改造"><a href="#1-Order相关代码的改造" class="headerlink" title="1.Order相关代码的改造"></a>1.Order相关代码的改造</h2><p>我们要对Order相关的代码进行改造，来满足以下两个点：</p><ol><li>可测试性，可以脱离对真实数据库连接的依赖</li><li>灵活的更新方法，可以支持对指定条件、指定字段的更新</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  gorm.io/gorm 指的是gorm V2版本，详细可参考 https://gorm.io/zh_CN/docs/v2_release_note.html</span></span><br><span class="line"><span class="comment">  github.com/jinzhu/gorm 一般指V1版本</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderRepo <span class="keyword">struct</span> &#123;</span><br><span class="line">db *gorm.DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将gorm.DB作为一个参数，在初始化时赋值：方便测试时，放一个mock的db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderRepo</span><span class="params">(db *gorm.DB)</span> *<span class="title">OrderRepo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;OrderRepo&#123;db: db&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order针对的是 orders 表中的一行数据</span></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">Id    <span class="keyword">int64</span></span><br><span class="line">Name  <span class="keyword">string</span></span><br><span class="line">Price <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderFields 作为一个 数据库Order对象+fields字段的组合</span></span><br><span class="line"><span class="comment">// fields用来指定Order中的哪些字段生效</span></span><br><span class="line"><span class="keyword">type</span> OrderFields <span class="keyword">struct</span> &#123;</span><br><span class="line">order  *Order</span><br><span class="line">fields []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderFields</span><span class="params">(order *Order, fields []<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">OrderFields</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;OrderFields&#123;</span><br><span class="line">order:  order,</span><br><span class="line">fields: fields,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">AddOrder</span><span class="params">(order *Order)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">err = repo.db.Create(order).Error</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">QueryOrders</span><span class="params">(pageNumber, pageSize <span class="keyword">int</span>, condition *OrderFields)</span> <span class="params">(orders []Order, err error)</span></span> &#123;</span><br><span class="line">db := repo.db</span><br><span class="line"><span class="comment">// condition非nil的话，追加条件</span></span><br><span class="line"><span class="keyword">if</span> condition != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 这里的field指定了order中生效的字段，这些字段会被放在SQL的where条件中</span></span><br><span class="line">db = db.Where(condition.order, condition.fields...)</span><br><span class="line">&#125;</span><br><span class="line">err = db.</span><br><span class="line">Limit(pageSize).</span><br><span class="line">Offset((pageNumber - <span class="number">1</span>) * pageSize).</span><br><span class="line">Find(&amp;orders).Error</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *OrderRepo)</span> <span class="title">UpdateOrder</span><span class="params">(updated, condition *OrderFields)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> updated == <span class="literal">nil</span> || <span class="built_in">len</span>(updated.fields) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;update must choose certain fields&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;update must include where condition&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = repo.db.</span><br><span class="line">Model(&amp;Order&#123;&#125;).</span><br><span class="line"><span class="comment">// 这里的field指定了order中被更新的字段</span></span><br><span class="line">Select(updated.fields[<span class="number">0</span>], updated.fields[<span class="number">1</span>:]...).</span><br><span class="line"><span class="comment">// 这里的field指定了被更新的where条件中的字段</span></span><br><span class="line">Where(condition.order, condition.fields...).</span><br><span class="line">Updates(updated.order).</span><br><span class="line">Error</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-引入sqlmock到测试代码"><a href="#2-引入sqlmock到测试代码" class="headerlink" title="2.引入sqlmock到测试代码"></a>2.引入sqlmock到测试代码</h2><p>sqlmock是检查数据库最常用的工具，我们先不管它使用起来的复杂性，先来看看怎么实现对应的测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，我们使用的是gorm 2.0，网上很多例子其实是针对1.0的</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">DB   *gorm.DB</span><br><span class="line">mock sqlmock.Sqlmock</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestMain是在当前package下，最先运行的一个函数，常用于初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">db  *sql.DB</span><br><span class="line">err error</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db, mock, err = sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DB, err = gorm.Open(mysql.New(mysql.Config&#123;</span><br><span class="line">Conn:                      db,</span><br><span class="line">SkipInitializeWithVersion: <span class="literal">true</span>,</span><br><span class="line">&#125;), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// m.Run 是真正调用下面各个Test函数的入口</span></span><br><span class="line">os.Exit(m.Run())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  sqlmock 对语法限制比较大，下面的sql语句必须精确匹配（包括符号和空格）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOrderRepo_AddOrder</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> order = &amp;Order&#123;Name: <span class="string">&quot;order1&quot;</span>, Price: <span class="number">1.1</span>&#125;</span><br><span class="line">orderRepo := NewOrderRepo(DB)</span><br><span class="line"></span><br><span class="line">mock.ExpectBegin()</span><br><span class="line">mock.ExpectExec(<span class="string">&quot;INSERT INTO `orders` (`name`,`price`) VALUES (?,?)&quot;</span>).</span><br><span class="line">WithArgs(order.Name, order.Price).</span><br><span class="line">WillReturnResult(sqlmock.NewResult(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">mock.ExpectCommit()</span><br><span class="line">err := orderRepo.AddOrder(order)</span><br><span class="line">assert.Nil(t, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOrderRepo_QueryOrders</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> orders = []Order&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="string">&quot;name1&quot;</span>, <span class="number">1.0</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>, <span class="string">&quot;name2&quot;</span>, <span class="number">1.0</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">page, size := <span class="number">2</span>, <span class="number">10</span></span><br><span class="line">orderRepo := NewOrderRepo(DB)</span><br><span class="line">condition := NewOrderFields(&amp;Order&#123;Price: <span class="number">1.0</span>&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;price&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">mock.ExpectQuery(</span><br><span class="line"><span class="string">&quot;SELECT * FROM `orders` WHERE `orders`.`price` = ? LIMIT 10 OFFSET 10&quot;</span>).</span><br><span class="line">WithArgs(condition.order.Price).</span><br><span class="line">WillReturnRows(</span><br><span class="line">sqlmock.NewRows([]<span class="keyword">string</span>&#123;<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;price&quot;</span>&#125;).</span><br><span class="line">AddRow(orders[<span class="number">0</span>].Id, orders[<span class="number">0</span>].Name, orders[<span class="number">0</span>].Price).</span><br><span class="line">AddRow(orders[<span class="number">1</span>].Id, orders[<span class="number">1</span>].Name, orders[<span class="number">1</span>].Price))</span><br><span class="line"></span><br><span class="line">ret, err := orderRepo.QueryOrders(page, size, condition)</span><br><span class="line">assert.Nil(t, err)</span><br><span class="line">assert.Equal(t, orders, ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOrderRepo_UpdateOrder</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">orderRepo := NewOrderRepo(DB)</span><br><span class="line"><span class="comment">// 表示要更新的字段为Order对象中的id,name两个字段</span></span><br><span class="line">updated := NewOrderFields(&amp;Order&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;test_name&quot;</span>&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// 表示更新的条件为Order对象中的price字段</span></span><br><span class="line">condition := NewOrderFields(&amp;Order&#123;Price: <span class="number">1.0</span>&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;price&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">mock.ExpectBegin()</span><br><span class="line">mock.ExpectExec(</span><br><span class="line"><span class="string">&quot;UPDATE `orders` SET `id`=?,`name`=? WHERE `orders`.`price` = ?&quot;</span>).</span><br><span class="line">WithArgs(updated.order.Id, updated.order.Name, condition.order.Price).</span><br><span class="line">WillReturnResult(sqlmock.NewResult(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">mock.ExpectCommit()</span><br><span class="line"></span><br><span class="line">err := orderRepo.UpdateOrder(updated, condition)</span><br><span class="line">assert.Nil(t, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-注意点讲解"><a href="#3-注意点讲解" class="headerlink" title="3.注意点讲解"></a>3.注意点讲解</h2><p>虽然添加了注释，我这边依旧讲一下修改的重点：</p><ol><li><code>gorm.DB</code>作为一个初始化的参数，将其转变成一个依赖注入，使这块代码更具可测试性</li><li>查询和更新采用了一个新的结构体<code>OrderFields</code>，是用里面的<code>fields</code>声明了<code>order</code>中哪个字段生效</li></ol><h2 id="GORM框架的进一步扩展"><a href="#GORM框架的进一步扩展" class="headerlink" title="GORM框架的进一步扩展"></a>GORM框架的进一步扩展</h2><p>通过这一次对GORM数据库相关代码的迭代，还是可以发现有些不足：</p><ol><li>对复杂SQL的支持不足：如group by、子查询等语句</li><li>对field这块限制不好，<code>id</code>, <code>name</code>， <code>price</code>，容易发生误填字段的问题</li><li>没有串联日志模块</li></ol><p>接下来的模块，我会逐渐对2、3两点进行补充，而第1点需要有选择性地实现，我也会结合具体的场景进行分享。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这一个小版本，我们让<code>DAO</code>这个与数据库交互模块的代码更具可读性（从调用侧可以清楚地了解到要做什么）、健壮性（单元测试）和可扩展性（对后续字段的扩展也很容易支持）。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着&lt;code&gt;GORM&lt;/code&gt;库的引入，我们在数据库持久化上已经有了解决方案。但上一篇我们使用的&lt;code&gt;GORM&lt;/code&gt;过于简单，应用到实际的项目中局限性很大。&lt;/p&gt;
&lt;p&gt;与此同时，我们也缺乏一个有效的手段来验证自己编写的相关代码。如果依靠连接到真实的&lt;code&gt;MySQL&lt;/code&gt;去验证功能，那成本实在太高。那么，这里我们就引入一个经典的&lt;code&gt;sqlmock&lt;/code&gt;框架，并配合对数据库相关代码的修改，来实现相关代码的可测试性。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 4.初识GORM库</title>
    <link href="http://example.com/2021/08/29/go-framework/go-framework-4/"/>
    <id>http://example.com/2021/08/29/go-framework/go-framework-4/</id>
    <published>2021-08-29T04:00:00.000Z</published>
    <updated>2021-09-26T02:52:13.703Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>数据持久化是服务的必要特性，最常见的组件就是关系型数据库<code>MySQL</code>。而在<code>Go</code>语言里，<code>GORM</code>已经成了对接<code>MySQL</code>事实上的标准，那么也就不去横向对比其它库了。</p><p><code>GORM</code>库是一个很强大、但同时也是一个非常复杂的工具。为了支持复杂的<code>SQL</code>语言，它比之前的配置文件加载工具<code>github.com/spf13/viper</code>要复杂不少。今天，我们不会全量地引入<code>GORM</code>里的所有特性，而是从一个最简单的场景入手，对它的基本特性有所了解。而后续随着框架的完善，我们会逐渐细化功能。</p><span id="more"></span><h2 id="v0-4-0：引入GORM库"><a href="#v0-4-0：引入GORM库" class="headerlink" title="v0.4.0：引入GORM库"></a>v0.4.0：引入GORM库</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.4.0">https://github.com/Junedayday/micro_web_service/tree/v0.4.0</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>利用GORM实现简单的增删改查功能。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>MySQL工具库的必要功能</li><li>GORM官方示例分析</li><li>使用GORM的思考</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务</span><br><span class="line">         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义</span><br><span class="line">      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- config                          配置相关的文件夹</span><br><span class="line">      |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">   |-- dao                             新增：Data Access Object层</span><br><span class="line">      |-- order.go                         新增：示例的一个Order对象，订单表</span><br><span class="line">   |-- mysql                           新增：MySQL连接</span><br><span class="line">      |-- init.go                          新增：初始化连接到MySQL的工作</span><br><span class="line">   |-- server                          服务器的实现</span><br><span class="line">      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">     |-- zlog                            封装日志的文件夹</span><br><span class="line">        |-- zap.go                           zap封装的代码实现</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具</span><br><span class="line">|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-MySQL工具库的必要功能"><a href="#1-MySQL工具库的必要功能" class="headerlink" title="1.MySQL工具库的必要功能"></a>1.MySQL工具库的必要功能</h2><p>对于<code>MySQL</code>数据库来说，我们对它的日常操作其实就关注在CRUD上（也就是增删改查）。</p><p>除此以外，还有一些是我们需要关注的点：</p><ul><li><strong>便捷性</strong>：能快速、方便地实现实现功能，而不用写大量重复性的<code>SQL</code></li><li><strong>透明性</strong>：ORM经过层层封装，最终与MySQL交互的<code>SQL</code>语句可供排查问题</li><li><strong>扩展性</strong>：支持原生的<code>SQL</code>，在复杂场景下的ORM框架不如原始的<code>SQL</code>好用</li></ul><p>这里，我们先聚焦于第一点，后面两块<code>GORM</code>框架是支持的。</p><h2 id="2-GORM官方示例分析"><a href="#2-GORM官方示例分析" class="headerlink" title="2.GORM官方示例分析"></a>2.GORM官方示例分析</h2><p>接下来，我们对照着官方文档，来看看有什么样的注意点。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>中文文档链接 - <a href="https://gorm.io/zh_CN/docs/create.html">https://gorm.io/zh_CN/docs/create.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐使用方式：定义一个结构体，填充字段</span></span><br><span class="line">user := User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;</span><br><span class="line">result := db.Create(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：指定要创建的字段名，也就是user中部分生效，很容易产生迷惑</span></span><br><span class="line"><span class="comment">// 更建议新建一个user结构体进行创建</span></span><br><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量创建同推荐</span></span><br><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu3&quot;</span>&#125;&#125;</span><br><span class="line">db.Create(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：钩子相关的特性，类似于数据库里的trigger，隐蔽而迷惑，不易维护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">BeforeCreate</span><span class="params">(tx *gorm.DB)</span> <span class="params">(err error)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：用Map硬编码创建记录，改动成本大</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Create(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 争议点：gorm.Model中预定了数据库中的四个字段，是否应该把它引入到模型的定义中</span></span><br><span class="line"><span class="comment">// 我个人不太喜欢将这四个字段强定义为数据库表中的字段名</span></span><br><span class="line"><span class="keyword">type</span> Model <span class="keyword">struct</span> &#123;</span><br><span class="line">ID        <span class="keyword">uint</span> <span class="string">`gorm:&quot;primarykey&quot;`</span></span><br><span class="line">CreatedAt time.Time</span><br><span class="line">UpdatedAt time.Time</span><br><span class="line">DeletedAt DeletedAt <span class="string">`gorm:&quot;index&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的一些操作可以看到，我推荐的使用方式有2个特点：</p><ol><li>尽可能简单，不要出现<strong>魔法变量</strong>，比如常量字符串</li><li><strong>不要让框架强约束表结构的设计</strong>，也是为了后续迁移框架、甚至语言时成本更低</li></ol><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>中文文档链接 - <a href="https://gorm.io/zh_CN/docs/query.html">https://gorm.io/zh_CN/docs/query.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐： 我个人不太建议使用First/Last这种和原生SQL定义不一致的语法，扩展性也不好</span></span><br><span class="line"><span class="comment">// 在这种情况下，我更建议采用Find+Order+Limit这样的组合方式，通用性也更强</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：Find支持返回多个记录，是最常用的方法，但需要结合一定的限制</span></span><br><span class="line">result := db.Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：条件查询的字段名采用hard code，体验不好</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line">db.Where(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：结合结构体的方式定义，体验会好很多</span></span><br><span class="line"><span class="comment">// 但是，上面这种方法不支持结构体中Field为默认值的情况，如0，&#x27;&#x27;，false等</span></span><br><span class="line"><span class="comment">// 所以，更推荐采用下面这种方式，虽然会带来一定的hard code，但能指定要查询的结构体名称。</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">20</span>&#125;).First(&amp;user)</span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：指定排序</span></span><br><span class="line">db.Order(<span class="string">&quot;age desc, name&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：限制查询范围，结合Find</span></span><br><span class="line">db.Limit(<span class="number">10</span>).Offset(<span class="number">5</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure><p>查询还有很多的特性，今天我们暂不细讲。其中，希望大家能重点看一下默认值问题：</p><p>我们固然可以通过在定义字段时，排除这些默认值的情况，如定义<code>int</code>类型字段时跳过0、从1开始。但在实际的项目中，定义往往很难控制，我们不得不做一定的妥协，这部分hard code的成本也是可以接受的。</p><p><strong>我们不能因为框架里的一些特性，过度地限制其余组件的使用</strong>。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>中文文档链接 - <a href="https://gorm.io/zh_CN/docs/update.html">https://gorm.io/zh_CN/docs/update.html</a></p><p>更新其实是最麻烦的事情，它包括<strong>更新的字段与条件</strong>。我们来看看几个重点的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐：单字段的更新，不常用</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：指定主键的多字段更新，但不支持默认类型</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>, Active: <span class="literal">false</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：指定主键的多字段的更新，但字段多了硬编码很麻烦</span></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：指定主键的多字段的更新，指定要更新的字段，*为全字段</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;new_name&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;*&quot;</span>).Update(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Role: <span class="string">&quot;admin&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：指定更新方式的多字段的更新</span></span><br><span class="line">db.Model(User&#123;&#125;).Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>中文文档链接 - <a href="https://gorm.io/zh_CN/docs/delete.html">https://gorm.io/zh_CN/docs/delete.html</a></p><p>删除我不太建议使用，更推荐用软删除的方式，也就是<strong>更新一个标识是否已经删除字段</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;email)</span><br></pre></td></tr></table></figure><h2 id="3-使用GORM的思考"><a href="#3-使用GORM的思考" class="headerlink" title="3.使用GORM的思考"></a>3.使用GORM的思考</h2><p><code>GORM</code>是一个非常重量级的工具，尤其是<code>*gorm.DB</code>提供了大量的类似于Builder模式的方法，用来拼接<code>SQL</code>。</p><p>整个使用过程，对于一个不熟悉<code>SQL</code>语言的同学来说是很痛苦的，需要大量调试问题的时间；而对于熟悉<code>SQL</code>的朋友也会很疑惑，例如<code>First</code>等这种自定义命名的底层实现。所以，基于<code>GORM</code>库做一个简单封装是非常必要的，能大幅度地降低用户的使用和理解的门槛，也是这个微服务框架后续的改善方向之一。</p><h2 id="对微服务框架的延伸思考"><a href="#对微服务框架的延伸思考" class="headerlink" title="对微服务框架的延伸思考"></a>对微服务框架的延伸思考</h2><p>从之前的分析可以看到，我对微服务的框架有一个很重要的要求 - <strong>透明</strong>，比如不要引入大量和原始SQL无关的特性、不要过度依赖ORM而忘记了原生SQL才是我们最重要的技能。</p><p><strong>透明</strong>也是一个框架能实现简单性的重要特质，减少使用方的理解成本，也就能提高研发效能。</p><p>从更高的层面来看整个微服务框架，我们会有更深的体会：</p><ol><li><strong>为什么Spring Boot那么成功？</strong>主要是Spring Boot的设计理念是比较符合工程化的，而JVM也提供了一套很好的运行时的机制；与此同时，社区提供了大量的Spring Boot组件供开发者调用，自然比较受欢迎。</li><li><strong>Go的微服务框架为什么没有统一？</strong>Go的运行时非常轻量级，很难巧妙地像Spring Boot完成框架层面对组件的大一统。Go语言提供的各类组件，很多都是开源社区对传统服务或云原生理念的自我实践，没有绝对的正确与错误。</li><li><strong>那如今社区上的那些微服务框架都不值一提吗？</strong>并不是。如果你仔细看这些框架，其实都是对各类Go优秀组件的拼装，只是各有各的想法。我觉得，所谓的Go微服务框架短期内很难统一，但这些组件都会趋于一致。</li><li><strong>那你做这个框架的意义是什么呢？</strong>其实我个人并不觉得本框架比现有框架好，我更关注两点：一是分享引入并迭代各个开源组件的过程，让大家更好地理解框架是怎么完善的；第二个是从工程化的角度去思考微服务框架的问题，从会用框架变得理解框架、并改造框架。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们简单地引入了<code>GORM</code>并实现了一套简单的增删改查的代码，更多地是讨论一些技术选型的思考，希望能给大家带来启发。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;数据持久化是服务的必要特性，最常见的组件就是关系型数据库&lt;code&gt;MySQL&lt;/code&gt;。而在&lt;code&gt;Go&lt;/code&gt;语言里，&lt;code&gt;GORM&lt;/code&gt;已经成了对接&lt;code&gt;MySQL&lt;/code&gt;事实上的标准，那么也就不去横向对比其它库了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GORM&lt;/code&gt;库是一个很强大、但同时也是一个非常复杂的工具。为了支持复杂的&lt;code&gt;SQL&lt;/code&gt;语言，它比之前的配置文件加载工具&lt;code&gt;github.com/spf13/viper&lt;/code&gt;要复杂不少。今天，我们不会全量地引入&lt;code&gt;GORM&lt;/code&gt;里的所有特性，而是从一个最简单的场景入手，对它的基本特性有所了解。而后续随着框架的完善，我们会逐渐细化功能。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 3.日志库的选型与引入</title>
    <link href="http://example.com/2021/08/25/go-framework/go-framework-3/"/>
    <id>http://example.com/2021/08/25/go-framework/go-framework-3/</id>
    <published>2021-08-25T04:00:00.000Z</published>
    <updated>2021-09-26T02:52:01.951Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>日志是一个框架的重要组成部分，那今天我们一起来看看这部分。</p><p>衡量日志库有多个指标，我们今天重点关注两点：<strong>简单易用</strong> 与 <strong>高性能</strong>。简单易用是一个日志库能被广泛使用的必要条件，而<strong>高性能</strong>则是企业级的日志库非常重要的衡量点，也能在源码层面对我们有一定的启发。</p><span id="more"></span><h2 id="v0-3-0：日志库的选型与引入"><a href="#v0-3-0：日志库的选型与引入" class="headerlink" title="v0.3.0：日志库的选型与引入"></a>v0.3.0：日志库的选型与引入</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.3.0">https://github.com/Junedayday/micro_web_service/tree/v0.3.0</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>选择一个开源的日志组件引入，支持常规的日志打印。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol start="3"><li>三款开源日志库的横向对比</li><li>zap日志库的关键实现</li><li>关于日志参数的解析</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务</span><br><span class="line">         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义</span><br><span class="line">      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- server                          服务器的实现</span><br><span class="line">      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">   |-- config                          配置相关的文件夹</span><br><span class="line">      |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">     |-- zlog                            新增：封装日志的文件夹</span><br><span class="line">        |-- zap.go                           新增：zap封装的代码实现</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具</span><br><span class="line">|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-三款开源日志库的横向对比"><a href="#1-三款开源日志库的横向对比" class="headerlink" title="1.三款开源日志库的横向对比"></a>1.三款开源日志库的横向对比</h2><ul><li>glog: <a href="https://github.com/golang/glog">https://github.com/golang/glog</a></li><li>logrus: <a href="https://github.com/sirupsen/logrus">https://github.com/sirupsen/logrus</a></li><li>zap: <a href="https://github.com/uber-go/zap">https://github.com/uber-go/zap</a></li></ul><p>如果用一次词语分别进行概括三者的特性，我分别会用：<strong>glog - 代码极简，logrus - 功能全面， zap - 高性能</strong>。经过反复思考，这个框架会选择zap库作为日志引擎的基本组件，主要考量如下：</p><ol><li><strong>高性能</strong> - 性能是一个日志库很重要的属性，它往往由前期的设计决定，很难通过后面的优化大幅度提高，所以zap的高性能很难被替代；</li><li><strong>方便封装</strong> - zap设计简单，容易进行二次封装（glog更简洁，相应地就需要更多的封装代码）</li><li><strong>大厂背书</strong> - zap库被很多大公司引用，作为内部的日志库的底层，再二次开发</li><li><strong>源码学习</strong> - zap库对性能追求极高，可以作为高性能Go语言代码的分析样例</li></ol><h2 id="2-zap日志库的关键实现"><a href="#2-zap日志库的关键实现" class="headerlink" title="2.zap日志库的关键实现"></a>2.zap日志库的关键实现</h2><h3 id="最简化的调用"><a href="#最简化的调用" class="headerlink" title="最简化的调用"></a>最简化的调用</h3><p>zap日志库的调用很简单，只需要两行代码就能实现初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger, _ := zap.NewProduction()</span><br><span class="line"><span class="keyword">defer</span> logger.Sync()</span><br></pre></td></tr></table></figure><p>但这样的zap代码存在两个明显弊端：</p><ul><li>默认输出到控制台上</li><li>无法保存到指定目录的文件</li></ul><h3 id="核心的日志文件实现"><a href="#核心的日志文件实现" class="headerlink" title="核心的日志文件实现"></a>核心的日志文件实现</h3><p>我们增加了一定的特性，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// Logger为zap提供的原始日志，但使用起来比较烦，有强类型约束</span></span><br><span class="line">logger *zap.Logger</span><br><span class="line"><span class="comment">// SugaredLogger为zap提供的一个通用性更好的日志组件，作为本项目的核心日志组件</span></span><br><span class="line">Sugar *zap.SugaredLogger</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(logPath <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 日志暂时只开放一个配置 - 配置文件路径，有需要可以后续开放</span></span><br><span class="line">hook := lumberjack.Logger&#123;</span><br><span class="line">Filename: logPath,</span><br><span class="line">&#125;</span><br><span class="line">w := zapcore.AddSync(&amp;hook)</span><br><span class="line"></span><br><span class="line">encoderConfig := zap.NewProductionEncoderConfig()</span><br><span class="line">encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder</span><br><span class="line"></span><br><span class="line">core := zapcore.NewCore(</span><br><span class="line">zapcore.NewConsoleEncoder(encoderConfig),</span><br><span class="line">w,</span><br><span class="line">zap.InfoLevel,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">logger = zap.New(core, zap.AddCaller())</span><br><span class="line">Sugar = logger.Sugar()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名和原生的Zap Log尽量一致，方便理解</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sync</span><span class="params">()</span></span> &#123;</span><br><span class="line">logger.Sync()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们是如何解决上面两个问题的呢？</p><ol><li>利用<code>go.uber.org/zap/zapcore</code>中的开放配置</li><li>借用了<code>github.com/natefinch/lumberjack</code>这个常用的日志切分库，也顺带实现了日志路径的支持</li></ol><h3 id="main函数的调用"><a href="#main函数的调用" class="headerlink" title="main函数的调用"></a>main函数的调用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logFilePath = flag.String(<span class="string">&quot;l&quot;</span>, <span class="string">&quot;log/service.log&quot;</span>, <span class="string">&quot;log file path&quot;</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">zlog.Init(*logFilePath)</span><br><span class="line"><span class="keyword">defer</span> zlog.Sync()</span><br></pre></td></tr></table></figure><p>至此，我们的日志功能已经基本打通。</p><h2 id="3-关于日志参数的解析"><a href="#3-关于日志参数的解析" class="headerlink" title="3.关于日志参数的解析"></a>3.关于日志参数的解析</h2><p>日志参数常见的方式分2种，一个是来自<code>flag</code>的解析，另一个是来自配置文件。</p><p>随着我们功能的拓展，日志库肯定会支持越来越复杂的场景。那这个时候用<code>flag</code>解析的扩展性就会很差，所以，我更推荐在微服务的框架中，<strong>用配置文件的方式去加载日志的相关配置</strong>。但这种方式会带来一个常见的现象：</p><p>程序代码的实现为：先加载配置文件，后加载日志，导致配置文件出错时，无法通过日志来排查，需要用控制台或者进程管理工具协助定位问题。</p><p>后续，随着框架的迭代，我会开放出更多的日志参数，目前只放出了一个日志路径的参数作为示例。</p><h2 id="后续的两点核心需求"><a href="#后续的两点核心需求" class="headerlink" title="后续的两点核心需求"></a>后续的两点核心需求</h2><p>至此，我们添加的代码量并不多，也算成功地实现了一个日志打印的功能。但在实际的工程中，日志模块还需要实现两个比较大的功能：</p><ol><li>支持Go程序Panic/Error Wrapping风格的<strong>多行打印与采集</strong></li><li>支持分布式TraceId的打印，用来排查<strong>微服务调用链路</strong></li></ol><p>这两块的内容会结合具体的相关相关技术，会在后续专题中专门分享，请大家重点关注。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>zap</code>库的代码是一个很棒的实现，我会在接下来的<strong>Go语言技巧系列</strong>中详细分析，欢迎大家进行关注。</p><p>至此，我们的框架逐渐成型，接下来我将对<code>GORM</code>做一个简单的讲解，引入到框架中。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;日志是一个框架的重要组成部分，那今天我们一起来看看这部分。&lt;/p&gt;
&lt;p&gt;衡量日志库有多个指标，我们今天重点关注两点：&lt;strong&gt;简单易用&lt;/strong&gt; 与 &lt;strong&gt;高性能&lt;/strong&gt;。简单易用是一个日志库能被广泛使用的必要条件，而&lt;strong&gt;高性能&lt;/strong&gt;则是企业级的日志库非常重要的衡量点，也能在源码层面对我们有一定的启发。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 2.实现加载静态配置文件</title>
    <link href="http://example.com/2021/08/21/go-framework/go-framework-2/"/>
    <id>http://example.com/2021/08/21/go-framework/go-framework-2/</id>
    <published>2021-08-21T04:00:00.000Z</published>
    <updated>2021-09-26T02:51:53.730Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>我们的基础RPC服务已经正常运行，我们再来看下一个特性：配置文件的加载。</p><p>首先，我们要正确地认识到配置文件的重要性：<strong>在程序交付后，变更代码的成本很大；相对而言，变更配置文件的成本就比较小</strong>。但有的同学又走了另一个极端，也就是将大量的逻辑放入到配置文件中，导致<strong>配置文件膨胀</strong>，本质上就是将部分本应在代码中维护的内容转移到了配置文件，导致配置文件也很难维护。</p><p>今天，我们先将重点放到加载配置文件库的技术选型，顺便分享一些常见的问题。</p><span id="more"></span><h2 id="一个基础的加载配置文件示例"><a href="#一个基础的加载配置文件示例" class="headerlink" title="一个基础的加载配置文件示例"></a>一个基础的加载配置文件示例</h2><p>在<code>Go</code>语言中，用官方库就能快速实现配置文件的加载，下面就是一个简单的代码实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b, err := ioutil.ReadFile(<span class="string">&quot;config.json&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> config MyConfig</span><br><span class="line">err = json.Unmarshal(b, &amp;config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键的实现分为两块：</p><ol><li>读取文件中的数据</li><li>将数据解析到Go程序的对象中，作为可识别的数据结构，这里指定了数据类型为<code>json</code></li></ol><h2 id="v0-2-0：实现加载静态配置文件"><a href="#v0-2-0：实现加载静态配置文件" class="headerlink" title="v0.2.0：实现加载静态配置文件"></a>v0.2.0：实现加载静态配置文件</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.2.0">https://github.com/Junedayday/micro_web_service/tree/v0.2.0</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>从配置文件中解析数据到程序中，并具备更高的可读性和扩展性。</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li>命令行参数与配置文件的差异</li><li>github.com/spf13/viper的介绍</li><li>使用viper库的推荐方式</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><p><code>github.com/spf13/viper</code>中存在一个全局变量<code>var v *Viper</code>（<a href="https://github.com/spf13/viper/blob/v1.7.0/viper.go#L62">点击查看</a>），如果我们调用默认的viper包，其实就是将参数解析到这个全局变量中。</p><p>在具体的项目中，更推荐的方式是将这个变量保存到内部项目中，作为一个项目中的全局变量，所以我们会新建一个<code>viper.New()</code>。配置参数会被全局调用，为了保证不会发生<strong>循环依赖</strong>，我们就需要一个专门的<code>package</code>来保存这个全局变量，这里对应项目中的<code>internal/config/viper.go</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务</span><br><span class="line">         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义</span><br><span class="line">      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- server                          服务器的实现</span><br><span class="line">      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">   |-- config                          新增：配置相关的文件夹</span><br><span class="line">      |-- viper.go                         新增：viper的相关加载逻辑</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具</span><br><span class="line">|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="1-命令行参数与配置文件的差异"><a href="#1-命令行参数与配置文件的差异" class="headerlink" title="1.命令行参数与配置文件的差异"></a>1.命令行参数与配置文件的差异</h2><p>命令行参数类似于<code>./demo --config=a.yaml --http_port=8080 --grpc_port=8081</code>，<code>Go</code>语言中自带<code>flag</code>包可供解析，开源的有<code>pflag</code>和相关的扩展工具，如<code>cobra</code>。</p><p>而配置文件则是<strong>将参数从文件解析到内存中</strong>，一般用读取文件+反序列化工具来使用。</p><p>同样是解析参数到程序里，我们该选择哪种方案呢？我们从可读性和可维护性来对比下：</p><ul><li>可读性：命令行参数是扁平化的，可读性远不如格式化后的配置文件</li><li>可维护性：配置文件增加了一个维护项，但成本不高</li></ul><p>所以，我个人倾向于的方案是：</p><ul><li>命令行参数：用于维护极少量关键性的参数，如配置文件的路径</li><li>配置文件：维护绝大多数的参数</li></ul><p>在某些极端的场景中，比如提供一个纯二进制文件作为工具，那不得不把所有配置参数都放入到命令行参数中。这并不是我们微服务框架要讨论的场景。所以，接下来我们重点讨论配置文件的加载。</p><blockquote><p>关于pflag相关的内容，在后续程序复杂到一定阶段后会引入。</p></blockquote><h2 id="2-github-com-spf13-viper的介绍"><a href="#2-github-com-spf13-viper的介绍" class="headerlink" title="2.github.com/spf13/viper的介绍"></a>2.github.com/spf13/viper的介绍</h2><p>对比上面的方案，我们来看一个业内使用最广的Go语言配置加载库<code>github.com/spf13/viper</code>的实现，对应的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">viper.SetConfigName(<span class="string">&quot;config&quot;</span>)        <span class="comment">// config file name without file type</span></span><br><span class="line">viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>)          <span class="comment">// config file type</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;./&quot;</span>)            <span class="comment">// config file path</span></span><br><span class="line"><span class="keyword">if</span> err := viper.ReadInConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在获取配置文件时，又采用key-value形式的语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viper.GetInt(<span class="string">&quot;server.grpc.port&quot;</span>)</span><br></pre></td></tr></table></figure><p>详细的特性我会在<strong>Go语言技巧系列</strong>里说明，今天我们聚焦于工程侧的宏观特性，来聊聊这个库的优劣势：</p><h3 id="可选的参数序列化"><a href="#可选的参数序列化" class="headerlink" title="可选的参数序列化"></a>可选的参数序列化</h3><p>从<code>viper</code>库的源码中(<a href="https://github.com/spf13/viper/blob/v1.7.0/viper.go#L328">点击跳转</a>)，我们可以看到它支持多种<strong>本地文件类型</strong>与<strong>远程k-v数据库</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SupportedExts are universally supported extensions.</span></span><br><span class="line"><span class="keyword">var</span> SupportedExts = []<span class="keyword">string</span>&#123;<span class="string">&quot;json&quot;</span>, <span class="string">&quot;toml&quot;</span>, <span class="string">&quot;yaml&quot;</span>, <span class="string">&quot;yml&quot;</span>, <span class="string">&quot;properties&quot;</span>, <span class="string">&quot;props&quot;</span>, <span class="string">&quot;prop&quot;</span>, <span class="string">&quot;hcl&quot;</span>, <span class="string">&quot;dotenv&quot;</span>, <span class="string">&quot;env&quot;</span>, <span class="string">&quot;ini&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SupportedRemoteProviders are universally supported remote providers.</span></span><br><span class="line"><span class="keyword">var</span> SupportedRemoteProviders = []<span class="keyword">string</span>&#123;<span class="string">&quot;etcd&quot;</span>, <span class="string">&quot;consul&quot;</span>, <span class="string">&quot;firestore&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>我们先忽略远程的存储，先看一下最常用的几个序列化的库：</p><ol><li>JSON: 官方自带的<code>encoding/json</code></li><li>TOML: 开源的<code>github.com/pelletier/go-toml</code></li><li>YAML: 官方推荐的<code>gopkg.in/yaml.v2</code></li><li>INI：官方推荐的<code>gopkg.in/ini.v1</code></li></ol><p>在这四种技术选型时，我个人倾向于选择<code>JSON</code>和<code>YAML</code>。进一步斟酌时，虽然<code>JSON</code>的适用范围最广，但当配置文件复杂到一定程度时，<code>JSON</code>格式的配置文件很难通过换行来约束，当存在大量的嵌套时，可读性很差。所以，我个人比较推荐使用<code>YAML</code>格式的配置文件，一方面通过强制的换行约束，可读性很棒；另一方面云原生相关技术大量使用了<code>YAML</code>作为配置文件，尤其是<code>Kubernetes</code>中各种定义。</p><p>例如，我们将服务的端口改造到配置文件里，就成了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">grpc:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8082</span></span><br></pre></td></tr></table></figure><p>对应的Go语言代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">viper.GetInt(<span class="string">&quot;server.http.port&quot;</span>)</span><br><span class="line">viper.GetInt(<span class="string">&quot;server.grpc.port&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="可扩展的获取参数方法"><a href="#可扩展的获取参数方法" class="headerlink" title="可扩展的获取参数方法"></a>可扩展的获取参数方法</h3><p><code>viper</code>库提供的获取参数方式为<code>viper.Get&#123;type&#125;(&quot;&#123;level1&#125;.&#123;level2&#125;.&#123;level3&#125;...&quot;)</code>的格式。随着配置文件的扩大，也只需新增Get方法即可。</p><p>从获取参数的方法来看，它的设计分为3种：</p><ol><li>基本类型，直接提供Get{具体类型}的方法，如<code>GetInt</code>，<code>GetString</code>；</li><li>任意类型，提供<code>Get(key string) interface&#123;&#125; </code>，自行转化</li><li>复杂类型的反序列化，提供<code>UnmarshalKey</code>等方法，更方便地获取复杂结构</li></ol><p>我个人建议各位只使用第一类的方法，将配置文件这个模块做到最简化。毕竟，<strong>配置文件的复杂化很容易引入各种问题，占用大量的排查故障的时间</strong>。如果你的系统必须引入一套非常复杂的配置，那么我更建议将它独立成一个专门的服务，用来维护这套配置。</p><h2 id="3-使用viper库的推荐方式"><a href="#3-使用viper库的推荐方式" class="headerlink" title="3.使用viper库的推荐方式"></a>3.使用viper库的推荐方式</h2><p>如果你仔细地阅读viper相关的代码，你会发现它有很多超酷的特性。但今天，我想告诉各位：<strong>请克制地使用进阶的特性，最棒的特性往往是简洁的</strong>。</p><p>我们对照着官方的README文件中介绍的特性进行讲解。</p><h3 id="尽量避免手动设置的参数值"><a href="#尽量避免手动设置的参数值" class="headerlink" title="尽量避免手动设置的参数值"></a>尽量避免手动设置的参数值</h3><p><a href="https://github.com/spf13/viper#establishing-defaults">原文链接</a></p><p>用<code>viper.SetDefault</code>函数可以给某些参数设置默认值，如果只是少数的几个参数还是很容易维护的。但如果设置的值过多了，就会给阅读代码的人带来困扰：<strong>这个参数是来自配置文件，还是在代码某处手动设置的？</strong>也就是存在<strong>二义性</strong>，增加了排查问题的复杂度。</p><h3 id="明确配置文件的来源"><a href="#明确配置文件的来源" class="headerlink" title="明确配置文件的来源"></a>明确配置文件的来源</h3><p><a href="https://github.com/spf13/viper#reading-config-files">原文链接</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viper.AddConfigPath(<span class="string">&quot;/etc/appname/&quot;</span>)   <span class="comment">// path to look for the config file in</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;$HOME/.appname&quot;</span>)  <span class="comment">// call multiple times to add many search paths</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)               <span class="comment">// optionally look for config in the working directory</span></span><br></pre></td></tr></table></figure><p><code>viper</code>支持多个配置文件的路径，这虽然带来了便利性，但如果多个文件路径中都存在配置文件，那究竟以哪个为准？这也是一个<strong>二义性</strong>的问题，所以我个人更建议只设置一个，而这个路径由<code>flag</code>传入。</p><h3 id="静态配置与动态配置的分离"><a href="#静态配置与动态配置的分离" class="headerlink" title="静态配置与动态配置的分离"></a>静态配置与动态配置的分离</h3><p><a href="https://github.com/spf13/viper#watching-and-re-reading-config-files">原文链接</a></p><p><code>viper</code>提供了接口<code>viper.WatchConfig()</code>，可以监听文件的变化，然后做相应的调整。这个特性很酷，我们可以用它实现<strong>热加载</strong>。但这个特性很容易让人产生混淆：例如发生了某个BUG，如何确定当时的配置文件情况？其实，这就需要引入一定的<strong>版本管理</strong>机制。</p><p>我更建议采用<strong>静态配置和动态配置分离</strong>的方案，也就是配置文件负责静态的、固定的配置，一旦启动后只加载一次；而动态的配置放在带版本管理的配置中心里，具备热加载的特性。</p><p>所以，我不太建议在配置文件这里引入监听文件变化的特性。</p><h2 id="核心代码示例"><a href="#核心代码示例" class="headerlink" title="核心代码示例"></a>核心代码示例</h2><h3 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h3><p>从<code>flag</code>中解析出配置文件路径，传到<code>config</code>包中用于解析。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> configFilePath = flag.String(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;./&quot;</span>, <span class="string">&quot;config file path&quot;</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := config.Load(*configFilePath); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="internal-config-viper-go"><a href="#internal-config-viper-go" class="headerlink" title="internal/config/viper.go"></a>internal/config/viper.go</h3><p>加载的代码并不多，尽量保证配置信息的简洁易懂。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局Viper变量</span></span><br><span class="line"><span class="keyword">var</span> Viper = viper.New()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Load</span><span class="params">(configFilePath <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">Viper.SetConfigName(<span class="string">&quot;config&quot;</span>)       <span class="comment">// config file name without file type</span></span><br><span class="line">Viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>)         <span class="comment">// config file type</span></span><br><span class="line">Viper.AddConfigPath(configFilePath) <span class="comment">// config file path</span></span><br><span class="line"><span class="keyword">return</span> Viper.ReadInConfig()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置使用方"><a href="#配置使用方" class="headerlink" title="配置使用方"></a>配置使用方</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.Viper.GetInt(<span class="string">&quot;server.grpc.port&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="使用viper库的注意事项"><a href="#使用viper库的注意事项" class="headerlink" title="使用viper库的注意事项"></a>使用viper库的注意事项</h2><p>在使用<code>viper</code>获取配置时，我们需要手动组装<code>key</code>，也就是<code>&quot;&#123;level1&#125;.&#123;level2&#125;.&#123;level3&#125;...&quot;</code>这种形式。这时，我们只能对照着原始配置文件逐个填充字段，一不小心填错、就会发生奇怪的问题。而如果采用的是将配置文件解析到结构体的方法，就能很容易地避免这个问题。</p><p>考虑到扩展性，官方库推荐的是手动组装key的方式，所以需要大家在认真查看这个<code>key</code>是否有效。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>加载静态配置文件是一个很常见的功能，<code>viper</code>提供了一套完整方案，兼具简洁和扩展性；与此同时，我们要学会<strong>克制</strong>，不要看到了<code>viper</code>中提供的各种特性、就想着应用到实际项目中，也就是常说的：<strong>手里拿了个锤子，看啥都是钉子</strong>。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们的基础RPC服务已经正常运行，我们再来看下一个特性：配置文件的加载。&lt;/p&gt;
&lt;p&gt;首先，我们要正确地认识到配置文件的重要性：&lt;strong&gt;在程序交付后，变更代码的成本很大；相对而言，变更配置文件的成本就比较小&lt;/strong&gt;。但有的同学又走了另一个极端，也就是将大量的逻辑放入到配置文件中，导致&lt;strong&gt;配置文件膨胀&lt;/strong&gt;，本质上就是将部分本应在代码中维护的内容转移到了配置文件，导致配置文件也很难维护。&lt;/p&gt;
&lt;p&gt;今天，我们先将重点放到加载配置文件库的技术选型，顺便分享一些常见的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go语言微服务框架 - 1.搭建gRPC+HTTP的双重网关服务</title>
    <link href="http://example.com/2021/08/19/go-framework/go-framework-1/"/>
    <id>http://example.com/2021/08/19/go-framework/go-framework-1/</id>
    <published>2021-08-19T04:00:00.000Z</published>
    <updated>2021-08-21T06:14:29.483Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg" alt="Go-Framework"></p><p>大家好，我是六月天天。如题所述，从今天开始，我将和大家一起逐步完成一个微服务框架。</p><p>整个迭代过程会围绕着两个核心思想进行：</p><ol><li><strong>关注技术选型背后的思想</strong>。虽然最终某个技术选型的可能并不是你喜欢的方案（如RPC、日志、数据库等，你可以fork后自行调整），但我们更关注各个技术组件背后的原理与思想，<strong>选择的过程比结果更重要</strong>；</li><li><strong>聚焦于简单，关注可维护性</strong>。技术框架是项目的基础设施，也是排查复杂业务问题的根本，所以框架层的功能会尽量考虑简单易用，可以让我们花更多的心思在业务开发中。许多开源库提供了大量扩展功能，但我们使用时会尽量<strong>克制</strong>，减少学习和排查问题时的成本。</li></ol><p>微服务框架系列重点介绍框架的搭建过程，期间对一些细节技术点的讲解，会在另一个系列<strong>Go语言技巧系列</strong>中展开。</p><span id="more"></span><h2 id="v0-1-0：搭建gRPC-HTTP的双重网关服务"><a href="#v0-1-0：搭建gRPC-HTTP的双重网关服务" class="headerlink" title="v0.1.0：搭建gRPC+HTTP的双重网关服务"></a>v0.1.0：搭建gRPC+HTTP的双重网关服务</h2><p>项目链接 <a href="https://github.com/Junedayday/micro_web_service/tree/v0.1.0">https://github.com/Junedayday/micro_web_service/tree/v0.1.0</a></p><p>gRPC-gateway官方Github <a href="https://github.com/grpc-ecosystem/grpc-gateway">https://github.com/grpc-ecosystem/grpc-gateway</a></p><blockquote><p>有很多朋友更喜欢使用Gin框架，但我依然选择了gRPC-gateway。</p><p>主要在于gRPC-gateway方案对接Google提供的各种开源插件生态都很棒。大家会在后面框架的迭代过程中慢慢体会到它的特性。</p><p>后续我也会对Gin做一些分析。</p></blockquote><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>完成RPC服务的框架的搭建</p><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><ol><li><code>protobuffer</code>定义IDL（Interface Definition Language 接口定义语言）</li><li><code>buf</code>工具生成<code>Go</code>代码（包括数据结构和RPC相关服务）</li><li><code>Go</code>项目实现RPC服务（实现RPC接口）</li></ol><h3 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line">|-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">   |-- idl                             对应idl文件夹</span><br><span class="line">      |-- demo                             对应idl/demo服务</span><br><span class="line">         |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">         |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">         |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line">|-- idl                            原始的idl定义</span><br><span class="line">   |-- demo                            业务package定义</span><br><span class="line">      |-- demo.proto                       protobuffer的原始定义</span><br><span class="line">|-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">   |-- server                          服务器的实现</span><br><span class="line">      |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">      |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">|-- buf.gen.yaml                   buf生成代码的定义</span><br><span class="line">|-- buf.yaml                       buf工具安装所需的工具</span><br><span class="line">|-- gen.sh                         buf生成的shell脚本</span><br><span class="line">|-- go.mod                         Go Module文件</span><br><span class="line">|-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure><h2 id="1-protobuffer定义IDL"><a href="#1-protobuffer定义IDL" class="headerlink" title="1. protobuffer定义IDL"></a>1. protobuffer定义IDL</h2><p>我们先看一下项目中的<code>demo.proto</code>文件，重点关注 <strong>rpc Echo(DemoRequest) returns (DemoResponse)</strong> 这个定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">message DemoRequest &#123;</span><br><span class="line">   string value = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message DemoResponse &#123;</span><br><span class="line">   int32 code = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 样例服务</span><br><span class="line">service DemoService &#123;</span><br><span class="line">  // Echo 样例接口</span><br><span class="line">  rpc Echo(DemoRequest) returns (DemoResponse) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      post : &quot;/apis/demo&quot;</span><br><span class="line">      body : &quot;*&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今天我们暂时不对<code>protobuffer</code>的语法做扩展讲解，只需要简单地了解下它的请求结构体<code>DemoRequest</code>和响应结构体<code>DemoResponse</code>。</p><h2 id="2-buf工具生成Go代码"><a href="#2-buf工具生成Go代码" class="headerlink" title="2. buf工具生成Go代码"></a>2. buf工具生成Go代码</h2><p>我们通过运行项目根目录中的<code>gen.sh</code>，会在<code>gen</code>目录下生成对应的Go语言代码。</p><p>这部分是自动化的工作，每次修改<code>proto</code>文件后需要运行。</p><blockquote><p>buf工具的安装请参考README.md，它是protoc的演进版本，不再需要大量flag参数，更加简单易用。</p><p>注意，如果修改了模块名，buf工具第一次初始化建议使用 buf beta mod init 指令</p></blockquote><h2 id="3-Go项目实现RPC服务"><a href="#3-Go项目实现RPC服务" class="headerlink" title="3.Go项目实现RPC服务"></a>3.Go项目实现RPC服务</h2><p>我们梳理一下整个逻辑，来看看这个<code>Go</code>程序是怎么提供RPC服务的。</p><ol><li>在<code>buf.gen.yaml</code>中定义了生成的2种服务， <code>go-grpc</code>和 <code>grpc-gateway</code>，分别表示<code>gRPC</code>和<code>HTTP</code></li><li><code>demo.proto</code>通过脚本，在<code>gen/idl/demo</code>生成了2个文件，<code>*_grpc.pb.go</code>和<code>*.pb.gw.go</code>，分别表示<code>gRPC</code>和<code>HTTP</code></li><li>在<code>main</code>函数中注册两个服务，分别为：<ol><li>gRPC - <code>demo.RegisterDemoServiceServer(s, &amp;server.Server&#123;&#125;)</code></li><li>HTTP - <code>demo.RegisterDemoServiceHandlerFromEndpoint(ctx, mux, *grpcServerEndpoint, opts)</code></li></ol></li><li>在<code>internal/server/server.go</code>中，<code>server.Server</code>需要实现<code>proto</code>中定义的方法，所以我们加入接口定义<code>demo.UnsafeDemoServiceServer</code></li><li>在<code>internal/server/demo.go</code>中，实现一个<code>func (s *Server) Echo(ctx context.Context, req *demo.DemoRequest) (*demo.DemoResponse, error)</code>方法</li></ol><h2 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h2><p>我们用简单的命令来运行，并用RPC访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译并运行</span></span><br><span class="line">go build &amp;&amp; ./micro_web_service </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 模拟HTTP请求</span></span><br><span class="line">curl --location --request POST &#x27;http://127.0.0.1:8081/apis/demo&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 收到返回值 &#123;<span class="string">&quot;code&quot;</span>:0&#125;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 而gRPC比较麻烦，是私有协议，我们查看一下对应的网络端口，发现正在监听，也就意味着正常运行</span></span><br><span class="line">netstat -an | grep 9090</span><br><span class="line">tcp4       0      0  127.0.0.1.9090         127.0.0.1.49266        ESTABLISHED</span><br><span class="line">tcp4       0      0  127.0.0.1.49266        127.0.0.1.9090         ESTABLISHED</span><br><span class="line">tcp46      0      0  *.9090                 *.*                    LISTEN </span><br></pre></td></tr></table></figure><h2 id="项目的私有化"><a href="#项目的私有化" class="headerlink" title="项目的私有化"></a>项目的私有化</h2><p>由于本项目只是一个框架，如果你希望修改为个人的项目，主要改动点在两处：</p><ol><li><code>go.mod</code>里的模块名，以及<code>Go</code>代码内部的import</li><li><code>proto</code>文件中定义的<code>go_package</code></li></ol><blockquote><p>建议用编辑工具全量替换</p></blockquote><h2 id="新增接口示例"><a href="#新增接口示例" class="headerlink" title="新增接口示例"></a>新增接口示例</h2><h3 id="添加proto定义"><a href="#添加proto定义" class="headerlink" title="添加proto定义"></a>添加proto定义</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EmptyMessage</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Empty 空接口</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Empty(EmptyMessage) <span class="keyword">returns</span> (EmptyMessage) </span>&#123;</span><br><span class="line">  <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">    post : <span class="string">&quot;/apis/empty&quot;</span></span><br><span class="line">    body : <span class="string">&quot;*&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成Go文件"><a href="#生成Go文件" class="headerlink" title="生成Go文件"></a>生成Go文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash gen.sh</span><br></pre></td></tr></table></figure><h3 id="添加接口定义"><a href="#添加接口定义" class="headerlink" title="添加接口定义"></a>添加接口定义</h3><p>这时候，我们会发现<code>main.go</code>中有报错，即提示<code>server.Server</code>这个对象需要实现<code>Empty</code>方法。于是，我们在<code>internal/server/demo.go</code>里添加</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Empty</span><span class="params">(ctx context.Context, req *demo.EmptyMessage)</span> <span class="params">(*demo.EmptyMessage, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;demo.EmptyMessage&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试新接口"><a href="#测试新接口" class="headerlink" title="测试新接口"></a>测试新接口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译并运行</span></span><br><span class="line">go build &amp;&amp; ./micro_web_service </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 模拟HTTP请求</span></span><br><span class="line">curl --location --request POST &#x27;http://127.0.0.1:8081/apis/empty&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回 &#123;&#125;</span> </span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>v0.1.0</code>版本是一个非常简单的web框架，只有样例的RPC接口。</p><p>开放<code>HTTP</code>接口是为了兼容传统方案，而<code>gRPC</code>则提供了高性能、跨语言的通信方案。从整个实现过程来看，我们只编写了一个具体的实现、也就是<code>Echo</code>这个方法，就完成了两种通信方式的兼容。</p><p><code>gRPC-Gateway</code>方案还有很多很棒的特性，我会在后续逐一介绍并引入。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/QfmqMJGaNOgt7LC.jpg&quot; alt=&quot;Go-Framework&quot;&gt;&lt;/p&gt;
&lt;p&gt;大家好，我是六月天天。如题所述，从今天开始，我将和大家一起逐步完成一个微服务框架。&lt;/p&gt;
&lt;p&gt;整个迭代过程会围绕着两个核心思想进行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;关注技术选型背后的思想&lt;/strong&gt;。虽然最终某个技术选型的可能并不是你喜欢的方案（如RPC、日志、数据库等，你可以fork后自行调整），但我们更关注各个技术组件背后的原理与思想，&lt;strong&gt;选择的过程比结果更重要&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;聚焦于简单，关注可维护性&lt;/strong&gt;。技术框架是项目的基础设施，也是排查复杂业务问题的根本，所以框架层的功能会尽量考虑简单易用，可以让我们花更多的心思在业务开发中。许多开源库提供了大量扩展功能，但我们使用时会尽量&lt;strong&gt;克制&lt;/strong&gt;，减少学习和排查问题时的成本。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;微服务框架系列重点介绍框架的搭建过程，期间对一些细节技术点的讲解，会在另一个系列&lt;strong&gt;Go语言技巧系列&lt;/strong&gt;中展开。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-Framework" scheme="http://example.com/tags/Go-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 9.【电话号码的字母组合LeetCode-17】</title>
    <link href="http://example.com/2021/08/18/go-leetcode/go-leetcode-9/"/>
    <id>http://example.com/2021/08/18/go-leetcode/go-leetcode-9/</id>
    <published>2021-08-18T04:00:00.000Z</published>
    <updated>2021-08-18T11:59:41.092Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-17-电话号码的字母组合"><a href="#Leetcode-17-电话号码的字母组合" class="headerlink" title="Leetcode-17 电话号码的字母组合"></a>Leetcode-17 电话号码的字母组合</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="基础解法"><a href="#基础解法" class="headerlink" title="基础解法"></a>基础解法</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>这道题的思路并不复杂，我们逐个处理<code>digits</code>里的字符，追加到结果上</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numToLetter = <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;2&quot;</span>: &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;3&quot;</span>: &#123;<span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;4&quot;</span>: &#123;<span class="string">&quot;g&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;i&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;5&quot;</span>: &#123;<span class="string">&quot;j&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;l&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;6&quot;</span>: &#123;<span class="string">&quot;m&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;o&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;7&quot;</span>: &#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;s&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;8&quot;</span>: &#123;<span class="string">&quot;t&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;v&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;9&quot;</span>: &#123;<span class="string">&quot;w&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> digits == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> matchNext([]<span class="keyword">string</span>&#123;&#125;, digits)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心递归，逐个处理剩余的字符串left</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">matchNext</span><span class="params">(current []<span class="keyword">string</span>, left <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> left == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> current</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从题目来看肯定是matched的</span></span><br><span class="line">matched, ok := numToLetter[<span class="keyword">string</span>(left[<span class="number">0</span>])]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> current</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(current) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> matchNext(matched, left[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line">next := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(current)*<span class="built_in">len</span>(matched))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> next &#123;</span><br><span class="line">  <span class="comment">// 利用位操作加速</span></span><br><span class="line">next[i] = current[i/<span class="built_in">len</span>(matched)] + matched[i%<span class="built_in">len</span>(matched)]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> matchNext(next, left[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="减少内存空间"><a href="#减少内存空间" class="headerlink" title="减少内存空间"></a>减少内存空间</h3><p>从运行结果来看：</p><ul><li>执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</li></ul><p>运行速度已经很难优化了，我们就想办法减少一下内存空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 减少空间，把切片转变成字符串</span></span><br><span class="line"><span class="keyword">var</span> numToLetter = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;2&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line"><span class="string">&quot;3&quot;</span>: <span class="string">&quot;def&quot;</span>,</span><br><span class="line"><span class="string">&quot;4&quot;</span>: <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line"><span class="string">&quot;5&quot;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line"><span class="string">&quot;6&quot;</span>: <span class="string">&quot;mno&quot;</span>,</span><br><span class="line"><span class="string">&quot;7&quot;</span>: <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line"><span class="string">&quot;8&quot;</span>: <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line"><span class="string">&quot;9&quot;</span>: <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> digits == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> matchNext([]<span class="keyword">string</span>&#123;&#125;, digits)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">matchNext</span><span class="params">(current []<span class="keyword">string</span>, left <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> left == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> current</span><br><span class="line">&#125;</span><br><span class="line">matched, ok := numToLetter[<span class="keyword">string</span>(left[<span class="number">0</span>])]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> current</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(current) == <span class="number">0</span> &#123;</span><br><span class="line">next := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(matched))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> matched &#123;</span><br><span class="line">next[i] = <span class="keyword">string</span>(matched[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> matchNext(next, left[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line">next := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(current)*<span class="built_in">len</span>(matched))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> next &#123;</span><br><span class="line"><span class="comment">// 利用位操作加速</span></span><br><span class="line">next[i] = current[i/<span class="built_in">len</span>(matched)] + <span class="keyword">string</span>(matched[i%<span class="built_in">len</span>(matched)])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> matchNext(next, left[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进阶：引入函数式编程"><a href="#进阶：引入函数式编程" class="headerlink" title="进阶：引入函数式编程"></a>进阶：引入函数式编程</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(digits) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result []<span class="keyword">string</span></span><br><span class="line">numToLetter := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;2&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line"><span class="string">&quot;3&quot;</span>: <span class="string">&quot;def&quot;</span>,</span><br><span class="line"><span class="string">&quot;4&quot;</span>: <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line"><span class="string">&quot;5&quot;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line"><span class="string">&quot;6&quot;</span>: <span class="string">&quot;mno&quot;</span>,</span><br><span class="line"><span class="string">&quot;7&quot;</span>: <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line"><span class="string">&quot;8&quot;</span>: <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line"><span class="string">&quot;9&quot;</span>: <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> matchNext <span class="function"><span class="keyword">func</span><span class="params">(current <span class="keyword">string</span>, left <span class="keyword">string</span>)</span></span></span><br><span class="line">matchNext = <span class="function"><span class="keyword">func</span><span class="params">(current <span class="keyword">string</span>, left <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(left) == <span class="number">0</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, current)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> numToLetter[<span class="keyword">string</span>(left[<span class="number">0</span>])] &#123;</span><br><span class="line">current = current + <span class="keyword">string</span>(v)</span><br><span class="line">matchNext(current, left[<span class="number">1</span>:])</span><br><span class="line">current = current[:<span class="built_in">len</span>(current)<span class="number">-1</span>] <span class="comment">//回溯</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">matchNext(<span class="string">&quot;&quot;</span>, digits)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个思路比较简单，最主要的优点在于将<code>numToLetter</code>和<code>matchNext</code>收敛到了函数中，对外暴露的细节就减少了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题的解法比较通俗易懂，最主要的切入点是引入<strong>递归的思想</strong>，来不断地缩减传入的字符串<code>digits</code>的长度，直到为0。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-17-电话号码的字母组合&quot;&gt;&lt;a href=&quot;#Leetcode-17-电话号码的字母组合&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-17 电话号码的字母组合&quot;&gt;&lt;/a&gt;Leetcode-17 电话号码的字母组合&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/&quot;&gt;https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;letterCombinations&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(digits &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; []&lt;span class=&quot;title&quot;&gt;string&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 8.【三数之和LeetCode-15】</title>
    <link href="http://example.com/2021/08/08/go-leetcode/go-leetcode-8/"/>
    <id>http://example.com/2021/08/08/go-leetcode/go-leetcode-8/</id>
    <published>2021-08-08T04:00:00.000Z</published>
    <updated>2021-08-15T13:18:56.227Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-15-三数之和"><a href="#Leetcode-15-三数之和" class="headerlink" title="Leetcode-15 三数之和"></a>Leetcode-15 三数之和</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="基础解法"><a href="#基础解法" class="headerlink" title="基础解法"></a>基础解法</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>在看到这道题的后，我们很自然地可以想到简单的解法，例如穷举出所有的值。这个代码我就不专门写了。</p><h3 id="利用排序进行优化"><a href="#利用排序进行优化" class="headerlink" title="利用排序进行优化"></a>利用排序进行优化</h3><p>由于这道题返回的<code>[][]int</code>要求是对应的值，而不是索引，所以我们可以利用排序做一定的加速，示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 先排序，为了方便处理</span></span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="comment">// 用于去重</span></span><br><span class="line"><span class="keyword">var</span> solutionMap = <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">3</span>]<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">for</span> k := j + <span class="number">1</span>; k &lt;= <span class="built_in">len</span>(nums)<span class="number">-1</span>; k++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i]+nums[j]+nums[k] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 取到一个解即可</span></span><br><span class="line">solutionMap[[<span class="number">3</span>]<span class="keyword">int</span>&#123;nums[i], nums[j], nums[k]&#125;] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[j]+nums[k] &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 如果已经大于0了，由于nums是递增的，无需继续循环下去了</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取一下去重后的解</span></span><br><span class="line"><span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> solutionMap &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, k[<span class="number">0</span>], k[<span class="number">1</span>], k[<span class="number">2</span>]))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但运行下来，在数据量大的情况下还是会超出时间限制</p><h3 id="利用二分查找加速"><a href="#利用二分查找加速" class="headerlink" title="利用二分查找加速"></a>利用二分查找加速</h3><p>我们把目光聚焦到<code>k</code>，在一个有序的数组中，可以利用二分查找加速</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="keyword">var</span> solutionMap = <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">3</span>]<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; j++ &#123;</span><br><span class="line"><span class="comment">// 用二分查找加速</span></span><br><span class="line"><span class="comment">// 但需要注意的是，go里的sort并不是精确匹配，所以需要二次判断</span></span><br><span class="line">k := sort.SearchInts(nums[j+<span class="number">1</span>:], -nums[i]-nums[j])</span><br><span class="line"><span class="keyword">if</span> k &lt; <span class="built_in">len</span>(nums[j+<span class="number">1</span>:]) &amp;&amp; nums[i]+nums[j]+nums[j+k+<span class="number">1</span>] == <span class="number">0</span> &#123;</span><br><span class="line">solutionMap[[<span class="number">3</span>]<span class="keyword">int</span>&#123;nums[i], nums[j], nums[j+k+<span class="number">1</span>]&#125;] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> solutionMap &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, k[<span class="number">0</span>], k[<span class="number">1</span>], k[<span class="number">2</span>]))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，代码已经可以通过验证，我们再看看有什么进一步的优化空间。</p><h3 id="优化1：减少元素的存储"><a href="#优化1：减少元素的存储" class="headerlink" title="优化1：减少元素的存储"></a>优化1：减少元素的存储</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="comment">// 缩小元素的存储</span></span><br><span class="line"><span class="keyword">var</span> solutionMap = <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">2</span>]<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; j++ &#123;</span><br><span class="line">k := sort.SearchInts(nums[j+<span class="number">1</span>:], -nums[i]-nums[j])</span><br><span class="line"><span class="keyword">if</span> k &lt; <span class="built_in">len</span>(nums[j+<span class="number">1</span>:]) &amp;&amp; nums[i]+nums[j]+nums[j+k+<span class="number">1</span>] == <span class="number">0</span> &#123;</span><br><span class="line">solutionMap[[<span class="number">2</span>]<span class="keyword">int</span>&#123;nums[i], nums[j]&#125;] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> solutionMap &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, k[<span class="number">0</span>], k[<span class="number">1</span>], -k[<span class="number">0</span>]-k[<span class="number">1</span>]))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化2：初始化切片大小，防止扩容效率"><a href="#优化2：初始化切片大小，防止扩容效率" class="headerlink" title="优化2：初始化切片大小，防止扩容效率"></a>优化2：初始化切片大小，防止扩容效率</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="keyword">var</span> solutionMap = <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">2</span>]<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; j++ &#123;</span><br><span class="line">k := sort.SearchInts(nums[j+<span class="number">1</span>:], -nums[i]-nums[j])</span><br><span class="line"><span class="keyword">if</span> k &lt; <span class="built_in">len</span>(nums[j+<span class="number">1</span>:]) &amp;&amp; nums[i]+nums[j]+nums[j+k+<span class="number">1</span>] == <span class="number">0</span> &#123;</span><br><span class="line">solutionMap[[<span class="number">2</span>]<span class="keyword">int</span>&#123;nums[i], nums[j]&#125;] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化切片空间</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(solutionMap))</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> solutionMap &#123;</span><br><span class="line">result[i] = []<span class="keyword">int</span>&#123;k[<span class="number">0</span>], k[<span class="number">1</span>], -k[<span class="number">0</span>] - k[<span class="number">1</span>]&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化3：利用map加速查询"><a href="#优化3：利用map加速查询" class="headerlink" title="优化3：利用map加速查询"></a>优化3：利用map加速查询</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="keyword">var</span> dataCountMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := dataCountMap[v]; !ok &#123;</span><br><span class="line">dataCountMap[v] = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dataCountMap[v]++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> solutionMap = <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">2</span>]<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; j++ &#123;</span><br><span class="line">expected := -nums[i] - nums[j]</span><br><span class="line"><span class="keyword">if</span> num, ok := dataCountMap[expected]; ok &amp;&amp; expected &gt;= nums[j] &#123;</span><br><span class="line"><span class="keyword">if</span> expected == nums[j] &#123;</span><br><span class="line">num--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> expected == nums[i] &#123;</span><br><span class="line">num--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">solutionMap[[<span class="number">2</span>]<span class="keyword">int</span>&#123;nums[i], nums[j]&#125;] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(solutionMap))</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> solutionMap &#123;</span><br><span class="line">result[i] = []<span class="keyword">int</span>&#123;k[<span class="number">0</span>], k[<span class="number">1</span>], -k[<span class="number">0</span>] - k[<span class="number">1</span>]&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进阶思路-双指针"><a href="#进阶思路-双指针" class="headerlink" title="进阶思路 -  双指针"></a>进阶思路 -  双指针</h2><p>我们把眼光放回到这个问题。通过排序，其实我们已经将问题变得比较清晰了。</p><p>在这个题目中，有三个关键的变量，我们可以将其中一个固定，例如<code>i</code>，将问题简化为<code>nums[j]+nums[k]=-nums[i]</code>。</p><p>于是，问题就在于<code>j</code>和<code>k</code>这两个坐标的移动。整体的代码思路并不难，但性能的提升集中在<strong>对剪枝情况的处理</strong>，尤其是值相同的元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 剪枝：最小值大于0时无需再遍历</span></span><br><span class="line"><span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 剪枝：最小值和前一个值一样时，上一个循环已经判断过，无需再判断</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// j,k 为两个指针，分别从最左边和最右边开始移动</span></span><br><span class="line">j, k := i+<span class="number">1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> j &lt; k &#123;</span><br><span class="line">left, right := nums[j], nums[k]</span><br><span class="line"><span class="keyword">if</span> nums[i]+nums[j]+nums[k] == <span class="number">0</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;nums[i], nums[j], nums[k]&#125;)</span><br><span class="line"><span class="comment">// 减枝：跳过 nums[j] == nums[j+1] 的情况</span></span><br><span class="line"><span class="keyword">for</span> j &lt; k &amp;&amp; nums[j] == left &#123;</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 减枝：跳过 nums[k] == nums[k-1] 的情况</span></span><br><span class="line"><span class="keyword">for</span> j &lt; k &amp;&amp; nums[k] == right &#123;</span><br><span class="line">k--</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[j]+nums[k] &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 和小于0，则增大最左边的j</span></span><br><span class="line">j++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 和大于0，则减少最右边的k</span></span><br><span class="line">k--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题的难度并不高，我们可以快速地实现这块代码。</p><p>与此同时，我们将更多的注意力放在了<strong>剪枝</strong>的情况，也就成为了最终算法是否高效的关键因素。在实际的工程中，<strong>剪枝</strong>是一个很重要的思想，我们经常要<strong>根据具体的数据特征进行策略调整</strong>。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-15-三数之和&quot;&gt;&lt;a href=&quot;#Leetcode-15-三数之和&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-15 三数之和&quot;&gt;&lt;/a&gt;Leetcode-15 三数之和&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/3sum/&quot;&gt;https://leetcode-cn.com/problems/3sum/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;threeSum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nums []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; [][]&lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 7.【盛最多水的容器LeetCode-11】</title>
    <link href="http://example.com/2021/08/02/go-leetcode/go-leetcode-7/"/>
    <id>http://example.com/2021/08/02/go-leetcode/go-leetcode-7/</id>
    <published>2021-08-02T04:00:00.000Z</published>
    <updated>2021-08-02T14:04:13.138Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-11-盛最多水的容器"><a href="#Leetcode-11-盛最多水的容器" class="headerlink" title="Leetcode-11 盛最多水的容器"></a>Leetcode-11 盛最多水的容器</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/container-with-most-water/">https://leetcode-cn.com/problems/container-with-most-water/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="基础解法"><a href="#基础解法" class="headerlink" title="基础解法"></a>基础解法</h2><h3 id="基本的递归"><a href="#基本的递归" class="headerlink" title="基本的递归"></a>基本的递归</h3><p>我们先通过递归来解一下这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(height) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(height) == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> height[<span class="number">0</span>] &gt; height[<span class="number">1</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> height[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> height[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右边固定为height[len(height) - 1]，左边不断移动，寻找最大的区域</span></span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(height) - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        right := height[<span class="built_in">len</span>(height) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> height[i] &lt; right &#123;</span><br><span class="line">            right = height[i]</span><br><span class="line">        &#125;</span><br><span class="line">        area := (<span class="built_in">len</span>(height) - <span class="number">1</span> - i) * right</span><br><span class="line">        <span class="keyword">if</span> area &gt; max &#123;</span><br><span class="line">            max = area</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// height去掉最右边的一个点，拆解为子问题</span></span><br><span class="line">    subArea := maxArea(height[:<span class="built_in">len</span>(height) - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> subArea &gt; max&#123;</span><br><span class="line">        <span class="keyword">return</span> subArea</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个代码的逻辑没有问题，但在线上执行的结果是<strong>超出了时间限制</strong>，也就是递归太深。</p><p>我们能否想个办法，做到<strong>减枝</strong>？我们尝试下将已经算出来的区域传递下去。</p><h3 id="利用减枝"><a href="#利用减枝" class="headerlink" title="利用减枝"></a>利用减枝</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 处理初始边界条件</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(height) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(height) == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">if</span> height[<span class="number">0</span>] &gt; height[<span class="number">1</span>] &#123;</span><br><span class="line"><span class="keyword">return</span> height[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> height[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxAreaWithAera(height, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxAreaWithAera</span><span class="params">(height []<span class="keyword">int</span>, area <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(height) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> area</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">right := height[<span class="built_in">len</span>(height)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> right != <span class="number">0</span> &#123;</span><br><span class="line">leftIndex := <span class="built_in">len</span>(height) - <span class="number">2</span></span><br><span class="line"><span class="comment">// 关键在于理解 len(height)-1-area/right，也就是左边至少从右边的边偏移area/right，才有可能大于area</span></span><br><span class="line"><span class="keyword">if</span> area != <span class="number">0</span> &amp;&amp; leftIndex &gt; <span class="built_in">len</span>(height)<span class="number">-1</span>-area/right &#123;</span><br><span class="line">leftIndex = <span class="built_in">len</span>(height) - <span class="number">1</span> - area/right</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// leftIndex往左偏移</span></span><br><span class="line"><span class="keyword">for</span> ; leftIndex &gt;= <span class="number">0</span>; leftIndex-- &#123;</span><br><span class="line">right := height[<span class="built_in">len</span>(height)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> height[leftIndex] &lt; right &#123;</span><br><span class="line">right = height[leftIndex]</span><br><span class="line">&#125;</span><br><span class="line">a := (<span class="built_in">len</span>(height) - <span class="number">1</span> - leftIndex) * right</span><br><span class="line"><span class="keyword">if</span> a &gt; area &#123;</span><br><span class="line">area = a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxAreaWithAera(height[:<span class="built_in">len</span>(height)<span class="number">-1</span>], area)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点就是<code>len(height)-1-area/right</code>这个值，这里利用了传递的<code>area</code>进行<strong>减枝</strong>。</p><h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><h3 id="梳理思路"><a href="#梳理思路" class="headerlink" title="梳理思路"></a>梳理思路</h3><p>我们跳出代码，来思考一下整个问题解决的宏观思路</p><ol><li>当左边与右边确定时，假设索引为<code>l1</code>和<code>r1</code>，区域大小是固定的<ol><li><code>area = min(height[l1], height[r1]) * (r1 - l1)</code></li></ol></li><li>接下来，我们要简化问题，也就是要将**[]height的左边界往右移或者右边界往左移**<ol><li>无论如何移动，<strong>x轴是不断缩小的</strong>，所以问题在于<code>左边界height[l2]</code>和右边界的高度<code>height[r2]</code></li><li><code>area2 = min(height[l2], height[r2]) * (r2 - l2)</code></li></ol></li><li><code>l2</code>和<code>r2</code>同时改变的话，整个计算方式就会很复杂，那我们就尝试固定其中一个不变，例如<ol><li><code>l1 = l2</code> 并且 <code>r1 &gt; r2</code>，即<strong>右边界往左移动</strong>，此时</li><li><code>area = min(height[l1], height[r1]) * (r1 - l1)</code></li><li><code>area2 = min(height[l1], height[r2]) * (r2 - l1)</code></li></ol></li><li>有什么办法可以对比<code>area</code>与<code>area2</code> 呢？<ol><li><code>r1 - l1 &gt; r2 - l1</code>可根据条件快速判断</li><li>核心在于对比 <code>min(height[l1], height[r1])</code> 和 <code>min(height[l1], height[r2])</code><ol><li>如果 <code>height[r1])</code> &gt;= <code>min(height[l1]</code>，也就是**[]height高度最右边最高于左边**，那么 <code>min(height[l1], height[r1])</code> &gt;=  <code>min(height[l1], height[r2])</code>成立，此时 area &gt;= area2 也必定成立</li><li>如果 <code>height[r1])</code> &lt; <code>min(height[l1]</code>，那么 area 与 area2 的关系没法判断</li></ol></li><li>归纳一下上面这个情况：就是<strong>当[]height高度最右边高于最左边时，移动右边面积肯定变小，移动左边面积变化未知</strong>。</li></ol></li><li>用更通用的说法就是，如果要找到[]height子集中更大的面积，<strong>固定较高边，移动较低边</strong>。在编程中，这种接法往往称为<strong>双指针</strong>。</li></ol><h3 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        <span class="keyword">var</span> area <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">if</span> height[left] &gt; height[right] &#123;</span><br><span class="line">            area = height[right] * (right - left)</span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            area = height[left] * (right - left)</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> area &gt; max &#123;</span><br><span class="line">            max = area</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双指针解法很简洁</strong>，但最重要的是推导过程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在编写代码的过程中，我们很难一步到位就写出最佳实现的解法，而前面的<strong>递归+减枝</strong>方法，虽然代码比较复杂，但是更符合我们直观逻辑的。<strong>双指针解法</strong>并不直观，这也就是体现出了刷题的价值。</p><p>值得一提的是，如果你上手就写出双指针解法，面试官会认为你是靠刷题记忆的，所以在面试算法的过程中，我们更应该关注<strong>解决问题的递进式思路</strong>，答案只是评价算法能力的其中一个重要项。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-11-盛最多水的容器&quot;&gt;&lt;a href=&quot;#Leetcode-11-盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-11 盛最多水的容器&quot;&gt;&lt;/a&gt;Leetcode-11 盛最多水的容器&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water/&quot;&gt;https://leetcode-cn.com/problems/container-with-most-water/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxArea&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(height []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 6.【正则表达式匹配LeetCode-10】</title>
    <link href="http://example.com/2021/07/28/go-leetcode/go-leetcode-6/"/>
    <id>http://example.com/2021/07/28/go-leetcode/go-leetcode-6/</id>
    <published>2021-07-28T04:00:00.000Z</published>
    <updated>2021-07-28T14:01:40.988Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-10-正则表达式匹配"><a href="#Leetcode-10-正则表达式匹配" class="headerlink" title="Leetcode-10 正则表达式匹配"></a>Leetcode-10 正则表达式匹配</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/regular-expression-matching/">https://leetcode-cn.com/problems/regular-expression-matching/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="基础解法"><a href="#基础解法" class="headerlink" title="基础解法"></a>基础解法</h2><p>我们先理一下正则匹配的大致思路：<strong>逐个对比s和p两个字符串，匹配则继续往后，发现不匹配直接退出</strong>。</p><p>那么，我们先简化一下问题，看看代码的大致结构：</p><h3 id="普通字符串匹配"><a href="#普通字符串匹配" class="headerlink" title="普通字符串匹配"></a>普通字符串匹配</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> || <span class="built_in">len</span>(p) == <span class="number">0</span> || s[<span class="number">0</span>] != p[<span class="number">0</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码思路很清晰，我们重点要解决的是两个通配符<code>.</code>和<code>*</code>：</p><h3 id="单个字符匹配"><a href="#单个字符匹配" class="headerlink" title="单个字符匹配"></a>单个字符匹配</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> || <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果p[0]为. ，则必定匹配</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] != p[<span class="number">0</span>] &amp;&amp; p[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配"><a href="#匹配" class="headerlink" title="*匹配"></a>*匹配</h2><p>接下来，我们就要解决最复杂的*匹配，也就是star符号。具体的解法我在下面给出，大家可以参考注释阅读：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 边界情况，即s为空，p前两个为 x*</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(p) &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> isMatch(s, p[<span class="number">2</span>:])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p是否为 x* 形式</span></span><br><span class="line"><span class="keyword">var</span> hasStar <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(p) &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">hasStar = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isMatch表示s与p的第一个字符是否匹配</span></span><br><span class="line"><span class="keyword">var</span> isMatched = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> s[<span class="number">0</span>] != p[<span class="number">0</span>] &amp;&amp; p[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">isMatched = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hasStar &#123;</span><br><span class="line"><span class="keyword">if</span> isMatched &#123;</span><br><span class="line"><span class="comment">// 情况1： 有星且第一个字符匹配，则递归包括2个情况：s去掉第一个字符，p去掉star这两个字符</span></span><br><span class="line"><span class="keyword">return</span> isMatch(s[<span class="number">1</span>:], p) || isMatch(s, p[<span class="number">2</span>:])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况2：有星且不匹配，则去掉p的前两个字符继续匹配</span></span><br><span class="line"><span class="keyword">return</span> isMatch(s, p[<span class="number">2</span>:])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !isMatched &#123;</span><br><span class="line"><span class="comment">// 情况3：没星且不匹配，则直接返回不匹配</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况4：没有星但是匹配，s和p删掉匹配的第一个字符，继续匹配</span></span><br><span class="line"><span class="keyword">return</span> isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解法虽然看过去复杂，但是比较直观，核心在于两个变量<code>hasStar</code>和<code>isMatch</code>，以及它们组合起来的四个情况。</p><h2 id="动态规划解"><a href="#动态规划解" class="headerlink" title="动态规划解"></a>动态规划解</h2><p>动态规划是一个面试高频的题，其核心是<strong>状态转移方程</strong>。这道题很符合动态规划的特征，我们通过了上面的递归解法，其实已经有了基本的思路：<strong>递归中的四种情况，其实就是状态转移方程的大致思路</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">row, col := <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp 就是核心的状态转移方程，这里注意要+1，是为了空字符串这个边界条件</span></span><br><span class="line"><span class="comment">// 所以后面的i/j默认都要-1</span></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, row+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, col+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充dp[0]数组，也就是s为空字符串</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; col+<span class="number">1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// p为空字符串的情况</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line"><span class="comment">// 如果p[j-1]为*，则可以认为匹配p和p[0:j-2]一样，类似于情况2</span></span><br><span class="line">dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-2</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充整个dp数组，注意i和j在dp中不变，但对应到字符串s/p中都要-1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; row+<span class="number">1</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; col+<span class="number">1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// 对应情况1，有星且第一个字符匹配</span></span><br><span class="line">dp[i][j] = dp[i][j<span class="number">-2</span>] || dp[i<span class="number">-1</span>][j]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 对应情况2，有星且不匹配</span></span><br><span class="line">dp[i][j] = dp[i][j<span class="number">-2</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// 对应情况4，没有星但是匹配</span></span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其余的对应情况3，没星且不匹配，即默认false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[row][col]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要有了递归解法的思路，动态规划的难度并不高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们又完成了一道hard级别的题目！</p><p>这道题，让我们看到了递归与动态规划存在共性。其中，递归解法的核心思路是<strong>将问题拆解为复杂度更低的子问题，直到边界情况</strong>，而动态规划解法的核心思路是<strong>从边界情况开始推导，从复杂度低的问题推导出复杂度更高的问题</strong>。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-10-正则表达式匹配&quot;&gt;&lt;a href=&quot;#Leetcode-10-正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-10 正则表达式匹配&quot;&gt;&lt;/a&gt;Leetcode-10 正则表达式匹配&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/regular-expression-matching/&quot;&gt;https://leetcode-cn.com/problems/regular-expression-matching/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isMatch&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(s &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;, p &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习路线 - 8.高级篇:从五个问题来畅想Go工程师的未来发展</title>
    <link href="http://example.com/2021/07/26/go-study/go-study-8/"/>
    <id>http://example.com/2021/07/26/go-study/go-study-8/</id>
    <published>2021-07-26T04:00:00.000Z</published>
    <updated>2021-07-26T05:10:11.322Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p><h2 id="编程语言对软件工程师的意义"><a href="#编程语言对软件工程师的意义" class="headerlink" title="编程语言对软件工程师的意义"></a>编程语言对软件工程师的意义</h2><p>有人常说，编程语言对软件工程师来说并不重要，更重要的是<strong>软件工程思想</strong>、<strong>架构设计能力</strong>等更高层面的内容。</p><p>这个观点本身没有问题，但它更多的是针对有相当工作经验的程序员。对于绝大多数的人，<strong>编程语言依然是最重要、最核心的技能，也是通往更高层面的敲门砖</strong>。所以，<strong>精通一门编程语言，不仅仅要熟悉其语法与原理，更要了解其周边的生态，包括框架、开源库、中间件等，以及掌握它适用的业务场景</strong>。</p><p>所以，作为一名将Go语言作为主要开发语言的工程师，如果你能合理地利用好这个敲门砖，你的职业发展必将更加通畅。下面，我会从几个常见问题谈起，分享我的经验与见解，希望能给各位带来启发。</p><span id="more"></span><h2 id="问题1：需要关注编程语言之争吗？"><a href="#问题1：需要关注编程语言之争吗？" class="headerlink" title="问题1：需要关注编程语言之争吗？"></a>问题1：需要关注编程语言之争吗？</h2><p>需要，而且非常有意义。但是，我们的精力毕竟有限，更应该关注哪些内容呢？我推荐三点：</p><ol><li><strong>编程语言常见特性的设计理念，能解决什么样的问题</strong>，如<code>try-catch</code></li><li><strong>编程范式所包含的思想</strong>，如<code>面向对象编程</code>、<code>函数式编程</code>、<code>依赖注入</code></li><li><strong>特定领域中语言的现状</strong>，如<code>Julia</code>在大数据体系中对<code>Java</code>的冲击</li></ol><p>上面这些例子是一些很发散的内容，但能证明你的<strong>视野足够广阔</strong>。不过，在关注编程语言之争的同时，我们仍应把主要精力聚焦于一门语言的深入学习，这才是我们的核心竞争力。</p><h2 id="问题2：Go语言工程师有什么其余语言无法替代的呢？"><a href="#问题2：Go语言工程师有什么其余语言无法替代的呢？" class="headerlink" title="问题2：Go语言工程师有什么其余语言无法替代的呢？"></a>问题2：Go语言工程师有什么其余语言无法替代的呢？</h2><p>说到一门语言的<strong>不可替代性</strong>，核心关注两点：</p><ol><li>现状：即<strong>一门语言在特定的领域中已沉淀的积累</strong>，包括开源软件、SDK库、文档、社区、用户等</li><li>未来：<strong>各公司或组织对这门语言的投入</strong>，如建立基金会、形成规范、招聘人才趋势等</li></ol><p>上面这两点，也间接地回答了一个很常见的问题：<code>Go</code>能替代<code>Java</code>成为主流业务开发语言吗？我个人短期内并不看好。</p><p>回到问题，那么Go最擅长的领域是什么呢？答案也是大家耳熟能详的<strong>云原生技术</strong>。</p><ol><li>现状：云原生的核心技术<code>Kubernetes</code>与大量相关套件都是用Go语言开发的，短期内无法被替换</li><li>未来：云原生在<code>CNCF</code>的推动下，已经在各类云厂商中形成事实标准</li></ol><h2 id="问题3：Go语法简洁，做业务开发很方便，可以用吗？"><a href="#问题3：Go语法简洁，做业务开发很方便，可以用吗？" class="headerlink" title="问题3：Go语法简洁，做业务开发很方便，可以用吗？"></a>问题3：Go语法简洁，做业务开发很方便，可以用吗？</h2><p>当然可以使用！Go语法简洁的特性能让代码更容易阅读，但我们要清楚地认识到其弊端，才能长期地坚持走这条路：</p><ol><li>由于不存在类似<code>Spring</code>的编程框架做强限制，不同人的代码风格差异还是很大，最好前期有个资深专家 <strong>做好前期框架规划</strong>，才能更好地体现Go的优势</li><li><strong>对接部分技术体系的开源库缺失或不够成熟</strong>，尤其是对接<code>Hive</code>、<code>Flink</code>等大数据体系时，<code>Java</code>仍是第一选择</li><li>Go的标准库中往往<strong>为了通用性而牺牲了定制化</strong>，例如排序函数采用的是一个工业级混合多种排序的方法，而无法灵活地按需选择冒泡、快排等，这就需要一定的二次开发</li></ol><p>也许你看完这三个问题，会觉得自己学Go语言的热情被劝退了，但其实换个角度来看问题，其实答案也很有意思：</p><ol><li>Go语言官方只做最基础的底层，而上层的业务框架由各家在实践中探索，发展空间很大</li><li>Google推出Go之后又推出的gRPC、云原生理念，就是希望编程语言百家齐鸣，各自有各自擅长的领域</li><li>一方面，通用性能降低编程语言学习的复杂度；另一方面，我们也是希望把一部分的复杂度从编程语言转移到各类中间件中，可以减少很多重复建设</li></ol><h2 id="问题4：从目前来看，Go业务开发工程师的前途不行吗？"><a href="#问题4：从目前来看，Go业务开发工程师的前途不行吗？" class="headerlink" title="问题4：从目前来看，Go业务开发工程师的前途不行吗？"></a>问题4：从目前来看，Go业务开发工程师的前途不行吗？</h2><p>综合上面讨论的问题来看，现有阶段用Go语言做业务开发并不是最快的。</p><p>但是，从目前<strong>云原生</strong>理念被越来越多的人接受，我相信Go语言做业务开发也是一个很棒的选择。这里，我强调一个点：<strong>借势</strong>。怎么理解这个词呢？</p><ol><li><strong>承认短板</strong>：既然需要”借”，那就先得承认自己有不足。如果幻想毕其功于一役，那这条路很容易走到尽头。</li><li><strong>善假于物</strong>：对于Go语言来说，借势的关键对象是两个：<strong>云原生</strong> 与 <strong>其余编程语言的生态</strong><ol><li>云原生：有大量优秀的基础组件与中间件，尽可能地复用这部分的能力（基本上覆盖了所有的基础设施）</li><li>其余编程语言：根据业务需要自行使用，建议在非熟悉的领域尽可能地做到简单，把复杂的业务逻辑放到最熟悉的编程语言中</li></ol></li></ol><p>上面聊的比较抽象，我再举两个具体的例子：</p><ol><li>对某个服务做网络的限流，更推荐放在<code>Istio</code>上，而不需要在应用程序中加上一堆计算流量的代码</li><li>某个Go服务想对接<code>Flink</code>计算业务数据，那就用利用JAVA的SDK开发一个对接的小服务，通过HTTP或MQ对外输出结果，而复杂的业务逻辑放在Go服务中</li></ol><h2 id="问题5：Go开发工程师的长期发展目标怎么定，才更有竞争力？"><a href="#问题5：Go开发工程师的长期发展目标怎么定，才更有竞争力？" class="headerlink" title="问题5：Go开发工程师的长期发展目标怎么定，才更有竞争力？"></a>问题5：Go开发工程师的长期发展目标怎么定，才更有竞争力？</h2><p>从能力层面来说，我认为Go语言工程师的核心技能点分为四层：</p><ol><li>基础层：计算机基础、网络、操作系统、算法</li><li>语言层：<strong>Go语言原理与实践</strong>，其它语言的优秀特性</li><li>应用层：中间件、软件工程、架构设计</li><li>业务层：业务逻辑、<strong>云原生生态与解决方案</strong></li></ol><blockquote><p>加粗的为Go语言特别关注</p></blockquote><p>这四层的内容极多，我建议围绕着两个重点进行学习：</p><ol><li><strong>系统性的学习Go语言原理与实践</strong>，向下即阅读源码，掌握操作系统、网络等基础原理；向上则结合项目，对接各类中间件，学习软件架构设计</li><li><strong>利用碎片时间了解云原生</strong>，云原生是一个日新月异的研发生态，对于非资深的开发者没必要前期就投入大量精力、导致基础不扎实，关注发展趋势、了解大致原理即可（技术的底层往往互通）</li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>整个Go语言学习路线到此已经更新完毕，很高兴有朋友陪我走到最后。后续我也会持续更新这个系列的文章，保证内容的实时性。</p><p>学习技术是一个长期的过程，敝帚自珍很容易中途失去信心而放弃，大家一起鼓励、探讨，就能走得更远。</p><p>欢迎大家私聊我探讨问题，也可以通过公众号加入到Go学习小组中交流更多日常问题。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;编程语言对软件工程师的意义&quot;&gt;&lt;a href=&quot;#编程语言对软件工程师的意义&quot; class=&quot;headerlink&quot; title=&quot;编程语言对软件工程师的意义&quot;&gt;&lt;/a&gt;编程语言对软件工程师的意义&lt;/h2&gt;&lt;p&gt;有人常说，编程语言对软件工程师来说并不重要，更重要的是&lt;strong&gt;软件工程思想&lt;/strong&gt;、&lt;strong&gt;架构设计能力&lt;/strong&gt;等更高层面的内容。&lt;/p&gt;
&lt;p&gt;这个观点本身没有问题，但它更多的是针对有相当工作经验的程序员。对于绝大多数的人，&lt;strong&gt;编程语言依然是最重要、最核心的技能，也是通往更高层面的敲门砖&lt;/strong&gt;。所以，&lt;strong&gt;精通一门编程语言，不仅仅要熟悉其语法与原理，更要了解其周边的生态，包括框架、开源库、中间件等，以及掌握它适用的业务场景&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以，作为一名将Go语言作为主要开发语言的工程师，如果你能合理地利用好这个敲门砖，你的职业发展必将更加通畅。下面，我会从几个常见问题谈起，分享我的经验与见解，希望能给各位带来启发。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习路线 - 7.进阶篇:一名软件工程师的价值沉淀</title>
    <link href="http://example.com/2021/07/25/go-study/go-study-7/"/>
    <id>http://example.com/2021/07/25/go-study/go-study-7/</id>
    <published>2021-07-25T04:00:00.000Z</published>
    <updated>2021-08-18T12:14:24.721Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p><h2 id="阶段性的思考"><a href="#阶段性的思考" class="headerlink" title="阶段性的思考"></a>阶段性的思考</h2><p>通过前面几讲的分享，相信大家已经能清楚地看到一名普通软件工程师的发展路线：<strong>不断学习技能，提高研发效能，实现业务功能</strong>。</p><p>如果我们尝试回头看，可能会对自己的定位存在疑问：这些日常CRUD的开发工作，很多不具备太高的技术难度，可以靠人力堆积来实现。那么，如何在研发团队里打造自己的<strong>技术壁垒</strong>、体现个人价值呢？</p><p>下面，我将分多个层面和大家聊聊，大家可以根据自己的发展目标和工作环境，选择性地发展几项。今天的内容会抛开编程语言之争，从更高的维度来看问题。</p><span id="more"></span><h2 id="1-专项业务领域"><a href="#1-专项业务领域" class="headerlink" title="1. 专项业务领域"></a>1. 专项业务领域</h2><p><strong>业务往往与公司的赢利点挂钩</strong>，决定了公司的生死存亡，所以业务驱动了公司里的很多事情，包括晋升、组织架构等。</p><p>大多数的开发者往往长期投入在公司的业务相关开发，或是满足产品的迭代，或是满足甲方的需求。从结果来看，业务开发是最容易看到成果的，可以与具体的增长和营收挂钩。那么，业务领域的开发者需要关注什么呢？我也列举三点</p><ul><li>产品设计 - 具备<strong>产品的规划与设计</strong>能力，将业务开发的经验沉淀为对产品的理解</li><li>业务架构 - 能将<strong>软件架构适配业务</strong>，也能根据公司的基础能力灵活调整</li><li>权衡能力 - <strong>权衡技术与业务的冲突</strong>，能保证业务快速实现的同时，尽可能地减少技术债</li></ul><h2 id="2-专项技术领域"><a href="#2-专项技术领域" class="headerlink" title="2. 专项技术领域"></a>2. 专项技术领域</h2><p>技术人常常期望能<strong>抛开烦杂的业务需求，长期在一个技术领域深耕</strong>，例如专职研究存储系统、网络架构、云原生架构、大数据引擎等。这里，我希望有此类想法的同学先想清楚一个问题：你究竟是厌倦了做需求迭代，还是真正喜欢某项技术？</p><p>深耕专项的技术领域，遇到的挑战很多，我列举三个比较重要的：</p><ul><li>评价产出 - 思考如何将<strong>技术变现</strong>，在公司中体现自己的<strong>能力价值</strong></li><li>承载业务 - <strong>对接并服务</strong>各个业务团队，根据具体场景做优化、适配等工作</li><li>探索前景 - <strong>紧跟并探索</strong>技术发展前景，方向准确，并长期坚持</li></ul><h2 id="3-团队领导力"><a href="#3-团队领导力" class="headerlink" title="3. 团队领导力"></a>3. 团队领导力</h2><p>合作与分工是所有团队都面临的问题。随着一名工程师的经验与资历的提升，都会直接或间接地带领团队去实现目标。</p><p>那怎么考验一个人的<strong>团队领导力</strong>呢？一般会更关注以下三点：</p><ul><li>能力提升 - 保证资深员工能有效地将<strong>经验与技能</strong>传递给新人，自身也有足够的发展空间</li><li>合理用人 - <strong>如何管理性格、能力各异的成员，尽可能实现产出最大化</strong></li><li>落地文化 - 一个团队如果要长久发展，必须得形成<strong>文化价值观</strong>，并聚拢一批认同这个价值观的成员</li></ul><h2 id="4-研发效能管理"><a href="#4-研发效能管理" class="headerlink" title="4. 研发效能管理"></a>4. 研发效能管理</h2><p>如今，<strong>软件工程日益精细化</strong>，公司越来越重视研发效能的管理，而非当初那种野蛮地堆人力、抢占市场。</p><p>研发效能的管理分为多个方向，例如：</p><ul><li>项目/需求/故障管理 - 用平台跟进项目进度、投入人力</li><li>CICD/devops - 各类自动化的工具平台，促进研发与运维一体化，让研发对整个生命周期负责</li><li>基础框架/库 - 加速研发对接日志、监控、部署等平台</li><li>流程平台化 - 将公司内的各种日常流程落地为平台</li></ul><h2 id="5-安全"><a href="#5-安全" class="headerlink" title="5. 安全"></a>5. 安全</h2><p>安全是一个很有意思的话题，大部分人的认知是：<strong>在没有问题时，安全一文不值；在出现问题后，安全又是至关重要的</strong>。</p><p>安全领域门槛很高，会有专属于自己的一个小圈子。绝大多数的开发者并不需要过多掌握安全相关的技能，只需了解一些常规的安全技能，在日常研发中有意识地加以重视：</p><ul><li>网络安全 - 常见的<code>HTTPS</code>、证书、<code>Sync Flooding</code>等</li><li>数据安全 - 加解密、备份</li><li>编程相关 - SQL注入、核心参数校验、审计功能</li></ul><h2 id="6-稳定性"><a href="#6-稳定性" class="headerlink" title="6. 稳定性"></a>6. 稳定性</h2><p>在项目投入生产使用后，<strong>稳定性</strong>逐渐成为一项重要指标，它与公司的营收直接相关。</p><p>在某个程度上，稳定性与安全非常类似，<strong>不出问题时，大家都不care稳定性，都想着快速迭代；出现问题后，又想法设法维持稳定</strong>。那如何体现一个人在稳定性上的能力呢？</p><ul><li>代码研发 - 从实际代码出发，保证核心功能的<strong>健壮性和可扩展性</strong></li><li>软件架构 - 软件架构稳定，既能保证<strong>功能迭代</strong>，也能随着规模扩大保证<strong>性能稳定</strong></li><li>工作流程 - 从功能迭代、需求上线、故障处理等流程出发，控制风险</li></ul><h2 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h2><p>以上六点，是作为开发者的价值点沉淀。我比较赞同一个观点：<strong>对公司的价值输出，决定了你的绩效；而对自己能力的沉淀，决定了你的市场价值</strong>。所以，绝大多数的人更应该把关注点放在自身的能力沉淀。</p><p>不过，我这边也针对一个极端的观点做一下修正：<strong>不要花太多心思在公司工作上，而是多提升自身能力。</strong></p><p>公司评定一个人包括两块：工作产出与自身能力。光有能力而没有足够产出，是可以让我们在当前岗位上表现达到中上，却很难让自己获得晋升、进而到一个更高的位置去锻炼自己。</p><p>个人能力毕竟有限，必须借助公司的力量，才能产出更大的价值；反之，如果你的产出全部依赖公司平台，也就是说脱离了平台你的价值大打折扣，那也是一个非常严重的问题。</p><p>我比较建议，在 <strong>保证自己能在当前岗位成为TOP10%的前提下，多多提升自己</strong>。</p><p>如果在工作中投入了100%的时间与精力，却依旧达不到TOP10%的业绩产出，这也是很多人遇到的问题。此时，我建议<strong>减少纯工作上的投入，多花时间提升个人能力</strong>。哪怕会在短期内会导致绩效的不如意，但能换来长期良好的职业发展。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本篇和大家聊了很多关于个人长期发展的话题，也探讨了个人与公司上的冲突问题。</p><p>如果用一句话总结，我会选择：<strong>软件工程师的价值沉淀是一个长期过程，核心是锻炼自身能力，也要借助公司的平台来帮助自己更快地成长</strong>。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;阶段性的思考&quot;&gt;&lt;a href=&quot;#阶段性的思考&quot; class=&quot;headerlink&quot; title=&quot;阶段性的思考&quot;&gt;&lt;/a&gt;阶段性的思考&lt;/h2&gt;&lt;p&gt;通过前面几讲的分享，相信大家已经能清楚地看到一名普通软件工程师的发展路线：&lt;strong&gt;不断学习技能，提高研发效能，实现业务功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果我们尝试回头看，可能会对自己的定位存在疑问：这些日常CRUD的开发工作，很多不具备太高的技术难度，可以靠人力堆积来实现。那么，如何在研发团队里打造自己的&lt;strong&gt;技术壁垒&lt;/strong&gt;、体现个人价值呢？&lt;/p&gt;
&lt;p&gt;下面，我将分多个层面和大家聊聊，大家可以根据自己的发展目标和工作环境，选择性地发展几项。今天的内容会抛开编程语言之争，从更高的维度来看问题。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习路线 - 6.提效篇:不懈地追求提升研发效率</title>
    <link href="http://example.com/2021/07/21/go-study/go-study-6/"/>
    <id>http://example.com/2021/07/21/go-study/go-study-6/</id>
    <published>2021-07-21T04:00:00.000Z</published>
    <updated>2021-07-26T05:10:50.464Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg" alt="Go-Study"></p><h2 id="为什么要追求研发效能"><a href="#为什么要追求研发效能" class="headerlink" title="为什么要追求研发效能"></a>为什么要追求研发效能</h2><p>在<strong>入门篇</strong>与<strong>基础篇</strong>之后，我选择做了这一讲<strong>提效篇</strong>。而在提效篇的推出之前，我也开启<a href="https://junedayday.github.io/tags/Go-Tip/">Go语言技巧系列</a>的更新，着重分享一些具体的工程化实例，包括错误处理、Go Module等。</p><p>也许有读者会好奇为什么会把提效篇放在这里，在我看来，<strong>如果工程师已经度过了入门阶段，就应该重点关注研发效能</strong>。</p><blockquote><p>严格意义来说，基础篇的<strong>分层思想</strong>，就是一个很有效的提升研发效能的手段。</p></blockquote><p><strong>研发效能</strong>涉及的面很广，但这里我们聚焦于讨论<strong>软件编码阶段</strong>的工作，专注于提升工程师在开发阶段的效率。</p><p>提升了研发效能后，我不太建议大家去<strong>主动接手更多的开发工作</strong>，而是<strong>投入到不断地学习和提升自己，持续提高效率，实现正反馈循环</strong>。至于投入到哪些方面更有价值，则是我今天分享的重点。</p><span id="more"></span><h2 id="培养意识是核心"><a href="#培养意识是核心" class="headerlink" title="培养意识是核心"></a>培养意识是核心</h2><p>我并不想直接聊提效的各种手段与方法，因为这些都是停留在 <strong>术</strong> 的阶段，大概率会随着时间变化而变化。那什么是 <strong>道</strong> 呢？我相信是工程师的思想意识。</p><p>举四个比较关键的点：</p><h3 id="保持一颗追求“偷懒”的心"><a href="#保持一颗追求“偷懒”的心" class="headerlink" title="保持一颗追求“偷懒”的心"></a>保持一颗追求“偷懒”的心</h3><p>提高效率的最大原动力是为了“偷懒”，这一点很容易理解。但难的是在重复性的日常工作下，我们如何能够抵抗住“混一天是一天”的躺平心态，想方设法地缩短现有的工作时间。</p><h3 id="对知识的开闭原则"><a href="#对知识的开闭原则" class="headerlink" title="对知识的开闭原则"></a>对知识的开闭原则</h3><p>软件工程里有开闭原则OCP，我们对待知识也要有一定的“开闭心态”：</p><ul><li><strong>开放 - 对待知识的初始心态要开放，海纳百川。</strong>要做到这一点很难，我们要抛开原有的观念，才能对有一个客观的认知。</li><li><strong>封闭 - 使用知识时前反复斟酌，考虑周全。</strong>要推广、实践一个技术点，不仅仅是技术本身的问题，还要考虑人员因素、团队现状、公司发展、投入产出比等现实性的问题。</li></ul><h3 id="原理决定选择，选择重于实现"><a href="#原理决定选择，选择重于实现" class="headerlink" title="原理决定选择，选择重于实现"></a>原理决定选择，选择重于实现</h3><p>如今，开源社区已经提供了各种现成工具，日常功能的实现已经基本没有技术瓶颈，这时更考验人的是如何适应后续的<strong>可扩展性</strong>。选择<code>MySQL</code>还是<code>ES</code>，选择 <code>官方sql库</code> 还是比较重量级的<code>GORM</code>库，都是很值得考量的点。</p><p><strong>不同选择代表着不同的发展方向</strong>，这个与我们的职业发展一样，一旦开了头，很难改变路线。所以，在做选择之前，我们要尽可能地了解背后的原理，根据自己的应用场景进行选择。</p><h3 id="脚踏实地，追求技术最优解"><a href="#脚踏实地，追求技术最优解" class="headerlink" title="脚踏实地，追求技术最优解"></a>脚踏实地，追求技术最优解</h3><p>技术人在<strong>面向业务编程时，常常会做技术上的妥协</strong>。固然，我们应脚踏实地从业务出发去做技术，但如果你对业务有了自己的理解，有了更优解，哪怕需要多几天的开发周期，你也应该尝试说服周围人，这样更能体现你的<strong>技术和业务的领导力</strong>。</p><h2 id="提效1-编程语言"><a href="#提效1-编程语言" class="headerlink" title="提效1 - 编程语言"></a>提效1 - 编程语言</h2><p>虽然这是一篇关于<code>Go</code>语言的学习路线，但我希望大家不要把目光局限于这一门语言。</p><p>比如，在日常开发、部署、故障排查的过程中，<code>Shell</code>是一个高频的工具；面对大数据处理场景时，用<code>Go</code>语言开发需要造大量轮子，远不如<code>Java</code>体系高度的成熟度；<code>Python</code>在做测试脚本的开发时颇具效率，也有大量的成熟的软件平台。</p><p><strong>对普通开发人员来说，逆主流是个大忌！</strong></p><h2 id="提效2-RPC框架"><a href="#提效2-RPC框架" class="headerlink" title="提效2 - RPC框架"></a>提效2 - RPC框架</h2><p>目前在开源社区中，最主流的RPC框架是<code>Gin</code>，可以通过<a href="https://github.com/gin-gonic/gin">链接</a>进行访问。如果你是一个初学者、公司也没有一个成熟的框架，那就毫不犹豫地选择这个吧！</p><p>同时，以<code>gRPC</code>为核心的<code>gRPC-Gateway</code>方案，是我比较推荐的进阶方案，相对<code>Gin</code>而言学习难度会高一些，大家可以通过这个<a href="https://github.com/grpc-ecosystem/grpc-gateway">链接</a>进行访问。它的优点是支持<code>http1.x</code>和<code>http2.0</code>，跨语言的解决方案<code>protobuffer</code>，以及大量的插件化工具（尤其是自动生成接口文档）。</p><p>最后，如果你所在的公司已有一个成熟的RPC框架，那就毫不犹豫地使用它吧！同时，你也可以学习<code>Gin</code>和<code>gRPC-Gateway</code>中优点，尝试往公司框架中贡献一些特性，提升自己的技术影响力。</p><blockquote><p>关于第二个gRPC-Gateway方案，后续我会在<strong>Go语言技巧系列</strong>中花几章进行介绍。</p></blockquote><h2 id="提效3-工具库"><a href="#提效3-工具库" class="headerlink" title="提效3 - 工具库"></a>提效3 - 工具库</h2><p><code>Go</code>语言在开源社区有广泛的现成工具库，但没有如<code>Spring</code>全家桶那般形成标准，往往需要我们自行挑选。</p><p>我们固然可以从百度中搜索出一个解决方案直接使用，也可以直接搜索一个使用率最高的库，但<strong>知其所以然</strong>更加重要。我非常建议大家在使用对应的工具库前，多花点时间学习底层原理，如使用<code>GORM</code>前先掌握<code>MySQL</code>的基础。</p><p>工具库这部分的学习是长期的工作，也是我后续分享的碎片知识点。</p><h2 id="提效4-IDE"><a href="#提效4-IDE" class="headerlink" title="提效4 - IDE"></a>提效4 - IDE</h2><p>我非常建议新手朋友使用<code>IDE</code>，也就是<code>Goland</code>。</p><p>虽然重度依赖IDE会带来限制，但往往利大于弊，例如：</p><ul><li>在内存中缓存数据，实现快速跳转</li><li><code>go fmt/goimports</code>等格式化代码的工具</li><li>引入<code>Golint</code>进行静态代码扫描</li><li><code>Refactor</code>重构等特性，在大型项目中很有价值</li><li>快速生成单元测试、接口、实现等</li><li>利用<code>Live Template</code>特性，给常用代码生成模板</li><li>断点调试</li></ul><p>如果你一上手就直接用<code>VSCode</code>、甚至<code>Vim</code>，你可能根本不清楚有这么多工具可以帮助你提升工程质量。当你熟练掌握后，就可以将这些特性作为插件引入到<code>VSCode</code>与<code>Vim</code>中。</p><h2 id="提效5-辅助工具"><a href="#提效5-辅助工具" class="headerlink" title="提效5 - 辅助工具"></a>提效5 - 辅助工具</h2><p>在日常研发时，有许多辅助性的工具，在特定场景带来意想不到的帮助，需要大家结合自己的场景选择：</p><ul><li>开发环境</li><li><code>git</code>命令与工作流</li><li><code>markdown</code>文档写作</li><li>个人任务管理</li><li><code>chrome/wireshark/postman</code>等网络相关工具</li><li><code>shell</code>排查性能问题</li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>提效是一个长期的工作，需要我们长期摸索前进。</p><p><strong>提效篇</strong>只是一个开始，更多的相关内容，我会放到 <a href="https://junedayday.github.io/tags/Go-Tip/">Go语言技巧系列</a> 里，欢迎大家持续关注。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/28/BnVH86E5owhsaFd.jpg&quot; alt=&quot;Go-Study&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么要追求研发效能&quot;&gt;&lt;a href=&quot;#为什么要追求研发效能&quot; class=&quot;headerlink&quot; title=&quot;为什么要追求研发效能&quot;&gt;&lt;/a&gt;为什么要追求研发效能&lt;/h2&gt;&lt;p&gt;在&lt;strong&gt;入门篇&lt;/strong&gt;与&lt;strong&gt;基础篇&lt;/strong&gt;之后，我选择做了这一讲&lt;strong&gt;提效篇&lt;/strong&gt;。而在提效篇的推出之前，我也开启&lt;a href=&quot;https://junedayday.github.io/tags/Go-Tip/&quot;&gt;Go语言技巧系列&lt;/a&gt;的更新，着重分享一些具体的工程化实例，包括错误处理、Go Module等。&lt;/p&gt;
&lt;p&gt;也许有读者会好奇为什么会把提效篇放在这里，在我看来，&lt;strong&gt;如果工程师已经度过了入门阶段，就应该重点关注研发效能&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;严格意义来说，基础篇的&lt;strong&gt;分层思想&lt;/strong&gt;，就是一个很有效的提升研发效能的手段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;研发效能&lt;/strong&gt;涉及的面很广，但这里我们聚焦于讨论&lt;strong&gt;软件编码阶段&lt;/strong&gt;的工作，专注于提升工程师在开发阶段的效率。&lt;/p&gt;
&lt;p&gt;提升了研发效能后，我不太建议大家去&lt;strong&gt;主动接手更多的开发工作&lt;/strong&gt;，而是&lt;strong&gt;投入到不断地学习和提升自己，持续提高效率，实现正反馈循环&lt;/strong&gt;。至于投入到哪些方面更有价值，则是我今天分享的重点。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Study" scheme="http://example.com/tags/Go-Study/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 4.【寻找两个正序数组的中位数LeetCode-4】</title>
    <link href="http://example.com/2021/07/19/go-leetcode/go-leetcode-4/"/>
    <id>http://example.com/2021/07/19/go-leetcode/go-leetcode-4/</id>
    <published>2021-07-19T04:00:00.000Z</published>
    <updated>2021-07-26T05:12:42.478Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-4-寻找两个正序数组的中位数"><a href="#Leetcode-4-寻找两个正序数组的中位数" class="headerlink" title="Leetcode-4 寻找两个正序数组的中位数"></a>Leetcode-4 寻找两个正序数组的中位数</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解这个题之前，我们要注意<strong>奇数和偶数</strong>的边界情况。</p><ul><li>奇数2n+1个，我们要取第n+1小的数</li><li>偶数2n个，我们要取第n和n+1小的数</li></ul><p>在Go语言中，因为是强类型的，切片<code>nums1</code>与<code>nums2</code>是整数，返回值则是浮点数</p><blockquote><p>这是我们遇到的第一道hard级别的题目，让我们一起尝试攻克它！</p></blockquote><span id="more"></span><h2 id="基本解法"><a href="#基本解法" class="headerlink" title="基本解法"></a>基本解法</h2><h3 id="常规思路1-逐个寻找"><a href="#常规思路1-逐个寻找" class="headerlink" title="常规思路1 - 逐个寻找"></a>常规思路1 - 逐个寻找</h3><p>常规思路来看，我们就是找第X小的数，那我们就一个一个找：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    length1, length2 := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="comment">// 注意，这里是向下取整</span></span><br><span class="line">    mid := (length1 + length2) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区分一下奇数与偶数，奇数为mid+1，偶数为mid/mid+1</span></span><br><span class="line">    <span class="comment">// 奇数为2n+1个，mid=n,这样下一个就是中位数</span></span><br><span class="line">    <span class="comment">// 偶数为2n个，mid=n，所以处理一下，让mid=n-1，这样接下来两个就是中位数</span></span><br><span class="line">    <span class="keyword">var</span> isOdd <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">if</span> (length1 + length2) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        isOdd = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mid =  mid - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> i1, i2 <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 移动两个索引i1与i2，找到最小的mid个</span></span><br><span class="line">    <span class="comment">// 关键是注意两个边界情况的判定</span></span><br><span class="line">    <span class="keyword">for</span> mid &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i1 &gt;= <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">            i2++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> i2 &gt;= <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">            i1++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i1] &gt; nums2[i2] &#123;</span><br><span class="line">            i2++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i1++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mid--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到mid后下一个</span></span><br><span class="line">    <span class="keyword">var</span> n1 <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> i1 &gt;= <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">        n1 = nums2[i2]</span><br><span class="line">        i2++</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> i2 &gt;= <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">        n1 = nums1[i1]</span><br><span class="line">        i1++</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i1] &gt; nums2[i2] &#123;</span><br><span class="line">        n1 = nums2[i2]</span><br><span class="line">        i2++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n1 = nums1[i1]</span><br><span class="line">        i1++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 奇数直接返回结果</span></span><br><span class="line">    <span class="keyword">if</span> isOdd &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(n1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偶数找到再下一个，再返回</span></span><br><span class="line">    <span class="keyword">var</span> n2 <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> i1 &gt;= <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">        n2 = nums2[i2]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> i2 &gt;= <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">        n2 = nums1[i1]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i1] &gt; nums2[i2] &#123;</span><br><span class="line">        n2 = nums2[i2]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n2 = nums1[i1]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(n1 + n2) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码很长，但性能不差，因为都是顺序的逻辑。</p><p>分析一下复杂度，空间复杂度是O(1)，时间复杂度为O(m+n)，其中m=len(nums1)，n=len(nums2)。</p><h3 id="常规思路2-排序后直接根据索引查找"><a href="#常规思路2-排序后直接根据索引查找" class="headerlink" title="常规思路2 - 排序后直接根据索引查找"></a>常规思路2 - 排序后直接根据索引查找</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="comment">// Go里面不支持对 []int 直接进行排序，必须通过 sort.IntSlice 做一次转化</span></span><br><span class="line">    <span class="keyword">var</span> intSlice sort.IntSlice</span><br><span class="line">    intSlice = <span class="built_in">append</span>(intSlice, nums1...)</span><br><span class="line">    intSlice = <span class="built_in">append</span>(intSlice, nums2...)</span><br><span class="line"></span><br><span class="line">    sort.Sort(intSlice)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(intSlice) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 注意这里的索引，切勿再+1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(intSlice[<span class="built_in">len</span>(intSlice) / <span class="number">2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(intSlice[<span class="built_in">len</span>(intSlice) / <span class="number">2</span> - <span class="number">1</span>] + intSlice[<span class="built_in">len</span>(intSlice) / <span class="number">2</span> ]) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我个人觉得Go语言里的排序函数<code>sort.Sort</code>对使用者的体验不是很好，尤其是对一些基础类型的支持。</p><p>这个解法的问题是对nums1和nums2进行了重新排序，没有充分利用nums1与nums2为<strong>有序数组</strong>这个条件。</p><h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><h3 id="递归的基本思路"><a href="#递归的基本思路" class="headerlink" title="递归的基本思路"></a>递归的基本思路</h3><p>我们注意到，这道题中给出的两个数组都是 <strong>已排序</strong> 的，所以可以利用<strong>数组的随机访问</strong>特性，做一定的加速。</p><p>这道题的问题是取中位数，但由于<strong>数组长度的奇偶性</strong>问题，这个中位数很难递归。所以，我们需要将问题做一个转化，实现<strong>找到第K小的数字</strong>，也就是下面的<code>findKthSortedArrays</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    length1, length2 := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="comment">// 奇数可以一步计算得出</span></span><br><span class="line">    <span class="keyword">if</span> (length1 + length2) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthSortedArrays(nums1, nums2, (length1 + length2) / <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 偶数的拆分为两个子问题</span></span><br><span class="line">    <span class="keyword">return</span> (findKthSortedArrays(nums1, nums2, (length1 + length2) / <span class="number">2</span>) +</span><br><span class="line">        findKthSortedArrays(nums1, nums2, (length1 + length2) / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    length1, length2 := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="comment">// 技巧1：保证nums1比nums2长，能减少下面很多条件的判断</span></span><br><span class="line">    <span class="keyword">if</span> length1 &lt; length2 &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthSortedArrays(nums2, nums1, k)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> length2 == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(nums1[k - <span class="number">1</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> k == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nums1[<span class="number">0</span>] &gt; nums2[<span class="number">0</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">float64</span>(nums2[<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(nums1[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们要保证i1和i2都要小于k，否则下面很难递归</span></span><br><span class="line">    i2 := k / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> i2 &gt; length2 &#123;</span><br><span class="line">      i2 = length2</span><br><span class="line">    &#125;</span><br><span class="line">    i1 := k - i2</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归的核心思路</span></span><br><span class="line">    <span class="keyword">if</span> nums1[i1 - <span class="number">1</span>] &lt; nums2[i2 - <span class="number">1</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthSortedArrays(nums1[i1:], nums2, k - i1)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i1 - <span class="number">1</span>] &gt; nums2[i2 - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthSortedArrays(nums1, nums2[i2:], k - i2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(nums1[i1 - <span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决这道题的难点在于3点：</p><ul><li>大量<strong>边界条件</strong>的编写，很容易发生遗漏导致运行失败</li><li>第n个数字转化为数组索引时，自带一个<code>-1</code>操作，在递归时容易混淆</li><li>递归的核心思路：<strong>将第k个元素转化为2个数组的索引之和，并保证不小于各自数组的长度</strong></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解决本题的难点在于大量的条件判断，存在大量<code>if-else</code>的代码，很容易让我们在编写代码时产生混乱，常常需要大量的调试。</p><p>我个人比较推荐用<strong>常规解法1</strong>这种笨办法来思路梳理，完整地处理好各种边界条件。接下来，再通过<strong>进阶解法</strong>来提升自己的抽象水平。</p><p>恭喜我们，正式解决了第一道困难的Leetcode！</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-4-寻找两个正序数组的中位数&quot;&gt;&lt;a href=&quot;#Leetcode-4-寻找两个正序数组的中位数&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-4 寻找两个正序数组的中位数&quot;&gt;&lt;/a&gt;Leetcode-4 寻找两个正序数组的中位数&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/median-of-two-sorted-arrays/&quot;&gt;https://leetcode-cn.com/problems/median-of-two-sorted-arrays/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;findMedianSortedArrays&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nums1 []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, nums2 []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;float64&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在解这个题之前，我们要注意&lt;strong&gt;奇数和偶数&lt;/strong&gt;的边界情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;奇数2n+1个，我们要取第n+1小的数&lt;/li&gt;
&lt;li&gt;偶数2n个，我们要取第n和n+1小的数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Go语言中，因为是强类型的，切片&lt;code&gt;nums1&lt;/code&gt;与&lt;code&gt;nums2&lt;/code&gt;是整数，返回值则是浮点数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是我们遇到的第一道hard级别的题目，让我们一起尝试攻克它！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 5.【最长回文子串LeetCode-5】</title>
    <link href="http://example.com/2021/07/19/go-leetcode/go-leetcode-5/"/>
    <id>http://example.com/2021/07/19/go-leetcode/go-leetcode-5/</id>
    <published>2021-07-19T04:00:00.000Z</published>
    <updated>2021-07-26T05:12:44.533Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-5-最长回文子串"><a href="#Leetcode-5-最长回文子串" class="headerlink" title="Leetcode-5 最长回文子串"></a>Leetcode-5 最长回文子串</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题中，我们也要注意<strong>奇数和偶数</strong>的边界情况。</p><span id="more"></span><h2 id="基本解法"><a href="#基本解法" class="headerlink" title="基本解法"></a>基本解法</h2><h3 id="枚举所有情况"><a href="#枚举所有情况" class="headerlink" title="枚举所有情况"></a>枚举所有情况</h3><p>刚拿到这道题时，我们很容易想到一个解法：</p><ul><li>枚举出s所有的子字符串</li><li>找到最长的回文串</li></ul><p>这个解法代码我就不专门写了，复杂度很高，但如果你想不到解决方案时，可以先写出这个解法，再逐步优化。</p><h3 id="利用递归拆分成子问题"><a href="#利用递归拆分成子问题" class="headerlink" title="利用递归拆分成子问题"></a>利用递归拆分成子问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找以s[0]为开头的最长回文子串</span></span><br><span class="line">    right := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> ; right &gt;= <span class="number">0</span>; right-- &#123;</span><br><span class="line">        <span class="comment">// 找到最长的回文子串就退出</span></span><br><span class="line">        <span class="keyword">if</span> isPalindrome(s[:right]) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用递归的方式获取s[1:]的长度，与上面的结果对比</span></span><br><span class="line">    subS := longestPalindrome(s[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(subS) &gt; right &#123;</span><br><span class="line">        <span class="keyword">return</span> subS</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[:right]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头尾两个指针不断往中间缩进</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果s长度为奇数，退出时刚好left=right，偶数则为 left &gt; right</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        <span class="keyword">if</span> s[left] != s[right] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        left++</span><br><span class="line">        right--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解法的代码思路相对清晰，核心思路是将 <strong>以s[0]开头的回文字符串</strong> 与 <strong>s[1:]中最长回文子串</strong> 进行对比，其中后者是递归的子问题。</p><p>在有一定的算法基础后，我个人比较喜欢先用 <strong>递归思路去简化问题</strong>，将代码拆分成子问题，能大量地简化代码。</p><h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><h3 id="利用对称点"><a href="#利用对称点" class="headerlink" title="利用对称点"></a>利用对称点</h3><p>从回文串的特点来看，它存在一个对称点：</p><ul><li>长度为奇数2n+1的字符串，对称点为第n+1个字符</li><li>长度为偶数2n的字符串，对称点为第n与n+1个字符之间，我们不妨命名为空白blank</li></ul><p>所以，我们就对字符串s进行遍历，查找它的<strong>每个对称点上最长的回文串</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> longest <span class="keyword">string</span></span><br><span class="line"><span class="comment">// 是否为空白</span></span><br><span class="line"><span class="comment">// 我们把字符串s看作为： s[0]-blank-s[1]-...-s[n-1]</span></span><br><span class="line"><span class="keyword">var</span> isBlank <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> mid <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> mid &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line"><span class="keyword">var</span> sub <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> isBlank &#123;</span><br><span class="line"><span class="comment">// 空白的话，我们认为这个空白是在mid-1和mid之间的，从两边开始对比</span></span><br><span class="line">sub = findLongestPalindromeByMid(s, mid<span class="number">-1</span>, mid)</span><br><span class="line">isBlank = <span class="literal">false</span></span><br><span class="line">mid++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 非空白的话，从索引mid的两边开始对比</span></span><br><span class="line">sub = findLongestPalindromeByMid(s, mid<span class="number">-1</span>, mid+<span class="number">1</span>)</span><br><span class="line">isBlank = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sub) &gt; <span class="built_in">len</span>(longest) &#123;</span><br><span class="line">longest = sub</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> longest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLongestPalindromeByMid</span><span class="params">(s <span class="keyword">string</span>, left, right <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="comment">// left和right就是两个指针，不断往两边移动，直到找到不相同的两个字符</span></span><br><span class="line"><span class="keyword">for</span> left &gt;= <span class="number">0</span> &amp;&amp; right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line"><span class="keyword">if</span> s[left] != s[right] &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">left--</span><br><span class="line">right++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里的索引，很容易搞混，我们要取的是left+1到right-1，这里切片后面的索引为right</span></span><br><span class="line"><span class="keyword">return</span> s[left+<span class="number">1</span> : right]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简化空白的处理"><a href="#简化空白的处理" class="headerlink" title="简化空白的处理"></a>简化空白的处理</h3><p>从上面的代码来看，空白的处理挺麻烦，我们可以直接从代码结构去优化。</p><p>大家可以仔细的阅读<code>isBlank</code>相关的代码，可以直接消除这个变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> longest <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> mid <span class="keyword">int</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> mid &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="comment">// 对称点为某个字符，长度为奇数</span></span><br><span class="line">        sub := findLongestPalindromeByMid(s, mid<span class="number">-1</span>, mid)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(sub) &gt; <span class="built_in">len</span>(longest) &#123;</span><br><span class="line">            longest = sub</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对称点为空白，长度为偶数</span></span><br><span class="line">        sub = findLongestPalindromeByMid(s, mid<span class="number">-1</span>, mid+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(sub) &gt; <span class="built_in">len</span>(longest) &#123;</span><br><span class="line">            longest = sub</span><br><span class="line">        &#125;</span><br><span class="line">        mid++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLongestPalindromeByMid</span><span class="params">(s <span class="keyword">string</span>, left, right <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> left &gt;= <span class="number">0</span> &amp;&amp; right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">if</span> s[left] != s[right] &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        left--</span><br><span class="line">        right++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s[left+<span class="number">1</span>:right]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划是算法中大量出现的一个解法，我们以这道题为例，进行探索。</p><blockquote><p>动态规划的细节请自行搜索，如 <a href="https://www.zhihu.com/question/39948290">https://www.zhihu.com/question/39948290</a> </p></blockquote><h3 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="comment">// 边界条件判断</span></span><br><span class="line">length := <span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回文子串至少为1，即单个字符</span></span><br><span class="line">begin, maxLen := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="comment">// 动态规划的关键数组dp</span></span><br><span class="line"><span class="keyword">var</span> dp = <span class="built_in">make</span>([][]<span class="keyword">bool</span>, length)</span><br><span class="line"><span class="keyword">for</span> k1 := <span class="keyword">range</span> dp &#123;</span><br><span class="line">dp[k1] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, length)</span><br><span class="line"><span class="keyword">for</span> k2 := <span class="keyword">range</span> dp[k1] &#123;</span><br><span class="line"><span class="comment">// 初始化均为false</span></span><br><span class="line">dp[k1][k2] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单个字符默认为回文串</span></span><br><span class="line">dp[k1][k1] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> size := <span class="number">2</span>; size &lt;= length; size++ &#123;</span><br><span class="line"><span class="keyword">for</span> start := <span class="number">0</span>; start &lt;= length-size; start++ &#123;</span><br><span class="line">end := start + size - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果首位字符串相同</span></span><br><span class="line"><span class="keyword">if</span> s[start] == s[end] &#123;</span><br><span class="line"><span class="keyword">if</span> size == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 边界情况，即只有2个字符且相等</span></span><br><span class="line">dp[start][end] = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 核心：动态规划的核心推导函数</span></span><br><span class="line">dp[start][end] = dp[start+<span class="number">1</span>][end<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新最长回文子串</span></span><br><span class="line"><span class="keyword">if</span> dp[start][end] &amp;&amp; size &gt; maxLen &#123;</span><br><span class="line">maxLen = size</span><br><span class="line">begin = start</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s[begin : begin+maxLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最核心的公式为<code>dp[start][end] = dp[start+1][end-1]</code>，其余都是对边界条件的处理。</p><p>但运行结果的效率偏低</p><ul><li>执行用时：104 ms, 在所有 Go 提交中击败了42.53%的用户</li><li>内存消耗：7 MB, 在所有 Go 提交中击败了24.68%的用户</li></ul><h3 id="优化1-优化条件分支"><a href="#优化1-优化条件分支" class="headerlink" title="优化1 优化条件分支"></a>优化1 优化条件分支</h3><p>我们分析一下上面的代码：从空间复杂度来看，动态规划的数组<code>dp</code>是不可或缺的，所以减少内存消耗比较困难了。</p><p>因此，我们把目光放在执行时间上，那么重点就是<code>for</code>循环里的代码复杂度。</p><p>我们注意到一个关键的变量<code>dp[start][end]</code>，对它进行改造</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">begin, maxLen := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> dp = <span class="built_in">make</span>([][]<span class="keyword">bool</span>, length)</span><br><span class="line"><span class="keyword">for</span> k1 := <span class="keyword">range</span> dp &#123;</span><br><span class="line">dp[k1] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, length)</span><br><span class="line"><span class="keyword">for</span> k2 := <span class="keyword">range</span> dp[k1] &#123;</span><br><span class="line">dp[k1][k2] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">dp[k1][k1] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> size := <span class="number">2</span>; size &lt;= length; size++ &#123;</span><br><span class="line"><span class="keyword">for</span> start := <span class="number">0</span>; start &lt;= length-size; start++ &#123;</span><br><span class="line">end := start + size - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s[start] == s[end] &#123;</span><br><span class="line"><span class="keyword">if</span> size == <span class="number">2</span> || dp[start+<span class="number">1</span>][end<span class="number">-1</span>] &#123;</span><br><span class="line">dp[start][end] = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 减少if-else的分支判断次数</span></span><br><span class="line"><span class="keyword">if</span> size &gt; maxLen &#123;</span><br><span class="line">maxLen = size</span><br><span class="line">begin = start</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s[begin : begin+maxLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果很明显，代码执行时间减少</p><ul><li>执行用时：72 ms, 在所有 Go 提交中击败了50.93%的用户</li><li>内存消耗：7 MB, 在所有 Go 提交中击败了28.37%的用户</li></ul><h3 id="优化2-分析循环内代码执行逻辑"><a href="#优化2-分析循环内代码执行逻辑" class="headerlink" title="优化2 分析循环内代码执行逻辑"></a>优化2 分析循环内代码执行逻辑</h3><p>我们继续看代码里的<code>size &gt; maxLen</code>条件，发现会出现如下情况：</p><ul><li>如果一个字符有多个相同<code>size</code>的回文子串，这个<code>if</code>内的语句会被执行多次</li><li>但我们只需要获得最长的回文子串之一，所以只需要记录第一次即可</li></ul><p>于是我们尝试改造：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">begin, maxLen := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> dp = <span class="built_in">make</span>([][]<span class="keyword">bool</span>, length)</span><br><span class="line"><span class="keyword">for</span> k1 := <span class="keyword">range</span> dp &#123;</span><br><span class="line">dp[k1] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, length)</span><br><span class="line"><span class="keyword">for</span> k2 := <span class="keyword">range</span> dp[k1] &#123;</span><br><span class="line">dp[k1][k2] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">dp[k1][k1] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> size := <span class="number">2</span>; size &lt;= length; size++ &#123;</span><br><span class="line"><span class="comment">// 用来表示对应size的字符串已经找到</span></span><br><span class="line">founded := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> start := <span class="number">0</span>; start &lt;= length-size; start++ &#123;</span><br><span class="line">end := start + size - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> s[start] == s[end] &#123;</span><br><span class="line"><span class="keyword">if</span> size == <span class="number">2</span> || dp[start+<span class="number">1</span>][end<span class="number">-1</span>] &#123;</span><br><span class="line">dp[start][end] = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 只记录第一个即可</span></span><br><span class="line"><span class="keyword">if</span> !founded &amp;&amp; size &gt; maxLen &#123;</span><br><span class="line">maxLen, begin = size, start</span><br><span class="line">founded = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s[begin : begin+maxLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行用时：80 ms, 在所有 Go 提交中击败了49.30%的用户</li><li>内存消耗：7 MB, 在所有 Go 提交中击败了31.54%的用户</li></ul><p>然而，执行结果告诉我们这部分的优化无明显效果，甚至还降低了评分。但我们无需沮丧，<strong>因为这道题针对的是小规模场景的算法题，这个思路可能在大规模的计算场景下带来很明显的提升</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Leetcode第五题的难度不高，也让我们初次接触了 <strong>动态规划</strong> 这个思路。</p><p>同时，我们也遇到了一个<strong>“失败的优化案例”</strong>。这也从侧面告诉了我们，<strong>抛开具体场景的优化都是不可靠的</strong>。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-5-最长回文子串&quot;&gt;&lt;a href=&quot;#Leetcode-5-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-5 最长回文子串&quot;&gt;&lt;/a&gt;Leetcode-5 最长回文子串&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-substring/&quot;&gt;https://leetcode-cn.com/problems/longest-palindromic-substring/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;longestPalindrome&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(s &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;string&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这道题中，我们也要注意&lt;strong&gt;奇数和偶数&lt;/strong&gt;的边界情况。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 3.【无重复字符的最长子串LeetCode-3】</title>
    <link href="http://example.com/2021/07/14/go-leetcode/go-leetcode-3/"/>
    <id>http://example.com/2021/07/14/go-leetcode/go-leetcode-3/</id>
    <published>2021-07-14T04:00:00.000Z</published>
    <updated>2021-07-26T05:12:39.412Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-3-无重复字符的最长子串"><a href="#Leetcode-3-无重复字符的最长子串" class="headerlink" title="Leetcode-3 无重复字符的最长子串"></a>Leetcode-3 无重复字符的最长子串</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="递归解题思路"><a href="#递归解题思路" class="headerlink" title="递归解题思路"></a>递归解题思路</h2><p>从函数签名<code>func lengthOfLongestSubstring(s string) int </code>来看，我们可以将问题拆分成子问题</p><ol><li>首字符<ol><li>包含s[0]的最长无重复子串</li><li>lengthOfLongestSubstring(s[1:n])</li></ol></li><li>尾字符<ol><li>lengthOfLongestSubstring(s[0:n-1])</li><li>包含s[n]的最长无重复子串</li></ol></li></ol><h3 id="利用首字符的递归问题"><a href="#利用首字符的递归问题" class="headerlink" title="利用首字符的递归问题"></a>利用首字符的递归问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// guard clauses，也就是卫语句，在递归中非常重要</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局的字符串，用于保存</span></span><br><span class="line">    <span class="keyword">var</span> mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := mp[s[i]]; ok &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// 找到重复的，直接退出</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mp[s[i]] = i <span class="comment">// 没找到重复的，加上这个子串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    length := lengthOfLongestSubstring(s[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">if</span> i &gt; length &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归的解法可读性较佳，但实际的时间复杂度会比较高，因为它的每一次 <strong>递归操作都要维护一个新的数据栈</strong>。</p><h2 id="非递归实现思路"><a href="#非递归实现思路" class="headerlink" title="非递归实现思路"></a>非递归实现思路</h2><h3 id="先用“笨办法”实现"><a href="#先用“笨办法”实现" class="headerlink" title="先用“笨办法”实现"></a>先用“笨办法”实现</h3><p>我们先不追求<strong>复杂度</strong>，先写一个简单的解法，搭建出解题框架：</p><p>从左往右看字符串s，如果我们限制了起始字符，然后逐个往右查找、找到第一个重复字符串，就是最长子串。</p><p>所以，如果s为<code>b1b2b3...bn</code>，它就能被拆解为 <strong>起始字符为<code>b1</code>，<code>b2</code>,<code>b3</code> …. <code>bn</code>这样n个子问题中的最大值</strong>。</p><p>于是，我们尝试写一下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 遍历s，以i作为起始点，找到最长的子串</span></span><br><span class="line">    <span class="comment">// 注意：在string中如果用range的方法遍历，类型不是byte，而是rune</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">        mp[s[i]] = i</span><br><span class="line">        <span class="comment">// j 作为一个从i往后移动的游标，找到第一个重复的词或者达到len(s)，也就是末尾</span></span><br><span class="line">        <span class="keyword">var</span> j <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(s); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> _, ok := mp[s[j]]; ok &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="comment">// 找到重复的，直接退出</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mp[s[j]] = j <span class="comment">// 没找到重复的，加上这个子串</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 算出以i为起点的最长子串</span></span><br><span class="line">        length := j - i</span><br><span class="line">        <span class="keyword">if</span> length &gt; max &#123;</span><br><span class="line">            max = length</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面存在一些边界条件的判定，需要大家认证思考。</p><h3 id="从核心map切入"><a href="#从核心map切入" class="headerlink" title="从核心map切入"></a>从核心map切入</h3><p>在上面的解法中，我们用到了一个<code>map[byte]int</code>，用来保存 <strong>字符与位置的映射关系</strong>。但在整个循环的过程中，我们反复地<code>var mp = make(map[byte]int)</code>创建了空间。</p><p>由于s是一个固定的字符串，我们可以换一个思路尝试，先写出一个纯过程式的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 全局的字符串，用于保存</span></span><br><span class="line">    <span class="keyword">var</span> mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="comment">// Case1: 这是一个暂时未出现过的字符</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := mp[s[i]]; !ok &#123;</span><br><span class="line">            length := i - left + <span class="number">1</span> <span class="comment">// 到最左边的距离</span></span><br><span class="line">            <span class="keyword">if</span> length &gt; max &#123;</span><br><span class="line">                max = length</span><br><span class="line">            &#125;</span><br><span class="line">            mp[s[i]] = i <span class="comment">// 不存在的新元素，直接添加进来</span></span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// 打断逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Case2: 这是一个出现过的重复字符</span></span><br><span class="line">        length := i - left + <span class="number">1</span> <span class="comment">// 到最左边的距离</span></span><br><span class="line">        length2 := i - mp[s[i]] <span class="comment">// 到上一个重复字符串的距离</span></span><br><span class="line">        <span class="keyword">if</span> length &gt; length2 &#123;</span><br><span class="line">            length = length2 <span class="comment">// 取较短值</span></span><br><span class="line">            left = mp[s[i]] + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> length &gt; max &#123;</span><br><span class="line">            max = length</span><br><span class="line">        &#125;</span><br><span class="line">        mp[s[i]] = i <span class="comment">// 更新索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理一下最后一个字符串</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) - left &gt; max &#123;</span><br><span class="line">        max = <span class="built_in">len</span>(s) - left </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码的关键实现在于<strong>两个索引index</strong>：</p><ol><li><code>i</code>，用于遍历s</li><li><code>left</code>，0 &lt;= left &lt;= i，s[left:i]是<strong>不存在重复字符的字符串</strong>，其中left尽量取最小。换一个说法，s[left:i]是<strong>以s[i]为右节点的、无重复的、最长的子字符串</strong>。</li></ol><p>我们再回头看一下上面的代码，可读性有不少改进空间，我们尝试做一下优化，让可读性更好：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        length := i - left + <span class="number">1</span> <span class="comment">// 到最左边的距离</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := mp[s[i]]; ok &#123;</span><br><span class="line">            length2 := i - mp[s[i]] <span class="comment">// 到上一个重复字符串的距离</span></span><br><span class="line">            <span class="keyword">if</span> length &gt; length2 &#123;</span><br><span class="line">                length = length2</span><br><span class="line">                left = mp[s[i]] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> length &gt; max &#123;</span><br><span class="line">            max = length</span><br><span class="line">        &#125;</span><br><span class="line">        mp[s[i]] = i </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) - left &gt; max &#123;</span><br><span class="line">        max = <span class="built_in">len</span>(s) - left </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改动点并不大，但抽离了不少共性的代码，整体的性能有所提升。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面对<strong>明显可用递归方案解决</strong>的题目时，个人比较推荐的解题思路是：</p><ul><li><strong>用递归的解决方案理清思路，写出一个可用的方案，此时不要关注性能</strong></li><li><strong>从复杂度的角度思考，哪部分的工作是重复性的，提取出一个非递归的方案</strong></li></ul><p>如果一开始就去抠所谓的最佳方案，很容易陷入细节问题，而丢失了全局视野。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-3-无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#Leetcode-3-无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-3 无重复字符的最长子串&quot;&gt;&lt;/a&gt;Leetcode-3 无重复字符的最长子串&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&quot;&gt;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lengthOfLongestSubstring&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(s &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 1.【两数相加LeetCode-2】递归解法</title>
    <link href="http://example.com/2021/07/10/go-leetcode/go-leetcode-1/"/>
    <id>http://example.com/2021/07/10/go-leetcode/go-leetcode-1/</id>
    <published>2021-07-10T04:00:00.000Z</published>
    <updated>2021-07-26T05:12:30.834Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-2-两数相加"><a href="#Leetcode-2-两数相加" class="headerlink" title="Leetcode-2 两数相加"></a>Leetcode-2 两数相加</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="keyword">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能保证代码都能执行，我会贴出所有代码，<strong>重点会用注释着重说明</strong>。</p><span id="more"></span><h2 id="递归实现的思路"><a href="#递归实现的思路" class="headerlink" title="递归实现的思路"></a>递归实现的思路</h2><h3 id="简化问题"><a href="#简化问题" class="headerlink" title="简化问题"></a>简化问题</h3><p>这道题的难点在于处理<strong>进位</strong>。那我们就先<strong>简化问题、把框架搭起来</strong>，看看先不考虑进位的大致代码怎么写的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// 先判断边界情况</span></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val</span><br><span class="line">        node.Next = addTwoNumbers(l1.Next, l2.Next)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val </span><br><span class="line">        node.Next = addTwoNumbers(l1.Next, l2)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val </span><br><span class="line">        node.Next = addTwoNumbers(l1, l2.Next)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这块代码有个问题- 当<code>l1</code>和<code>l2</code>都为空时，还会进入一次<code>addTwoNumbers</code>，导致最高位必定是0。</p><p>所以，我们需要保证<strong>最高位不要产生一个冗余，也就是l1和l2都为nil时，不要再进入addTwoNumbers函数</strong>。</p><h3 id="修复最高位的问题"><a href="#修复最高位的问题" class="headerlink" title="修复最高位的问题"></a>修复最高位的问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="comment">// 这里l1和l2作为指针传递下去</span></span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val </span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果都为空，无需继续处理</span></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续处理下一个节点</span></span><br><span class="line">    node.Next = addTwoNumbers(l1, l2)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归函数增加进位参数carry"><a href="#递归函数增加进位参数carry" class="headerlink" title="递归函数增加进位参数carry"></a>递归函数增加进位参数carry</h3><p>进位carry是一个在不同位中传递的参数，所以必须要加到函数签名中，所以我们得对递归函数进行改造。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的函数参数 carry</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val + carry</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + carry</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val + carry</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newCarry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> node.Val &gt; <span class="number">9</span> &#123;</span><br><span class="line">        node.Val = node.Val - <span class="number">10</span></span><br><span class="line">        newCarry = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; newCarry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, newCarry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="边界条件修复"><a href="#边界条件修复" class="headerlink" title="边界条件修复"></a>边界条件修复</h3><p>到了这里，我们看似完成了功能，但还有个边界条件没有修复：引入进位后，当<code>l1/l2</code>为nil，carry为1时，我们很容易就修复了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val + carry</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + carry</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val + carry</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        node.Val = carry <span class="comment">// 修复进位的边界问题</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newCarry <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> node.Val &gt; <span class="number">9</span> &#123;</span><br><span class="line">        node.Val = node.Val - <span class="number">10</span></span><br><span class="line">        newCarry = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; newCarry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, newCarry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="持续优化"><a href="#持续优化" class="headerlink" title="持续优化"></a>持续优化</h2><p>首先，先明确一下优化的原则：</p><p><strong>我并不是单纯地为了提升性能而去优化，而是更应该从全局入手，考虑代码的可读性和扩展性！</strong></p><p>所以，下面的优化并不一定是性能最优的，但或多或少可能让你感受到代码的迭代升级。</p><h3 id="A-复用变量"><a href="#A-复用变量" class="headerlink" title="A - 复用变量"></a>A - 复用变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val + carry</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + carry</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val + carry</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.Val = carry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node.Val &gt; <span class="number">9</span> &#123;</span><br><span class="line">        node.Val = node.Val - <span class="number">10</span></span><br><span class="line">        carry = <span class="number">1</span> <span class="comment">// 复用carry变量</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; carry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, carry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除<code>newCarry</code>变量，节省了内存。</p><p>虽然这点改进很小，但我想表达的重点是：<strong>大家不要小看变量的复用，尤其是在一些递归调用的场景下，能节省大量的空间。</strong>上面的<code>l1</code>与<code>l2</code>这两个指针也进行了变量的复用。</p><h3 id="B-增加位操作，去除if-else分支"><a href="#B-增加位操作，去除if-else分支" class="headerlink" title="B - 增加位操作，去除if-else分支"></a>B - 增加位操作，去除if-else分支</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + l2.Val + carry</span><br><span class="line">        l1, l2 = l1.Next, l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l1.Val + carry</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val = l2.Val + carry</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.Val = carry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> <span class="comment">// 引入位操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; carry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, carry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-增加代码的扩展性（推荐）"><a href="#C-增加代码的扩展性（推荐）" class="headerlink" title="C - 增加代码的扩展性（推荐）"></a>C - 增加代码的扩展性（推荐）</h3><p>在这个代码里，我们只支持2个<code>ListNode</code>的相加，就引入了4个<code>if-else</code>的分支，这就很难支持大量<code>ListNode</code>的扩展。</p><p><strong>总体来说，我个人推荐这个解法，它的思路很清晰，也不会出现边界问题。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val += l1.Val</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val += l2.Val</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Val += carry</span><br><span class="line">    carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> <span class="comment">// 引入位操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; carry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, carry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战化特性"><a href="#实战化特性" class="headerlink" title="实战化特性"></a>实战化特性</h2><p>在实际的项目中，我们会希望这个函数的扩展性能更好，例如支持多个输入参数。</p><h3 id="引入不定参数的特性"><a href="#引入不定参数的特性" class="headerlink" title="引入不定参数的特性"></a>引入不定参数的特性</h3><p>我们进一步改造成<strong>不定参数</strong>形式的函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(<span class="number">0</span>, l1, l2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不定参数必须是最后一个函数签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(carry <span class="keyword">int</span>, nodes ...*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">        <span class="keyword">if</span> nodes[k] != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val += nodes[k].Val</span><br><span class="line">            nodes[k] = nodes[k].Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Val += carry</span><br><span class="line">    carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> <span class="comment">// 引入位操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断所有node是否为空</span></span><br><span class="line">    <span class="keyword">var</span> isEnd = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">        <span class="keyword">if</span> nodes[k] != <span class="literal">nil</span> &#123;</span><br><span class="line">            isEnd = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> isEnd &amp;&amp; carry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(carry, nodes...)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-2-两数相加&quot;&gt;&lt;a href=&quot;#Leetcode-2-两数相加&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-2 两数相加&quot;&gt;&lt;/a&gt;Leetcode-2 两数相加&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers/&quot;&gt;https://leetcode-cn.com/problems/add-two-numbers/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; ListNode &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Val &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Next *ListNode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addTwoNumbers&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(l1 *ListNode, l2 *ListNode)&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;为了能保证代码都能执行，我会贴出所有代码，&lt;strong&gt;重点会用注释着重说明&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
</feed>
