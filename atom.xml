<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Junedayday Blog</title>
  
  <subtitle>六月天天的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-14T04:20:00.195Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Junedayday</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>技术阅读摘要 - 5.Go语言面试概述类问题</title>
    <link href="http://example.com/2022/08/07/readings/go-digest-5/"/>
    <id>http://example.com/2022/08/07/readings/go-digest-5/</id>
    <published>2022-08-07T04:00:00.000Z</published>
    <updated>2022-08-14T04:20:00.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>目前，Go语言在中国市场虽然蓬勃发展，但相较于JAVA语言的成熟面试体系，Go缺少了很多“八股文”性质的资料，出现了两个问题：</p><ol><li>对新手来说，知识很难体系化；</li><li>对面试者来说，遇到的问题千奇百怪，甚至面试官之间的答案也不一样</li></ol><p>那么，我将挑选五个概述类的问题，并给出我的思考，希望能对大家带来帮助。</p><span id="more"></span><h2 id="1-谈谈你对Go语言的错误处理的思考"><a href="#1-谈谈你对Go语言的错误处理的思考" class="headerlink" title="1.谈谈你对Go语言的错误处理的思考"></a>1.谈谈你对Go语言的错误处理的思考</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在谈论这个话题前，我们最好先掌握两个知识点：</p><ol><li>了解以JAVA体系为代表的try-catch模式的错误处理方式</li><li>Go语言error封装的常见技巧</li></ol><p>我们的回答先围绕这两个点展开：</p><ol><li>Go语言对错误处理的设计是偏向于过程性的。虽然会牺牲一定的简洁性、增加代码冗余，但在阅读代码时，我们能明确地知道，错误是在方法的哪一行产生的；</li><li>推荐使用<code>github.com/pkg/errors</code>这个Go官方推荐的库（具体方法可以参考 <a href="https://junedayday.github.io/2021/05/07/go-tip/go-tip-3/">我的博客</a>）。简单来说，将错误进行堆栈化，丰富错误所包含的信息。</li></ol><p>关于这个问题，你要谈到的三个关键点是：</p><ol><li>error处理的代码会导致冗余，牺牲一定的简洁性，但阅读者可以清晰地看到错误产生的源头；</li><li>熟悉对error处理的技巧，如<code>bufio.Scanner</code>将error封装到结构体中；</li><li>官方思路 - 以<code>github.com/pkg/errors</code>为代表的，将error进行堆栈化处理；</li></ol><h2 id="2-谈谈你对Go程序故障的排查心得"><a href="#2-谈谈你对Go程序故障的排查心得" class="headerlink" title="2.谈谈你对Go程序故障的排查心得"></a>2.谈谈你对Go程序故障的排查心得</h2><p>线下问题相对简单，可以通过 <strong>单元测试</strong> 或者 <strong>代码调试</strong> 的手段进行排查。</p><p>我们讨论的重点是线上程序，我将思路分为3类：</p><ol><li>可观测性：重点是监控指标metrics与链路追踪tracing</li><li>Go语言自带的pprof：主要用来分析复杂的程序瓶颈</li><li>操作系统层面的工具：包括CPU、磁盘、网络等，如tracert、tcpdump等</li></ol><p>一般情况下，第1类成本最低，能解决绝大部分的问题，是稳定性重点建设的目标。</p><h2 id="3-你认为Go语言的弊端有什么？"><a href="#3-你认为Go语言的弊端有什么？" class="headerlink" title="3.你认为Go语言的弊端有什么？"></a>3.你认为Go语言的弊端有什么？</h2><p>我将从小到大、谈谈Go语言的三个问题（主要与JAVA进行对比）：</p><ol><li>基础库：基础库提供的能力比较受限，这就导致大量各异的轮子被发明出来，很难统一；</li><li>代码风格：风格迥异，如新手容易写出过程性的代码，资深人员会写出面向接口、高度抽象的代码；</li><li>编程框架：业界没有统一的Go框架，框架间思路也差异很大；</li></ol><p>总体来说，Go现状依然是百家齐鸣。这对语言的丰富性来说是个好事，但对工程项目来说，很难统一约束，<strong>多样性会导致可维护性变差</strong>。</p><h2 id="4-如何体现你的Go语言水平"><a href="#4-如何体现你的Go语言水平" class="headerlink" title="4.如何体现你的Go语言水平"></a>4.如何体现你的Go语言水平</h2><p>展示Go语言的能力发展分为两个方向：底层与上层。</p><p>底层能力包括：源码理解、GMP、性能问题、runtime、编译器等方向，体现出了计算机基础功底。一般来说，在底层这块进一步深钻的话，技术栈需要重点扩充操作系统与网络方向，而编程语言上也需要有一定C++的能力。</p><p>上层能力又可以区分为两块：工程化能力与特定业务领域的能力。通俗点说，工程化是怎么写出可维护的、优雅的Go代码，考验的是经验与基本功；特定业务领域能力则是掌握怎么用Go语言的特性或者特定库，去解决对应的领域问题，如云原生、区块链。</p><h2 id="5-什么样的项目适合用Go语言开发"><a href="#5-什么样的项目适合用Go语言开发" class="headerlink" title="5.什么样的项目适合用Go语言开发"></a>5.什么样的项目适合用Go语言开发</h2><p>单从语言来看，任何一门语言都具备可替代性。那么Go语言的核心竞争力是什么呢？我看重的是两点；<strong>业务生态与语言特性</strong>，其中生态的重要性远超语言特性。</p><p>先聊一下业务生态。成熟的生态会沉淀相关的工具或现成库，大幅度减少开发成本，逆主流的语言意味着重建生态。比如说，Kubernetes沉淀了Go相关的大量插件与工具，区块链领域也基本都是Go语言的天下。</p><p>在没有绝对统治力的生态下、或者重建生态的成本很低，语言自身的特性才有参考价值。比如在devops领域，常见的有Python、Go、PHP，以及少量的JAVA。这时，Go语言以学习成本低、高性能等因素，脱颖而出，成为首选。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文和大家聊了5个Go语言概述类问题，它们相对于底层问题更容易快速记忆。</p><p>希望能为大家在学习Go语言的过程中带来启发，也可以帮助大家在面试的回答中展现出亮点。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;目前，Go语言在中国市场虽然蓬勃发展，但相较于JAVA语言的成熟面试体系，Go缺少了很多“八股文”性质的资料，出现了两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对新手来说，知识很难体系化；&lt;/li&gt;
&lt;li&gt;对面试者来说，遇到的问题千奇百怪，甚至面试官之间的答案也不一样&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么，我将挑选五个概述类的问题，并给出我的思考，希望能对大家带来帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Digest" scheme="http://example.com/tags/Digest/"/>
    
  </entry>
  
  <entry>
    <title>etcd源码分析 - 5.【打通核心流程】EtcdServer消息的处理函数</title>
    <link href="http://example.com/2022/07/25/etcd/etcd-5/"/>
    <id>http://example.com/2022/07/25/etcd/etcd-5/</id>
    <published>2022-07-25T04:00:00.000Z</published>
    <updated>2022-07-26T02:45:32.730Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg"></p><p>在上一讲，我们梳理了<code>EtcdServer</code>的关键函数<code>processInternalRaftRequestOnce</code>里的四个细节。</p><p>其中，<code>wait.Wait</code>组件使用里，我们还遗留了一个细节实现，也就是请求的处理结果是怎么通过channel返回的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="comment">// 正常消息的返回，也就是我们本章要研究的</span></span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line"><span class="keyword">return</span> x.(*applyResult), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-cctx.Done():</span><br><span class="line">proposalsFailed.Inc()</span><br><span class="line">s.w.Trigger(id, <span class="literal">nil</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, s.parseProposeCtxErr(cctx.Err(), start)</span><br><span class="line"><span class="keyword">case</span> &lt;-s.done:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrStopped</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="明确问题与思路"><a href="#明确问题与思路" class="headerlink" title="明确问题与思路"></a>明确问题与思路</h2><p>我们回顾上节的问题，我们就是要找到下面两处操作的代码：</p><ol><li>往<code>ch</code>这个channel里发送了一个<code>*applyResult</code>结构的消息</li><li>对wait进行了Trigger操作</li></ol><p>常见思路分为两种：</p><ol><li>顺序思维 - 也就是自顶向下阅读代码，主要是找到调用的入口</li><li>逆向思维 - 通过IDE的代码跳转功能，查找关键函数的调用处，再向上找到对应的调用栈</li></ol><p>顺序思维不是一种源码阅读的常见行为，毕竟这需要我们非常了解源码的结构；而逆向思维，是我们快速定位到对应代码的最常见手段。</p><p>而为了加深对代码的理解，通常会采用 <strong>先逆向、理清代码调用逻辑，后顺序、理解代码层级设计</strong> 这样的两轮阅读。我们就针对今天的case来看看。</p><h2 id="逆向阅读-调用逻辑"><a href="#逆向阅读-调用逻辑" class="headerlink" title="逆向阅读 - 调用逻辑"></a>逆向阅读 - 调用逻辑</h2><h3 id="Trigger的调用"><a href="#Trigger的调用" class="headerlink" title="Trigger的调用"></a>Trigger的调用</h3><p>我们利用IDE，可以查到所有的Trigger调用代码，共计10处，可以先根据文件名快速理解：</p><ul><li>7处 <code>server.go</code> - 通用server部分</li><li>1处 <code>v2_server.go</code> - 针对v2版本协议</li><li>2处 <code>v3_server.go</code> - 针对v3版本协议（即我们阅读的<code>processInternalRaftRequestOnce</code>函数）</li></ul><p>于是，我们就跳转到<code> server.go</code>，查看这7个调用函数：</p><ul><li><p>configure - 2个Tigger</p><ul><li>配置相关，直接忽略</li></ul></li><li><p>apply - 1个Tigger</p><ul><li>发送的数据结构不为<code>*applyResult</code>，忽略</li></ul></li><li><p>applyEntryNormal - 4个Tigger</p><ul><li>前两个为V2版本</li><li>后两个为V3版本</li></ul></li></ul><p>确定了入口函数为<code>applyEntryNormal</code>，我们接下来就是去用IDE查找调用逻辑，不断跳转，查找它的调用栈了。</p><h3 id="调用栈分析"><a href="#调用栈分析" class="headerlink" title="调用栈分析"></a>调用栈分析</h3><ol><li>applyEntryNormal</li><li>apply</li><li>applyEntries</li><li>applyAll</li><li>run</li><li>start</li><li>Start</li><li>StartEtcd</li></ol><blockquote><p>序号越小，表示越底层</p></blockquote><p>这一块的代码跳转非常顺利，每一个方法基本都只有一个被调用方，我们可以快速地逐层查找，直到<code>main()</code>函数。接着，我们开始顺序阅读代码的过程。</p><h2 id="顺序阅读-代码设计"><a href="#顺序阅读-代码设计" class="headerlink" title="顺序阅读 - 代码设计"></a>顺序阅读 - 代码设计</h2><p><code>start</code>之前的方法很简单，我们直接从<code>run</code>方法开始看。</p><h3 id="EtcdServer-run"><a href="#EtcdServer-run" class="headerlink" title="(*EtcdServer) run()"></a>(*EtcdServer) run()</h3><p><code>run()</code>函数可以拆分为两部分，而关键的分界线是<code>go</code>语言里经典的<code>for+select</code>语法。在一个常驻的进程中，例如服务器，<code>for+select</code>是一个非常优雅的实现，里面的每一个case都是一种处理逻辑，类似IO复用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// 正常消息</span></span><br><span class="line">    <span class="keyword">case</span> ap := &lt;-s.r.apply():</span><br><span class="line">    <span class="comment">// 超时租约</span></span><br><span class="line">    <span class="keyword">case</span> leases := &lt;-expiredLeaseC:</span><br><span class="line">    <span class="comment">// 错误信号</span></span><br><span class="line">    <span class="keyword">case</span> err := &lt;-s.errorc:</span><br><span class="line">    <span class="comment">// 定时器</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-getSyncC():</span><br><span class="line">    <span class="comment">// 停止信号</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-s.stop:</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这种使用方法，有一个重点需要注意：<strong>每一个case中的处理耗时要尽可能地少（除了退出），这样才能保证程序的性能。</strong>尤其是对常见请求的处理，例如示例中的正常消息，要尽可能地短。</p><blockquote><p>缩短单个case的处理耗时有两种思路：性能优化 或 异步化。</p><p>后者看似很简单，比如开启一个goroutine，但很有可能破坏程序数据的一致性，需要慎重。</p></blockquote><p>正常消息的处理代码很短，即两行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行功能的函数，关键实现为applyAll，即下一层要看的代码</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(context.Context)</span></span> &#123; s.applyAll(&amp;ep, &amp;ap) &#125;</span><br><span class="line"><span class="comment">// sched是一个先入先出的调度方法，而Schedule只是把这个执行函数追加进去</span></span><br><span class="line"><span class="comment">// 这部分真正的执行在另一处，即出队列的地方，暂时无需关心</span></span><br><span class="line">sched.Schedule(f)</span><br></pre></td></tr></table></figure><h3 id="（-EtcdServer-applyAll"><a href="#（-EtcdServer-applyAll" class="headerlink" title="（*EtcdServer) applyAll()"></a>（*EtcdServer) applyAll()</h3><p>通过<code>applyEntries()</code>函数，将每一项<code>entry</code>应用到<code>etcd</code>服务上。</p><h3 id="EtcdServer-applyEntries"><a href="#EtcdServer-applyEntries" class="headerlink" title="(*EtcdServer) applyEntries()"></a>(*EtcdServer) applyEntries()</h3><p>通过<code>apply()</code>应用entry，这里有3个返回值：</p><ul><li>term - 轮次，这是raft协议相关</li><li>index - 索引</li><li>shouldstop - 是否停止</li></ul><h3 id="EtcdServer-apply"><a href="#EtcdServer-apply" class="headerlink" title="(*EtcdServer) apply()"></a>(*EtcdServer) apply()</h3><p>apply将多个entries进行处理，核心代码结构整理如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐个处理entries</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> es &#123;</span><br><span class="line">  e := es[i]</span><br><span class="line">  <span class="keyword">switch</span> e.Type &#123;</span><br><span class="line">    <span class="comment">// 常规消息</span></span><br><span class="line">    <span class="keyword">case</span> raftpb.EntryNormal:</span><br><span class="line">    <span class="comment">// 配置变更</span></span><br><span class="line">    <span class="keyword">case</span> raftpb.EntryConfChange:</span><br><span class="line">    <span class="comment">// 异常情况</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而常规消息里的三步处理也很容易理解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用普通entry的地方</span></span><br><span class="line">s.applyEntryNormal(&amp;e)</span><br><span class="line"><span class="comment">// 设置applied的索引位置，表示已经被应用</span></span><br><span class="line">s.setAppliedIndex(e.Index)</span><br><span class="line"><span class="comment">// 设置轮次term信息</span></span><br><span class="line">s.setTerm(e.Term)</span><br></pre></td></tr></table></figure><h3 id="EtcdServer-applyEntryNormal"><a href="#EtcdServer-applyEntryNormal" class="headerlink" title="(*EtcdServer) applyEntryNormal()"></a>(*EtcdServer) applyEntryNormal()</h3><p>整个函数比较长，但核心处理逻辑只有如下两块内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理raft请求，将结果返回到 *applyResult 中</span></span><br><span class="line"><span class="keyword">var</span> ar *applyResult</span><br><span class="line">needResult := s.w.IsRegistered(id)</span><br><span class="line"><span class="keyword">if</span> needResult || !noSideEffect(&amp;raftReq) &#123;</span><br><span class="line">  <span class="keyword">if</span> !needResult &amp;&amp; raftReq.Txn != <span class="literal">nil</span> &#123;</span><br><span class="line">    removeNeedlessRangeReqs(raftReq.Txn)</span><br><span class="line">  &#125;</span><br><span class="line">  ar = s.applyV3.Apply(&amp;raftReq)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用Trigger触发wait.Wait组件，将 *applyResult 发送出去</span></span><br><span class="line">s.goAttach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := &amp;pb.AlarmRequest&#123;</span><br><span class="line">    MemberID: <span class="keyword">uint64</span>(s.ID()),</span><br><span class="line">    Action:   pb.AlarmRequest_ACTIVATE,</span><br><span class="line">    Alarm:    pb.AlarmType_NOSPACE,</span><br><span class="line">  &#125;</span><br><span class="line">  s.raftRequest(s.ctx, pb.InternalRaftRequest&#123;Alarm: a&#125;)</span><br><span class="line">  s.w.Trigger(id, ar)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇重点是分享一种常见的阅读代码方式：<strong>自底向上</strong>+<strong>自顶向下</strong>。在阅读了EtcdServer处理请求后，将结果通过channel发送出去的整个逻辑，相关代码的调用链路见下图。</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd-4.png"></p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一讲，我们梳理了&lt;code&gt;EtcdServer&lt;/code&gt;的关键函数&lt;code&gt;processInternalRaftRequestOnce&lt;/code&gt;里的四个细节。&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;wait.Wait&lt;/code&gt;组件使用里，我们还遗留了一个细节实现，也就是请求的处理结果是怎么通过channel返回的。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 正常消息的返回，也就是我们本章要研究的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; x := &amp;lt;-ch:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x.(*applyResult), &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &amp;lt;-cctx.Done():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		proposalsFailed.Inc()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		s.w.Trigger(id, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, s.parseProposeCtxErr(cctx.Err(), start)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &amp;lt;-s.done:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, ErrStopped&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-etcd" scheme="http://example.com/tags/Go-etcd/"/>
    
  </entry>
  
  <entry>
    <title>etcd源码分析 - 4.【打通核心流程】processInternalRaftRequestOnce四个细节</title>
    <link href="http://example.com/2022/07/12/etcd/etcd-4/"/>
    <id>http://example.com/2022/07/12/etcd/etcd-4/</id>
    <published>2022-07-12T04:00:00.000Z</published>
    <updated>2022-07-14T05:46:26.285Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg"></p><p>在上一讲，我们继续梳理了<code>PUT</code>请求到<code>EtcdServer</code>这一层的逻辑，并大概阅读了其中的关键函数<code>processInternalRaftRequestOnce</code>。</p><p>这个方法里面有不少细节，我们今天就选择其中有价值的四点来看看。</p><span id="more"></span><h3 id="1-entry索引-appliedIndex与committedIndex"><a href="#1-entry索引-appliedIndex与committedIndex" class="headerlink" title="1. entry索引 - appliedIndex与committedIndex"></a>1. entry索引 - appliedIndex与committedIndex</h3><p>在etcd中，我们将每个客户端的操作（如PUT）抽象为一个日志项（entry）。如果这个操作生效，etcd就将这个entry项同步给其它etcd server，作为数据同步。</p><p>操作有顺序之分，于是服务端就保存了一个长entry数组，用一个关键的索引index来进行区分entry数组（即一个分界的标志），对entry状态进行分类：</p><ul><li>entry处于状态A - 小于等于索引的entry项</li><li>entry处于状态B - 大于索引的entry项</li></ul><blockquote><p>一般状态A和B都是互补的，即是一种二分类状态。</p></blockquote><p>而由于分布式的特性，entry不能立刻完成执行的，于是这里就区分出了两种状态，它们复用一个entry数组：</p><ul><li>已应用 - applied</li><li>已提交 - committed</li></ul><p>对应索引<code>appliedIndex</code>与<code>committedIndex</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数用atomic保证原子性</span></span><br><span class="line">ai := s.getAppliedIndex()</span><br><span class="line">ci := s.getCommittedIndex()</span><br><span class="line"><span class="comment">// 两者的差值，表示已应用但是未提交的entry数，不能太多</span></span><br><span class="line"><span class="keyword">if</span> ci &gt; ai+maxGapBetweenApplyAndCommitIndex &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>, ErrTooManyRequests</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>entry数组中的索引的一致性非常重要，尤其是在并发的场景下。而示例中的原子操作，其实是一种乐观锁的实现。</p><blockquote><p>更多的细节就涉及到分布式相关了，这里就不展开。</p></blockquote><h3 id="2-id生成器-idutil-Generator"><a href="#2-id生成器-idutil-Generator" class="headerlink" title="2.id生成器 - idutil.Generator"></a>2.id生成器 - idutil.Generator</h3><p><code>Generator</code>数据结构不复杂，它的设计详情都放在了备注里，我们可以自行阅读：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator generates unique identifiers based on counters, timestamps, and</span></span><br><span class="line"><span class="comment">// a node member ID.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The initial id is in this format:</span></span><br><span class="line"><span class="comment">// High order 2 bytes are from memberID, next 5 bytes are from timestamp,</span></span><br><span class="line"><span class="comment">// and low order one byte is a counter.</span></span><br><span class="line"><span class="comment">// | prefix   | suffix              |</span></span><br><span class="line"><span class="comment">// | 2 bytes  | 5 bytes   | 1 byte  |</span></span><br><span class="line"><span class="comment">// | memberID | timestamp | cnt     |</span></span><br></pre></td></tr></table></figure><p>在很多分布式系统中，都需要有一套唯一id生成器。etcd的这个方案相对简单，就是 成员id+时间戳 的组合方案。</p><blockquote><p>关于分布式唯一id，更全面的设计可以参考Snowflake，如 <a href="https://segmentfault.com/a/1190000020899379">https://segmentfault.com/a/1190000020899379</a> </p></blockquote><h3 id="3-认证模块-auth-AuthStore"><a href="#3-认证模块-auth-AuthStore" class="headerlink" title="3.认证模块 - auth.AuthStore"></a>3.认证模块 - auth.AuthStore</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">authInfo, err := s.AuthInfoFromCtx(ctx)</span><br></pre></td></tr></table></figure><p>认证功能在成熟软件中非常常见。在etcd，被独立到了<code>etcd/auth</code>模块中。这个模块的内部调用不复杂，功能就是从<code>context</code>中提取出 <strong>用户名+版本信息</strong>。</p><p>这个提取过程中值得注意的是，<code>AuthStore</code>是从<code>grpc</code>的<code>metadata</code>提取出想要的认证信息，而<code>metadata</code>类似于<code>HTTP1</code>协议中的header，是一种用KV形式保存和提取数据的结构。</p><blockquote><p>串联一下我们之前的思路，etcd通过grpc-gateway将HTTP1转化成了gRPC，那么就有一个 HTTP header到grpc metadata的映射过程，有兴趣的可以去研究一下。</p></blockquote><p>总体来说，etcd的认证模块做得很简单，也方便其接入service-mesh。</p><h3 id="4-多协程小工具-wait-Wait"><a href="#4-多协程小工具-wait-Wait" class="headerlink" title="4.多协程小工具 - wait.Wait"></a>4.多协程小工具 - wait.Wait</h3><p><code>wait.Wait</code>是一个很精巧的小工具，使用起来非常简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line">ch := s.w.Register(id)</span><br><span class="line">s.w.Trigger(id, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>我们可以在<code>etcd/pkg/wait</code>目录下看到它的具体实现，我提取了重点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过id，来等待和触发对应的事件。</span></span><br><span class="line"><span class="comment">// 注意使用的顺序：先等待，再触发。</span></span><br><span class="line"><span class="keyword">type</span> Wait <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 等待，即注册一个id</span></span><br><span class="line">Register(id <span class="keyword">uint64</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 触发，用一个id</span></span><br><span class="line">Trigger(id <span class="keyword">uint64</span>, x <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">IsRegistered(id <span class="keyword">uint64</span>) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现：读写锁+map数据结构</span></span><br><span class="line"><span class="keyword">type</span> list <span class="keyword">struct</span> &#123;</span><br><span class="line">l sync.RWMutex</span><br><span class="line">m <span class="keyword">map</span>[<span class="keyword">uint64</span>]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *list)</span> <span class="title">Register</span><span class="params">(id <span class="keyword">uint64</span>)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">w.l.Lock()</span><br><span class="line"><span class="keyword">defer</span> w.l.Unlock()</span><br><span class="line">ch := w.m[id]</span><br><span class="line"><span class="keyword">if</span> ch == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// go官方建议带buffer的channel尽量设置大小为1</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">w.m[id] = ch</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不允许重复</span></span><br><span class="line">log.Panicf(<span class="string">&quot;dup id %x&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发id的channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *list)</span> <span class="title">Trigger</span><span class="params">(id <span class="keyword">uint64</span>, x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">w.l.Lock()</span><br><span class="line">ch := w.m[id]</span><br><span class="line"><span class="built_in">delete</span>(w.m, id)</span><br><span class="line">  <span class="comment">// 取出ch后直接Unlock（可以思考一下与defer的区别）</span></span><br><span class="line">w.l.Unlock()</span><br><span class="line">  <span class="comment">// 如果触发的id不存在map里，就直接跳过这个判断</span></span><br><span class="line"><span class="keyword">if</span> ch != <span class="literal">nil</span> &#123;</span><br><span class="line">ch &lt;- x</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解<code>Wait</code>的实现之后，我们就知道在正常情况下，<code>Register</code>和<code>Trigger</code>必须一一对应。</p><p>但是，我们再往下看<code>processInternalRaftRequestOnce</code>这部分代码，发现了一个异常点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="comment">// 异常：没有找到Trigger，难道忘了？</span></span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line"><span class="keyword">return</span> x.(*applyResult), <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 正常：用Trigger退出</span></span><br><span class="line"><span class="keyword">case</span> &lt;-cctx.Done():</span><br><span class="line">proposalsFailed.Inc()</span><br><span class="line">s.w.Trigger(id, <span class="literal">nil</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, s.parseProposeCtxErr(cctx.Err(), start)</span><br><span class="line">  <span class="comment">// 正常：整个server停止，此时不用关心单个Trigger了</span></span><br><span class="line"><span class="keyword">case</span> &lt;-s.done:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrStopped</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们可以做个简单的猜测：在另一个goroutine中，这个etcd server进行了一个操作，包括下面两步：</p><ol><li>往<code>ch</code>这个channel里发送了一个<code>*applyResult</code>结构的消息</li><li>对wait进行了Trigger操作</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天我们进一步阅读了<code>processInternalRaftRequestOnce</code>中的四个细节，加强了etcd server对请求处理的印象。</p><p>etcd作为一款优秀的开源项目，其模块设计比较精巧，而阅读源码的同学也要掌握一个技巧：<strong>适当控制阅读深度</strong>。比如，在阅读<code>PUT</code>请求时，第一阶段阅读到<code>EtcdServer</code>的<code>processInternalRaftRequestOnce</code>这层即可：</p><ul><li>如果继续深入看<code>raftNode</code>等实现，很容易导致你的整体思路变成过程性的调用，学习不成体系</li><li>这时，回过头来巩固一下当前学习的部分，通过串联细节来加深印象，会对你梳理整体更有帮助</li></ul><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一讲，我们继续梳理了&lt;code&gt;PUT&lt;/code&gt;请求到&lt;code&gt;EtcdServer&lt;/code&gt;这一层的逻辑，并大概阅读了其中的关键函数&lt;code&gt;processInternalRaftRequestOnce&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个方法里面有不少细节，我们今天就选择其中有价值的四点来看看。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-etcd" scheme="http://example.com/tags/Go-etcd/"/>
    
  </entry>
  
  <entry>
    <title>etcd源码分析 - 3.【打通核心流程】PUT键值对的执行链路</title>
    <link href="http://example.com/2022/07/04/etcd/etcd-3/"/>
    <id>http://example.com/2022/07/04/etcd/etcd-3/</id>
    <published>2022-07-04T04:00:00.000Z</published>
    <updated>2022-07-05T12:10:59.849Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg"></p><p>在上一讲，我们一起看了etcd server是怎么匹配到对应的处理函数的，如果忘记了请回顾一下。</p><p>今天，我们再进一步，看看<code>PUT</code>操作接下来是怎么执行的。</p><span id="more"></span><h2 id="HTTP1部分"><a href="#HTTP1部分" class="headerlink" title="HTTP1部分"></a>HTTP1部分</h2><h3 id="request-KV-Put-0"><a href="#request-KV-Put-0" class="headerlink" title="request_KV_Put_0"></a>request_KV_Put_0</h3><p>整个函数主要分为两步：</p><ol><li>解析请求到<code>etcdserverpb.PutRequest</code>数据结构；</li><li><code>client</code>执行<code>PUT</code>操作；</li></ol><p>关于解析部分，我们暂时不用关心如何反序列化的（反序列化是一种可替换的插件，常见的如json/protobuffer/xml），重点看看它的数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PutRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">Key []<span class="keyword">byte</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=key,proto3&quot; json:&quot;key,omitempty&quot;`</span></span><br><span class="line">Value []<span class="keyword">byte</span> <span class="string">`protobuf:&quot;bytes,2,opt,name=value,proto3&quot; json:&quot;value,omitempty&quot;`</span></span><br><span class="line">Lease <span class="keyword">int64</span> <span class="string">`protobuf:&quot;varint,3,opt,name=lease,proto3&quot; json:&quot;lease,omitempty&quot;`</span></span><br><span class="line">PrevKv <span class="keyword">bool</span> <span class="string">`protobuf:&quot;varint,4,opt,name=prev_kv,json=prevKv,proto3&quot; json:&quot;prev_kv,omitempty&quot;`</span></span><br><span class="line">IgnoreValue <span class="keyword">bool</span> <span class="string">`protobuf:&quot;varint,5,opt,name=ignore_value,json=ignoreValue,proto3&quot; json:&quot;ignore_value,omitempty&quot;`</span></span><br><span class="line">IgnoreLease <span class="keyword">bool</span> <span class="string">`protobuf:&quot;varint,6,opt,name=ignore_lease,json=ignoreLease,proto3&quot; json:&quot;ignore_lease,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从我们执行的<code>etcdctl put mykey &quot;this is awesome&quot;</code>为例，不难猜到：</p><ul><li>Key - mykey</li><li>Value - this is awesome</li></ul><p>接下来，我们去看看client是如何执行<code>PUT</code>的。</p><h3 id="etcdserverpb-kVClient"><a href="#etcdserverpb-kVClient" class="headerlink" title="etcdserverpb.kVClient"></a>etcdserverpb.kVClient</h3><p><code>request_KV_Put_0</code>函数中的client是一个接口<code>KVClient</code>，包括Range/Put/DeleteRange/Txn/Compact五种操作。</p><blockquote><p>这里提一下，很多开源库将接口与其实现，用大小写来区分，来强制要求外部模块依赖其接口：</p><p>比如KVClient作为接口，而kVClient作为其实现是小写的，所以外部模块无法直接使用kVClient这个数据结构。</p></blockquote><p>它的实现可以很容易地翻阅代码找到，是<code>etcdserverpb.kVClient</code>。我们去看看对应的<code>PUT</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *kVClient)</span> <span class="title">Put</span><span class="params">(ctx context.Context, in *PutRequest, opts ...grpc.CallOption)</span> <span class="params">(*PutResponse, error)</span></span> &#123;</span><br><span class="line">out := <span class="built_in">new</span>(PutResponse)</span><br><span class="line">err := grpc.Invoke(ctx, <span class="string">&quot;/etcdserverpb.KV/Put&quot;</span>, in, out, c.cc, opts...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们就找到了HTTP调用gRPC的影子，也就是这个<code>Invoke</code>方法。</p><h2 id="gRPC部分"><a href="#gRPC部分" class="headerlink" title="gRPC部分"></a>gRPC部分</h2><h3 id="proto文件"><a href="#proto文件" class="headerlink" title="proto文件"></a>proto文件</h3><p>关于gRPC的调用部分，我比较推荐从最原始的<code>proto</code>文件开始阅读，主要包括2个文件：</p><ul><li><code>etcd/etcdserver/etcdserverpb/rpc.proto</code> 原始文件</li><li><code>etcd/etcdserver/etcdserverpb/rpc.pb.go</code> 生成文件</li></ul><p>从下面的定义可以看到HTTP1采用了<code>POST</code>方法，对应URL为<code>/v3/kv/put</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpc Put(PutRequest) returns (PutResponse) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v3/kv/put&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="etcdserverpb-RegisterKVServer"><a href="#etcdserverpb-RegisterKVServer" class="headerlink" title="etcdserverpb.RegisterKVServer"></a>etcdserverpb.RegisterKVServer</h3><p>我们要注意，proto文件及其生成的go代码只是定义了server的接口，具体的实现需要开发者自行编码实现，通过注册函数<code>RegisterKVServer</code>将两者串联起来。</p><p>查找该函数的调用，分为三个，各有用途：</p><ol><li><code>grpc.go</code> - server的调用处</li><li><code>grpc_proxy.go</code> - proxy代理模式，忽略</li><li><code>mockserver.go</code> - mock服务，忽略</li></ol><p>跳转到1对应的代码处，我们看到了注册函数<code>pb.RegisterKVServer(grpcServer, NewQuotaKVServer(s))</code>。</p><h3 id="NewQuotaKVServer"><a href="#NewQuotaKVServer" class="headerlink" title="NewQuotaKVServer"></a>NewQuotaKVServer</h3><p>进一步跳转，来到了<code>NewKVServer</code>函数中。</p><h3 id="NewKVServer"><a href="#NewKVServer" class="headerlink" title="NewKVServer"></a>NewKVServer</h3><p>这个函数新建了一个<code>kvServer</code>对象，它实现接口<code>etcdserverpb.KVServer</code>。我们再看对应的<code>PUT</code>方法。</p><h3 id="kvServer-Put"><a href="#kvServer-Put" class="headerlink" title="(*kvServer) Put"></a>(*kvServer) Put</h3><p><code>Put</code>方法代码很少：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *kvServer)</span> <span class="title">Put</span><span class="params">(ctx context.Context, r *pb.PutRequest)</span> <span class="params">(*pb.PutResponse, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := checkPutRequest(r); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp, err := s.kv.Put(ctx, r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, togRPCError(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.hdr.fill(resp.Header)</span><br><span class="line"><span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这里的<code>s.kv</code>，其定义为接口<code>etcdserver.RaftKV</code>，定义了如下五个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RaftKV <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 范围操作</span></span><br><span class="line">Range(ctx context.Context, r *pb.RangeRequest) (*pb.RangeResponse, error)</span><br><span class="line">  <span class="comment">// KV操作</span></span><br><span class="line">Put(ctx context.Context, r *pb.PutRequest) (*pb.PutResponse, error)</span><br><span class="line">  <span class="comment">// 删除范围</span></span><br><span class="line">DeleteRange(ctx context.Context, r *pb.DeleteRangeRequest) (*pb.DeleteRangeResponse, error)</span><br><span class="line">  <span class="comment">// 事务</span></span><br><span class="line">Txn(ctx context.Context, r *pb.TxnRequest) (*pb.TxnResponse, error)</span><br><span class="line">  <span class="comment">// 压缩</span></span><br><span class="line">Compact(ctx context.Context, r *pb.CompactionRequest) (*pb.CompactionResponse, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>etcd server集群之间采用的是RAFT协议，而<code>RaftKV</code>则是实现的关键。查找RaftKV的具体实现<code>EtcdServer</code>，我们就找到了如下代码：</p><h3 id="EtcdServer-Put"><a href="#EtcdServer-Put" class="headerlink" title="(*EtcdServer) Put"></a>(*EtcdServer) Put</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span> <span class="title">Put</span><span class="params">(ctx context.Context, r *pb.PutRequest)</span> <span class="params">(*pb.PutResponse, error)</span></span> &#123;</span><br><span class="line">ctx = context.WithValue(ctx, traceutil.StartTimeKey, time.Now())</span><br><span class="line">resp, err := s.raftRequest(ctx, pb.InternalRaftRequest&#123;Put: r&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resp.(*pb.PutResponse), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，这里将多种请求命令（如PUT/RANGE），都封装到了一个结构体<code>InternalRaftRequest</code>中。</p><p>我们继续跳转。</p><h3 id="EtcdServer-raftRequest"><a href="#EtcdServer-raftRequest" class="headerlink" title="(*EtcdServer) raftRequest"></a>(*EtcdServer) raftRequest</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span> <span class="title">raftRequest</span><span class="params">(ctx context.Context, r pb.InternalRaftRequest)</span> <span class="params">(proto.Message, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> s.raftRequestOnce(ctx, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，带<code>Once</code>关键字的函数，强调只执行一次，简单的可以用<code>sync.Once</code>函数实现，复杂的会结合<code>sync</code>和<code>atomic</code>进行针对性的设计。</p><p>我们再进一步跳转。</p><h3 id="EtcdServer-processInternalRaftRequestOnce"><a href="#EtcdServer-processInternalRaftRequestOnce" class="headerlink" title="(*EtcdServer) processInternalRaftRequestOnce"></a>(*EtcdServer) processInternalRaftRequestOnce</h3><p>这部分的代码我做了个精简，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起RAFT提案Propose（分布式共识算法的术语，不清楚的同学有个初步印象即可）</span></span><br><span class="line">err = s.r.Propose(cctx, data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监控的metrics，表示提案处于Pending计数+1，退出则-1</span></span><br><span class="line">proposalsPending.Inc()</span><br><span class="line"><span class="keyword">defer</span> proposalsPending.Dec()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理结果异步返回，分为三个情况</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="comment">// 正常返回结果</span></span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line"><span class="keyword">return</span> x.(*applyResult), <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 超时等异常处理</span></span><br><span class="line"><span class="keyword">case</span> &lt;-cctx.Done():</span><br><span class="line">proposalsFailed.Inc()</span><br><span class="line">s.w.Trigger(id, <span class="literal">nil</span>) <span class="comment">// GC wait</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, s.parseProposeCtxErr(cctx.Err(), start)</span><br><span class="line">  <span class="comment">// 被正常关闭</span></span><br><span class="line"><span class="keyword">case</span> &lt;-s.done:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrStopped</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="raftNode部分"><a href="#raftNode部分" class="headerlink" title="raftNode部分"></a>raftNode部分</h2><h3 id="raftNode-Propose"><a href="#raftNode-Propose" class="headerlink" title="(raftNode)Propose"></a>(raftNode)Propose</h3><p>如果我们对<code>Propose</code>方法感兴趣，就需要深入学习<code>raftNode</code>这一大块了，它是对RAFT协议的整体封装。</p><p>在<code>etcd</code>里，<code>raftNode</code>是一个比较独立的模块，我们会在后续模块专门分析。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过本篇的代码阅读，我们经历了 HTTP1 -&gt; gRPC -&gt; raftNode 三层，对整个<code>PUT</code>调用链有了一个基本印象。</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd-1-main-Page-3.drawio%20(1).png"></p><p>我在图中特别标注了一些关键的接口与实现。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一讲，我们一起看了etcd server是怎么匹配到对应的处理函数的，如果忘记了请回顾一下。&lt;/p&gt;
&lt;p&gt;今天，我们再进一步，看看&lt;code&gt;PUT&lt;/code&gt;操作接下来是怎么执行的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-etcd" scheme="http://example.com/tags/Go-etcd/"/>
    
  </entry>
  
  <entry>
    <title>etcd源码分析 - 2.【打通核心流程】PUT键值对匹配处理函数</title>
    <link href="http://example.com/2022/06/28/etcd/etcd-2/"/>
    <id>http://example.com/2022/06/28/etcd/etcd-2/</id>
    <published>2022-06-28T04:00:00.000Z</published>
    <updated>2022-07-04T07:24:07.791Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg"></p><p>在阅读了etcd server的启动流程后，我们对很多关键性函数的入口都有了初步印象。</p><p>那么，接下来我们一起看看对键值对的修改，在etcd server内部是怎么流转的。</p><span id="more"></span><h2 id="PUT键值对的HTTP请求"><a href="#PUT键值对的HTTP请求" class="headerlink" title="PUT键值对的HTTP请求"></a>PUT键值对的HTTP请求</h2><p>用<code>etcdctl</code>这个指令，我们可以快速地用命令<code>etcdctl put key value</code>发送PUT键值对的请求。</p><p>但<code>etcdctl</code>对请求做了封装，我们要了解原始的HTTP请求格式，才能方便地阅读相关代码。相关的途径有很多，比如抓包、读源码等，这里为了可阅读性，我给出一个<code>curl</code>请求。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L http://localhost:2379/v3/kv/put -X POST -d &#x27;&#123;&quot;key&quot;:&quot;mykey&quot;,&quot;value&quot;:&quot;myvalue&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure><p>主要关注如下三点：</p><ol><li>Method - <code>POST</code></li><li>URL -<code> /v3/kv/put</code></li><li>Body - <code>&#123;&quot;key&quot;:&quot;mykey&quot;,&quot;value&quot;:&quot;myvalue&quot;&#125;</code></li></ol><blockquote><p>这个请求是v3版本的，而v2版本的差异比较大，暂不细谈。</p></blockquote><h2 id="Mux的路由匹配"><a href="#Mux的路由匹配" class="headerlink" title="Mux的路由匹配"></a>Mux的路由匹配</h2><h2 id="背景知识介绍"><a href="#背景知识介绍" class="headerlink" title="背景知识介绍"></a>背景知识介绍</h2><p>为了更好地介绍下面的内容，我先介绍mux下的2个概念。</p><ul><li><code>pattern</code>指的是一种URL的匹配模式，最常见的如全量匹配、前缀匹配、正则匹配。当一个请求进来时，它会有自己的一个URL，去匹配<code>mux</code>中预先定义的多个<code>pattern</code>，找到一个最合适的。这是一种<strong>URL路由规则的实现</strong>。</li><li>当请求匹配到一个<code>pattern</code>后，就会执行它预定义的<code>handler</code>，也就是一个处理函数，返回结果。</li></ul><p>所以， <code>pattern</code>负责匹配，而<code>handler</code>负责执行。在不同语境下，它们的专业术语有所差异，大家自行对应即可。</p><h3 id="http-mux的创建"><a href="#http-mux的创建" class="headerlink" title="http mux的创建"></a>http mux的创建</h3><p>我们要找HTTP1.X的路由匹配逻辑，就回到了上一节最后看到的代码中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建路由匹配规则</span></span><br><span class="line">httpmux := sctx.createMux(gwmux, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建http server对象</span></span><br><span class="line">srvhttp := &amp;http.Server&#123;</span><br><span class="line">  Handler:  createAccessController(sctx.lg, s, httpmux),</span><br><span class="line">  ErrorLog: logger, <span class="comment">// do not log user error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个cumx.HTTP1是检查协议是否满足HTTP1</span></span><br><span class="line">httpl := m.Match(cmux.HTTP1())</span><br><span class="line"><span class="comment">// 运行server</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; errHandler(srvhttp.Serve(httpl)) &#125;()</span><br></pre></td></tr></table></figure><h3 id="（-serveCtx-createMux"><a href="#（-serveCtx-createMux" class="headerlink" title="（*serveCtx)createMux"></a>（*serveCtx)createMux</h3><p>本函数不长，但很容易让读源码的同学陷入误区，我们一起来看看。这块代码主要分为三段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sctx *serveCtx)</span> <span class="title">createMux</span><span class="params">(gwmux *gw.ServeMux, handler http.Handler)</span> *<span class="title">http</span>.<span class="title">ServeMux</span></span> &#123;</span><br><span class="line">httpmux := http.NewServeMux()</span><br><span class="line">  <span class="comment">// 1.注册handler</span></span><br><span class="line"><span class="keyword">for</span> path, h := <span class="keyword">range</span> sctx.userHandlers &#123;</span><br><span class="line">httpmux.Handle(path, h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.注册grpcGateway mux中的handler到/v3/路径下</span></span><br><span class="line"><span class="keyword">if</span> gwmux != <span class="literal">nil</span> &#123;</span><br><span class="line">httpmux.Handle(</span><br><span class="line"><span class="string">&quot;/v3/&quot;</span>,</span><br><span class="line">wsproxy.WebsocketProxy(</span><br><span class="line">gwmux,</span><br><span class="line">wsproxy.WithRequestMutator(</span><br><span class="line"><span class="comment">// Default to the POST method for streams</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ *http.Request, outgoing *http.Request)</span> *<span class="title">http</span>.<span class="title">Request</span></span> &#123;</span><br><span class="line">outgoing.Method = <span class="string">&quot;POST&quot;</span></span><br><span class="line"><span class="keyword">return</span> outgoing</span><br><span class="line">&#125;,</span><br><span class="line">),</span><br><span class="line">wsproxy.WithMaxRespBodyBufferSize(<span class="number">0x7fffffff</span>),</span><br><span class="line">),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 3.注册根路径下的handler</span></span><br><span class="line"><span class="keyword">if</span> handler != <span class="literal">nil</span> &#123;</span><br><span class="line">httpmux.Handle(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> httpmux</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一点，可以通过简单的代码阅读，看到是对<code>pprof</code>和<code>debug</code>这些通用功能的URL功能注册，也是一些用户自定义的<code>handler</code>注册，这就很好地对应到<code>sctx.userHandlers</code>这个变量的命名了。</p><p>第三点很快就能被排除，它注册的是对根路径下的handler。我们阅读代码，找到handler最原始的生成处，就能看到它是对version、metrcis这类handler的注册。</p><p>所以，我们的重点就放在了<code>gwmux</code>这个对象上。阅读它的创建过程，就得跳转到上层函数。</p><h3 id="serveCtx-registerGateway"><a href="#serveCtx-registerGateway" class="headerlink" title="(*serveCtx)registerGateway"></a>(*serveCtx)registerGateway</h3><p>在函数中，我们可以看到它注册了一个类型为<code>registerHandlerFunc</code>的handlers列表，包括如下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">handlers := []registerHandlerFunc&#123;</span><br><span class="line">etcdservergw.RegisterKVHandler, <span class="comment">// KV键值对的处理</span></span><br><span class="line">etcdservergw.RegisterWatchHandler, <span class="comment">// Watch监听</span></span><br><span class="line">etcdservergw.RegisterLeaseHandler, <span class="comment">// Lease租约</span></span><br><span class="line">etcdservergw.RegisterClusterHandler, <span class="comment">// 集群</span></span><br><span class="line">etcdservergw.RegisterMaintenanceHandler, <span class="comment">// 维护相关</span></span><br><span class="line">etcdservergw.RegisterAuthHandler, <span class="comment">// 认证</span></span><br><span class="line">v3lockgw.RegisterLockHandler, <span class="comment">// 锁</span></span><br><span class="line">v3electiongw.RegisterElectionHandler, <span class="comment">// 选举</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, h := <span class="keyword">range</span> handlers &#123;</span><br><span class="line">  <span class="keyword">if</span> err := h(ctx, gwmux, conn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们聚焦到PUT请求的处理，它自然走的是<code>etcdservergw.RegisterKVHandler</code>这个入口。</p><h3 id="RegisterKVHandler"><a href="#RegisterKVHandler" class="headerlink" title="RegisterKVHandler"></a>RegisterKVHandler</h3><p>本函数位于<code>etcd/etcdserver/etcdserverpb/gw/rpc.pb.gw.go</code>。它其实是用protobuf自动生成的，其中用到了<code>grpc-gateway</code>这个关键性技术，它的作用是将HTTP1的请求转换成gRPC，实现一个server可以同时支持HTTP1与gRPC，并且只写一份gRPC处理的代码即可。</p><blockquote><p>有兴趣地可以去看看 <a href="https://github.com/grpc-ecosystem/grpc-gateway">https://github.com/grpc-ecosystem/grpc-gateway</a> 项目。</p><p>大致调用链路为： HTTP1 -&gt; gRPC -&gt; 自己实现的handler</p></blockquote><h3 id="RegisterKVHandlerClient"><a href="#RegisterKVHandlerClient" class="headerlink" title="RegisterKVHandlerClient"></a>RegisterKVHandlerClient</h3><p>该函数是由proto文件生成的，这里我忽略了关于context的处理，提取关键性的内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mux.Handle(<span class="string">&quot;POST&quot;</span>, pattern_KV_Put_0, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request, pathParams <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 反序列化请求和序列化响应</span></span><br><span class="line">  inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)</span><br><span class="line">  <span class="comment">// 执行PUT请求</span></span><br><span class="line">  resp, md, err := request_KV_Put_0(rctx, inboundMarshaler, client, req, pathParams)</span><br><span class="line">  <span class="comment">// 返回结果</span></span><br><span class="line">  forward_KV_Put_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>序列化与反序列化存在多种选择，我们暂不深入，先来看看处理这部分的工作：</p><p>首先是如何匹配请求，也就是<code>http://localhost:2379/v3/kv/put</code>，对应如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern_KV_Put_0 = runtime.MustPattern(runtime.NewPattern(<span class="number">1</span>, []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">&quot;v3&quot;</span>, <span class="string">&quot;kv&quot;</span>, <span class="string">&quot;put&quot;</span>&#125;, <span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure><p>而最核心的处理，也就是解析PUT请求的函数<code>request_KV_Put_0</code>与返回处理结果的函数<code>forward_KV_Put_0</code>，我们放到下一讲再来看。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天我们看了<code>PUT</code>请求在etcd server中通过<code>mux</code>的匹配逻辑，思路参考下图。</p><p>在阅读代码期间，我们接触到了grpc-gateway这个技术方案，有兴趣的朋友可以参考我的<a href="https://junedayday.github.io/2021/08/19/go-framework/go-framework-1/">另一篇文章</a>。</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd-2-mux.drawio.png"></p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在阅读了etcd server的启动流程后，我们对很多关键性函数的入口都有了初步印象。&lt;/p&gt;
&lt;p&gt;那么，接下来我们一起看看对键值对的修改，在etcd server内部是怎么流转的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-etcd" scheme="http://example.com/tags/Go-etcd/"/>
    
  </entry>
  
  <entry>
    <title>etcd源码分析 - 1.【打通核心流程】etcd server的启动流程</title>
    <link href="http://example.com/2022/06/20/etcd/etcd-1/"/>
    <id>http://example.com/2022/06/20/etcd/etcd-1/</id>
    <published>2022-06-20T04:00:00.000Z</published>
    <updated>2022-06-27T05:55:00.438Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg"></p><p><code>etcd</code>的源码相对<code>Kubernetes</code>少了很多，但学习成本依旧在。</p><p>在第一阶段，我将从主流程出发，讲述一个<code>PUT</code>指令是怎么将数据更新到<code>etcd server</code>中的。今天，我们先来看看server是怎么启动的。</p><span id="more"></span><h2 id="etcd-server启动代码"><a href="#etcd-server启动代码" class="headerlink" title="etcd server启动代码"></a>etcd server启动代码</h2><p>运行<code>etcd server</code>的最简化代码为<code>./bin/etcd</code>，无需添加任何参数。我们就根据这个命令来阅读代码，看看启动的主逻辑是怎么样的。</p><h3 id="etcdmain-Main"><a href="#etcdmain-Main" class="headerlink" title="etcdmain.Main"></a>etcdmain.Main</h3><p>主入口函数中，只要我们能理解<code>os.Args</code>它的含义，就能快速地跳过中间代码，找到下一层函数的入口<code>startEtcdOrProxyV2()</code>。</p><h3 id="startEtcdOrProxyV2"><a href="#startEtcdOrProxyV2" class="headerlink" title="startEtcdOrProxyV2"></a>startEtcdOrProxyV2</h3><p>本函数较长，就比较考验我们的通读能力。在阅读这一块代码时，我一般会用到三个小技巧：</p><ol><li>忽略<code>err != nil</code>的判断分支，一般它们都是对异常case的处理；</li><li>忽略<code>变量 == 默认值</code>的判断分支，如<code>字符串变量 == &quot;&quot;</code>，这种多为对默认值的处理，如做变量初始化等；</li><li>寻找串联上下文的关键性变量，一般都会有明确的命名或注释；</li></ol><p>而在这块代码里呢，我们就能找到2个关键性的变量，以及相关的使用处：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示停止动作与错误的两个channel</span></span><br><span class="line"><span class="keyword">var</span> stopped &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> errc &lt;-<span class="keyword">chan</span> error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种模式：第一种是正常的etcd server，第二种是代理模式</span></span><br><span class="line"><span class="keyword">switch</span> which &#123;</span><br><span class="line"><span class="keyword">case</span> dirMember:</span><br><span class="line">stopped, errc, err = startEtcd(&amp;cfg.ec)</span><br><span class="line"><span class="keyword">case</span> dirProxy:</span><br><span class="line">err = startProxy(cfg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞并监听两个通道的地方</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> lerr := &lt;-errc:</span><br><span class="line"><span class="keyword">case</span> &lt;-stopped:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这部分的代码，我们就能定位到下一层的函数入口 - <code>startEtcd</code>。</p><h3 id="startEtcd"><a href="#startEtcd" class="headerlink" title="startEtcd"></a>startEtcd</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startEtcd</span><span class="params">(cfg *embed.Config)</span> <span class="params">(&lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, &lt;-<span class="keyword">chan</span> error, error)</span></span> &#123;</span><br><span class="line">e, err := embed.StartEtcd(cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">osutil.RegisterInterruptHandler(e.Close)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-e.Server.ReadyNotify(): <span class="comment">// wait for e.Server to join the cluster</span></span><br><span class="line"><span class="keyword">case</span> &lt;-e.Server.StopNotify(): <span class="comment">// publish aborted from &#x27;ErrStopped&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e.Server.StopNotify(), e.Err(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以从三个关键动作，来了解这个函数的功能：</p><ol><li>启动etcd，如果失败则通过<code>error</code>返回；</li><li>启动etcd后，本节点会加入到整个集群中，就绪后则通过channel<code>e.Server.ReadyNotify()</code>收到消息；</li><li>启动etcd后，如果遇到异常，则会通过channel<code>e.Server.StopNotify()</code>收到消息；</li></ol><p>另外，<code>osutil.RegisterInterruptHandler(e.Close)</code>这个函数注册了etcd异常退出的函数，里面涉及到一些汇编，有兴趣可以深入阅读。</p><h3 id="embed-StartEtcd"><a href="#embed-StartEtcd" class="headerlink" title="embed.StartEtcd"></a>embed.StartEtcd</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">StartEtcd</span><span class="params">(inCfg *Config)</span> <span class="params">(e *Etcd, err error)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们先简单地通读一下注释，可以了解到：<strong>本函数返回的Etcd并没有保证加入到集群，而是要等待channel通知</strong>。这就印证了上面的猜想。<code>StartEtcd</code>函数很长，我先解释两个关键词：</p><ol><li>peer - 英文翻译为同等地位的人，在当前语义下表示其余同等的etcd server节点，共同组成集群；</li><li>client - 即客户端，可以理解为发起etcd请求方，如程序；</li></ol><p>我们看到一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建 etcdserver.EtcdServer 对象</span></span><br><span class="line"><span class="keyword">if</span> e.Server, err = etcdserver.NewServer(srvcfg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> e, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动etcdserver</span></span><br><span class="line">e.Server.Start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接peer/client，以及提供metrics指标</span></span><br><span class="line"><span class="keyword">if</span> err = e.servePeers(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> e, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = e.serveClients(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> e, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = e.serveMetrics(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> e, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入Start方法，可以看到里面都是一些常驻的daemon程序，如监控版本/KV值，与我们关注的PUT操作的核心流程无关。所以，我们的目标就转移到<code>serveClients</code>函数。</p><h3 id="serveClients"><a href="#serveClients" class="headerlink" title="serveClients"></a>serveClients</h3><p>本函数的重点在于下面这段。这里有个变量叫<code>sctx</code>，就是server context的简写，是在前面<code>embed.StartEtcd</code>里初始化的，主要由context、日志、网络信息组成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, sctx := <span class="keyword">range</span> e.sctxs &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s *serveCtx)</span></span> &#123;</span><br><span class="line">    e.errHandler(s.serve(e.Server, &amp;e.cfg.ClientTLSInfo, h, e.errHandler, gopts...))</span><br><span class="line">  &#125;(sctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点理解下面这个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Etcd)</span> <span class="title">errHandler</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 第一次select，如果收到停止消息，则退出，否则到第二个select</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-e.stopc:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第二次select，一般情况下长期阻塞在这里：要么收到停止消息，要么将error从e.errc发送出去</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-e.stopc:</span><br><span class="line"><span class="keyword">case</span> e.errc &lt;- err:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="serveCtx-serve"><a href="#serveCtx-serve" class="headerlink" title="(*serveCtx)serve()"></a>(*serveCtx)serve()</h3><p><code>serve()</code>函数我们可以快速地通过缩进来阅读：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非安全，即HTTP</span></span><br><span class="line"><span class="keyword">if</span> sctx.insecure &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全，即HTTPS</span></span><br><span class="line"><span class="keyword">if</span> sctx.secure &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们关注的HTTP部分，又分为两块 - HTTP2和HTTP1。而每一个server都有一个关键变量：</p><p><code>mux</code>多路复用器 - 在web编程的场景下，往往指多个路由规则的匹配，最常见的如将URL映射到一个处理函数；而创建完<code>mux</code>后，将它注册到server中运行起来。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里，我们串联了整个<code>main</code>函数运行的相关代码，也建立了etcd server运行的主要逻辑，我也总结到了下面这张图中。</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd-1-main.drawio.png"></p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;etcd&lt;/code&gt;的源码相对&lt;code&gt;Kubernetes&lt;/code&gt;少了很多，但学习成本依旧在。&lt;/p&gt;
&lt;p&gt;在第一阶段，我将从主流程出发，讲述一个&lt;code&gt;PUT&lt;/code&gt;指令是怎么将数据更新到&lt;code&gt;etcd server&lt;/code&gt;中的。今天，我们先来看看server是怎么启动的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-etcd" scheme="http://example.com/tags/Go-etcd/"/>
    
  </entry>
  
  <entry>
    <title>etcd源码分析 - 0.搭建学习etcd的环境</title>
    <link href="http://example.com/2022/06/14/etcd/etcd-0/"/>
    <id>http://example.com/2022/06/14/etcd/etcd-0/</id>
    <published>2022-06-14T04:00:00.000Z</published>
    <updated>2022-07-04T06:12:40.046Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg"></p><p>之前，我在b站视频简单地讲述了etcd的功能与特性，有兴趣的可以参考<a href="https://www.bilibili.com/video/BV155411Y7Pq/">相关视频</a>。</p><p>但如果要更深入地研究etcd，就需要我们涉及到源码、并结合实践进行学习。那么，接下来，我将基于<code>v3.4</code>这个版本，做一期深入的环境搭建。</p><span id="more"></span><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>Macbook - 为了方便读代码与编译运行，也可自行搭建Ubuntu等可视化系统</li><li>Go语言 - v1.17，我选用的是v1.17.11</li><li>Goland/VSCode</li><li>etcd源码 - 建议用Github Desktop进行下载</li></ol><h2 id="基本调试"><a href="#基本调试" class="headerlink" title="基本调试"></a>基本调试</h2><p>为了保证etcd可运行，我们先在根目录上运行<code>go mod tidy</code>，保证依赖库没有问题。</p><p>接着，我们阅读<code>Makefile</code>文件，发现其提供了<code>make build</code>指令。运行后，在<code>bin</code>目录下生成了<code>etcd</code>/<code>etcdctl</code>/<code>etcdutl</code>三个可执行文件，并且打印出了版本信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./bin/etcd --version</span><br><span class="line">etcd Version: 3.4.18</span><br><span class="line">Git SHA: c2c9e7de0</span><br><span class="line">Go Version: go1.17.11</span><br><span class="line">Go OS/Arch: darwin/amd64</span><br><span class="line">./bin/etcdctl version</span><br><span class="line">etcdctl version: 3.4.18</span><br><span class="line">API version: 3.4</span><br></pre></td></tr></table></figure><p>我们暂时只关注<code>etcd</code>与<code>etcdctl</code>，可以简单地将两者理解为服务端与客户端。我们分别在两个终端进行操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行etcd server</span></span><br><span class="line">./bin/etcd</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 写入一个key</span></span><br><span class="line">./bin/etcdctl put mykey &quot;this is awesome&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取一个key</span></span><br><span class="line">./bin/etcdctl get mykey</span><br></pre></td></tr></table></figure><p>如果你能读取到对应的信息，那么就证明整个环境已经很好地运行起来了。</p><h2 id="从Makefile看Go的编译步骤"><a href="#从Makefile看Go的编译步骤" class="headerlink" title="从Makefile看Go的编译步骤"></a>从Makefile看Go的编译步骤</h2><p>在日常开发的过程中，我们对Go程序的编译往往只是一行简单的<code>go build</code>，但在大型工程中往往还不够。我们看看etcd做了什么。</p><h3 id="GIT-SHA"><a href="#GIT-SHA" class="headerlink" title="GIT_SHA"></a>GIT_SHA</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GIT_SHA=$(git rev-parse --short HEAD || echo &quot;GitNotFound&quot;)</span><br><span class="line">GO_LDFLAGS=&quot;$GO_LDFLAGS -X $&#123;REPO_PATH&#125;/version.GitSHA=$&#123;GIT_SHA&#125;&quot;</span><br></pre></td></tr></table></figure><p>这个参数是取git最新一次的commit的短hash，用来标识源码的版本，比如c2c9e7de0。</p><p>然后，将这个相对唯一的值，作为GO_LDFLAGS中的一个参数，打入到go程序中。</p><h3 id="ldflags"><a href="#ldflags" class="headerlink" title="ldflags"></a>ldflags</h3><p>在Makefile中的编译里，我们会用到<code>-ldflags &quot;$GO_LDFLAGS&quot;</code>这个参数。通过运行<code>go help build</code>，可以看到这么一段说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-ldflags &#x27;[pattern=]arg list&#x27;</span><br><span class="line">               arguments to pass on each go tool link invocation.</span><br></pre></td></tr></table></figure><p>也就是用key=value对的格式，将想要的信息传递给Go程序。</p><blockquote><p>ldflags可以记忆为 load flags，即将标记信息加载到程序中。</p></blockquote><h2 id="传递ldflags中的参数"><a href="#传递ldflags中的参数" class="headerlink" title="传递ldflags中的参数"></a>传递ldflags中的参数</h2><p><code>ldflags</code>传递参数的方式是 <code>package_path.variable_name=new_value</code>。</p><p>以示例中的build为例，这个值为<code>go.etcd.io/etcd/version.GitSHA=$&#123;GIT_SHA&#125;</code>，对应到三块：</p><ol><li>package_path = go.etcd.io/etcd/version</li><li>variable_name = GitSHA</li><li>new_value = ${GIT_SHA}</li></ol><p>所以，这里所做的就是将<code>go.etcd.io/etcd/version</code>这个package下的<code>GitSHA</code>变量替换为想要的值。我们去对应的代码里看，发现对应的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// MinClusterVersion is the min cluster version this etcd binary is compatible with.</span></span><br><span class="line">MinClusterVersion = <span class="string">&quot;3.0.0&quot;</span></span><br><span class="line">Version           = <span class="string">&quot;3.4.18&quot;</span></span><br><span class="line">APIVersion        = <span class="string">&quot;unknown&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Git SHA Value will be set during build</span></span><br><span class="line">GitSHA = <span class="string">&quot;Not provided (use ./build instead of go build)&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>所以，我们可以通过编译脚本实现代码中变量的替换。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>etcd的学习环境搭建并不复杂，主要是有一台Mac电脑。接下来，我们将逐步开始一起阅读代码。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/etcd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前，我在b站视频简单地讲述了etcd的功能与特性，有兴趣的可以参考&lt;a href=&quot;https://www.bilibili.com/video/BV155411Y7Pq/&quot;&gt;相关视频&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但如果要更深入地研究etcd，就需要我们涉及到源码、并结合实践进行学习。那么，接下来，我将基于&lt;code&gt;v3.4&lt;/code&gt;这个版本，做一期深入的环境搭建。&lt;/p&gt;
    
    </summary>
    
      <category term="技术框架" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Go-etcd" scheme="http://example.com/tags/Go-etcd/"/>
    
  </entry>
  
  <entry>
    <title>Go语言技巧 - 16.【Go泛型】何时使用泛型</title>
    <link href="http://example.com/2022/06/07/go-tip/go-tip-16/"/>
    <id>http://example.com/2022/06/07/go-tip/go-tip-16/</id>
    <published>2022-06-07T04:00:00.000Z</published>
    <updated>2022-06-09T12:31:52.330Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg" alt="go-tip"></p><h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>本文重点依赖于 <a href="https://go.dev/blog/when-generics">https://go.dev/blog/when-generics</a> 这篇博客，有时间的可以自行阅读。</p><p>本文会结合个人的理解与经验，强调其中的重点。</p><span id="more"></span><h2 id="两个示例"><a href="#两个示例" class="headerlink" title="两个示例"></a>两个示例</h2><p>文章给出了两个示例，我们看一下签名，了解其功能即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 1</span></span><br><span class="line"><span class="comment">// 两个泛型Key,Val，Key是可比较的类型，而Val是任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapKeys</span>[<span class="title">Key</span> <span class="title">comparable</span>, <span class="title">Val</span> <span class="title">any</span>]<span class="params">(m <span class="keyword">map</span>[Key]Val)</span> []<span class="title">Key</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 2</span></span><br><span class="line"><span class="comment">// T表示任意类型，它被嵌入到具体的数据结构 Tree[T any] 和 node[T any] 中</span></span><br><span class="line"><span class="keyword">type</span> Tree[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    cmp  <span class="function"><span class="keyword">func</span><span class="params">(T, T)</span> <span class="title">int</span></span></span><br><span class="line">    root *node[T]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    left, right  *node[T]</span><br><span class="line">    val          T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *Tree[T])</span> <span class="title">find</span><span class="params">(val T)</span> **<span class="title">node</span>[<span class="title">T</span>]</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例一分析"><a href="#示例一分析" class="headerlink" title="示例一分析"></a>示例一分析</h2><p>示例一就是将泛型直接用到的 <strong>函数签名中的变量类型</strong>。</p><p>它的特点主要是：能力受限于基础类型，只有关键词any和comparable两种。所以，这种方式适合基础类型的基本操作，如针对map/slice的遍历、求和等。</p><p>文章也强调了：由于它无法在编译期用静态类型检查，所以在运行时会慢一点。这点性能损失对普通应用来说完全可以忽略。</p><h2 id="示例二分析"><a href="#示例二分析" class="headerlink" title="示例二分析"></a>示例二分析</h2><p>示例二非常重要，值得我们反复阅读。</p><p>先提炼一下，它的泛型<code>T</code>体现在两块：</p><ol><li>数据结构的命名 - <code>Tree[T any]</code>和<code> node[T any]</code>，这里的泛型不做任何限制，只表示<strong>数据结构</strong>；</li><li>关键性的计算功能 - <code>cmp  func(T, T) int</code>，这里是<strong>泛型T的计算能力的关键实现</strong>；</li></ol><p>所以，这就是一种 <strong>数据结构与计算分离的实现</strong>。</p><p>在这个例子中，泛型<code>T</code>表示任意类型。由于它的数据结构的不确定性，自然就无法进行计算；这时引入的<code>cmp</code>函数，则是将<code>T</code>的计算逻辑作为输入</p><h2 id="泛型中更倾向于用函数，而不是方法"><a href="#泛型中更倾向于用函数，而不是方法" class="headerlink" title="泛型中更倾向于用函数，而不是方法"></a>泛型中更倾向于用函数，而不是方法</h2><p>上面示例二明显比示例一更具通用性。我们重点分析一下<code>cmp</code>这个函数。</p><p>在传统的面向对象中，我们倾向于使用方法来定义某个功能，比如<code>(t1 T)cmp (t2 T) int </code>这样的方法，但这是有依赖的。试想一下，如果你接着写这个方法的实现，势必会写到<code>t1</code>与<code>t2</code>这两个数据结构的对比了。绕了一圈，我们还是不得不面对<code>func(T, T) int</code>这么一个函数。</p><p>所以，在Go泛型中，最有效的方式就是直接传入这个函数，由开发者自行实现。</p><h2 id="泛型与接口"><a href="#泛型与接口" class="headerlink" title="泛型与接口"></a>泛型与接口</h2><p>泛型和接口有不少相似之处，比如上面的泛型需要传入<code>cmp</code>这个一个对比函数，而如果用接口，往往也需要自己实现接口相关的方法。</p><p>但是，我们切勿混淆两者。我们仔细去思考两者的实现，会发现两者的关键性差异：</p><ul><li>泛型：泛型往往更强调的是数据结构的共同特征，相关的函数只是起到辅助功能，并且处理逻辑要完全一致；</li><li>接口：接口不关心具体的数据结构，而强调要实现对应的相关方法；</li></ul><p>所以，<strong>泛型更多的是从数据结构来思考共同特征，会偏向于过程性思维，适合底层的基础工具库；而接口则是用方法来抽象各种对象，是面向对象的思维，适合中、高层的编程</strong>。</p><h2 id="指导性原则"><a href="#指导性原则" class="headerlink" title="指导性原则"></a>指导性原则</h2><p>最后，作者总结了一个指导性原则：</p><p><strong>当你反复地写类似的代码时，而这些代码之间的差异只是数据结构不同，那你就可以考虑使用泛型。</strong></p><p>这里有2个特点：</p><ol><li><strong>反复性</strong>：如果只是写两三次就能解决的，就没必要使用泛型了；</li><li><strong>非逻辑类问题</strong>：如果是计算逻辑有差异，那也不能使用泛型；</li></ol><p>换一句话来说，<strong>先写重复性代码，再提炼成泛型</strong>，不要过早引入泛型。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说，Go的泛型提供了新的语法糖，主要针对底层库的提效，并非解决重复性coding的银弹。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/my_wechat.jpeg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/go-study.jpeg&quot; alt=&quot;go-tip&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h2&gt;&lt;p&gt;本文重点依赖于 &lt;a href=&quot;https://go.dev/blog/when-generics&quot;&gt;https://go.dev/blog/when-generics&lt;/a&gt; 这篇博客，有时间的可以自行阅读。&lt;/p&gt;
&lt;p&gt;本文会结合个人的理解与经验，强调其中的重点。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Go-Tip" scheme="http://example.com/tags/Go-Tip/"/>
    
  </entry>
  
  <entry>
    <title>技术阅读摘要 - 4.闲谈晋升</title>
    <link href="http://example.com/2022/06/04/readings/go-digest-4/"/>
    <id>http://example.com/2022/06/04/readings/go-digest-4/</id>
    <published>2022-06-04T04:00:00.000Z</published>
    <updated>2022-06-04T07:56:39.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>晋升是每个技术人都应该经历的一次洗礼。一般来说，分为提名、准备、述职、答辩这四个步骤。</p><p>尽管每个人的经历与体会都有不同，很难照搬硬套，但我相信只要是真心分享的经验，总会对人有帮助。接下来，我将从五个点展开。</p><span id="more"></span><h2 id="一切以如何被提名为前提"><a href="#一切以如何被提名为前提" class="headerlink" title="一切以如何被提名为前提"></a>一切以如何被提名为前提</h2><p>晋升提名分为自提名和领导提名，一般只建议走后面的渠道。</p><p>如何被提名，每个公司在不同阶段都有不同的标准，但有两点是必备的：绩效与能力。这个很容易理解，我就不赘述了。</p><p>除了以上两点，还有不少因素会左右被提名这件事，往往和组织结构息息相关：</p><ul><li>某团队很讲究先来后到，那么晋升往往就像排队</li><li>某领导很讲究团队和谐，那么“刺头们”往往要往后挪</li><li>某组织很看重稳定性，那么出一次事故，再多的功劳与能力都没用</li></ul><p>这类因素很多，这部分往往需要你融入团队后才能知道。如果你希望得到晋升，请尊重这个玩法：在作为基层的时候，不要与组织正面抗衡。这么说很有功利性色彩：要么适应、要么滚，没必要把自己撞得头破血流。</p><p>有一句话，我希望对大家有启发：<strong>你有再多的证据可以证明自己满足下一职级，也不代表你会被提名。</strong>晋升提名是一个分界线，请注意这个游戏的先后关系：先有提名，再准备材料向评委证明自己的能力。</p><h2 id="晋升提名后，先降低自己的预期"><a href="#晋升提名后，先降低自己的预期" class="headerlink" title="晋升提名后，先降低自己的预期"></a>晋升提名后，先降低自己的预期</h2><p>在准备的过程中，有不少因素会打击到人的心态。很多人会慢慢变得不自信，开始怀疑自己是不是有能力、有资格晋升，于是变得消极，甚至开始摆烂。</p><p>如何调节沮丧、低落的情绪，因人而异，不过有一点很明确 - 如果你具有足够的辨识能力的话，接受到外部反馈的因素越多，你的晋升述职效果就会被打磨得越好。但，当你过度失落时，你的分辨能力也会大幅下降。</p><p>这时，我建议不要再接收外部反馈的信息了。最简单的方式，就是只跟着直属领导的思路去写一份PPT，不与外界其他人交流。</p><p>我有个建议：<strong>拿到晋升名额，不代表你的当前思路是满足晋升述职的。</strong>不少人的失落，是因为他们觉得自己被提名后，过去的经历被贬得一文不值，就开始怀疑自己了。所以，一切清零，破而后立，降低自己的预期，能建立一个更好的心态。</p><h2 id="晋升材料是立足现在看过去"><a href="#晋升材料是立足现在看过去" class="headerlink" title="晋升材料是立足现在看过去"></a>晋升材料是立足现在看过去</h2><p>立足过去，我们写的往往是过程性的What。这部分材料像是一篇记叙文，讲你做了什么，所以拿到了什么样的成果，很难证明自己的能力：有没有更好的解法？这样的成果足够吗？你的认识是不是有局限性？</p><p>而立足现在，则能从更高的角度，去回答很多Why类问题。于是，整篇文章就变得像一篇论文，证明你的能力足以到下一个级别。在这个过程中，你会发现有很多以前的不足，有改进项，要基于现在的个人能力，适当包装。</p><p>所以，我们要明确思路：<strong>你做过什么，都体现在晋升名额里了；而你做事的能力，才是应该在晋升述职里体现的。</strong>从这个角度来看，丢掉80%以上无意义的工作内容也毫不可惜。</p><h2 id="晋升答辩不是PK，而是能力挖掘"><a href="#晋升答辩不是PK，而是能力挖掘" class="headerlink" title="晋升答辩不是PK，而是能力挖掘"></a>晋升答辩不是PK，而是能力挖掘</h2><p>并非所有的晋升评委都非常优秀，但可以肯定的是，绝大多数都是抱着善意的。</p><p>晋升述职的重点，就是评委的提问环节。一般来说，问题分两类：了解你的表达内容、发掘你的能力。前面的问题往往源于你的材料没有表述清楚，需要你快速、准确地传达内容。而后者，则是支撑你晋升成功的关键。</p><p>挖掘问题的能力，主要在于三个：细节、深度、广度。这类问题往往源于你的晋升材料，所以可以尝试着做一些伏笔，引导评委来问。</p><p>对于评委的提问，我们要明确：<strong>不要只回答问题，而是尽可能地感受评委的用意，表现出自己的能力</strong>。打铁还需自身硬，但良好的心态能有不少加分。</p><h2 id="晋升与面试里的表现形式"><a href="#晋升与面试里的表现形式" class="headerlink" title="晋升与面试里的表现形式"></a>晋升与面试里的表现形式</h2><p>晋升与面试其实有很多相似点，尤其是评判逻辑上：晋升是公司评定你的能力可以达到下一个级别，而面试则是公司评价你的能力可以为公司带来对应的效益。核心，都是在于个人能力。</p><p>那么，如何表现出个人能力呢？常见的方式有项目、业绩、技术难点、领导团队等，但两者的表现形式有明显差异：</p><p>晋升的表现形式必须遵循公司的玩法，关注点很有限。比如，下一个级别的重点指标是技术架构能力，那你花大篇幅写某个技术深度的研究，虽然很棒，但偏题了。</p><p>而面试呢，我们往往是一份简历、多处投递，这就考验我们材料的普适性，一般来说都要各个点均有涉及、并且有几处亮点。除此以外，在面试时，还需要针对面试官感兴趣的点，能快速地扩展，所以临场应变非常重要。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>晋升过程是一个很好回顾过去的机会，不仅仅是自己在反复推敲，也能接收来自高层管理的反馈。</p><p>晋升的目标自然是获得成功，但从长期来看，这个过程对你的成长更有帮助。</p><p>如果说要用一个词概括我的最大感触，那就是放弃：晋升阶段是一个很特殊的时期，适当放弃日常工作模式下的思维方式，才能让你更好地进入这个阶段。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p><img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;晋升是每个技术人都应该经历的一次洗礼。一般来说，分为提名、准备、述职、答辩这四个步骤。&lt;/p&gt;
&lt;p&gt;尽管每个人的经历与体会都有不同，很难照搬硬套，但我相信只要是真心分享的经验，总会对人有帮助。接下来，我将从五个点展开。&lt;/p&gt;
    
    </summary>
    
      <category term="成长分享" scheme="http://example.com/categories/%E6%88%90%E9%95%BF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Digest" scheme="http://example.com/tags/Digest/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 7.【盛最多水的容器LeetCode-11】</title>
    <link href="http://example.com/2022/04/09/go-leetcode/go-leetcode-7/"/>
    <id>http://example.com/2022/04/09/go-leetcode/go-leetcode-7/</id>
    <published>2022-04-09T03:00:00.000Z</published>
    <updated>2022-04-09T03:40:31.591Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-11-盛最多水的容器"><a href="#Leetcode-11-盛最多水的容器" class="headerlink" title="Leetcode-11 盛最多水的容器"></a>Leetcode-11 盛最多水的容器</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/container-with-most-water/">https://leetcode-cn.com/problems/container-with-most-water/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 左右两个指针往中间逼近</span></span><br><span class="line">left, right := <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line"><span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line"><span class="keyword">var</span> area <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 哪边高度低，就挪哪边</span></span><br><span class="line"><span class="keyword">if</span> height[left] &lt; height[right] &#123;</span><br><span class="line">area = (right - left) * height[left]</span><br><span class="line">left++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">area = (right - left) * height[right]</span><br><span class="line">right--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> area &gt; max &#123;</span><br><span class="line">max = area</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-11-盛最多水的容器&quot;&gt;&lt;a href=&quot;#Leetcode-11-盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-11 盛最多水的容器&quot;&gt;&lt;/a&gt;Leetcode-11 盛最多水的容器&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water/&quot;&gt;https://leetcode-cn.com/problems/container-with-most-water/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxArea&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(height []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法实战" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 8.【三数之和LeetCode-15】</title>
    <link href="http://example.com/2022/04/09/go-leetcode/go-leetcode-8/"/>
    <id>http://example.com/2022/04/09/go-leetcode/go-leetcode-8/</id>
    <published>2022-04-09T03:00:00.000Z</published>
    <updated>2022-04-10T03:45:49.815Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-15-三数之和"><a href="#Leetcode-15-三数之和" class="headerlink" title="Leetcode-15 三数之和"></a>Leetcode-15 三数之和</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -2是保证至少留下2个数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 剪枝：最小值大于0时无需再遍历</span></span><br><span class="line"><span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 剪枝：最小值和前一个值一样时，上一个循环已经判断过，无需再判断</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// j,k 为两个指针，分别从最左边和最右边开始移动</span></span><br><span class="line">j, k := i+<span class="number">1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> j &lt; k &#123;</span><br><span class="line">left, right := nums[j], nums[k]</span><br><span class="line"><span class="keyword">if</span> nums[i]+nums[j]+nums[k] == <span class="number">0</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;nums[i], nums[j], nums[k]&#125;)</span><br><span class="line"><span class="comment">// 减枝：同值的话左边往右移，跳过 nums[j] == nums[j+1] 的情况</span></span><br><span class="line"><span class="keyword">for</span> j &lt; k &amp;&amp; nums[j] == left &#123;</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 减枝：同值的话右边往左移，跳过 nums[k] == nums[k-1] 的情况</span></span><br><span class="line"><span class="keyword">for</span> j &lt; k &amp;&amp; nums[k] == right &#123;</span><br><span class="line">k--</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[j]+nums[k] &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 和小于0，则增大最左边的j</span></span><br><span class="line">j++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 和大于0，则减少最右边的k</span></span><br><span class="line">k--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-15-三数之和&quot;&gt;&lt;a href=&quot;#Leetcode-15-三数之和&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-15 三数之和&quot;&gt;&lt;/a&gt;Leetcode-15 三数之和&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/3sum/&quot;&gt;https://leetcode-cn.com/problems/3sum/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;threeSum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nums []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; [][]&lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法实战" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 6.【正则表达式匹配LeetCode-10】</title>
    <link href="http://example.com/2022/04/09/go-leetcode/go-leetcode-6/"/>
    <id>http://example.com/2022/04/09/go-leetcode/go-leetcode-6/</id>
    <published>2022-04-09T00:00:00.000Z</published>
    <updated>2022-04-09T03:40:11.636Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-10-正则表达式匹配"><a href="#Leetcode-10-正则表达式匹配" class="headerlink" title="Leetcode-10 正则表达式匹配"></a>Leetcode-10 正则表达式匹配</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/regular-expression-matching/">https://leetcode-cn.com/problems/regular-expression-matching/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">row, col := <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp 就是核心的状态转移方程，这里注意要+1，是为了空字符串这个边界条件</span></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, row+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, col+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充dp[0]数组，也就是s为空字符串</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; col+<span class="number">1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// p为空字符串的情况</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line"><span class="comment">// 如果p[j-1]为*，则可以截断*和它前面的一个字符，表示匹配0个对应字符</span></span><br><span class="line">dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-2</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充整个dp数组，注意i和j在dp中不变，但对应到字符串s/p中都要-1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; row+<span class="number">1</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; col+<span class="number">1</span>; j++ &#123;</span><br><span class="line">            <span class="comment">// 最后一个字符是*的话</span></span><br><span class="line"><span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">                    <span class="comment">// *匹配上一个字符，要么截断s一个字符，要么去掉*和前一个字符</span></span><br><span class="line">dp[i][j] = dp[i][j<span class="number">-2</span>] || dp[i<span class="number">-1</span>][j]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果不匹配，则认为*没匹配上，只能去掉*和前一个字符</span></span><br><span class="line">dp[i][j] = dp[i][j<span class="number">-2</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line"><span class="comment">// 如果精确匹配或者匹配上了.，就各自截断后往前找</span></span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[row][col]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-10-正则表达式匹配&quot;&gt;&lt;a href=&quot;#Leetcode-10-正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-10 正则表达式匹配&quot;&gt;&lt;/a&gt;Leetcode-10 正则表达式匹配&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/regular-expression-matching/&quot;&gt;https://leetcode-cn.com/problems/regular-expression-matching/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isMatch&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(s &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;, p &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法实战" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 5.【最长回文子串LeetCode-5】</title>
    <link href="http://example.com/2022/04/08/go-leetcode/go-leetcode-5/"/>
    <id>http://example.com/2022/04/08/go-leetcode/go-leetcode-5/</id>
    <published>2022-04-08T00:00:00.000Z</published>
    <updated>2022-04-09T03:40:04.178Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-5-最长回文子串"><a href="#Leetcode-5-最长回文子串" class="headerlink" title="Leetcode-5 最长回文子串"></a>Leetcode-5 最长回文子串</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>递归版本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line">s1 := longestPalindrome(s[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从右往左移动指针，查询最大子字符串</span></span><br><span class="line">right := <span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">for</span> ; right &gt; <span class="number">0</span>; right-- &#123;</span><br><span class="line"><span class="keyword">if</span> isOk(s[:right]) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">s2 := s[:right]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s1) &gt; <span class="built_in">len</span>(s2) &#123;</span><br><span class="line"><span class="keyword">return</span> s1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isOk</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移动双指针进行判断</span></span><br><span class="line">start, end := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> start &lt; end &#123;</span><br><span class="line"><span class="keyword">if</span> s[start] != s[end] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">start++</span><br><span class="line">end--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归版本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">begin, maxLen := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> dp = <span class="built_in">make</span>([][]<span class="keyword">bool</span>, length)</span><br><span class="line"><span class="keyword">for</span> k1 := <span class="keyword">range</span> dp &#123;</span><br><span class="line">dp[k1] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, length)</span><br><span class="line"><span class="keyword">for</span> k2 := <span class="keyword">range</span> dp[k1] &#123;</span><br><span class="line">dp[k1][k2] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 长度为1的字符串，为回文字符串</span></span><br><span class="line">dp[k1][k1] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> size := <span class="number">2</span>; size &lt;= length; size++ &#123;</span><br><span class="line"><span class="comment">// founded用来表示对应size的回文字符串已经找到</span></span><br><span class="line">founded := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> start := <span class="number">0</span>; start &lt;= length-size; start++ &#123;</span><br><span class="line">end := start + size - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> s[start] == s[end] &#123;</span><br><span class="line"><span class="comment">// 长度为2的不用继续查了</span></span><br><span class="line"><span class="keyword">if</span> size == <span class="number">2</span> || dp[start+<span class="number">1</span>][end<span class="number">-1</span>] &#123;</span><br><span class="line">dp[start][end] = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 全局最长的字符串，只记录第一个即可</span></span><br><span class="line"><span class="keyword">if</span> !founded &amp;&amp; size &gt; maxLen &#123;</span><br><span class="line">maxLen, begin = size, start</span><br><span class="line">founded = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s[begin : begin+maxLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-5-最长回文子串&quot;&gt;&lt;a href=&quot;#Leetcode-5-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-5 最长回文子串&quot;&gt;&lt;/a&gt;Leetcode-5 最长回文子串&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-substring/&quot;&gt;https://leetcode-cn.com/problems/longest-palindromic-substring/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;longestPalindrome&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(s &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;string&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法实战" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 4.【寻找两个正序数组的中位数LeetCode-4】</title>
    <link href="http://example.com/2022/04/07/go-leetcode/go-leetcode-4/"/>
    <id>http://example.com/2022/04/07/go-leetcode/go-leetcode-4/</id>
    <published>2022-04-07T00:00:00.000Z</published>
    <updated>2022-04-06T23:46:13.778Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-4-寻找两个正序数组的中位数"><a href="#Leetcode-4-寻找两个正序数组的中位数" class="headerlink" title="Leetcode-4 寻找两个正序数组的中位数"></a>Leetcode-4 寻找两个正序数组的中位数</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">l1, l2 := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line"><span class="keyword">if</span> (l1+l2)%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(findKthInSortedArrays(nums1, nums2, (l1+l2)/<span class="number">2</span>+<span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(findKthInSortedArrays(nums1, nums2, (l1+l2)/<span class="number">2</span>)+findKthInSortedArrays(nums1, nums2, (l1+l2)/<span class="number">2</span>+<span class="number">1</span>)) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthInSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(nums1, nums2, k)</span><br><span class="line">length1, length2 := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line"><span class="keyword">if</span> length1 &lt; length2 &#123;</span><br><span class="line"><span class="keyword">return</span> findKthInSortedArrays(nums2, nums1, k)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> length2 == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums1[k<span class="number">-1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> k == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> nums1[<span class="number">0</span>] &gt; nums2[<span class="number">0</span>] &#123;</span><br><span class="line"><span class="keyword">return</span> nums2[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums1[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取i1/i2为k/2，并处理越界</span></span><br><span class="line">i1, i2 := k/<span class="number">2</span>, k-k/<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> i2 &gt; length2 &#123;</span><br><span class="line">i2 = length2</span><br><span class="line">i1 = k - length2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 截断小的数组后，继续递归查找</span></span><br><span class="line"><span class="keyword">if</span> nums1[i1<span class="number">-1</span>] &lt; nums2[i2<span class="number">-1</span>] &#123;</span><br><span class="line"><span class="keyword">return</span> findKthInSortedArrays(nums1[i1:], nums2, k-i1)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i1<span class="number">-1</span>] &gt; nums2[i2<span class="number">-1</span>] &#123;</span><br><span class="line"><span class="keyword">return</span> findKthInSortedArrays(nums1, nums2[i2:], k-i2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums1[i1<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-4-寻找两个正序数组的中位数&quot;&gt;&lt;a href=&quot;#Leetcode-4-寻找两个正序数组的中位数&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-4 寻找两个正序数组的中位数&quot;&gt;&lt;/a&gt;Leetcode-4 寻找两个正序数组的中位数&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/median-of-two-sorted-arrays/&quot;&gt;https://leetcode-cn.com/problems/median-of-two-sorted-arrays/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;findMedianSortedArrays&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nums1 []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, nums2 []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;float64&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法实战" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 3.【无重复字符的最长子串LeetCode-3】</title>
    <link href="http://example.com/2022/04/06/go-leetcode/go-leetcode-3/"/>
    <id>http://example.com/2022/04/06/go-leetcode/go-leetcode-3/</id>
    <published>2022-04-06T04:00:00.000Z</published>
    <updated>2022-04-06T23:46:02.783Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-3-无重复字符的最长子串"><a href="#Leetcode-3-无重复字符的最长子串" class="headerlink" title="Leetcode-3 无重复字符的最长子串"></a>Leetcode-3 无重复字符的最长子串</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// byte与其index，如果重复取最大的index覆盖</span></span><br><span class="line"><span class="keyword">var</span> mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> left, max = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">length := i - left + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> _, ok := mp[s[i]]; ok &#123;</span><br><span class="line">length2 := i - mp[s[i]]</span><br><span class="line"><span class="comment">// 如果left+1在mp[s[i]]左边，则更新left指针到mp[s[i]]+1</span></span><br><span class="line"><span class="keyword">if</span> left<span class="number">-1</span> &lt; mp[s[i]] &#123;</span><br><span class="line">length = length2</span><br><span class="line">left = mp[s[i]] + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> length &gt; max &#123;</span><br><span class="line">max = length</span><br><span class="line">&#125;</span><br><span class="line">mp[s[i]] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结尾的字符串</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s)-left &gt; max &#123;</span><br><span class="line">max = <span class="built_in">len</span>(s) - left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-3-无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#Leetcode-3-无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-3 无重复字符的最长子串&quot;&gt;&lt;/a&gt;Leetcode-3 无重复字符的最长子串&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&quot;&gt;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lengthOfLongestSubstring&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(s &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法实战" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 2.【两数相加LeetCode-2】非递归解法</title>
    <link href="http://example.com/2022/04/06/go-leetcode/go-leetcode-2/"/>
    <id>http://example.com/2022/04/06/go-leetcode/go-leetcode-2/</id>
    <published>2022-04-06T00:00:00.000Z</published>
    <updated>2022-04-06T15:01:28.504Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-2-两数相加"><a href="#Leetcode-2-两数相加" class="headerlink" title="Leetcode-2 两数相加"></a>Leetcode-2 两数相加</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></p><p>我们继续看上一个题目，这次我们尝试写一个非递归的解法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="keyword">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="comment">// walker是为了在l1/l2里遍历，修改Next指针</span></span><br><span class="line"><span class="keyword">var</span> carry, sentinel, walker = <span class="number">0</span>, l1, l1</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> walker != l1 &#123;</span><br><span class="line">walker.Val += l1.Val</span><br><span class="line">&#125;</span><br><span class="line">l1 = l1.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> walker != l2 &#123;</span><br><span class="line">walker.Val += l2.Val</span><br><span class="line">&#125;</span><br><span class="line">l2 = l2.Next</span><br><span class="line">&#125;</span><br><span class="line">walker.Val += carry</span><br><span class="line">carry, walker.Val = walker.Val/<span class="number">10</span>, walker.Val%<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里很重要，指定的是walker.Next的指向，能解决l1/l2跨链表的访问</span></span><br><span class="line"><span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">walker.Next = l1</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">walker.Next = l2</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> carry &gt; <span class="number">0</span> &#123;</span><br><span class="line">walker.Next = <span class="built_in">new</span>(ListNode)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">walker = walker.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sentinel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-2-两数相加&quot;&gt;&lt;a href=&quot;#Leetcode-2-两数相加&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-2 两数相加&quot;&gt;&lt;/a&gt;Leetcode-2 两数相加&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers/&quot;&gt;https://leetcode-cn.com/problems/add-two-numbers/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们继续看上一个题目，这次我们尝试写一个非递归的解法。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; ListNode &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Val &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Next *ListNode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addTwoNumbers&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(l1 *ListNode, l2 *ListNode)&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法实战" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 1.【两数相加LeetCode-2】递归解法</title>
    <link href="http://example.com/2022/04/05/go-leetcode/go-leetcode-1/"/>
    <id>http://example.com/2022/04/05/go-leetcode/go-leetcode-1/</id>
    <published>2022-04-05T00:00:00.000Z</published>
    <updated>2022-04-06T15:01:06.903Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-2-两数相加"><a href="#Leetcode-2-两数相加" class="headerlink" title="Leetcode-2 两数相加"></a>Leetcode-2 两数相加</h2><p>原题链接 - <a href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="keyword">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addTwoNumbersWithCarry(l1, l2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbersWithCarry</span><span class="params">(l1 *ListNode, l2 *ListNode, carry <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">new</span>(ListNode)</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val += l1.Val</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Val += l2.Val</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Val += carry</span><br><span class="line">    <span class="comment">// 引入位操作</span></span><br><span class="line">    carry, node.Val = node.Val/<span class="number">10</span>, node.Val%<span class="number">10</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有后续节点</span></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; carry == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.Next = addTwoNumbersWithCarry(l1, l2, carry)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-2-两数相加&quot;&gt;&lt;a href=&quot;#Leetcode-2-两数相加&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-2 两数相加&quot;&gt;&lt;/a&gt;Leetcode-2 两数相加&lt;/h2&gt;&lt;p&gt;原题链接 - &lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers/&quot;&gt;https://leetcode-cn.com/problems/add-two-numbers/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; ListNode &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Val &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Next *ListNode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addTwoNumbers&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(l1 *ListNode, l2 *ListNode)&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法实战" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 12.【二分查找LeetCode-704】</title>
    <link href="http://example.com/2022/04/01/go-leetcode/go-leetcode-12/"/>
    <id>http://example.com/2022/04/01/go-leetcode/go-leetcode-12/</id>
    <published>2022-04-01T05:00:00.000Z</published>
    <updated>2022-04-10T05:01:00.329Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-704-二分查找"><a href="#Leetcode-704-二分查找" class="headerlink" title="Leetcode-704 二分查找"></a>Leetcode-704 二分查找</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/binary-search/submissions/">https://leetcode-cn.com/problems/binary-search/submissions/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">start, end := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"><span class="comment">// 注意，当nums长度为1时，start=end=0</span></span><br><span class="line"><span class="comment">// 所以这个判断逻辑要注意</span></span><br><span class="line"><span class="keyword">for</span> end &gt;= start &#123;</span><br><span class="line">mid := (start + end) / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">end = mid - <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">start = mid + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-704-二分查找&quot;&gt;&lt;a href=&quot;#Leetcode-704-二分查找&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-704 二分查找&quot;&gt;&lt;/a&gt;Leetcode-704 二分查找&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/binary-search/submissions/&quot;&gt;https://leetcode-cn.com/problems/binary-search/submissions/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nums []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, target &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法实战" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go算法实战 - 11.【反转链表LeetCode-206】</title>
    <link href="http://example.com/2022/04/01/go-leetcode/go-leetcode-11/"/>
    <id>http://example.com/2022/04/01/go-leetcode/go-leetcode-11/</id>
    <published>2022-04-01T04:00:00.000Z</published>
    <updated>2022-04-10T05:00:33.631Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg" alt="Go-Leetcode"></p><h2 id="Leetcode-206-反转链表"><a href="#Leetcode-206-反转链表" class="headerlink" title="Leetcode-206 反转链表"></a>Leetcode-206 反转链表</h2><p>原题链接 <a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val  <span class="keyword">int</span></span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>递归</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = reverseList(head.Next)</span><br><span class="line"><span class="comment">// 重点：调整两个前置指针</span></span><br><span class="line">head.Next.Next = head</span><br><span class="line">head.Next = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="comment">// 这里初始为nil，解决了第一个head指向为nil</span></span><br><span class="line"><span class="keyword">var</span> pre *ListNode</span><br><span class="line"><span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 存一下next指针，防止丢失</span></span><br><span class="line">next := head.Next</span><br><span class="line"><span class="comment">// head指向前驱节点</span></span><br><span class="line">head.Next = pre</span><br><span class="line"><span class="comment">// 两个指针往后挪，注意先后顺序</span></span><br><span class="line">pre = head</span><br><span class="line">head = next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/10/SbG3k5XFRlsJdOV.jpg&quot; alt=&quot;Go-Leetcode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-206-反转链表&quot;&gt;&lt;a href=&quot;#Leetcode-206-反转链表&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-206 反转链表&quot;&gt;&lt;/a&gt;Leetcode-206 反转链表&lt;/h2&gt;&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list/&quot;&gt;https://leetcode-cn.com/problems/reverse-linked-list/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; ListNode &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Val  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Next *ListNode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;reverseList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(head *ListNode)&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法实战" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Go-Leetcode" scheme="http://example.com/tags/Go-Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>五分钟技术小分享 - 2022Week13</title>
    <link href="http://example.com/2022/03/28/sharing-5min/2022-03/2022Week13/"/>
    <id>http://example.com/2022/03/28/sharing-5min/2022-03/2022Week13/</id>
    <published>2022-03-28T04:00:00.000Z</published>
    <updated>2022-04-02T06:45:54.974Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57591641299799_.pic_hd.jpg" alt="2020-03"></p><h2 id="2022-03-28-Go1-5的GC概览3-Tri-color"><a href="#2022-03-28-Go1-5的GC概览3-Tri-color" class="headerlink" title="2022-03-28 Go1.5的GC概览3 - Tri-color"></a>2022-03-28 Go1.5的GC概览3 - Tri-color</h2><p>在标记阶段，Go语言使用了 tri-color，也就是著名的三色标记法。在这篇文章里，详细地描述了这部分的实现。</p><blockquote><p>原文链接 - <a href="https://go.dev/blog/go15gc">https://go.dev/blog/go15gc</a></p></blockquote><p>三色标记法是一种堆上对象的图算法。这里图的边Edge即指针，所以这里的关系是<strong>单向</strong>的。</p><blockquote><p> In a tri-color collector, every object is either white, grey, or black and we view the heap as a graph of connected objects.</p></blockquote><p>接下来，就是具体的三色标记法的工作了：</p><blockquote><p>At the start of a GC cycle all objects are white. The GC visits all <em>roots</em>, which are objects directly accessible by the application such as globals and things on the stack, and colors these grey. The GC then chooses a grey object, blackens it, and then scans it for pointers to other objects. When this scan finds a pointer to a white object, it turns that object grey. This process repeats until there are no more grey objects. At this point, white objects are known to be unreachable and can be reused.</p></blockquote><p>这一段内容很长，但描述得很直白，我简单概括下：</p><ul><li>GC初始化<ul><li>将所有的对象设置为 <strong>白色</strong></li></ul></li><li>Mark的初始化<ul><li>将全局变量和栈上的对象，标记为 <strong>灰色</strong></li><li>这些灰色对象会被放入队列中</li></ul></li><li>Mark的核心流程<ul><li>从队列中弹出一个灰色对象</li><li>访问这个灰色对象的指针，将<strong>白色对象</strong>的转变为<strong>灰色对象</strong>，并加入到队列中</li><li>将这个<strong>灰色对象</strong>标记为<strong>黑色</strong>，表示访问完毕</li><li>重复上述过程，直到队列为空</li></ul></li><li>清理阶段<ul><li>将所有剩余的 <strong>白色对象</strong> 进行垃圾回收</li></ul></li></ul><p>我们重点看这里的 <strong>Mark的核心流程</strong>，里面有个关键问题：<code>mutator</code>（也就是运行中的程序）在不停地修改对象的指针，所以会出现各种异常情况，比如说让一个黑色对象指向白色对象（正常情况下，黑色对象指向的是黑色或者灰色）。</p><blockquote><p>网上有很多关于三色标记的资料，不太清楚的朋友需要自行搜索，比如 <a href="https://segmentfault.com/a/1190000022030353">https://segmentfault.com/a/1190000022030353</a> 。</p><p>重点可以结合写屏障要解决的问题，进行理解。</p></blockquote><p>这个时候，就引入了我们前面说的内容 - <strong>写屏障write barrier</strong>。</p><blockquote><p>Go’s write barrier colors the now-reachable object grey if it is currently white, ensuring that the garbage collector will eventually scan it for pointers.</p></blockquote><p>写屏障即会在每次发生指针变更时，加入一小段代码：比如检测到新的被指向的对象是白色，就将它修改为灰色，需要扫描。这只是一个简单例子，后续Go语言对写屏障进行了迭代，采用的写屏障技术是 <strong>混合写屏障</strong>，也就是 <strong>插入写屏障</strong>+<strong>删除写屏障</strong>。</p><h2 id="2022-04-02-Go1-5的GC概览4-深入细节"><a href="#2022-04-02-Go1-5的GC概览4-深入细节" class="headerlink" title="2022-04-02 Go1.5的GC概览4 - 深入细节"></a>2022-04-02 Go1.5的GC概览4 - 深入细节</h2><p>今天我们会开始抠细节，来加深大家对这块的理解。</p><blockquote><p>原文链接 - <a href="https://go.dev/blog/go15gc">https://go.dev/blog/go15gc</a></p></blockquote><p><strong>Of course the devil is in the details.</strong> 细节才是恶魔，但只有去抠这些细节，我们才能掌握GC的实现。作者在文中抛出了很多问题，我们挑出3个关键性的问题进行回答。</p><h3 id="When-do-we-start-a-GC-cycle"><a href="#When-do-we-start-a-GC-cycle" class="headerlink" title="When do we start a GC cycle?"></a>When do we start a GC cycle?</h3><p><strong>一个主动调用和两个被动调用</strong>。</p><p>主动调用指的是代码调用<code>runtime.GC()</code>函数，被动调用包括 周期性强制执行（如2min）和GC Pacing算法。</p><p>其中GC Pacing主要和堆上空间的增长速度相关，增长越快，GC频率越快。</p><h3 id="How-do-we-know-where-the-roots-are"><a href="#How-do-we-know-where-the-roots-are" class="headerlink" title="How do we know where the roots are?"></a>How do we know where the roots are?</h3><p>标记阶段的根节点来自于哪里呢？从程序的维度来说，包括 <strong>全局变量</strong> 和 <strong>Goroutine的栈上变量</strong>。</p><p>全局变量，对应到进程结构中的bss段(未初始化的全局变量)和data段(已初始化的全局变量)。bss和data段的概念是通用的，也就是Go、C++等任意进程都是这样的数据结构。</p><p>而Goroutine栈上变量是Go的runtime自己维护的。</p><h3 id="How-do-we-know-where-in-an-object-pointers-are-located"><a href="#How-do-we-know-where-in-an-object-pointers-are-located" class="headerlink" title="How do we know where in an object pointers are located?"></a>How do we know where in an object pointers are located?</h3><p>在一个对象中，我们如何识别出对象内部的指针呢？</p><p>首先，我们要了解到，一个对象在内存中是一段连续0和1。由于Go语言的强类型特点，我们可以清楚地计算出这个结构体的总大小、以及内部各个成员变量的大小。</p><p>对象内部的变量分为两类：具体的数值和指针。具体的数值，如int64 a=1，那就在开辟一个可以存储int64大小空间段，存下1这个数值；而指针呢，如*int64这个指针，它在堆上先存储int64具体的值，记录它的起始地址如0x1111，结构体内部开辟一个指针大小的空间，记录地址的值0x1111。</p><p>如果抛开强类型，我们看到程序中的数值是无法区分的，比如上述例子中的1可以被理解地址0x0001，而0x1111也可以被理解为是具体的数字。强类型的语言是一种解决方案，它能在编译期就识别出具体的类型。</p><blockquote><p>为了延伸思考，这边也提一下另一种方案：</p><p>扩展数据，将它拆分为 对象类型（如前x位）+数据 。比如，</p><ul><li>数值1 = int64数据 + 1</li><li>指针1 = int64的指针 + 指针起始地址</li></ul><p>这就有JAVA里“一切皆对象”的影子了。</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>细节既是恶魔，也提供了我们梳理知识体系的过程。虽然大多数的时间我们没法掌握细节，但只要怀着一颗保持探索的心，总是能不断往前进的。</p><blockquote><p>Github: <a href="https://github.com/Junedayday/code_reading">https://github.com/Junedayday/code_reading</a></p><p>Blog: <a href="http://junes.tech/">http://junes.tech/</a></p><p>Bilibili: <a href="https://space.bilibili.com/293775192">https://space.bilibili.com/293775192</a></p><p>公众号: golangcoding</p><p> <img src="https://i.loli.net/2021/02/28/RPzy7Hjc9GZ8I3e.jpg" alt="二维码"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cloud-fitter-1305666920.cos.ap-beijing.myqcloud.com/57591641299799_.pic_hd.jpg&quot; alt=&quot;2020-03&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2022-03-28-G
      
    
    </summary>
    
      <category term="每日技术分享" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Daily-Sharing" scheme="http://example.com/tags/Daily-Sharing/"/>
    
  </entry>
  
</feed>
